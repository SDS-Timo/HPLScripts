// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/@dfinity/principal/lib/cjs/utils/base32.js
var require_base32 = __commonJS((exports) => {
  var encode = function(input) {
    let skip = 0;
    let bits = 0;
    let output = "";
    function encodeByte(byte) {
      if (skip < 0) {
        bits |= byte >> -skip;
      } else {
        bits = byte << skip & 248;
      }
      if (skip > 3) {
        skip -= 8;
        return 1;
      }
      if (skip < 4) {
        output += alphabet[bits >> 3];
        skip += 5;
      }
      return 0;
    }
    for (let i = 0;i < input.length; ) {
      i += encodeByte(input[i]);
    }
    return output + (skip < 0 ? alphabet[bits >> 3] : "");
  };
  var decode = function(input) {
    let skip = 0;
    let byte = 0;
    const output = new Uint8Array(input.length * 4 / 3 | 0);
    let o = 0;
    function decodeChar(char) {
      let val = lookupTable[char.toLowerCase()];
      if (val === undefined) {
        throw new Error(`Invalid character: ${JSON.stringify(char)}`);
      }
      val <<= 3;
      byte |= val >>> skip;
      skip += 5;
      if (skip >= 8) {
        output[o++] = byte;
        skip -= 8;
        if (skip > 0) {
          byte = val << 5 - skip & 255;
        } else {
          byte = 0;
        }
      }
    }
    for (const c of input) {
      decodeChar(c);
    }
    return output.slice(0, o);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decode = exports.encode = undefined;
  var alphabet = "abcdefghijklmnopqrstuvwxyz234567";
  var lookupTable = Object.create(null);
  for (let i = 0;i < alphabet.length; i++) {
    lookupTable[alphabet[i]] = i;
  }
  lookupTable["0"] = lookupTable.o;
  lookupTable["1"] = lookupTable.i;
  exports.encode = encode;
  exports.decode = decode;
});

// node_modules/@dfinity/principal/lib/cjs/utils/getCrc.js
var require_getCrc = __commonJS((exports) => {
  var getCrc32 = function(buf) {
    const b = new Uint8Array(buf);
    let crc = -1;
    for (let i = 0;i < b.length; i++) {
      const byte = b[i];
      const t2 = (byte ^ crc) & 255;
      crc = lookUpTable[t2] ^ crc >>> 8;
    }
    return (crc ^ -1) >>> 0;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCrc32 = undefined;
  var lookUpTable = new Uint32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ]);
  exports.getCrc32 = getCrc32;
});

// node_modules/js-sha256/src/sha256.js
var require_sha256 = __commonJS((exports, module) => {
  (function() {
    var ERROR = "input is invalid type";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA256_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = global;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && exports;
    var AMD = typeof define === "function" && define.amd;
    var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var EXTRA = [-2147483648, 8388608, 32768, 128];
    var SHIFT = [24, 16, 8, 0];
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
    var blocks = [];
    if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(outputType, is224) {
      return function(message) {
        return new Sha256(is224, true).update(message)[outputType]();
      };
    };
    var createMethod = function(is224) {
      var method = createOutputMethod("hex", is224);
      if (NODE_JS) {
        method = nodeWrap(method, is224);
      }
      method.create = function() {
        return new Sha256(is224);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      for (var i = 0;i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createOutputMethod(type, is224);
      }
      return method;
    };
    var nodeWrap = function(method, is224) {
      var crypto2 = (0, eval)("require('crypto')");
      var Buffer2 = (0, eval)("require('buffer').Buffer");
      var algorithm = is224 ? "sha224" : "sha256";
      var nodeMethod = function(message) {
        if (typeof message === "string") {
          return crypto2.createHash(algorithm).update(message, "utf8").digest("hex");
        } else {
          if (message === null || message === undefined) {
            throw new Error(ERROR);
          } else if (message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          }
        }
        if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer2) {
          return crypto2.createHash(algorithm).update(new Buffer2(message)).digest("hex");
        } else {
          return method(message);
        }
      };
      return nodeMethod;
    };
    var createHmacOutputMethod = function(outputType, is224) {
      return function(key, message) {
        return new HmacSha256(key, is224, true).update(message)[outputType]();
      };
    };
    var createHmacMethod = function(is224) {
      var method = createHmacOutputMethod("hex", is224);
      method.create = function(key) {
        return new HmacSha256(key, is224);
      };
      method.update = function(key, message) {
        return method.create(key).update(message);
      };
      for (var i = 0;i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createHmacOutputMethod(type, is224);
      }
      return method;
    };
    function Sha256(is224, sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        this.blocks = blocks;
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      if (is224) {
        this.h0 = 3238371032;
        this.h1 = 914150663;
        this.h2 = 812702999;
        this.h3 = 4144912697;
        this.h4 = 4290775857;
        this.h5 = 1750603025;
        this.h6 = 1694076839;
        this.h7 = 3204075428;
      } else {
        this.h0 = 1779033703;
        this.h1 = 3144134277;
        this.h2 = 1013904242;
        this.h3 = 2773480762;
        this.h4 = 1359893119;
        this.h5 = 2600822924;
        this.h6 = 528734635;
        this.h7 = 1541459225;
      }
      this.block = this.start = this.bytes = this.hBytes = 0;
      this.finalized = this.hashed = false;
      this.first = true;
      this.is224 = is224;
    }
    Sha256.prototype.update = function(message) {
      if (this.finalized) {
        return;
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(ERROR);
            }
          }
        } else {
          throw new Error(ERROR);
        }
        notString = true;
      }
      var code, index = 0, i, length = message.length, blocks2 = this.blocks;
      while (index < length) {
        if (this.hashed) {
          this.hashed = false;
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        if (notString) {
          for (i = this.start;index < length && i < 64; ++index) {
            blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
          }
        } else {
          for (i = this.start;index < length && i < 64; ++index) {
            code = message.charCodeAt(index);
            if (code < 128) {
              blocks2[i >> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 2048) {
              blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            } else if (code < 55296 || code >= 57344) {
              blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            } else {
              code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
              blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            }
          }
        }
        this.lastByteIndex = i;
        this.bytes += i - this.start;
        if (i >= 64) {
          this.block = blocks2[16];
          this.start = i - 64;
          this.hash();
          this.hashed = true;
        } else {
          this.start = i;
        }
      }
      if (this.bytes > 4294967295) {
        this.hBytes += this.bytes / 4294967296 << 0;
        this.bytes = this.bytes % 4294967296;
      }
      return this;
    };
    Sha256.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks2 = this.blocks, i = this.lastByteIndex;
      blocks2[16] = this.block;
      blocks2[i >> 2] |= EXTRA[i & 3];
      this.block = blocks2[16];
      if (i >= 56) {
        if (!this.hashed) {
          this.hash();
        }
        blocks2[0] = this.block;
        blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
      }
      blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
      blocks2[15] = this.bytes << 3;
      this.hash();
    };
    Sha256.prototype.hash = function() {
      var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
      for (j = 16;j < 64; ++j) {
        t1 = blocks2[j - 15];
        s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
        t1 = blocks2[j - 2];
        s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
        blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
      }
      bc = b & c;
      for (j = 0;j < 64; j += 4) {
        if (this.first) {
          if (this.is224) {
            ab = 300032;
            t1 = blocks2[0] - 1413257819;
            h = t1 - 150054599 << 0;
            d = t1 + 24177077 << 0;
          } else {
            ab = 704751109;
            t1 = blocks2[0] - 210244248;
            h = t1 - 1521486534 << 0;
            d = t1 + 143694565 << 0;
          }
          this.first = false;
        } else {
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ab = a & b;
          maj = ab ^ a & c ^ bc;
          ch = e & f ^ ~e & g;
          t1 = h + s1 + ch + K[j] + blocks2[j];
          t2 = s0 + maj;
          h = d + t1 << 0;
          d = t1 + t2 << 0;
        }
        s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
        s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
        da = d & a;
        maj = da ^ d & b ^ ab;
        ch = h & e ^ ~h & f;
        t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
        t2 = s0 + maj;
        g = c + t1 << 0;
        c = t1 + t2 << 0;
        s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
        s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
        cd = c & d;
        maj = cd ^ c & a ^ da;
        ch = g & h ^ ~g & e;
        t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
        t2 = s0 + maj;
        f = b + t1 << 0;
        b = t1 + t2 << 0;
        s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
        s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
        bc = b & c;
        maj = bc ^ b & d ^ cd;
        ch = f & g ^ ~f & h;
        t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
        t2 = s0 + maj;
        e = a + t1 << 0;
        a = t1 + t2 << 0;
      }
      this.h0 = this.h0 + a << 0;
      this.h1 = this.h1 + b << 0;
      this.h2 = this.h2 + c << 0;
      this.h3 = this.h3 + d << 0;
      this.h4 = this.h4 + e << 0;
      this.h5 = this.h5 + f << 0;
      this.h6 = this.h6 + g << 0;
      this.h7 = this.h7 + h << 0;
    };
    Sha256.prototype.hex = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
      if (!this.is224) {
        hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
      }
      return hex;
    };
    Sha256.prototype.toString = Sha256.prototype.hex;
    Sha256.prototype.digest = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var arr = [
        h0 >> 24 & 255,
        h0 >> 16 & 255,
        h0 >> 8 & 255,
        h0 & 255,
        h1 >> 24 & 255,
        h1 >> 16 & 255,
        h1 >> 8 & 255,
        h1 & 255,
        h2 >> 24 & 255,
        h2 >> 16 & 255,
        h2 >> 8 & 255,
        h2 & 255,
        h3 >> 24 & 255,
        h3 >> 16 & 255,
        h3 >> 8 & 255,
        h3 & 255,
        h4 >> 24 & 255,
        h4 >> 16 & 255,
        h4 >> 8 & 255,
        h4 & 255,
        h5 >> 24 & 255,
        h5 >> 16 & 255,
        h5 >> 8 & 255,
        h5 & 255,
        h6 >> 24 & 255,
        h6 >> 16 & 255,
        h6 >> 8 & 255,
        h6 & 255
      ];
      if (!this.is224) {
        arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
      }
      return arr;
    };
    Sha256.prototype.array = Sha256.prototype.digest;
    Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
      var dataView = new DataView(buffer);
      dataView.setUint32(0, this.h0);
      dataView.setUint32(4, this.h1);
      dataView.setUint32(8, this.h2);
      dataView.setUint32(12, this.h3);
      dataView.setUint32(16, this.h4);
      dataView.setUint32(20, this.h5);
      dataView.setUint32(24, this.h6);
      if (!this.is224) {
        dataView.setUint32(28, this.h7);
      }
      return buffer;
    };
    function HmacSha256(key, is224, sharedMemory) {
      var i, type = typeof key;
      if (type === "string") {
        var bytes = [], length = key.length, index = 0, code;
        for (i = 0;i < length; ++i) {
          code = key.charCodeAt(i);
          if (code < 128) {
            bytes[index++] = code;
          } else if (code < 2048) {
            bytes[index++] = 192 | code >> 6;
            bytes[index++] = 128 | code & 63;
          } else if (code < 55296 || code >= 57344) {
            bytes[index++] = 224 | code >> 12;
            bytes[index++] = 128 | code >> 6 & 63;
            bytes[index++] = 128 | code & 63;
          } else {
            code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
            bytes[index++] = 240 | code >> 18;
            bytes[index++] = 128 | code >> 12 & 63;
            bytes[index++] = 128 | code >> 6 & 63;
            bytes[index++] = 128 | code & 63;
          }
        }
        key = bytes;
      } else {
        if (type === "object") {
          if (key === null) {
            throw new Error(ERROR);
          } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
            key = new Uint8Array(key);
          } else if (!Array.isArray(key)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
              throw new Error(ERROR);
            }
          }
        } else {
          throw new Error(ERROR);
        }
      }
      if (key.length > 64) {
        key = new Sha256(is224, true).update(key).array();
      }
      var oKeyPad = [], iKeyPad = [];
      for (i = 0;i < 64; ++i) {
        var b = key[i] || 0;
        oKeyPad[i] = 92 ^ b;
        iKeyPad[i] = 54 ^ b;
      }
      Sha256.call(this, is224, sharedMemory);
      this.update(iKeyPad);
      this.oKeyPad = oKeyPad;
      this.inner = true;
      this.sharedMemory = sharedMemory;
    }
    HmacSha256.prototype = new Sha256;
    HmacSha256.prototype.finalize = function() {
      Sha256.prototype.finalize.call(this);
      if (this.inner) {
        this.inner = false;
        var innerHash = this.array();
        Sha256.call(this, this.is224, this.sharedMemory);
        this.update(this.oKeyPad);
        this.update(innerHash);
        Sha256.prototype.finalize.call(this);
      }
    };
    var exports2 = createMethod();
    exports2.sha256 = exports2;
    exports2.sha224 = createMethod(true);
    exports2.sha256.hmac = createHmacMethod();
    exports2.sha224.hmac = createHmacMethod(true);
    if (COMMON_JS) {
      module.exports = exports2;
    } else {
      root.sha256 = exports2.sha256;
      root.sha224 = exports2.sha224;
      if (AMD) {
        define(function() {
          return exports2;
        });
      }
    }
  })();
});

// node_modules/@dfinity/principal/lib/cjs/utils/sha224.js
var require_sha224 = __commonJS((exports) => {
  var sha224 = function(data) {
    const shaObj = js_sha256_1.sha224.create();
    shaObj.update(data);
    return new Uint8Array(shaObj.array());
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha224 = undefined;
  var js_sha256_1 = require_sha256();
  exports.sha224 = sha224;
});

// node_modules/@dfinity/principal/lib/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Principal = undefined;
  var base32_1 = require_base32();
  var getCrc_1 = require_getCrc();
  var sha224_1 = require_sha224();
  var SELF_AUTHENTICATING_SUFFIX = 2;
  var ANONYMOUS_SUFFIX = 4;
  var MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR = "aaaaa-aa";
  var fromHexString = (hexString) => {
    var _a;
    return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== undefined ? _a : []).map((byte) => parseInt(byte, 16)));
  };
  var toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");

  class Principal {
    constructor(_arr) {
      this._arr = _arr;
      this._isPrincipal = true;
    }
    static anonymous() {
      return new this(new Uint8Array([ANONYMOUS_SUFFIX]));
    }
    static managementCanister() {
      return this.fromHex(MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR);
    }
    static selfAuthenticating(publicKey) {
      const sha = (0, sha224_1.sha224)(publicKey);
      return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));
    }
    static from(other) {
      if (typeof other === "string") {
        return Principal.fromText(other);
      } else if (typeof other === "object" && other !== null && other._isPrincipal === true) {
        return new Principal(other._arr);
      }
      throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
    }
    static fromHex(hex) {
      return new this(fromHexString(hex));
    }
    static fromText(text) {
      const canisterIdNoDash = text.toLowerCase().replace(/-/g, "");
      let arr = (0, base32_1.decode)(canisterIdNoDash);
      arr = arr.slice(4, arr.length);
      const principal = new this(arr);
      if (principal.toText() !== text) {
        throw new Error(`Principal "${principal.toText()}" does not have a valid checksum (original value "${text}" may not be a valid Principal ID).`);
      }
      return principal;
    }
    static fromUint8Array(arr) {
      return new this(arr);
    }
    isAnonymous() {
      return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;
    }
    toUint8Array() {
      return this._arr;
    }
    toHex() {
      return toHexString(this._arr).toUpperCase();
    }
    toText() {
      const checksumArrayBuf = new ArrayBuffer(4);
      const view = new DataView(checksumArrayBuf);
      view.setUint32(0, (0, getCrc_1.getCrc32)(this._arr));
      const checksum = new Uint8Array(checksumArrayBuf);
      const bytes = Uint8Array.from(this._arr);
      const array = new Uint8Array([...checksum, ...bytes]);
      const result = (0, base32_1.encode)(array);
      const matches = result.match(/.{1,5}/g);
      if (!matches) {
        throw new Error;
      }
      return matches.join("-");
    }
    toString() {
      return this.toText();
    }
    compareTo(other) {
      for (let i = 0;i < Math.min(this._arr.length, other._arr.length); i++) {
        if (this._arr[i] < other._arr[i])
          return "lt";
        else if (this._arr[i] > other._arr[i])
          return "gt";
      }
      if (this._arr.length < other._arr.length)
        return "lt";
      if (this._arr.length > other._arr.length)
        return "gt";
      return "eq";
    }
    ltEq(other) {
      const cmp = this.compareTo(other);
      return cmp == "lt" || cmp == "eq";
    }
    gtEq(other) {
      const cmp = this.compareTo(other);
      return cmp == "gt" || cmp == "eq";
    }
  }
  exports.Principal = Principal;
});

// node_modules/@dfinity/candid/lib/cjs/utils/buffer.js
var require_buffer = __commonJS((exports) => {
  var concat = function(...buffers) {
    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));
    let index = 0;
    for (const b of buffers) {
      result.set(new Uint8Array(b), index);
      index += b.byteLength;
    }
    return result;
  };
  var toHexString = function(bytes) {
    return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
  };
  var fromHexString = function(hexString) {
    var _a;
    return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== undefined ? _a : []).map((byte) => parseInt(byte, 16)));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PipeArrayBuffer = exports.fromHexString = exports.toHexString = exports.concat = undefined;
  exports.concat = concat;
  exports.toHexString = toHexString;
  exports.fromHexString = fromHexString;

  class PipeArrayBuffer {
    constructor(buffer, length = (buffer === null || buffer === undefined ? undefined : buffer.byteLength) || 0) {
      this._buffer = buffer || new ArrayBuffer(0);
      this._view = new Uint8Array(this._buffer, 0, length);
    }
    get buffer() {
      return this._view.slice();
    }
    get byteLength() {
      return this._view.byteLength;
    }
    read(num) {
      const result = this._view.subarray(0, num);
      this._view = this._view.subarray(num);
      return result.slice().buffer;
    }
    readUint8() {
      const result = this._view[0];
      this._view = this._view.subarray(1);
      return result;
    }
    write(buf) {
      const b = new Uint8Array(buf);
      const offset = this._view.byteLength;
      if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {
        this.alloc(b.byteLength);
      } else {
        this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b.byteLength);
      }
      this._view.set(b, offset);
    }
    get end() {
      return this._view.byteLength === 0;
    }
    alloc(amount) {
      const b = new ArrayBuffer((this._buffer.byteLength + amount) * 1.2 | 0);
      const v = new Uint8Array(b, 0, this._view.byteLength + amount);
      v.set(this._view);
      this._buffer = b;
      this._view = v;
    }
  }
  exports.PipeArrayBuffer = PipeArrayBuffer;
});

// node_modules/@dfinity/candid/lib/cjs/utils/hash.js
var require_hash = __commonJS((exports) => {
  var idlHash = function(s2) {
    const utf8encoder = new TextEncoder;
    const array = utf8encoder.encode(s2);
    let h = 0;
    for (const c of array) {
      h = (h * 223 + c) % 2 ** 32;
    }
    return h;
  };
  var idlLabelToId = function(label) {
    if (/^_\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {
      const num = +label.slice(1, -1);
      if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {
        return num;
      }
    }
    return idlHash(label);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.idlLabelToId = undefined;
  exports.idlLabelToId = idlLabelToId;
});

// node_modules/@dfinity/candid/lib/cjs/utils/leb128.js
var require_leb128 = __commonJS((exports) => {
  var eob = function() {
    throw new Error("unexpected end of buffer");
  };
  var safeRead = function(pipe, num) {
    if (pipe.byteLength < num) {
      eob();
    }
    return pipe.read(num);
  };
  var safeReadUint8 = function(pipe) {
    const byte = pipe.readUint8();
    if (byte === undefined) {
      eob();
    }
    return byte;
  };
  var lebEncode = function(value) {
    if (typeof value === "number") {
      value = BigInt(value);
    }
    if (value < BigInt(0)) {
      throw new Error("Cannot leb encode negative values.");
    }
    const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;
    const pipe = new buffer_1.PipeArrayBuffer(new ArrayBuffer(byteLength), 0);
    while (true) {
      const i = Number(value & BigInt(127));
      value /= BigInt(128);
      if (value === BigInt(0)) {
        pipe.write(new Uint8Array([i]));
        break;
      } else {
        pipe.write(new Uint8Array([i | 128]));
      }
    }
    return pipe.buffer;
  };
  var lebDecode = function(pipe) {
    let weight = BigInt(1);
    let value = BigInt(0);
    let byte;
    do {
      byte = safeReadUint8(pipe);
      value += BigInt(byte & 127).valueOf() * weight;
      weight *= BigInt(128);
    } while (byte >= 128);
    return value;
  };
  var slebEncode = function(value) {
    if (typeof value === "number") {
      value = BigInt(value);
    }
    const isNeg = value < BigInt(0);
    if (isNeg) {
      value = -value - BigInt(1);
    }
    const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;
    const pipe = new buffer_1.PipeArrayBuffer(new ArrayBuffer(byteLength), 0);
    while (true) {
      const i = getLowerBytes(value);
      value /= BigInt(128);
      if (isNeg && value === BigInt(0) && (i & 64) !== 0 || !isNeg && value === BigInt(0) && (i & 64) === 0) {
        pipe.write(new Uint8Array([i]));
        break;
      } else {
        pipe.write(new Uint8Array([i | 128]));
      }
    }
    function getLowerBytes(num) {
      const bytes = num % BigInt(128);
      if (isNeg) {
        return Number(BigInt(128) - bytes - BigInt(1));
      } else {
        return Number(bytes);
      }
    }
    return pipe.buffer;
  };
  var slebDecode = function(pipe) {
    const pipeView = new Uint8Array(pipe.buffer);
    let len = 0;
    for (;len < pipeView.byteLength; len++) {
      if (pipeView[len] < 128) {
        if ((pipeView[len] & 64) === 0) {
          return lebDecode(pipe);
        }
        break;
      }
    }
    const bytes = new Uint8Array(safeRead(pipe, len + 1));
    let value = BigInt(0);
    for (let i = bytes.byteLength - 1;i >= 0; i--) {
      value = value * BigInt(128) + BigInt(128 - (bytes[i] & 127) - 1);
    }
    return -value - BigInt(1);
  };
  var writeUIntLE = function(value, byteLength) {
    if (BigInt(value) < BigInt(0)) {
      throw new Error("Cannot write negative values.");
    }
    return writeIntLE(value, byteLength);
  };
  var writeIntLE = function(value, byteLength) {
    value = BigInt(value);
    const pipe = new buffer_1.PipeArrayBuffer(new ArrayBuffer(Math.min(1, byteLength)), 0);
    let i = 0;
    let mul = BigInt(256);
    let sub = BigInt(0);
    let byte = Number(value % mul);
    pipe.write(new Uint8Array([byte]));
    while (++i < byteLength) {
      if (value < 0 && sub === BigInt(0) && byte !== 0) {
        sub = BigInt(1);
      }
      byte = Number((value / mul - sub) % BigInt(256));
      pipe.write(new Uint8Array([byte]));
      mul *= BigInt(256);
    }
    return pipe.buffer;
  };
  var readUIntLE = function(pipe, byteLength) {
    let val = BigInt(safeReadUint8(pipe));
    let mul = BigInt(1);
    let i = 0;
    while (++i < byteLength) {
      mul *= BigInt(256);
      const byte = BigInt(safeReadUint8(pipe));
      val = val + mul * byte;
    }
    return val;
  };
  var readIntLE = function(pipe, byteLength) {
    let val = readUIntLE(pipe, byteLength);
    const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));
    if (val >= mul) {
      val -= mul * BigInt(2);
    }
    return val;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readIntLE = exports.readUIntLE = exports.writeIntLE = exports.writeUIntLE = exports.slebDecode = exports.slebEncode = exports.lebDecode = exports.lebEncode = exports.safeReadUint8 = exports.safeRead = undefined;
  var buffer_1 = require_buffer();
  exports.safeRead = safeRead;
  exports.safeReadUint8 = safeReadUint8;
  exports.lebEncode = lebEncode;
  exports.lebDecode = lebDecode;
  exports.slebEncode = slebEncode;
  exports.slebDecode = slebDecode;
  exports.writeUIntLE = writeUIntLE;
  exports.writeIntLE = writeIntLE;
  exports.readUIntLE = readUIntLE;
  exports.readIntLE = readIntLE;
});

// node_modules/@dfinity/candid/lib/cjs/utils/bigint-math.js
var require_bigint_math = __commonJS((exports) => {
  var ilog2 = function(n) {
    const nBig = BigInt(n);
    if (n <= 0) {
      throw new RangeError("Input must be positive");
    }
    return nBig.toString(2).length - 1;
  };
  var iexp2 = function(n) {
    const nBig = BigInt(n);
    if (n < 0) {
      throw new RangeError("Input must be non-negative");
    }
    return BigInt(1) << nBig;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iexp2 = exports.ilog2 = undefined;
  exports.ilog2 = ilog2;
  exports.iexp2 = iexp2;
});

// node_modules/@dfinity/candid/lib/cjs/idl.js
var require_idl = __commonJS((exports) => {
  var zipWith = function(xs, ys, f) {
    return xs.map((x, i) => f(x, ys[i]));
  };
  var decodePrincipalId = function(b) {
    const x = (0, leb128_1.safeReadUint8)(b);
    if (x !== 1) {
      throw new Error("Cannot decode principal");
    }
    const len = Number((0, leb128_1.lebDecode)(b));
    return principal_1.Principal.fromUint8Array(new Uint8Array((0, leb128_1.safeRead)(b, len)));
  };
  var toReadableString = function(x) {
    const str = JSON.stringify(x, (_key, value) => typeof value === "bigint" ? `BigInt(${value})` : value);
    return str && str.length > toReadableString_max ? str.substring(0, toReadableString_max - 3) + "..." : str;
  };
  var encode = function(argTypes, args) {
    if (args.length < argTypes.length) {
      throw Error("Wrong number of message arguments");
    }
    const typeTable = new TypeTable;
    argTypes.forEach((t2) => t2.buildTypeTable(typeTable));
    const magic = new TextEncoder().encode(magicNumber);
    const table = typeTable.encode();
    const len = (0, leb128_1.lebEncode)(args.length);
    const typs = (0, buffer_1.concat)(...argTypes.map((t2) => t2.encodeType(typeTable)));
    const vals = (0, buffer_1.concat)(...zipWith(argTypes, args, (t2, x) => {
      try {
        t2.covariant(x);
      } catch (e) {
        const err = new Error(e.message + "\n\n");
        throw err;
      }
      return t2.encodeValue(x);
    }));
    return (0, buffer_1.concat)(magic, table, len, typs, vals);
  };
  var decode = function(retTypes, bytes) {
    const b = new buffer_1.PipeArrayBuffer(bytes);
    if (bytes.byteLength < magicNumber.length) {
      throw new Error("Message length smaller than magic number");
    }
    const magicBuffer = (0, leb128_1.safeRead)(b, magicNumber.length);
    const magic = new TextDecoder().decode(magicBuffer);
    if (magic !== magicNumber) {
      throw new Error("Wrong magic number: " + JSON.stringify(magic));
    }
    function readTypeTable(pipe) {
      const typeTable = [];
      const len = Number((0, leb128_1.lebDecode)(pipe));
      for (let i = 0;i < len; i++) {
        const ty = Number((0, leb128_1.slebDecode)(pipe));
        switch (ty) {
          case -18:
          case -19: {
            const t2 = Number((0, leb128_1.slebDecode)(pipe));
            typeTable.push([ty, t2]);
            break;
          }
          case -20:
          case -21: {
            const fields = [];
            let objectLength = Number((0, leb128_1.lebDecode)(pipe));
            let prevHash;
            while (objectLength--) {
              const hash = Number((0, leb128_1.lebDecode)(pipe));
              if (hash >= Math.pow(2, 32)) {
                throw new Error("field id out of 32-bit range");
              }
              if (typeof prevHash === "number" && prevHash >= hash) {
                throw new Error("field id collision or not sorted");
              }
              prevHash = hash;
              const t2 = Number((0, leb128_1.slebDecode)(pipe));
              fields.push([hash, t2]);
            }
            typeTable.push([ty, fields]);
            break;
          }
          case -22: {
            const args = [];
            let argLength = Number((0, leb128_1.lebDecode)(pipe));
            while (argLength--) {
              args.push(Number((0, leb128_1.slebDecode)(pipe)));
            }
            const returnValues = [];
            let returnValuesLength = Number((0, leb128_1.lebDecode)(pipe));
            while (returnValuesLength--) {
              returnValues.push(Number((0, leb128_1.slebDecode)(pipe)));
            }
            const annotations = [];
            let annotationLength = Number((0, leb128_1.lebDecode)(pipe));
            while (annotationLength--) {
              const annotation = Number((0, leb128_1.lebDecode)(pipe));
              switch (annotation) {
                case 1: {
                  annotations.push("query");
                  break;
                }
                case 2: {
                  annotations.push("oneway");
                  break;
                }
                case 3: {
                  annotations.push("composite_query");
                  break;
                }
                default:
                  throw new Error("unknown annotation");
              }
            }
            typeTable.push([ty, [args, returnValues, annotations]]);
            break;
          }
          case -23: {
            let servLength = Number((0, leb128_1.lebDecode)(pipe));
            const methods = [];
            while (servLength--) {
              const nameLength = Number((0, leb128_1.lebDecode)(pipe));
              const funcName = new TextDecoder().decode((0, leb128_1.safeRead)(pipe, nameLength));
              const funcType = (0, leb128_1.slebDecode)(pipe);
              methods.push([funcName, funcType]);
            }
            typeTable.push([ty, methods]);
            break;
          }
          default:
            throw new Error("Illegal op_code: " + ty);
        }
      }
      const rawList = [];
      const length = Number((0, leb128_1.lebDecode)(pipe));
      for (let i = 0;i < length; i++) {
        rawList.push(Number((0, leb128_1.slebDecode)(pipe)));
      }
      return [typeTable, rawList];
    }
    const [rawTable, rawTypes] = readTypeTable(b);
    if (rawTypes.length < retTypes.length) {
      throw new Error("Wrong number of return values");
    }
    const table = rawTable.map((_) => Rec());
    function getType(t2) {
      if (t2 < -24) {
        throw new Error("future value not supported");
      }
      if (t2 < 0) {
        switch (t2) {
          case -1:
            return exports.Null;
          case -2:
            return exports.Bool;
          case -3:
            return exports.Nat;
          case -4:
            return exports.Int;
          case -5:
            return exports.Nat8;
          case -6:
            return exports.Nat16;
          case -7:
            return exports.Nat32;
          case -8:
            return exports.Nat64;
          case -9:
            return exports.Int8;
          case -10:
            return exports.Int16;
          case -11:
            return exports.Int32;
          case -12:
            return exports.Int64;
          case -13:
            return exports.Float32;
          case -14:
            return exports.Float64;
          case -15:
            return exports.Text;
          case -16:
            return exports.Reserved;
          case -17:
            return exports.Empty;
          case -24:
            return exports.Principal;
          default:
            throw new Error("Illegal op_code: " + t2);
        }
      }
      if (t2 >= rawTable.length) {
        throw new Error("type index out of range");
      }
      return table[t2];
    }
    function buildType(entry) {
      switch (entry[0]) {
        case -19: {
          const ty = getType(entry[1]);
          return Vec(ty);
        }
        case -18: {
          const ty = getType(entry[1]);
          return Opt(ty);
        }
        case -20: {
          const fields = {};
          for (const [hash, ty] of entry[1]) {
            const name = `_${hash}_`;
            fields[name] = getType(ty);
          }
          const record = Record(fields);
          const tuple = record.tryAsTuple();
          if (Array.isArray(tuple)) {
            return Tuple(...tuple);
          } else {
            return record;
          }
        }
        case -21: {
          const fields = {};
          for (const [hash, ty] of entry[1]) {
            const name = `_${hash}_`;
            fields[name] = getType(ty);
          }
          return Variant(fields);
        }
        case -22: {
          const [args, returnValues, annotations] = entry[1];
          return Func(args.map((t2) => getType(t2)), returnValues.map((t2) => getType(t2)), annotations);
        }
        case -23: {
          const rec = {};
          const methods = entry[1];
          for (const [name, typeRef] of methods) {
            let type = getType(typeRef);
            if (type instanceof RecClass) {
              type = type.getType();
            }
            if (!(type instanceof FuncClass)) {
              throw new Error("Illegal service definition: services can only contain functions");
            }
            rec[name] = type;
          }
          return Service(rec);
        }
        default:
          throw new Error("Illegal op_code: " + entry[0]);
      }
    }
    rawTable.forEach((entry, i) => {
      if (entry[0] === -22) {
        const t2 = buildType(entry);
        table[i].fill(t2);
      }
    });
    rawTable.forEach((entry, i) => {
      if (entry[0] !== -22) {
        const t2 = buildType(entry);
        table[i].fill(t2);
      }
    });
    const types = rawTypes.map((t2) => getType(t2));
    const output = retTypes.map((t2, i) => {
      return t2.decodeValue(b, types[i]);
    });
    for (let ind = retTypes.length;ind < types.length; ind++) {
      types[ind].decodeValue(b, types[ind]);
    }
    if (b.byteLength > 0) {
      throw new Error("decode: Left-over bytes");
    }
    return output;
  };
  var Tuple = function(...types) {
    return new TupleClass(types);
  };
  var Vec = function(t2) {
    return new VecClass(t2);
  };
  var Opt = function(t2) {
    return new OptClass(t2);
  };
  var Record = function(t2) {
    return new RecordClass(t2);
  };
  var Variant = function(fields) {
    return new VariantClass(fields);
  };
  var Rec = function() {
    return new RecClass;
  };
  var Func = function(args, ret2, annotations = []) {
    return new FuncClass(args, ret2, annotations);
  };
  var Service = function(t2) {
    return new ServiceClass(t2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Variant = exports.Record = exports.Opt = exports.Vec = exports.Tuple = exports.Principal = exports.Nat64 = exports.Nat32 = exports.Nat16 = exports.Nat8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Float64 = exports.Float32 = exports.Nat = exports.Int = exports.Text = exports.Null = exports.Bool = exports.Unknown = exports.Reserved = exports.Empty = exports.decode = exports.encode = exports.ServiceClass = exports.FuncClass = exports.PrincipalClass = exports.RecClass = exports.VariantClass = exports.TupleClass = exports.RecordClass = exports.OptClass = exports.VecClass = exports.FixedNatClass = exports.FixedIntClass = exports.FloatClass = exports.NatClass = exports.IntClass = exports.TextClass = exports.ReservedClass = exports.NullClass = exports.BoolClass = exports.UnknownClass = exports.EmptyClass = exports.ConstructType = exports.PrimitiveType = exports.Type = exports.Visitor = undefined;
  exports.Service = exports.Func = exports.Rec = undefined;
  var principal_1 = require_cjs();
  var buffer_1 = require_buffer();
  var hash_1 = require_hash();
  var leb128_1 = require_leb128();
  var bigint_math_1 = require_bigint_math();
  var magicNumber = "DIDL";
  var toReadableString_max = 400;

  class TypeTable {
    constructor() {
      this._typs = [];
      this._idx = new Map;
    }
    has(obj) {
      return this._idx.has(obj.name);
    }
    add(type, buf) {
      const idx = this._typs.length;
      this._idx.set(type.name, idx);
      this._typs.push(buf);
    }
    merge(obj, knot) {
      const idx = this._idx.get(obj.name);
      const knotIdx = this._idx.get(knot);
      if (idx === undefined) {
        throw new Error("Missing type index for " + obj);
      }
      if (knotIdx === undefined) {
        throw new Error("Missing type index for " + knot);
      }
      this._typs[idx] = this._typs[knotIdx];
      this._typs.splice(knotIdx, 1);
      this._idx.delete(knot);
    }
    encode() {
      const len = (0, leb128_1.lebEncode)(this._typs.length);
      const buf = (0, buffer_1.concat)(...this._typs);
      return (0, buffer_1.concat)(len, buf);
    }
    indexOf(typeName) {
      if (!this._idx.has(typeName)) {
        throw new Error("Missing type index for " + typeName);
      }
      return (0, leb128_1.slebEncode)(this._idx.get(typeName) || 0);
    }
  }

  class Visitor {
    visitType(t2, data) {
      throw new Error("Not implemented");
    }
    visitPrimitive(t2, data) {
      return this.visitType(t2, data);
    }
    visitEmpty(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitBool(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitNull(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitReserved(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitText(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitNumber(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitInt(t2, data) {
      return this.visitNumber(t2, data);
    }
    visitNat(t2, data) {
      return this.visitNumber(t2, data);
    }
    visitFloat(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitFixedInt(t2, data) {
      return this.visitNumber(t2, data);
    }
    visitFixedNat(t2, data) {
      return this.visitNumber(t2, data);
    }
    visitPrincipal(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitConstruct(t2, data) {
      return this.visitType(t2, data);
    }
    visitVec(t2, ty, data) {
      return this.visitConstruct(t2, data);
    }
    visitOpt(t2, ty, data) {
      return this.visitConstruct(t2, data);
    }
    visitRecord(t2, fields, data) {
      return this.visitConstruct(t2, data);
    }
    visitTuple(t2, components, data) {
      const fields = components.map((ty, i) => [`_${i}_`, ty]);
      return this.visitRecord(t2, fields, data);
    }
    visitVariant(t2, fields, data) {
      return this.visitConstruct(t2, data);
    }
    visitRec(t2, ty, data) {
      return this.visitConstruct(ty, data);
    }
    visitFunc(t2, data) {
      return this.visitConstruct(t2, data);
    }
    visitService(t2, data) {
      return this.visitConstruct(t2, data);
    }
  }
  exports.Visitor = Visitor;

  class Type {
    display() {
      return this.name;
    }
    valueToString(x) {
      return toReadableString(x);
    }
    buildTypeTable(typeTable) {
      if (!typeTable.has(this)) {
        this._buildTypeTableImpl(typeTable);
      }
    }
  }
  exports.Type = Type;

  class PrimitiveType extends Type {
    checkType(t2) {
      if (this.name !== t2.name) {
        throw new Error(`type mismatch: type on the wire ${t2.name}, expect type ${this.name}`);
      }
      return t2;
    }
    _buildTypeTableImpl(typeTable) {
      return;
    }
  }
  exports.PrimitiveType = PrimitiveType;

  class ConstructType extends Type {
    checkType(t2) {
      if (t2 instanceof RecClass) {
        const ty = t2.getType();
        if (typeof ty === "undefined") {
          throw new Error("type mismatch with uninitialized type");
        }
        return ty;
      }
      throw new Error(`type mismatch: type on the wire ${t2.name}, expect type ${this.name}`);
    }
    encodeType(typeTable) {
      return typeTable.indexOf(this.name);
    }
  }
  exports.ConstructType = ConstructType;

  class EmptyClass extends PrimitiveType {
    accept(v, d) {
      return v.visitEmpty(this, d);
    }
    covariant(x) {
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue() {
      throw new Error("Empty cannot appear as a function argument");
    }
    valueToString() {
      throw new Error("Empty cannot appear as a value");
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-17);
    }
    decodeValue() {
      throw new Error("Empty cannot appear as an output");
    }
    get name() {
      return "empty";
    }
  }
  exports.EmptyClass = EmptyClass;

  class UnknownClass extends Type {
    checkType(t2) {
      throw new Error("Method not implemented for unknown.");
    }
    accept(v, d) {
      throw v.visitType(this, d);
    }
    covariant(x) {
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue() {
      throw new Error("Unknown cannot appear as a function argument");
    }
    valueToString() {
      throw new Error("Unknown cannot appear as a value");
    }
    encodeType() {
      throw new Error("Unknown cannot be serialized");
    }
    decodeValue(b, t2) {
      let decodedValue = t2.decodeValue(b, t2);
      if (Object(decodedValue) !== decodedValue) {
        decodedValue = Object(decodedValue);
      }
      let typeFunc;
      if (t2 instanceof RecClass) {
        typeFunc = () => t2.getType();
      } else {
        typeFunc = () => t2;
      }
      Object.defineProperty(decodedValue, "type", {
        value: typeFunc,
        writable: true,
        enumerable: false,
        configurable: true
      });
      return decodedValue;
    }
    _buildTypeTableImpl() {
      throw new Error("Unknown cannot be serialized");
    }
    get name() {
      return "Unknown";
    }
  }
  exports.UnknownClass = UnknownClass;

  class BoolClass extends PrimitiveType {
    accept(v, d) {
      return v.visitBool(this, d);
    }
    covariant(x) {
      if (typeof x === "boolean")
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      return new Uint8Array([x ? 1 : 0]);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-2);
    }
    decodeValue(b, t2) {
      this.checkType(t2);
      switch ((0, leb128_1.safeReadUint8)(b)) {
        case 0:
          return false;
        case 1:
          return true;
        default:
          throw new Error("Boolean value out of range");
      }
    }
    get name() {
      return "bool";
    }
  }
  exports.BoolClass = BoolClass;

  class NullClass extends PrimitiveType {
    accept(v, d) {
      return v.visitNull(this, d);
    }
    covariant(x) {
      if (x === null)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue() {
      return new ArrayBuffer(0);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-1);
    }
    decodeValue(b, t2) {
      this.checkType(t2);
      return null;
    }
    get name() {
      return "null";
    }
  }
  exports.NullClass = NullClass;

  class ReservedClass extends PrimitiveType {
    accept(v, d) {
      return v.visitReserved(this, d);
    }
    covariant(x) {
      return true;
    }
    encodeValue() {
      return new ArrayBuffer(0);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-16);
    }
    decodeValue(b, t2) {
      if (t2.name !== this.name) {
        t2.decodeValue(b, t2);
      }
      return null;
    }
    get name() {
      return "reserved";
    }
  }
  exports.ReservedClass = ReservedClass;

  class TextClass extends PrimitiveType {
    accept(v, d) {
      return v.visitText(this, d);
    }
    covariant(x) {
      if (typeof x === "string")
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      const buf = new TextEncoder().encode(x);
      const len = (0, leb128_1.lebEncode)(buf.byteLength);
      return (0, buffer_1.concat)(len, buf);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-15);
    }
    decodeValue(b, t2) {
      this.checkType(t2);
      const len = (0, leb128_1.lebDecode)(b);
      const buf = (0, leb128_1.safeRead)(b, Number(len));
      const decoder = new TextDecoder("utf8", { fatal: true });
      return decoder.decode(buf);
    }
    get name() {
      return "text";
    }
    valueToString(x) {
      return '"' + x + '"';
    }
  }
  exports.TextClass = TextClass;

  class IntClass extends PrimitiveType {
    accept(v, d) {
      return v.visitInt(this, d);
    }
    covariant(x) {
      if (typeof x === "bigint" || Number.isInteger(x))
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      return (0, leb128_1.slebEncode)(x);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-4);
    }
    decodeValue(b, t2) {
      this.checkType(t2);
      return (0, leb128_1.slebDecode)(b);
    }
    get name() {
      return "int";
    }
    valueToString(x) {
      return x.toString();
    }
  }
  exports.IntClass = IntClass;

  class NatClass extends PrimitiveType {
    accept(v, d) {
      return v.visitNat(this, d);
    }
    covariant(x) {
      if (typeof x === "bigint" && x >= BigInt(0) || Number.isInteger(x) && x >= 0)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      return (0, leb128_1.lebEncode)(x);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-3);
    }
    decodeValue(b, t2) {
      this.checkType(t2);
      return (0, leb128_1.lebDecode)(b);
    }
    get name() {
      return "nat";
    }
    valueToString(x) {
      return x.toString();
    }
  }
  exports.NatClass = NatClass;

  class FloatClass extends PrimitiveType {
    constructor(_bits) {
      super();
      this._bits = _bits;
      if (_bits !== 32 && _bits !== 64) {
        throw new Error("not a valid float type");
      }
    }
    accept(v, d) {
      return v.visitFloat(this, d);
    }
    covariant(x) {
      if (typeof x === "number" || x instanceof Number)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      const buf = new ArrayBuffer(this._bits / 8);
      const view = new DataView(buf);
      if (this._bits === 32) {
        view.setFloat32(0, x, true);
      } else {
        view.setFloat64(0, x, true);
      }
      return buf;
    }
    encodeType() {
      const opcode = this._bits === 32 ? -13 : -14;
      return (0, leb128_1.slebEncode)(opcode);
    }
    decodeValue(b, t2) {
      this.checkType(t2);
      const bytes = (0, leb128_1.safeRead)(b, this._bits / 8);
      const view = new DataView(bytes);
      if (this._bits === 32) {
        return view.getFloat32(0, true);
      } else {
        return view.getFloat64(0, true);
      }
    }
    get name() {
      return "float" + this._bits;
    }
    valueToString(x) {
      return x.toString();
    }
  }
  exports.FloatClass = FloatClass;

  class FixedIntClass extends PrimitiveType {
    constructor(_bits) {
      super();
      this._bits = _bits;
    }
    accept(v, d) {
      return v.visitFixedInt(this, d);
    }
    covariant(x) {
      const min = (0, bigint_math_1.iexp2)(this._bits - 1) * BigInt(-1);
      const max = (0, bigint_math_1.iexp2)(this._bits - 1) - BigInt(1);
      let ok = false;
      if (typeof x === "bigint") {
        ok = x >= min && x <= max;
      } else if (Number.isInteger(x)) {
        const v = BigInt(x);
        ok = v >= min && v <= max;
      } else {
        ok = false;
      }
      if (ok)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      return (0, leb128_1.writeIntLE)(x, this._bits / 8);
    }
    encodeType() {
      const offset = Math.log2(this._bits) - 3;
      return (0, leb128_1.slebEncode)(-9 - offset);
    }
    decodeValue(b, t2) {
      this.checkType(t2);
      const num = (0, leb128_1.readIntLE)(b, this._bits / 8);
      if (this._bits <= 32) {
        return Number(num);
      } else {
        return num;
      }
    }
    get name() {
      return `int${this._bits}`;
    }
    valueToString(x) {
      return x.toString();
    }
  }
  exports.FixedIntClass = FixedIntClass;

  class FixedNatClass extends PrimitiveType {
    constructor(_bits) {
      super();
      this._bits = _bits;
    }
    accept(v, d) {
      return v.visitFixedNat(this, d);
    }
    covariant(x) {
      const max = (0, bigint_math_1.iexp2)(this._bits);
      let ok = false;
      if (typeof x === "bigint" && x >= BigInt(0)) {
        ok = x < max;
      } else if (Number.isInteger(x) && x >= 0) {
        const v = BigInt(x);
        ok = v < max;
      } else {
        ok = false;
      }
      if (ok)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      return (0, leb128_1.writeUIntLE)(x, this._bits / 8);
    }
    encodeType() {
      const offset = Math.log2(this._bits) - 3;
      return (0, leb128_1.slebEncode)(-5 - offset);
    }
    decodeValue(b, t2) {
      this.checkType(t2);
      const num = (0, leb128_1.readUIntLE)(b, this._bits / 8);
      if (this._bits <= 32) {
        return Number(num);
      } else {
        return num;
      }
    }
    get name() {
      return `nat${this._bits}`;
    }
    valueToString(x) {
      return x.toString();
    }
  }
  exports.FixedNatClass = FixedNatClass;

  class VecClass extends ConstructType {
    constructor(_type) {
      super();
      this._type = _type;
      this._blobOptimization = false;
      if (_type instanceof FixedNatClass && _type._bits === 8) {
        this._blobOptimization = true;
      }
    }
    accept(v, d) {
      return v.visitVec(this, this._type, d);
    }
    covariant(x) {
      const bits = this._type instanceof FixedNatClass ? this._type._bits : this._type instanceof FixedIntClass ? this._type._bits : 0;
      if (ArrayBuffer.isView(x) && bits == x.BYTES_PER_ELEMENT * 8 || Array.isArray(x) && x.every((v, idx) => {
        try {
          return this._type.covariant(v);
        } catch (e) {
          throw new Error(`Invalid ${this.display()} argument: \n\nindex ${idx} -> ${e.message}`);
        }
      }))
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      const len = (0, leb128_1.lebEncode)(x.length);
      if (this._blobOptimization) {
        return (0, buffer_1.concat)(len, new Uint8Array(x));
      }
      if (ArrayBuffer.isView(x)) {
        return (0, buffer_1.concat)(len, new Uint8Array(x.buffer));
      }
      const buf = new buffer_1.PipeArrayBuffer(new ArrayBuffer(len.byteLength + x.length), 0);
      buf.write(len);
      for (const d of x) {
        const encoded = this._type.encodeValue(d);
        buf.write(new Uint8Array(encoded));
      }
      return buf.buffer;
    }
    _buildTypeTableImpl(typeTable) {
      this._type.buildTypeTable(typeTable);
      const opCode = (0, leb128_1.slebEncode)(-19);
      const buffer = this._type.encodeType(typeTable);
      typeTable.add(this, (0, buffer_1.concat)(opCode, buffer));
    }
    decodeValue(b, t2) {
      const vec = this.checkType(t2);
      if (!(vec instanceof VecClass)) {
        throw new Error("Not a vector type");
      }
      const len = Number((0, leb128_1.lebDecode)(b));
      if (this._type instanceof FixedNatClass) {
        if (this._type._bits == 8) {
          return new Uint8Array(b.read(len));
        }
        if (this._type._bits == 16) {
          return new Uint16Array(b.read(len * 2));
        }
        if (this._type._bits == 32) {
          return new Uint32Array(b.read(len * 4));
        }
        if (this._type._bits == 64) {
          return new BigUint64Array(b.read(len * 8));
        }
      }
      if (this._type instanceof FixedIntClass) {
        if (this._type._bits == 8) {
          return new Int8Array(b.read(len));
        }
        if (this._type._bits == 16) {
          return new Int16Array(b.read(len * 2));
        }
        if (this._type._bits == 32) {
          return new Int32Array(b.read(len * 4));
        }
        if (this._type._bits == 64) {
          return new BigInt64Array(b.read(len * 8));
        }
      }
      const rets = [];
      for (let i = 0;i < len; i++) {
        rets.push(this._type.decodeValue(b, vec._type));
      }
      return rets;
    }
    get name() {
      return `vec ${this._type.name}`;
    }
    display() {
      return `vec ${this._type.display()}`;
    }
    valueToString(x) {
      const elements = x.map((e) => this._type.valueToString(e));
      return "vec {" + elements.join("; ") + "}";
    }
  }
  exports.VecClass = VecClass;

  class OptClass extends ConstructType {
    constructor(_type) {
      super();
      this._type = _type;
    }
    accept(v, d) {
      return v.visitOpt(this, this._type, d);
    }
    covariant(x) {
      try {
        if (Array.isArray(x) && (x.length === 0 || x.length === 1 && this._type.covariant(x[0])))
          return true;
      } catch (e) {
        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)} \n\n-> ${e.message}`);
      }
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      if (x.length === 0) {
        return new Uint8Array([0]);
      } else {
        return (0, buffer_1.concat)(new Uint8Array([1]), this._type.encodeValue(x[0]));
      }
    }
    _buildTypeTableImpl(typeTable) {
      this._type.buildTypeTable(typeTable);
      const opCode = (0, leb128_1.slebEncode)(-18);
      const buffer = this._type.encodeType(typeTable);
      typeTable.add(this, (0, buffer_1.concat)(opCode, buffer));
    }
    decodeValue(b, t2) {
      const opt = this.checkType(t2);
      if (!(opt instanceof OptClass)) {
        throw new Error("Not an option type");
      }
      switch ((0, leb128_1.safeReadUint8)(b)) {
        case 0:
          return [];
        case 1:
          return [this._type.decodeValue(b, opt._type)];
        default:
          throw new Error("Not an option value");
      }
    }
    get name() {
      return `opt ${this._type.name}`;
    }
    display() {
      return `opt ${this._type.display()}`;
    }
    valueToString(x) {
      if (x.length === 0) {
        return "null";
      } else {
        return `opt ${this._type.valueToString(x[0])}`;
      }
    }
  }
  exports.OptClass = OptClass;

  class RecordClass extends ConstructType {
    constructor(fields = {}) {
      super();
      this._fields = Object.entries(fields).sort((a, b) => (0, hash_1.idlLabelToId)(a[0]) - (0, hash_1.idlLabelToId)(b[0]));
    }
    accept(v, d) {
      return v.visitRecord(this, this._fields, d);
    }
    tryAsTuple() {
      const res = [];
      for (let i = 0;i < this._fields.length; i++) {
        const [key, type] = this._fields[i];
        if (key !== `_${i}_`) {
          return null;
        }
        res.push(type);
      }
      return res;
    }
    covariant(x) {
      if (typeof x === "object" && this._fields.every(([k, t2]) => {
        if (!x.hasOwnProperty(k)) {
          throw new Error(`Record is missing key "${k}".`);
        }
        try {
          return t2.covariant(x[k]);
        } catch (e) {
          throw new Error(`Invalid ${this.display()} argument: \n\nfield ${k} -> ${e.message}`);
        }
      }))
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      const values = this._fields.map(([key]) => x[key]);
      const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));
      return (0, buffer_1.concat)(...bufs);
    }
    _buildTypeTableImpl(T) {
      this._fields.forEach(([_, value]) => value.buildTypeTable(T));
      const opCode = (0, leb128_1.slebEncode)(-20);
      const len = (0, leb128_1.lebEncode)(this._fields.length);
      const fields = this._fields.map(([key, value]) => (0, buffer_1.concat)((0, leb128_1.lebEncode)((0, hash_1.idlLabelToId)(key)), value.encodeType(T)));
      T.add(this, (0, buffer_1.concat)(opCode, len, (0, buffer_1.concat)(...fields)));
    }
    decodeValue(b, t2) {
      const record = this.checkType(t2);
      if (!(record instanceof RecordClass)) {
        throw new Error("Not a record type");
      }
      const x = {};
      let expectedRecordIdx = 0;
      let actualRecordIdx = 0;
      while (actualRecordIdx < record._fields.length) {
        const [hash, type] = record._fields[actualRecordIdx];
        if (expectedRecordIdx >= this._fields.length) {
          type.decodeValue(b, type);
          actualRecordIdx++;
          continue;
        }
        const [expectKey, expectType] = this._fields[expectedRecordIdx];
        const expectedId = (0, hash_1.idlLabelToId)(this._fields[expectedRecordIdx][0]);
        const actualId = (0, hash_1.idlLabelToId)(hash);
        if (expectedId === actualId) {
          x[expectKey] = expectType.decodeValue(b, type);
          expectedRecordIdx++;
          actualRecordIdx++;
        } else if (actualId > expectedId) {
          if (expectType instanceof OptClass || expectType instanceof ReservedClass) {
            x[expectKey] = [];
            expectedRecordIdx++;
          } else {
            throw new Error("Cannot find required field " + expectKey);
          }
        } else {
          type.decodeValue(b, type);
          actualRecordIdx++;
        }
      }
      for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {
        if (expectType instanceof OptClass || expectType instanceof ReservedClass) {
          x[expectKey] = [];
        } else {
          throw new Error("Cannot find required field " + expectKey);
        }
      }
      return x;
    }
    get name() {
      const fields = this._fields.map(([key, value]) => key + ":" + value.name);
      return `record {${fields.join("; ")}}`;
    }
    display() {
      const fields = this._fields.map(([key, value]) => key + ":" + value.display());
      return `record {${fields.join("; ")}}`;
    }
    valueToString(x) {
      const values = this._fields.map(([key]) => x[key]);
      const fields = zipWith(this._fields, values, ([k, c], d) => k + "=" + c.valueToString(d));
      return `record {${fields.join("; ")}}`;
    }
  }
  exports.RecordClass = RecordClass;

  class TupleClass extends RecordClass {
    constructor(_components) {
      const x = {};
      _components.forEach((e, i) => x["_" + i + "_"] = e);
      super(x);
      this._components = _components;
    }
    accept(v, d) {
      return v.visitTuple(this, this._components, d);
    }
    covariant(x) {
      if (Array.isArray(x) && x.length >= this._fields.length && this._components.every((t2, i) => {
        try {
          return t2.covariant(x[i]);
        } catch (e) {
          throw new Error(`Invalid ${this.display()} argument: \n\nindex ${i} -> ${e.message}`);
        }
      }))
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));
      return (0, buffer_1.concat)(...bufs);
    }
    decodeValue(b, t2) {
      const tuple = this.checkType(t2);
      if (!(tuple instanceof TupleClass)) {
        throw new Error("not a tuple type");
      }
      if (tuple._components.length < this._components.length) {
        throw new Error("tuple mismatch");
      }
      const res = [];
      for (const [i, wireType] of tuple._components.entries()) {
        if (i >= this._components.length) {
          wireType.decodeValue(b, wireType);
        } else {
          res.push(this._components[i].decodeValue(b, wireType));
        }
      }
      return res;
    }
    display() {
      const fields = this._components.map((value) => value.display());
      return `record {${fields.join("; ")}}`;
    }
    valueToString(values) {
      const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));
      return `record {${fields.join("; ")}}`;
    }
  }
  exports.TupleClass = TupleClass;

  class VariantClass extends ConstructType {
    constructor(fields = {}) {
      super();
      this._fields = Object.entries(fields).sort((a, b) => (0, hash_1.idlLabelToId)(a[0]) - (0, hash_1.idlLabelToId)(b[0]));
    }
    accept(v, d) {
      return v.visitVariant(this, this._fields, d);
    }
    covariant(x) {
      if (typeof x === "object" && Object.entries(x).length === 1 && this._fields.every(([k, v]) => {
        try {
          return !x.hasOwnProperty(k) || v.covariant(x[k]);
        } catch (e) {
          throw new Error(`Invalid ${this.display()} argument: \n\nvariant ${k} -> ${e.message}`);
        }
      }))
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      for (let i = 0;i < this._fields.length; i++) {
        const [name, type] = this._fields[i];
        if (x.hasOwnProperty(name)) {
          const idx = (0, leb128_1.lebEncode)(i);
          const buf = type.encodeValue(x[name]);
          return (0, buffer_1.concat)(idx, buf);
        }
      }
      throw Error("Variant has no data: " + x);
    }
    _buildTypeTableImpl(typeTable) {
      this._fields.forEach(([, type]) => {
        type.buildTypeTable(typeTable);
      });
      const opCode = (0, leb128_1.slebEncode)(-21);
      const len = (0, leb128_1.lebEncode)(this._fields.length);
      const fields = this._fields.map(([key, value]) => (0, buffer_1.concat)((0, leb128_1.lebEncode)((0, hash_1.idlLabelToId)(key)), value.encodeType(typeTable)));
      typeTable.add(this, (0, buffer_1.concat)(opCode, len, ...fields));
    }
    decodeValue(b, t2) {
      const variant = this.checkType(t2);
      if (!(variant instanceof VariantClass)) {
        throw new Error("Not a variant type");
      }
      const idx = Number((0, leb128_1.lebDecode)(b));
      if (idx >= variant._fields.length) {
        throw Error("Invalid variant index: " + idx);
      }
      const [wireHash, wireType] = variant._fields[idx];
      for (const [key, expectType] of this._fields) {
        if ((0, hash_1.idlLabelToId)(wireHash) === (0, hash_1.idlLabelToId)(key)) {
          const value = expectType.decodeValue(b, wireType);
          return { [key]: value };
        }
      }
      throw new Error("Cannot find field hash " + wireHash);
    }
    get name() {
      const fields = this._fields.map(([key, type]) => key + ":" + type.name);
      return `variant {${fields.join("; ")}}`;
    }
    display() {
      const fields = this._fields.map(([key, type]) => key + (type.name === "null" ? "" : `:${type.display()}`));
      return `variant {${fields.join("; ")}}`;
    }
    valueToString(x) {
      for (const [name, type] of this._fields) {
        if (x.hasOwnProperty(name)) {
          const value = type.valueToString(x[name]);
          if (value === "null") {
            return `variant {${name}}`;
          } else {
            return `variant {${name}=${value}}`;
          }
        }
      }
      throw new Error("Variant has no data: " + x);
    }
  }
  exports.VariantClass = VariantClass;

  class RecClass extends ConstructType {
    constructor() {
      super(...arguments);
      this._id = RecClass._counter++;
      this._type = undefined;
    }
    accept(v, d) {
      if (!this._type) {
        throw Error("Recursive type uninitialized.");
      }
      return v.visitRec(this, this._type, d);
    }
    fill(t2) {
      this._type = t2;
    }
    getType() {
      return this._type;
    }
    covariant(x) {
      if (this._type ? this._type.covariant(x) : false)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      if (!this._type) {
        throw Error("Recursive type uninitialized.");
      }
      return this._type.encodeValue(x);
    }
    _buildTypeTableImpl(typeTable) {
      if (!this._type) {
        throw Error("Recursive type uninitialized.");
      }
      typeTable.add(this, new Uint8Array([]));
      this._type.buildTypeTable(typeTable);
      typeTable.merge(this, this._type.name);
    }
    decodeValue(b, t2) {
      if (!this._type) {
        throw Error("Recursive type uninitialized.");
      }
      return this._type.decodeValue(b, t2);
    }
    get name() {
      return `rec_${this._id}`;
    }
    display() {
      if (!this._type) {
        throw Error("Recursive type uninitialized.");
      }
      return `\u03BC${this.name}.${this._type.name}`;
    }
    valueToString(x) {
      if (!this._type) {
        throw Error("Recursive type uninitialized.");
      }
      return this._type.valueToString(x);
    }
  }
  exports.RecClass = RecClass;
  RecClass._counter = 0;

  class PrincipalClass extends PrimitiveType {
    accept(v, d) {
      return v.visitPrincipal(this, d);
    }
    covariant(x) {
      if (x && x._isPrincipal)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      const buf = x.toUint8Array();
      const len = (0, leb128_1.lebEncode)(buf.byteLength);
      return (0, buffer_1.concat)(new Uint8Array([1]), len, buf);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-24);
    }
    decodeValue(b, t2) {
      this.checkType(t2);
      return decodePrincipalId(b);
    }
    get name() {
      return "principal";
    }
    valueToString(x) {
      return `${this.name} "${x.toText()}"`;
    }
  }
  exports.PrincipalClass = PrincipalClass;

  class FuncClass extends ConstructType {
    constructor(argTypes, retTypes, annotations = []) {
      super();
      this.argTypes = argTypes;
      this.retTypes = retTypes;
      this.annotations = annotations;
    }
    static argsToString(types, v) {
      if (types.length !== v.length) {
        throw new Error("arity mismatch");
      }
      return "(" + types.map((t2, i) => t2.valueToString(v[i])).join(", ") + ")";
    }
    accept(v, d) {
      return v.visitFunc(this, d);
    }
    covariant(x) {
      if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === "string")
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue([principal, methodName]) {
      const buf = principal.toUint8Array();
      const len = (0, leb128_1.lebEncode)(buf.byteLength);
      const canister = (0, buffer_1.concat)(new Uint8Array([1]), len, buf);
      const method = new TextEncoder().encode(methodName);
      const methodLen = (0, leb128_1.lebEncode)(method.byteLength);
      return (0, buffer_1.concat)(new Uint8Array([1]), canister, methodLen, method);
    }
    _buildTypeTableImpl(T) {
      this.argTypes.forEach((arg) => arg.buildTypeTable(T));
      this.retTypes.forEach((arg) => arg.buildTypeTable(T));
      const opCode = (0, leb128_1.slebEncode)(-22);
      const argLen = (0, leb128_1.lebEncode)(this.argTypes.length);
      const args = (0, buffer_1.concat)(...this.argTypes.map((arg) => arg.encodeType(T)));
      const retLen = (0, leb128_1.lebEncode)(this.retTypes.length);
      const rets = (0, buffer_1.concat)(...this.retTypes.map((arg) => arg.encodeType(T)));
      const annLen = (0, leb128_1.lebEncode)(this.annotations.length);
      const anns = (0, buffer_1.concat)(...this.annotations.map((a) => this.encodeAnnotation(a)));
      T.add(this, (0, buffer_1.concat)(opCode, argLen, args, retLen, rets, annLen, anns));
    }
    decodeValue(b) {
      const x = (0, leb128_1.safeReadUint8)(b);
      if (x !== 1) {
        throw new Error("Cannot decode function reference");
      }
      const canister = decodePrincipalId(b);
      const mLen = Number((0, leb128_1.lebDecode)(b));
      const buf = (0, leb128_1.safeRead)(b, mLen);
      const decoder = new TextDecoder("utf8", { fatal: true });
      const method = decoder.decode(buf);
      return [canister, method];
    }
    get name() {
      const args = this.argTypes.map((arg) => arg.name).join(", ");
      const rets = this.retTypes.map((arg) => arg.name).join(", ");
      const annon = " " + this.annotations.join(" ");
      return `(${args}) -> (${rets})${annon}`;
    }
    valueToString([principal, str]) {
      return `func "${principal.toText()}".${str}`;
    }
    display() {
      const args = this.argTypes.map((arg) => arg.display()).join(", ");
      const rets = this.retTypes.map((arg) => arg.display()).join(", ");
      const annon = " " + this.annotations.join(" ");
      return `(${args}) \u2192 (${rets})${annon}`;
    }
    encodeAnnotation(ann) {
      if (ann === "query") {
        return new Uint8Array([1]);
      } else if (ann === "oneway") {
        return new Uint8Array([2]);
      } else if (ann === "composite_query") {
        return new Uint8Array([3]);
      } else {
        throw new Error("Illegal function annotation");
      }
    }
  }
  exports.FuncClass = FuncClass;

  class ServiceClass extends ConstructType {
    constructor(fields) {
      super();
      this._fields = Object.entries(fields).sort((a, b) => (0, hash_1.idlLabelToId)(a[0]) - (0, hash_1.idlLabelToId)(b[0]));
    }
    accept(v, d) {
      return v.visitService(this, d);
    }
    covariant(x) {
      if (x && x._isPrincipal)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
    }
    encodeValue(x) {
      const buf = x.toUint8Array();
      const len = (0, leb128_1.lebEncode)(buf.length);
      return (0, buffer_1.concat)(new Uint8Array([1]), len, buf);
    }
    _buildTypeTableImpl(T) {
      this._fields.forEach(([_, func]) => func.buildTypeTable(T));
      const opCode = (0, leb128_1.slebEncode)(-23);
      const len = (0, leb128_1.lebEncode)(this._fields.length);
      const meths = this._fields.map(([label, func]) => {
        const labelBuf = new TextEncoder().encode(label);
        const labelLen = (0, leb128_1.lebEncode)(labelBuf.length);
        return (0, buffer_1.concat)(labelLen, labelBuf, func.encodeType(T));
      });
      T.add(this, (0, buffer_1.concat)(opCode, len, ...meths));
    }
    decodeValue(b) {
      return decodePrincipalId(b);
    }
    get name() {
      const fields = this._fields.map(([key, value]) => key + ":" + value.name);
      return `service {${fields.join("; ")}}`;
    }
    valueToString(x) {
      return `service "${x.toText()}"`;
    }
  }
  exports.ServiceClass = ServiceClass;
  exports.encode = encode;
  exports.decode = decode;
  exports.Empty = new EmptyClass;
  exports.Reserved = new ReservedClass;
  exports.Unknown = new UnknownClass;
  exports.Bool = new BoolClass;
  exports.Null = new NullClass;
  exports.Text = new TextClass;
  exports.Int = new IntClass;
  exports.Nat = new NatClass;
  exports.Float32 = new FloatClass(32);
  exports.Float64 = new FloatClass(64);
  exports.Int8 = new FixedIntClass(8);
  exports.Int16 = new FixedIntClass(16);
  exports.Int32 = new FixedIntClass(32);
  exports.Int64 = new FixedIntClass(64);
  exports.Nat8 = new FixedNatClass(8);
  exports.Nat16 = new FixedNatClass(16);
  exports.Nat32 = new FixedNatClass(32);
  exports.Nat64 = new FixedNatClass(64);
  exports.Principal = new PrincipalClass;
  exports.Tuple = Tuple;
  exports.Vec = Vec;
  exports.Opt = Opt;
  exports.Record = Record;
  exports.Variant = Variant;
  exports.Rec = Rec;
  exports.Func = Func;
  exports.Service = Service;
});

// node_modules/@dfinity/candid/lib/cjs/candid-core.js
var require_candid_core = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VecForm = exports.OptionForm = exports.VariantForm = exports.TupleForm = exports.RecordForm = exports.InputForm = exports.InputBox = undefined;

  class InputBox {
    constructor(idl, ui) {
      this.idl = idl;
      this.ui = ui;
      this.label = null;
      this.value = undefined;
      const status = document.createElement("span");
      status.className = "status";
      this.status = status;
      if (ui.input) {
        ui.input.addEventListener("blur", () => {
          if (ui.input.value === "") {
            return;
          }
          this.parse();
        });
        ui.input.addEventListener("input", () => {
          status.style.display = "none";
          ui.input.classList.remove("reject");
        });
      }
    }
    isRejected() {
      return this.value === undefined;
    }
    parse(config = {}) {
      if (this.ui.form) {
        const value = this.ui.form.parse(config);
        this.value = value;
        return value;
      }
      if (this.ui.input) {
        const input = this.ui.input;
        try {
          const value = this.ui.parse(this.idl, config, input.value);
          if (!this.idl.covariant(value)) {
            throw new Error(`${input.value} is not of type ${this.idl.display()}`);
          }
          this.status.style.display = "none";
          this.value = value;
          return value;
        } catch (err) {
          input.classList.add("reject");
          this.status.style.display = "block";
          this.status.innerHTML = "InputError: " + err.message;
          this.value = undefined;
          return;
        }
      }
      return null;
    }
    render(dom) {
      const container = document.createElement("span");
      if (this.label) {
        const label = document.createElement("label");
        label.innerText = this.label;
        container.appendChild(label);
      }
      if (this.ui.input) {
        container.appendChild(this.ui.input);
        container.appendChild(this.status);
      }
      if (this.ui.form) {
        this.ui.form.render(container);
      }
      dom.appendChild(container);
    }
  }
  exports.InputBox = InputBox;

  class InputForm {
    constructor(ui) {
      this.ui = ui;
      this.form = [];
    }
    renderForm(dom) {
      if (this.ui.container) {
        this.form.forEach((e) => e.render(this.ui.container));
        dom.appendChild(this.ui.container);
      } else {
        this.form.forEach((e) => e.render(dom));
      }
    }
    render(dom) {
      if (this.ui.open && this.ui.event) {
        dom.appendChild(this.ui.open);
        const form = this;
        form.ui.open.addEventListener(form.ui.event, () => {
          if (form.ui.container) {
            form.ui.container.innerHTML = "";
          } else {
            const oldContainer = form.ui.open.nextElementSibling;
            if (oldContainer) {
              oldContainer.parentNode.removeChild(oldContainer);
            }
          }
          form.generateForm();
          form.renderForm(dom);
        });
      } else {
        this.generateForm();
        this.renderForm(dom);
      }
    }
  }
  exports.InputForm = InputForm;

  class RecordForm extends InputForm {
    constructor(fields, ui) {
      super(ui);
      this.fields = fields;
      this.ui = ui;
    }
    generateForm() {
      this.form = this.fields.map(([key, type]) => {
        const input = this.ui.render(type);
        if (this.ui.labelMap && this.ui.labelMap.hasOwnProperty(key)) {
          input.label = this.ui.labelMap[key] + " ";
        } else {
          input.label = key + " ";
        }
        return input;
      });
    }
    parse(config) {
      const v = {};
      this.fields.forEach(([key, _], i) => {
        const value = this.form[i].parse(config);
        v[key] = value;
      });
      if (this.form.some((input) => input.isRejected())) {
        return;
      }
      return v;
    }
  }
  exports.RecordForm = RecordForm;

  class TupleForm extends InputForm {
    constructor(components, ui) {
      super(ui);
      this.components = components;
      this.ui = ui;
    }
    generateForm() {
      this.form = this.components.map((type) => {
        const input = this.ui.render(type);
        return input;
      });
    }
    parse(config) {
      const v = [];
      this.components.forEach((_, i) => {
        const value = this.form[i].parse(config);
        v.push(value);
      });
      if (this.form.some((input) => input.isRejected())) {
        return;
      }
      return v;
    }
  }
  exports.TupleForm = TupleForm;

  class VariantForm extends InputForm {
    constructor(fields, ui) {
      super(ui);
      this.fields = fields;
      this.ui = ui;
    }
    generateForm() {
      const index = this.ui.open.selectedIndex;
      const [_, type] = this.fields[index];
      const variant = this.ui.render(type);
      this.form = [variant];
    }
    parse(config) {
      const select = this.ui.open;
      const selected = select.options[select.selectedIndex].value;
      const value = this.form[0].parse(config);
      if (value === undefined) {
        return;
      }
      const v = {};
      v[selected] = value;
      return v;
    }
  }
  exports.VariantForm = VariantForm;

  class OptionForm extends InputForm {
    constructor(ty, ui) {
      super(ui);
      this.ty = ty;
      this.ui = ui;
    }
    generateForm() {
      if (this.ui.open.checked) {
        const opt = this.ui.render(this.ty);
        this.form = [opt];
      } else {
        this.form = [];
      }
    }
    parse(config) {
      if (this.form.length === 0) {
        return [];
      } else {
        const value = this.form[0].parse(config);
        if (value === undefined) {
          return;
        }
        return [value];
      }
    }
  }
  exports.OptionForm = OptionForm;

  class VecForm extends InputForm {
    constructor(ty, ui) {
      super(ui);
      this.ty = ty;
      this.ui = ui;
    }
    generateForm() {
      const len = +this.ui.open.value;
      this.form = [];
      for (let i = 0;i < len; i++) {
        const t2 = this.ui.render(this.ty);
        this.form.push(t2);
      }
    }
    parse(config) {
      const value = this.form.map((input) => {
        return input.parse(config);
      });
      if (this.form.some((input) => input.isRejected())) {
        return;
      }
      return value;
    }
  }
  exports.VecForm = VecForm;
});

// node_modules/@dfinity/candid/lib/cjs/candid-ui.js
var require_candid_ui = __commonJS((exports) => {
  var parsePrimitive = function(t2, config, d) {
    if (config.random && d === "") {
      return t2.accept(new Random, d);
    } else {
      return t2.accept(new Parse, d);
    }
  };
  var renderInput = function(t2) {
    return t2.accept(new Render, null);
  };
  var renderValue = function(t2, input, value) {
    return t2.accept(new RenderValue, { input, value });
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.renderValue = exports.renderInput = exports.Render = exports.vecForm = exports.optForm = exports.variantForm = exports.tupleForm = exports.recordForm = exports.inputBox = undefined;
  var IDL = __importStar(require_idl());
  var principal_1 = require_cjs();
  var UI = __importStar(require_candid_core());
  var InputConfig = { parse: parsePrimitive };
  var FormConfig = { render: renderInput };
  var inputBox = (t2, config) => {
    return new UI.InputBox(t2, Object.assign(Object.assign({}, InputConfig), config));
  };
  exports.inputBox = inputBox;
  var recordForm = (fields, config) => {
    return new UI.RecordForm(fields, Object.assign(Object.assign({}, FormConfig), config));
  };
  exports.recordForm = recordForm;
  var tupleForm = (components, config) => {
    return new UI.TupleForm(components, Object.assign(Object.assign({}, FormConfig), config));
  };
  exports.tupleForm = tupleForm;
  var variantForm = (fields, config) => {
    return new UI.VariantForm(fields, Object.assign(Object.assign({}, FormConfig), config));
  };
  exports.variantForm = variantForm;
  var optForm = (ty, config) => {
    return new UI.OptionForm(ty, Object.assign(Object.assign({}, FormConfig), config));
  };
  exports.optForm = optForm;
  var vecForm = (ty, config) => {
    return new UI.VecForm(ty, Object.assign(Object.assign({}, FormConfig), config));
  };
  exports.vecForm = vecForm;

  class Render extends IDL.Visitor {
    visitType(t2, d) {
      const input = document.createElement("input");
      input.classList.add("argument");
      input.placeholder = t2.display();
      return (0, exports.inputBox)(t2, { input });
    }
    visitNull(t2, d) {
      return (0, exports.inputBox)(t2, {});
    }
    visitRecord(t2, fields, d) {
      let config = {};
      if (fields.length > 1) {
        const container = document.createElement("div");
        container.classList.add("popup-form");
        config = { container };
      }
      const form = (0, exports.recordForm)(fields, config);
      return (0, exports.inputBox)(t2, { form });
    }
    visitTuple(t2, components, d) {
      let config = {};
      if (components.length > 1) {
        const container = document.createElement("div");
        container.classList.add("popup-form");
        config = { container };
      }
      const form = (0, exports.tupleForm)(components, config);
      return (0, exports.inputBox)(t2, { form });
    }
    visitVariant(t2, fields, d) {
      const select = document.createElement("select");
      for (const [key, type] of fields) {
        const option = new Option(key);
        select.add(option);
      }
      select.selectedIndex = -1;
      select.classList.add("open");
      const config = { open: select, event: "change" };
      const form = (0, exports.variantForm)(fields, config);
      return (0, exports.inputBox)(t2, { form });
    }
    visitOpt(t2, ty, d) {
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.classList.add("open");
      const form = (0, exports.optForm)(ty, { open: checkbox, event: "change" });
      return (0, exports.inputBox)(t2, { form });
    }
    visitVec(t2, ty, d) {
      const len = document.createElement("input");
      len.type = "number";
      len.min = "0";
      len.max = "100";
      len.style.width = "8rem";
      len.placeholder = "len";
      len.classList.add("open");
      const container = document.createElement("div");
      container.classList.add("popup-form");
      const form = (0, exports.vecForm)(ty, { open: len, event: "change", container });
      return (0, exports.inputBox)(t2, { form });
    }
    visitRec(t2, ty, d) {
      return renderInput(ty);
    }
  }
  exports.Render = Render;

  class Parse extends IDL.Visitor {
    visitNull(t2, v) {
      return null;
    }
    visitBool(t2, v) {
      if (v === "true") {
        return true;
      }
      if (v === "false") {
        return false;
      }
      throw new Error(`Cannot parse ${v} as boolean`);
    }
    visitText(t2, v) {
      return v;
    }
    visitFloat(t2, v) {
      return parseFloat(v);
    }
    visitFixedInt(t2, v) {
      if (t2._bits <= 32) {
        return parseInt(v, 10);
      } else {
        return BigInt(v);
      }
    }
    visitFixedNat(t2, v) {
      if (t2._bits <= 32) {
        return parseInt(v, 10);
      } else {
        return BigInt(v);
      }
    }
    visitNumber(t2, v) {
      return BigInt(v);
    }
    visitPrincipal(t2, v) {
      return principal_1.Principal.fromText(v);
    }
    visitService(t2, v) {
      return principal_1.Principal.fromText(v);
    }
    visitFunc(t2, v) {
      const x = v.split(".", 2);
      return [principal_1.Principal.fromText(x[0]), x[1]];
    }
  }

  class Random extends IDL.Visitor {
    visitNull(t2, v) {
      return null;
    }
    visitBool(t2, v) {
      return Math.random() < 0.5;
    }
    visitText(t2, v) {
      return Math.random().toString(36).substring(6);
    }
    visitFloat(t2, v) {
      return Math.random();
    }
    visitInt(t2, v) {
      return BigInt(this.generateNumber(true));
    }
    visitNat(t2, v) {
      return BigInt(this.generateNumber(false));
    }
    visitFixedInt(t2, v) {
      const x = this.generateNumber(true);
      if (t2._bits <= 32) {
        return x;
      } else {
        return BigInt(v);
      }
    }
    visitFixedNat(t2, v) {
      const x = this.generateNumber(false);
      if (t2._bits <= 32) {
        return x;
      } else {
        return BigInt(v);
      }
    }
    generateNumber(signed) {
      const num = Math.floor(Math.random() * 100);
      if (signed && Math.random() < 0.5) {
        return -num;
      } else {
        return num;
      }
    }
  }
  exports.renderInput = renderInput;
  exports.renderValue = renderValue;

  class RenderValue extends IDL.Visitor {
    visitType(t2, d) {
      d.input.ui.input.value = t2.valueToString(d.value);
    }
    visitNull(t2, d) {
    }
    visitText(t2, d) {
      d.input.ui.input.value = d.value;
    }
    visitRec(t2, ty, d) {
      renderValue(ty, d.input, d.value);
    }
    visitOpt(t2, ty, d) {
      if (d.value.length === 0) {
        return;
      } else {
        const form = d.input.ui.form;
        const open = form.ui.open;
        open.checked = true;
        open.dispatchEvent(new Event(form.ui.event));
        renderValue(ty, form.form[0], d.value[0]);
      }
    }
    visitRecord(t2, fields, d) {
      const form = d.input.ui.form;
      fields.forEach(([key, type], i) => {
        renderValue(type, form.form[i], d.value[key]);
      });
    }
    visitTuple(t2, components, d) {
      const form = d.input.ui.form;
      components.forEach((type, i) => {
        renderValue(type, form.form[i], d.value[i]);
      });
    }
    visitVariant(t2, fields, d) {
      const form = d.input.ui.form;
      const selected = Object.entries(d.value)[0];
      fields.forEach(([key, type], i) => {
        if (key === selected[0]) {
          const open = form.ui.open;
          open.selectedIndex = i;
          open.dispatchEvent(new Event(form.ui.event));
          renderValue(type, form.form[0], selected[1]);
        }
      });
    }
    visitVec(t2, ty, d) {
      const form = d.input.ui.form;
      const len = d.value.length;
      const open = form.ui.open;
      open.value = len;
      open.dispatchEvent(new Event(form.ui.event));
      d.value.forEach((v, i) => {
        renderValue(ty, form.form[i], v);
      });
    }
  }
});

// node_modules/@dfinity/candid/lib/cjs/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@dfinity/candid/lib/cjs/index.js
var require_cjs2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IDL = undefined;
  __exportStar(require_candid_ui(), exports);
  __exportStar(require_candid_core(), exports);
  exports.IDL = __importStar(require_idl());
  __exportStar(require_hash(), exports);
  __exportStar(require_leb128(), exports);
  __exportStar(require_buffer(), exports);
  __exportStar(require_types(), exports);
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS((exports) => {
  var getLens = function(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  };
  var byteLength = function(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  };
  var _byteLength = function(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  };
  var toByteArray = function(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0;i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  };
  var tripletToBase64 = function(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  };
  var encodeChunk = function(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start;i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  };
  var fromByteArray = function(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes;i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  };
  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (i = 0, len = code.length;i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  var i;
  var len;
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS((exports) => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s2 = buffer[offset + i];
    i += d;
    e = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (;nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (;nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s2 ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (;mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (;eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i - d] |= s2 * 128;
  };
});

// node_modules/@dfinity/agent/lib/esm/errors.js
class AgentError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    Object.setPrototypeOf(this, AgentError.prototype);
  }
}
var init_errors = __esm(() => {
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS((exports, module) => {
  (function(globalObject) {
    var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 100000000000000, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1000, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 10000000000, 100000000000, 1000000000000, 10000000000000], SQRT_BASE = 1e7, MAX = 1e9;
    function clone(configObject) {
      var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "\xA0",
        suffix: ""
      }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
      function BigNumber2(v, b) {
        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
        if (!(x instanceof BigNumber2))
          return new BigNumber2(v, b);
        if (b == null) {
          if (v && v._isBigNumber === true) {
            x.s = v.s;
            if (!v.c || v.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (v.e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = v.e;
              x.c = v.c.slice();
            }
            return;
          }
          if ((isNum = typeof v == "number") && v * 0 == 0) {
            x.s = 1 / v < 0 ? (v = -v, -1) : 1;
            if (v === ~~v) {
              for (e = 0, i = v;i >= 10; i /= 10, e++)
                ;
              if (e > MAX_EXP) {
                x.c = x.e = null;
              } else {
                x.e = e;
                x.c = [v];
              }
              return;
            }
            str = String(v);
          } else {
            if (!isNumeric.test(str = String(v)))
              return parseNumeric(x, str, isNum);
            x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0)
              e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
        } else {
          intCheck(b, 2, ALPHABET.length, "Base");
          if (b == 10 && alphabetHasNormalDecimalDigits) {
            x = new BigNumber2(v);
            return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
          }
          str = String(v);
          if (isNum = typeof v == "number") {
            if (v * 0 != 0)
              return parseNumeric(x, str, isNum, b);
            x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v);
            }
          } else {
            x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet = ALPHABET.slice(0, b);
          e = i = 0;
          for (len = str.length;i < len; i++) {
            if (alphabet.indexOf(c = str.charAt(i)) < 0) {
              if (c == ".") {
                if (i > e) {
                  e = len;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i = -1;
                  e = 0;
                  continue;
                }
              }
              return parseNumeric(x, String(v), isNum, b);
            }
          }
          isNum = false;
          str = convertBase(str, b, 10, x.s);
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          else
            e = str.length;
        }
        for (i = 0;str.charCodeAt(i) === 48; i++)
          ;
        for (len = str.length;str.charCodeAt(--len) === 48; )
          ;
        if (str = str.slice(i, ++len)) {
          len -= i;
          if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error(tooManyDigits + x.s * v);
          }
          if ((e = e - i - 1) > MAX_EXP) {
            x.c = x.e = null;
          } else if (e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = e;
            x.c = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0)
              i += LOG_BASE;
            if (i < len) {
              if (i)
                x.c.push(+str.slice(0, i));
              for (len -= LOG_BASE;i < len; ) {
                x.c.push(+str.slice(i, i += LOG_BASE));
              }
              i = LOG_BASE - (str = str.slice(i)).length;
            } else {
              i -= len;
            }
            for (;i--; str += "0")
              ;
            x.c.push(+str);
          }
        } else {
          x.c = [x.e = 0];
        }
      }
      BigNumber2.clone = clone;
      BigNumber2.ROUND_UP = 0;
      BigNumber2.ROUND_DOWN = 1;
      BigNumber2.ROUND_CEIL = 2;
      BigNumber2.ROUND_FLOOR = 3;
      BigNumber2.ROUND_HALF_UP = 4;
      BigNumber2.ROUND_HALF_DOWN = 5;
      BigNumber2.ROUND_HALF_EVEN = 6;
      BigNumber2.ROUND_HALF_CEIL = 7;
      BigNumber2.ROUND_HALF_FLOOR = 8;
      BigNumber2.EUCLID = 9;
      BigNumber2.config = BigNumber2.set = function(obj) {
        var p, v;
        if (obj != null) {
          if (typeof obj == "object") {
            if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              DECIMAL_PLACES = v;
            }
            if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
              v = obj[p];
              intCheck(v, 0, 8, p);
              ROUNDING_MODE = v;
            }
            if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, 0, p);
                intCheck(v[1], 0, MAX, p);
                TO_EXP_NEG = v[0];
                TO_EXP_POS = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
              }
            }
            if (obj.hasOwnProperty(p = "RANGE")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, -1, p);
                intCheck(v[1], 1, MAX, p);
                MIN_EXP = v[0];
                MAX_EXP = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                if (v) {
                  MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                } else {
                  throw Error(bignumberError + p + " cannot be zero: " + v);
                }
              }
            }
            if (obj.hasOwnProperty(p = "CRYPTO")) {
              v = obj[p];
              if (v === !!v) {
                if (v) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v;
                  } else {
                    CRYPTO = !v;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v;
                }
              } else {
                throw Error(bignumberError + p + " not true or false: " + v);
              }
            }
            if (obj.hasOwnProperty(p = "MODULO_MODE")) {
              v = obj[p];
              intCheck(v, 0, 9, p);
              MODULO_MODE = v;
            }
            if (obj.hasOwnProperty(p = "POW_PRECISION")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              POW_PRECISION = v;
            }
            if (obj.hasOwnProperty(p = "FORMAT")) {
              v = obj[p];
              if (typeof v == "object")
                FORMAT = v;
              else
                throw Error(bignumberError + p + " not an object: " + v);
            }
            if (obj.hasOwnProperty(p = "ALPHABET")) {
              v = obj[p];
              if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                ALPHABET = v;
              } else {
                throw Error(bignumberError + p + " invalid: " + v);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj);
          }
        }
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET
        };
      };
      BigNumber2.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true)
          return false;
        if (!BigNumber2.DEBUG)
          return true;
        var i, n, c = v.c, e = v.e, s2 = v.s;
        out:
          if ({}.toString.call(c) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1)
                  return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1)
                i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0;i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n))
                    break out;
                }
                if (n !== 0)
                  return true;
              }
            }
          } else if (c === null && e === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
        throw Error(bignumberError + "Invalid BigNumber: " + v);
      };
      BigNumber2.maximum = BigNumber2.max = function() {
        return maxOrMin(arguments, -1);
      };
      BigNumber2.minimum = BigNumber2.min = function() {
        return maxOrMin(arguments, 1);
      };
      BigNumber2.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
          if (dp == null)
            dp = DECIMAL_PLACES;
          else
            intCheck(dp, 0, MAX);
          k = mathceil(dp / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a = crypto.getRandomValues(new Uint32Array(k *= 2));
              for (;i < k; ) {
                v = a[i] * 131072 + (a[i + 1] >>> 11);
                if (v >= 9000000000000000) {
                  b = crypto.getRandomValues(new Uint32Array(2));
                  a[i] = b[0];
                  a[i + 1] = b[1];
                } else {
                  c.push(v % 100000000000000);
                  i += 2;
                }
              }
              i = k / 2;
            } else if (crypto.randomBytes) {
              a = crypto.randomBytes(k *= 7);
              for (;i < k; ) {
                v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                if (v >= 9000000000000000) {
                  crypto.randomBytes(7).copy(a, i);
                } else {
                  c.push(v % 100000000000000);
                  i += 7;
                }
              }
              i = k / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (;i < k; ) {
              v = random53bitInt();
              if (v < 9000000000000000)
                c[i++] = v % 100000000000000;
            }
          }
          k = c[--i];
          dp %= LOG_BASE;
          if (k && dp) {
            v = POWS_TEN[LOG_BASE - dp];
            c[i] = mathfloor(k / v) * v;
          }
          for (;c[i] === 0; c.pop(), i--)
            ;
          if (i < 0) {
            c = [e = 0];
          } else {
            for (e = -1;c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
              ;
            for (i = 1, v = c[0];v >= 10; v /= 10, i++)
              ;
            if (i < LOG_BASE)
              e -= LOG_BASE - i;
          }
          rand.e = e;
          rand.c = c;
          return rand;
        };
      }();
      BigNumber2.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber2(args[0]);
        for (;i < args.length; )
          sum = sum.plus(args[i++]);
        return sum;
      };
      convertBase = function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet) {
          var j, arr = [0], arrL, i = 0, len = str.length;
          for (;i < len; ) {
            for (arrL = arr.length;arrL--; arr[arrL] *= baseIn)
              ;
            arr[0] += alphabet.indexOf(str.charAt(i++));
            for (j = 0;j < arr.length; j++) {
              if (arr[j] > baseOut - 1) {
                if (arr[j + 1] == null)
                  arr[j + 1] = 0;
                arr[j + 1] += arr[j] / baseOut | 0;
                arr[j] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign, callerIsToString) {
          var alphabet, d, e, k, r, x, xc, y2, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (i >= 0) {
            k = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y2 = new BigNumber2(baseIn);
            x = y2.pow(str.length - i);
            POW_PRECISION = k;
            y2.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
            y2.e = y2.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
          e = k = xc.length;
          for (;xc[--k] == 0; xc.pop())
            ;
          if (!xc[0])
            return alphabet.charAt(0);
          if (i < 0) {
            --e;
          } else {
            x.c = xc;
            x.e = e;
            x.s = sign;
            x = div(x, y2, dp, rm, baseOut);
            xc = x.c;
            r = x.r;
            e = x.e;
          }
          d = e + dp + 1;
          i = xc[d];
          k = baseOut / 2;
          r = r || d < 0 || xc[d + 1] != null;
          r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
          if (d < 1 || !xc[0]) {
            str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
          } else {
            xc.length = d;
            if (r) {
              for (--baseOut;++xc[--d] > baseOut; ) {
                xc[d] = 0;
                if (!d) {
                  ++e;
                  xc = [1].concat(xc);
                }
              }
            }
            for (k = xc.length;!xc[--k]; )
              ;
            for (i = 0, str = "";i <= k; str += alphabet.charAt(xc[i++]))
              ;
            str = toFixedPoint(str, e, alphabet.charAt(0));
          }
          return str;
        };
      }();
      div = function() {
        function multiply(x, k, base) {
          var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
          for (x = x.slice();i--; ) {
            xlo = x[i] % SQRT_BASE;
            xhi = x[i] / SQRT_BASE | 0;
            m = khi * xlo + xhi * klo;
            temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
            x[i] = temp % base;
          }
          if (carry)
            x = [carry].concat(x);
          return x;
        }
        function compare4(a, b, aL, bL) {
          var i, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i = cmp = 0;i < aL; i++) {
              if (a[i] != b[i]) {
                cmp = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract(a, b, aL, base) {
          var i = 0;
          for (;aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (;!a[0] && a.length > 1; a.splice(0, 1))
            ;
        }
        return function(x, y2, dp, rm, base) {
          var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x.s == y2.s ? 1 : -1, xc = x.c, yc = y2.c;
          if (!xc || !xc[0] || !yc || !yc[0]) {
            return new BigNumber2(!x.s || !y2.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0);
          }
          q = new BigNumber2(s2);
          qc = q.c = [];
          e = x.e - y2.e;
          s2 = dp + e + 1;
          if (!base) {
            base = BASE;
            e = bitFloor(x.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
            s2 = s2 / LOG_BASE | 0;
          }
          for (i = 0;yc[i] == (xc[i] || 0); i++)
            ;
          if (yc[i] > (xc[i] || 0))
            e--;
          if (s2 < 0) {
            qc.push(1);
            more = true;
          } else {
            xL = xc.length;
            yL = yc.length;
            i = 0;
            s2 += 2;
            n = mathfloor(base / (yc[0] + 1));
            if (n > 1) {
              yc = multiply(yc, n, base);
              xc = multiply(xc, n, base);
              yL = yc.length;
              xL = xc.length;
            }
            xi = yL;
            rem = xc.slice(0, yL);
            remL = rem.length;
            for (;remL < yL; rem[remL++] = 0)
              ;
            yz = yc.slice();
            yz = [0].concat(yz);
            yc0 = yc[0];
            if (yc[1] >= base / 2)
              yc0++;
            do {
              n = 0;
              cmp = compare4(yc, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base + (rem[1] || 0);
                n = mathfloor(rem0 / yc0);
                if (n > 1) {
                  if (n >= base)
                    n = base - 1;
                  prod = multiply(yc, n, base);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare4(prod, rem, prodL, remL) == 1) {
                    n--;
                    subtract(prod, yL < prodL ? yz : yc, prodL, base);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n == 0) {
                    cmp = n = 1;
                  }
                  prod = yc.slice();
                  prodL = prod.length;
                }
                if (prodL < remL)
                  prod = [0].concat(prod);
                subtract(rem, prod, remL, base);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare4(yc, rem, yL, remL) < 1) {
                    n++;
                    subtract(rem, yL < remL ? yz : yc, remL, base);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n++;
                rem = [0];
              }
              qc[i++] = n;
              if (rem[0]) {
                rem[remL++] = xc[xi] || 0;
              } else {
                rem = [xc[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] != null) && s2--);
            more = rem[0] != null;
            if (!qc[0])
              qc.splice(0, 1);
          }
          if (base == BASE) {
            for (i = 1, s2 = qc[0];s2 >= 10; s2 /= 10, i++)
              ;
            round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
          } else {
            q.e = e;
            q.r = +more;
          }
          return q;
        };
      }();
      function format(n, i, rm, id) {
        var c0, e, ne, len, str;
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        if (!n.c)
          return n.toString();
        c0 = n.c[0];
        ne = n.e;
        if (i == null) {
          str = coeffToString(n.c);
          str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
        } else {
          n = round(new BigNumber2(n), i, rm);
          e = n.e;
          str = coeffToString(n.c);
          len = str.length;
          if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
            for (;len < i; str += "0", len++)
              ;
            str = toExponential(str, e);
          } else {
            i -= ne;
            str = toFixedPoint(str, e, "0");
            if (e + 1 > len) {
              if (--i > 0)
                for (str += ".";i--; str += "0")
                  ;
            } else {
              i += e - len;
              if (i > 0) {
                if (e + 1 == len)
                  str += ".";
                for (;i--; str += "0")
                  ;
              }
            }
          }
        }
        return n.s < 0 && c0 ? "-" + str : str;
      }
      function maxOrMin(args, n) {
        var k, y2, i = 1, x = new BigNumber2(args[0]);
        for (;i < args.length; i++) {
          y2 = new BigNumber2(args[i]);
          if (!y2.s || (k = compare3(x, y2)) === n || k === 0 && x.s === n) {
            x = y2;
          }
        }
        return x;
      }
      function normalise(n, c, e) {
        var i = 1, j = c.length;
        for (;!c[--j]; c.pop())
          ;
        for (j = c[0];j >= 10; j /= 10, i++)
          ;
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
          n.c = n.e = null;
        } else if (e < MIN_EXP) {
          n.c = [n.e = 0];
        } else {
          n.e = e;
          n.c = c;
        }
        return n;
      }
      parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, str, isNum, b) {
          var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s2)) {
            x.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s2 = s2.replace(basePrefix, function(m, p1, p2) {
                base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b || b == base ? p1 : m;
              });
              if (b) {
                base = b;
                s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s2)
                return new BigNumber2(s2, base);
            }
            if (BigNumber2.DEBUG) {
              throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
            }
            x.s = null;
          }
          x.c = x.e = null;
        };
      }();
      function round(x, sd, rm, r) {
        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
        if (xc) {
          out: {
            for (d = 1, k = xc[0];k >= 10; k /= 10, d++)
              ;
            i = sd - d;
            if (i < 0) {
              i += LOG_BASE;
              j = sd;
              n = xc[ni = 0];
              rd = mathfloor(n / pows10[d - j - 1] % 10);
            } else {
              ni = mathceil((i + 1) / LOG_BASE);
              if (ni >= xc.length) {
                if (r) {
                  for (;xc.length <= ni; xc.push(0))
                    ;
                  n = rd = 0;
                  d = 1;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n = k = xc[ni];
                for (d = 1;k >= 10; k /= 10, d++)
                  ;
                i %= LOG_BASE;
                j = i - LOG_BASE + d;
                rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
              }
            }
            r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
            r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xc[0]) {
              xc.length = 0;
              if (r) {
                sd -= x.e + 1;
                xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                x.e = -sd || 0;
              } else {
                xc[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xc.length = ni;
              k = 1;
              ni--;
            } else {
              xc.length = ni + 1;
              k = pows10[LOG_BASE - i];
              xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
            }
            if (r) {
              for (;; ) {
                if (ni == 0) {
                  for (i = 1, j = xc[0];j >= 10; j /= 10, i++)
                    ;
                  j = xc[0] += k;
                  for (k = 1;j >= 10; j /= 10, k++)
                    ;
                  if (i != k) {
                    x.e++;
                    if (xc[0] == BASE)
                      xc[0] = 1;
                  }
                  break;
                } else {
                  xc[ni] += k;
                  if (xc[ni] != BASE)
                    break;
                  xc[ni--] = 0;
                  k = 1;
                }
              }
            }
            for (i = xc.length;xc[--i] === 0; xc.pop())
              ;
          }
          if (x.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (x.e < MIN_EXP) {
            x.c = [x.e = 0];
          }
        }
        return x;
      }
      function valueOf(n) {
        var str, e = n.e;
        if (e === null)
          return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
        return n.s < 0 ? "-" + str : str;
      }
      P.absoluteValue = P.abs = function() {
        var x = new BigNumber2(this);
        if (x.s < 0)
          x.s = 1;
        return x;
      };
      P.comparedTo = function(y2, b) {
        return compare3(this, new BigNumber2(y2, b));
      };
      P.decimalPlaces = P.dp = function(dp, rm) {
        var c, n, v, x = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber2(x), dp + x.e + 1, rm);
        }
        if (!(c = x.c))
          return null;
        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v = c[v])
          for (;v % 10 == 0; v /= 10, n--)
            ;
        if (n < 0)
          n = 0;
        return n;
      };
      P.dividedBy = P.div = function(y2, b) {
        return div(this, new BigNumber2(y2, b), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P.dividedToIntegerBy = P.idiv = function(y2, b) {
        return div(this, new BigNumber2(y2, b), 0, 1);
      };
      P.exponentiatedBy = P.pow = function(n, m) {
        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y2, x = this;
        n = new BigNumber2(n);
        if (n.c && !n.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
        }
        if (m != null)
          m = new BigNumber2(m);
        nIsBig = n.e > 14;
        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
          y2 = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
          return m ? y2.mod(m) : y2;
        }
        nIsNeg = n.s < 0;
        if (m) {
          if (m.c ? !m.c[0] : !m.s)
            return new BigNumber2(NaN);
          isModExp = !nIsNeg && x.isInteger() && m.isInteger();
          if (isModExp)
            x = x.mod(m);
        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 240000000 : x.c[0] < 80000000000000 || nIsBig && x.c[0] <= 99999750000000))) {
          k = x.s < 0 && isOdd(n) ? -0 : 0;
          if (x.e > -1)
            k = 1 / k;
          return new BigNumber2(nIsNeg ? 1 / k : k);
        } else if (POW_PRECISION) {
          k = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber2(0.5);
          if (nIsNeg)
            n.s = 1;
          nIsOdd = isOdd(n);
        } else {
          i = Math.abs(+valueOf(n));
          nIsOdd = i % 2;
        }
        y2 = new BigNumber2(ONE);
        for (;; ) {
          if (nIsOdd) {
            y2 = y2.times(x);
            if (!y2.c)
              break;
            if (k) {
              if (y2.c.length > k)
                y2.c.length = k;
            } else if (isModExp) {
              y2 = y2.mod(m);
            }
          }
          if (i) {
            i = mathfloor(i / 2);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          } else {
            n = n.times(half);
            round(n, n.e + 1, 1);
            if (n.e > 14) {
              nIsOdd = isOdd(n);
            } else {
              i = +valueOf(n);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            }
          }
          x = x.times(x);
          if (k) {
            if (x.c && x.c.length > k)
              x.c.length = k;
          } else if (isModExp) {
            x = x.mod(m);
          }
        }
        if (isModExp)
          return y2;
        if (nIsNeg)
          y2 = ONE.div(y2);
        return m ? y2.mod(m) : k ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
      };
      P.integerValue = function(rm) {
        var n = new BigNumber2(this);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(n, n.e + 1, rm);
      };
      P.isEqualTo = P.eq = function(y2, b) {
        return compare3(this, new BigNumber2(y2, b)) === 0;
      };
      P.isFinite = function() {
        return !!this.c;
      };
      P.isGreaterThan = P.gt = function(y2, b) {
        return compare3(this, new BigNumber2(y2, b)) > 0;
      };
      P.isGreaterThanOrEqualTo = P.gte = function(y2, b) {
        return (b = compare3(this, new BigNumber2(y2, b))) === 1 || b === 0;
      };
      P.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P.isLessThan = P.lt = function(y2, b) {
        return compare3(this, new BigNumber2(y2, b)) < 0;
      };
      P.isLessThanOrEqualTo = P.lte = function(y2, b) {
        return (b = compare3(this, new BigNumber2(y2, b))) === -1 || b === 0;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = function() {
        return this.s < 0;
      };
      P.isPositive = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P.minus = function(y2, b) {
        var i, j, t2, xLTy, x = this, a = x.s;
        y2 = new BigNumber2(y2, b);
        b = y2.s;
        if (!a || !b)
          return new BigNumber2(NaN);
        if (a != b) {
          y2.s = -b;
          return x.plus(y2);
        }
        var xe = x.e / LOG_BASE, ye = y2.e / LOG_BASE, xc = x.c, yc = y2.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return xc ? (y2.s = -b, y2) : new BigNumber2(yc ? x : NaN);
          if (!xc[0] || !yc[0]) {
            return yc[0] ? (y2.s = -b, y2) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
          }
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (xLTy = a < 0) {
            a = -a;
            t2 = xc;
          } else {
            ye = xe;
            t2 = yc;
          }
          t2.reverse();
          for (b = a;b--; t2.push(0))
            ;
          t2.reverse();
        } else {
          j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
          for (a = b = 0;b < j; b++) {
            if (xc[b] != yc[b]) {
              xLTy = xc[b] < yc[b];
              break;
            }
          }
        }
        if (xLTy) {
          t2 = xc;
          xc = yc;
          yc = t2;
          y2.s = -y2.s;
        }
        b = (j = yc.length) - (i = xc.length);
        if (b > 0)
          for (;b--; xc[i++] = 0)
            ;
        b = BASE - 1;
        for (;j > a; ) {
          if (xc[--j] < yc[j]) {
            for (i = j;i && !xc[--i]; xc[i] = b)
              ;
            --xc[i];
            xc[j] += BASE;
          }
          xc[j] -= yc[j];
        }
        for (;xc[0] == 0; xc.splice(0, 1), --ye)
          ;
        if (!xc[0]) {
          y2.s = ROUNDING_MODE == 3 ? -1 : 1;
          y2.c = [y2.e = 0];
          return y2;
        }
        return normalise(y2, xc, ye);
      };
      P.modulo = P.mod = function(y2, b) {
        var q, s2, x = this;
        y2 = new BigNumber2(y2, b);
        if (!x.c || !y2.s || y2.c && !y2.c[0]) {
          return new BigNumber2(NaN);
        } else if (!y2.c || x.c && !x.c[0]) {
          return new BigNumber2(x);
        }
        if (MODULO_MODE == 9) {
          s2 = y2.s;
          y2.s = 1;
          q = div(x, y2, 0, 3);
          y2.s = s2;
          q.s *= s2;
        } else {
          q = div(x, y2, 0, MODULO_MODE);
        }
        y2 = x.minus(q.times(y2));
        if (!y2.c[0] && MODULO_MODE == 1)
          y2.s = x.s;
        return y2;
      };
      P.multipliedBy = P.times = function(y2, b) {
        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y2 = new BigNumber2(y2, b)).c;
        if (!xc || !yc || !xc[0] || !yc[0]) {
          if (!x.s || !y2.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
            y2.c = y2.e = y2.s = null;
          } else {
            y2.s *= x.s;
            if (!xc || !yc) {
              y2.c = y2.e = null;
            } else {
              y2.c = [0];
              y2.e = 0;
            }
          }
          return y2;
        }
        e = bitFloor(x.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
        y2.s *= x.s;
        xcL = xc.length;
        ycL = yc.length;
        if (xcL < ycL) {
          zc = xc;
          xc = yc;
          yc = zc;
          i = xcL;
          xcL = ycL;
          ycL = i;
        }
        for (i = xcL + ycL, zc = [];i--; zc.push(0))
          ;
        base = BASE;
        sqrtBase = SQRT_BASE;
        for (i = ycL;--i >= 0; ) {
          c = 0;
          ylo = yc[i] % sqrtBase;
          yhi = yc[i] / sqrtBase | 0;
          for (k = xcL, j = i + k;j > i; ) {
            xlo = xc[--k] % sqrtBase;
            xhi = xc[k] / sqrtBase | 0;
            m = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
            c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
            zc[j--] = xlo % base;
          }
          zc[j] = c;
        }
        if (c) {
          ++e;
        } else {
          zc.splice(0, 1);
        }
        return normalise(y2, zc, e);
      };
      P.negated = function() {
        var x = new BigNumber2(this);
        x.s = -x.s || null;
        return x;
      };
      P.plus = function(y2, b) {
        var t2, x = this, a = x.s;
        y2 = new BigNumber2(y2, b);
        b = y2.s;
        if (!a || !b)
          return new BigNumber2(NaN);
        if (a != b) {
          y2.s = -b;
          return x.minus(y2);
        }
        var xe = x.e / LOG_BASE, ye = y2.e / LOG_BASE, xc = x.c, yc = y2.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return new BigNumber2(a / 0);
          if (!xc[0] || !yc[0])
            return yc[0] ? y2 : new BigNumber2(xc[0] ? x : a * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (a > 0) {
            ye = xe;
            t2 = yc;
          } else {
            a = -a;
            t2 = xc;
          }
          t2.reverse();
          for (;a--; t2.push(0))
            ;
          t2.reverse();
        }
        a = xc.length;
        b = yc.length;
        if (a - b < 0) {
          t2 = yc;
          yc = xc;
          xc = t2;
          b = a;
        }
        for (a = 0;b; ) {
          a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
          xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
        }
        if (a) {
          xc = [a].concat(xc);
          ++ye;
        }
        return normalise(y2, xc, ye);
      };
      P.precision = P.sd = function(sd, rm) {
        var c, n, v, x = this;
        if (sd != null && sd !== !!sd) {
          intCheck(sd, 1, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber2(x), sd, rm);
        }
        if (!(c = x.c))
          return null;
        v = c.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c[v]) {
          for (;v % 10 == 0; v /= 10, n--)
            ;
          for (v = c[0];v >= 10; v /= 10, n++)
            ;
        }
        if (sd && x.e + 1 > n)
          n = x.e + 1;
        return n;
      };
      P.shiftedBy = function(k) {
        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times("1e" + k);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, r, rep, t2, x = this, c = x.c, s2 = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
        if (s2 !== 1 || !c || !c[0]) {
          return new BigNumber2(!s2 || s2 < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
        }
        s2 = Math.sqrt(+valueOf(x));
        if (s2 == 0 || s2 == 1 / 0) {
          n = coeffToString(c);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s2 = Math.sqrt(+n);
          e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s2 == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s2.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new BigNumber2(n);
        } else {
          r = new BigNumber2(s2 + "");
        }
        if (r.c[0]) {
          e = r.e;
          s2 = e + dp;
          if (s2 < 3)
            s2 = 0;
          for (;; ) {
            t2 = r;
            r = half.times(t2.plus(div(x, t2, dp, 1)));
            if (coeffToString(t2.c).slice(0, s2) === (n = coeffToString(r.c)).slice(0, s2)) {
              if (r.e < e)
                --s2;
              n = n.slice(s2 - 3, s2 + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  round(t2, t2.e + DECIMAL_PLACES + 2, 0);
                  if (t2.times(t2).eq(x)) {
                    r = t2;
                    break;
                  }
                }
                dp += 4;
                s2 += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  round(r, r.e + DECIMAL_PLACES + 2, 1);
                  m = !r.times(r).eq(x);
                }
                break;
              }
            }
          }
        }
        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
      };
      P.toExponential = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format(this, dp, rm, 1);
      };
      P.toFixed = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format(this, dp, rm);
      };
      P.toFormat = function(dp, rm, format2) {
        var str, x = this;
        if (format2 == null) {
          if (dp != null && rm && typeof rm == "object") {
            format2 = rm;
            rm = null;
          } else if (dp && typeof dp == "object") {
            format2 = dp;
            dp = rm = null;
          } else {
            format2 = FORMAT;
          }
        } else if (typeof format2 != "object") {
          throw Error(bignumberError + "Argument not an object: " + format2);
        }
        str = x.toFixed(dp, rm);
        if (x.c) {
          var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
          if (g2) {
            i = g1;
            g1 = g2;
            g2 = i;
            len -= i;
          }
          if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);
            for (;i < len; i += g1)
              intPart += groupSeparator + intDigits.substr(i, g1);
            if (g2 > 0)
              intPart += groupSeparator + intDigits.slice(i);
            if (isNeg)
              intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
        }
        return (format2.prefix || "") + str + (format2.suffix || "");
      };
      P.toFraction = function(md) {
        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s2, x = this, xc = x.c;
        if (md != null) {
          n = new BigNumber2(md);
          if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
            throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
          }
        }
        if (!xc)
          return new BigNumber2(x);
        d = new BigNumber2(ONE);
        n1 = d0 = new BigNumber2(ONE);
        d1 = n0 = new BigNumber2(ONE);
        s2 = coeffToString(xc);
        e = d.e = s2.length - x.e - 1;
        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber2(s2);
        n0.c[0] = 0;
        for (;; ) {
          q = div(n, d, 0, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.comparedTo(md) == 1)
            break;
          d0 = d1;
          d1 = d2;
          n1 = n0.plus(q.times(d2 = n1));
          n0 = d2;
          d = n.minus(q.times(d2 = d));
          n = d2;
        }
        d2 = div(md.minus(d0), d1, 0, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        e = e * 2;
        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        MAX_EXP = exp;
        return r;
      };
      P.toNumber = function() {
        return +valueOf(this);
      };
      P.toPrecision = function(sd, rm) {
        if (sd != null)
          intCheck(sd, 1, MAX);
        return format(this, sd, rm, 2);
      };
      P.toString = function(b) {
        var str, n = this, s2 = n.s, e = n.e;
        if (e === null) {
          if (s2) {
            str = "Infinity";
            if (s2 < 0)
              str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b == null) {
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
          } else if (b === 10 && alphabetHasNormalDecimalDigits) {
            n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n.c), n.e, "0");
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s2, true);
          }
          if (s2 < 0 && n.c[0])
            str = "-" + str;
        }
        return str;
      };
      P.valueOf = P.toJSON = function() {
        return valueOf(this);
      };
      P._isBigNumber = true;
      if (configObject != null)
        BigNumber2.set(configObject);
      return BigNumber2;
    }
    function bitFloor(n) {
      var i = n | 0;
      return n > 0 || n === i ? i : i - 1;
    }
    function coeffToString(a) {
      var s2, z, i = 1, j = a.length, r = a[0] + "";
      for (;i < j; ) {
        s2 = a[i++] + "";
        z = LOG_BASE - s2.length;
        for (;z--; s2 = "0" + s2)
          ;
        r += s2;
      }
      for (j = r.length;r.charCodeAt(--j) === 48; )
        ;
      return r.slice(0, j + 1 || 1);
    }
    function compare3(x, y2) {
      var a, b, xc = x.c, yc = y2.c, i = x.s, j = y2.s, k = x.e, l = y2.e;
      if (!i || !j)
        return null;
      a = xc && !xc[0];
      b = yc && !yc[0];
      if (a || b)
        return a ? b ? 0 : -j : i;
      if (i != j)
        return i;
      a = i < 0;
      b = k == l;
      if (!xc || !yc)
        return b ? 0 : !xc ^ a ? 1 : -1;
      if (!b)
        return k > l ^ a ? 1 : -1;
      j = (k = xc.length) < (l = yc.length) ? k : l;
      for (i = 0;i < j; i++)
        if (xc[i] != yc[i])
          return xc[i] > yc[i] ^ a ? 1 : -1;
      return k == l ? 0 : k > l ^ a ? 1 : -1;
    }
    function intCheck(n, min, max, name) {
      if (n < min || n > max || n !== mathfloor(n)) {
        throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
      }
    }
    function isOdd(n) {
      var k = n.c.length - 1;
      return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
    }
    function toExponential(str, e) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z) {
      var len, zs;
      if (e < 0) {
        for (zs = z + ".";++e; zs += z)
          ;
        str = zs + str;
      } else {
        len = str.length;
        if (++e > len) {
          for (zs = z, e -= len;--e; zs += z)
            ;
          str += zs;
        } else if (e < len) {
          str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      return str;
    }
    BigNumber = clone();
    BigNumber["default"] = BigNumber.BigNumber = BigNumber;
    if (typeof define == "function" && define.amd) {
      define(function() {
        return BigNumber;
      });
    } else if (typeof module != "undefined" && exports) {
      module.exports = BigNumber;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber;
    }
  })(exports);
});

// node_modules/borc/src/decoder.asm.js
var require_decoder_asm = __commonJS((exports, module) => {
  module.exports = function decodeAsm(stdlib, foreign, buffer) {
    var heap = new stdlib.Uint8Array(buffer);
    var pushInt = foreign.pushInt;
    var pushInt32 = foreign.pushInt32;
    var pushInt32Neg = foreign.pushInt32Neg;
    var pushInt64 = foreign.pushInt64;
    var pushInt64Neg = foreign.pushInt64Neg;
    var pushFloat = foreign.pushFloat;
    var pushFloatSingle = foreign.pushFloatSingle;
    var pushFloatDouble = foreign.pushFloatDouble;
    var pushTrue = foreign.pushTrue;
    var pushFalse = foreign.pushFalse;
    var pushUndefined = foreign.pushUndefined;
    var pushNull = foreign.pushNull;
    var pushInfinity = foreign.pushInfinity;
    var pushInfinityNeg = foreign.pushInfinityNeg;
    var pushNaN = foreign.pushNaN;
    var pushNaNNeg = foreign.pushNaNNeg;
    var pushArrayStart = foreign.pushArrayStart;
    var pushArrayStartFixed = foreign.pushArrayStartFixed;
    var pushArrayStartFixed32 = foreign.pushArrayStartFixed32;
    var pushArrayStartFixed64 = foreign.pushArrayStartFixed64;
    var pushObjectStart = foreign.pushObjectStart;
    var pushObjectStartFixed = foreign.pushObjectStartFixed;
    var pushObjectStartFixed32 = foreign.pushObjectStartFixed32;
    var pushObjectStartFixed64 = foreign.pushObjectStartFixed64;
    var pushByteString = foreign.pushByteString;
    var pushByteStringStart = foreign.pushByteStringStart;
    var pushUtf8String = foreign.pushUtf8String;
    var pushUtf8StringStart = foreign.pushUtf8StringStart;
    var pushSimpleUnassigned = foreign.pushSimpleUnassigned;
    var pushTagStart = foreign.pushTagStart;
    var pushTagStart4 = foreign.pushTagStart4;
    var pushTagStart8 = foreign.pushTagStart8;
    var pushTagUnassigned = foreign.pushTagUnassigned;
    var pushBreak = foreign.pushBreak;
    var pow = stdlib.Math.pow;
    var offset = 0;
    var inputLength = 0;
    var code = 0;
    function parse(input) {
      input = input | 0;
      offset = 0;
      inputLength = input;
      while ((offset | 0) < (inputLength | 0)) {
        code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0;
        if ((code | 0) > 0) {
          break;
        }
      }
      return code | 0;
    }
    function checkOffset2(n) {
      n = n | 0;
      if (((offset | 0) + (n | 0) | 0) < (inputLength | 0)) {
        return 0;
      }
      return 1;
    }
    function readUInt16(n) {
      n = n | 0;
      return heap[n | 0] << 8 | heap[n + 1 | 0] | 0;
    }
    function readUInt32(n) {
      n = n | 0;
      return heap[n | 0] << 24 | heap[n + 1 | 0] << 16 | heap[n + 2 | 0] << 8 | heap[n + 3 | 0] | 0;
    }
    function INT_P(octet) {
      octet = octet | 0;
      pushInt(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function UINT_P_8(octet) {
      octet = octet | 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      pushInt(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function UINT_P_16(octet) {
      octet = octet | 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      pushInt(readUInt16(offset + 1 | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function UINT_P_32(octet) {
      octet = octet | 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      pushInt32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function UINT_P_64(octet) {
      octet = octet | 0;
      if (checkOffset2(8) | 0) {
        return 1;
      }
      pushInt64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function INT_N(octet) {
      octet = octet | 0;
      pushInt(-1 - (octet - 32 | 0) | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function UINT_N_8(octet) {
      octet = octet | 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      pushInt(-1 - (heap[offset + 1 | 0] | 0) | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function UINT_N_16(octet) {
      octet = octet | 0;
      var val = 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      val = readUInt16(offset + 1 | 0) | 0;
      pushInt(-1 - (val | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function UINT_N_32(octet) {
      octet = octet | 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      pushInt32Neg(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function UINT_N_64(octet) {
      octet = octet | 0;
      if (checkOffset2(8) | 0) {
        return 1;
      }
      pushInt64Neg(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function BYTE_STRING(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var step = 0;
      step = octet - 64 | 0;
      if (checkOffset2(step | 0) | 0) {
        return 1;
      }
      start = offset + 1 | 0;
      end = (offset + 1 | 0) + (step | 0) | 0;
      pushByteString(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function BYTE_STRING_8(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      length = heap[offset + 1 | 0] | 0;
      start = offset + 2 | 0;
      end = (offset + 2 | 0) + (length | 0) | 0;
      if (checkOffset2(length + 1 | 0) | 0) {
        return 1;
      }
      pushByteString(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function BYTE_STRING_16(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      length = readUInt16(offset + 1 | 0) | 0;
      start = offset + 3 | 0;
      end = (offset + 3 | 0) + (length | 0) | 0;
      if (checkOffset2(length + 2 | 0) | 0) {
        return 1;
      }
      pushByteString(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function BYTE_STRING_32(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      length = readUInt32(offset + 1 | 0) | 0;
      start = offset + 5 | 0;
      end = (offset + 5 | 0) + (length | 0) | 0;
      if (checkOffset2(length + 4 | 0) | 0) {
        return 1;
      }
      pushByteString(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function BYTE_STRING_64(octet) {
      octet = octet | 0;
      return 1;
    }
    function BYTE_STRING_BREAK(octet) {
      octet = octet | 0;
      pushByteStringStart();
      offset = offset + 1 | 0;
      return 0;
    }
    function UTF8_STRING(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var step = 0;
      step = octet - 96 | 0;
      if (checkOffset2(step | 0) | 0) {
        return 1;
      }
      start = offset + 1 | 0;
      end = (offset + 1 | 0) + (step | 0) | 0;
      pushUtf8String(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function UTF8_STRING_8(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      length = heap[offset + 1 | 0] | 0;
      start = offset + 2 | 0;
      end = (offset + 2 | 0) + (length | 0) | 0;
      if (checkOffset2(length + 1 | 0) | 0) {
        return 1;
      }
      pushUtf8String(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function UTF8_STRING_16(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      length = readUInt16(offset + 1 | 0) | 0;
      start = offset + 3 | 0;
      end = (offset + 3 | 0) + (length | 0) | 0;
      if (checkOffset2(length + 2 | 0) | 0) {
        return 1;
      }
      pushUtf8String(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function UTF8_STRING_32(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      length = readUInt32(offset + 1 | 0) | 0;
      start = offset + 5 | 0;
      end = (offset + 5 | 0) + (length | 0) | 0;
      if (checkOffset2(length + 4 | 0) | 0) {
        return 1;
      }
      pushUtf8String(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function UTF8_STRING_64(octet) {
      octet = octet | 0;
      return 1;
    }
    function UTF8_STRING_BREAK(octet) {
      octet = octet | 0;
      pushUtf8StringStart();
      offset = offset + 1 | 0;
      return 0;
    }
    function ARRAY(octet) {
      octet = octet | 0;
      pushArrayStartFixed(octet - 128 | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function ARRAY_8(octet) {
      octet = octet | 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      pushArrayStartFixed(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function ARRAY_16(octet) {
      octet = octet | 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      pushArrayStartFixed(readUInt16(offset + 1 | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function ARRAY_32(octet) {
      octet = octet | 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      pushArrayStartFixed32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function ARRAY_64(octet) {
      octet = octet | 0;
      if (checkOffset2(8) | 0) {
        return 1;
      }
      pushArrayStartFixed64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function ARRAY_BREAK(octet) {
      octet = octet | 0;
      pushArrayStart();
      offset = offset + 1 | 0;
      return 0;
    }
    function MAP(octet) {
      octet = octet | 0;
      var step = 0;
      step = octet - 160 | 0;
      if (checkOffset2(step | 0) | 0) {
        return 1;
      }
      pushObjectStartFixed(step | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function MAP_8(octet) {
      octet = octet | 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      pushObjectStartFixed(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function MAP_16(octet) {
      octet = octet | 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      pushObjectStartFixed(readUInt16(offset + 1 | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function MAP_32(octet) {
      octet = octet | 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      pushObjectStartFixed32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function MAP_64(octet) {
      octet = octet | 0;
      if (checkOffset2(8) | 0) {
        return 1;
      }
      pushObjectStartFixed64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function MAP_BREAK(octet) {
      octet = octet | 0;
      pushObjectStart();
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_KNOWN(octet) {
      octet = octet | 0;
      pushTagStart(octet - 192 | 0 | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BIGNUM_POS(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BIGNUM_NEG(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_FRAC(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BIGNUM_FLOAT(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_UNASSIGNED(octet) {
      octet = octet | 0;
      pushTagStart(octet - 192 | 0 | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BASE64_URL(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BASE64(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BASE16(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_MORE_1(octet) {
      octet = octet | 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      pushTagStart(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function TAG_MORE_2(octet) {
      octet = octet | 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      pushTagStart(readUInt16(offset + 1 | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function TAG_MORE_4(octet) {
      octet = octet | 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      pushTagStart4(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function TAG_MORE_8(octet) {
      octet = octet | 0;
      if (checkOffset2(8) | 0) {
        return 1;
      }
      pushTagStart8(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function SIMPLE_UNASSIGNED(octet) {
      octet = octet | 0;
      pushSimpleUnassigned((octet | 0) - 224 | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_FALSE(octet) {
      octet = octet | 0;
      pushFalse();
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_TRUE(octet) {
      octet = octet | 0;
      pushTrue();
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_NULL(octet) {
      octet = octet | 0;
      pushNull();
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_UNDEFINED(octet) {
      octet = octet | 0;
      pushUndefined();
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_BYTE(octet) {
      octet = octet | 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      pushSimpleUnassigned(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function SIMPLE_FLOAT_HALF(octet) {
      octet = octet | 0;
      var f = 0;
      var g = 0;
      var sign = 1;
      var exp = 0;
      var mant = 0;
      var r = 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      f = heap[offset + 1 | 0] | 0;
      g = heap[offset + 2 | 0] | 0;
      if ((f | 0) & 128) {
        sign = -1;
      }
      exp = +(((f | 0) & 124) >> 2);
      mant = +(((f | 0) & 3) << 8 | g);
      if (+exp == 0) {
        pushFloat(+(+sign * 0.00000005960464477539063 * +mant));
      } else if (+exp == 31) {
        if (+sign == 1) {
          if (+mant > 0) {
            pushNaN();
          } else {
            pushInfinity();
          }
        } else {
          if (+mant > 0) {
            pushNaNNeg();
          } else {
            pushInfinityNeg();
          }
        }
      } else {
        pushFloat(+(+sign * pow(2, +(+exp - 25)) * +(1024 + mant)));
      }
      offset = offset + 3 | 0;
      return 0;
    }
    function SIMPLE_FLOAT_SINGLE(octet) {
      octet = octet | 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      pushFloatSingle(heap[offset + 1 | 0] | 0, heap[offset + 2 | 0] | 0, heap[offset + 3 | 0] | 0, heap[offset + 4 | 0] | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function SIMPLE_FLOAT_DOUBLE(octet) {
      octet = octet | 0;
      if (checkOffset2(8) | 0) {
        return 1;
      }
      pushFloatDouble(heap[offset + 1 | 0] | 0, heap[offset + 2 | 0] | 0, heap[offset + 3 | 0] | 0, heap[offset + 4 | 0] | 0, heap[offset + 5 | 0] | 0, heap[offset + 6 | 0] | 0, heap[offset + 7 | 0] | 0, heap[offset + 8 | 0] | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function ERROR(octet) {
      octet = octet | 0;
      return 1;
    }
    function BREAK(octet) {
      octet = octet | 0;
      pushBreak();
      offset = offset + 1 | 0;
      return 0;
    }
    var jumpTable = [
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      UINT_P_8,
      UINT_P_16,
      UINT_P_32,
      UINT_P_64,
      ERROR,
      ERROR,
      ERROR,
      ERROR,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      UINT_N_8,
      UINT_N_16,
      UINT_N_32,
      UINT_N_64,
      ERROR,
      ERROR,
      ERROR,
      ERROR,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING_8,
      BYTE_STRING_16,
      BYTE_STRING_32,
      BYTE_STRING_64,
      ERROR,
      ERROR,
      ERROR,
      BYTE_STRING_BREAK,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING_8,
      UTF8_STRING_16,
      UTF8_STRING_32,
      UTF8_STRING_64,
      ERROR,
      ERROR,
      ERROR,
      UTF8_STRING_BREAK,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY_8,
      ARRAY_16,
      ARRAY_32,
      ARRAY_64,
      ERROR,
      ERROR,
      ERROR,
      ARRAY_BREAK,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP_8,
      MAP_16,
      MAP_32,
      MAP_64,
      ERROR,
      ERROR,
      ERROR,
      MAP_BREAK,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_MORE_1,
      TAG_MORE_2,
      TAG_MORE_4,
      TAG_MORE_8,
      ERROR,
      ERROR,
      ERROR,
      ERROR,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_FALSE,
      SIMPLE_TRUE,
      SIMPLE_NULL,
      SIMPLE_UNDEFINED,
      SIMPLE_BYTE,
      SIMPLE_FLOAT_HALF,
      SIMPLE_FLOAT_SINGLE,
      SIMPLE_FLOAT_DOUBLE,
      ERROR,
      ERROR,
      ERROR,
      BREAK
    ];
    return {
      parse
    };
  };
});

// node_modules/borc/src/constants.js
var require_constants = __commonJS((exports) => {
  var Bignumber = require_bignumber().BigNumber;
  exports.MT = {
    POS_INT: 0,
    NEG_INT: 1,
    BYTE_STRING: 2,
    UTF8_STRING: 3,
    ARRAY: 4,
    MAP: 5,
    TAG: 6,
    SIMPLE_FLOAT: 7
  };
  exports.TAG = {
    DATE_STRING: 0,
    DATE_EPOCH: 1,
    POS_BIGINT: 2,
    NEG_BIGINT: 3,
    DECIMAL_FRAC: 4,
    BIGFLOAT: 5,
    BASE64URL_EXPECTED: 21,
    BASE64_EXPECTED: 22,
    BASE16_EXPECTED: 23,
    CBOR: 24,
    URI: 32,
    BASE64URL: 33,
    BASE64: 34,
    REGEXP: 35,
    MIME: 36
  };
  exports.NUMBYTES = {
    ZERO: 0,
    ONE: 24,
    TWO: 25,
    FOUR: 26,
    EIGHT: 27,
    INDEFINITE: 31
  };
  exports.SIMPLE = {
    FALSE: 20,
    TRUE: 21,
    NULL: 22,
    UNDEFINED: 23
  };
  exports.SYMS = {
    NULL: Symbol("null"),
    UNDEFINED: Symbol("undef"),
    PARENT: Symbol("parent"),
    BREAK: Symbol("break"),
    STREAM: Symbol("stream")
  };
  exports.SHIFT32 = Math.pow(2, 32);
  exports.SHIFT16 = Math.pow(2, 16);
  exports.MAX_SAFE_HIGH = 2097151;
  exports.NEG_ONE = new Bignumber(-1);
  exports.TEN = new Bignumber(10);
  exports.TWO = new Bignumber(2);
  exports.PARENT = {
    ARRAY: 0,
    OBJECT: 1,
    MAP: 2,
    TAG: 3,
    BYTE_STRING: 4,
    UTF8_STRING: 5
  };
});

// node_modules/borc/src/utils.js
var require_utils = __commonJS((exports) => {
  var toHex = function(n) {
    if (n < 16) {
      return "0" + n.toString(16);
    }
    return n.toString(16);
  };
  var { Buffer: Buffer3 } = import.meta.require("buffer");
  var Bignumber = require_bignumber().BigNumber;
  var constants = require_constants();
  var SHIFT32 = constants.SHIFT32;
  var SHIFT16 = constants.SHIFT16;
  var MAX_SAFE_HIGH = 2097151;
  exports.parseHalf = function parseHalf(buf) {
    var exp, mant, sign;
    sign = buf[0] & 128 ? -1 : 1;
    exp = (buf[0] & 124) >> 2;
    mant = (buf[0] & 3) << 8 | buf[1];
    if (!exp) {
      return sign * 0.00000005960464477539063 * mant;
    } else if (exp === 31) {
      return sign * (mant ? 0 / 0 : Infinity);
    } else {
      return sign * Math.pow(2, exp - 25) * (1024 + mant);
    }
  };
  exports.arrayBufferToBignumber = function(buf) {
    const len = buf.byteLength;
    let res = "";
    for (let i = 0;i < len; i++) {
      res += toHex(buf[i]);
    }
    return new Bignumber(res, 16);
  };
  exports.buildMap = (obj) => {
    const res = new Map;
    const keys = Object.keys(obj);
    const length = keys.length;
    for (let i = 0;i < length; i++) {
      res.set(keys[i], obj[keys[i]]);
    }
    return res;
  };
  exports.buildInt32 = (f, g) => {
    return f * SHIFT16 + g;
  };
  exports.buildInt64 = (f1, f2, g1, g2) => {
    const f = exports.buildInt32(f1, f2);
    const g = exports.buildInt32(g1, g2);
    if (f > MAX_SAFE_HIGH) {
      return new Bignumber(f).times(SHIFT32).plus(g);
    } else {
      return f * SHIFT32 + g;
    }
  };
  exports.writeHalf = function writeHalf(buf, half) {
    const u32 = Buffer3.allocUnsafe(4);
    u32.writeFloatBE(half, 0);
    const u = u32.readUInt32BE(0);
    if ((u & 8191) !== 0) {
      return false;
    }
    var s16 = u >> 16 & 32768;
    const exp = u >> 23 & 255;
    const mant = u & 8388607;
    if (exp >= 113 && exp <= 142) {
      s16 += (exp - 112 << 10) + (mant >> 13);
    } else if (exp >= 103 && exp < 113) {
      if (mant & (1 << 126 - exp) - 1) {
        return false;
      }
      s16 += mant + 8388608 >> 126 - exp;
    } else {
      return false;
    }
    buf.writeUInt16BE(s16, 0);
    return true;
  };
  exports.keySorter = function(a, b) {
    var lenA = a[0].byteLength;
    var lenB = b[0].byteLength;
    if (lenA > lenB) {
      return 1;
    }
    if (lenB > lenA) {
      return -1;
    }
    return a[0].compare(b[0]);
  };
  exports.isNegativeZero = (x) => {
    return x === 0 && 1 / x < 0;
  };
  exports.nextPowerOf2 = (n) => {
    let count = 0;
    if (n && !(n & n - 1)) {
      return n;
    }
    while (n !== 0) {
      n >>= 1;
      count += 1;
    }
    return 1 << count;
  };
});

// node_modules/borc/src/simple.js
var require_simple = __commonJS((exports, module) => {
  var constants = require_constants();
  var MT = constants.MT;
  var SIMPLE = constants.SIMPLE;
  var SYMS = constants.SYMS;

  class Simple {
    constructor(value) {
      if (typeof value !== "number") {
        throw new Error("Invalid Simple type: " + typeof value);
      }
      if (value < 0 || value > 255 || (value | 0) !== value) {
        throw new Error("value must be a small positive integer: " + value);
      }
      this.value = value;
    }
    toString() {
      return "simple(" + this.value + ")";
    }
    inspect() {
      return "simple(" + this.value + ")";
    }
    encodeCBOR(gen) {
      return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
    }
    static isSimple(obj) {
      return obj instanceof Simple;
    }
    static decode(val, hasParent) {
      if (hasParent == null) {
        hasParent = true;
      }
      switch (val) {
        case SIMPLE.FALSE:
          return false;
        case SIMPLE.TRUE:
          return true;
        case SIMPLE.NULL:
          if (hasParent) {
            return null;
          } else {
            return SYMS.NULL;
          }
        case SIMPLE.UNDEFINED:
          if (hasParent) {
            return;
          } else {
            return SYMS.UNDEFINED;
          }
        case -1:
          if (!hasParent) {
            throw new Error("Invalid BREAK");
          }
          return SYMS.BREAK;
        default:
          return new Simple(val);
      }
    }
  }
  module.exports = Simple;
});

// node_modules/borc/src/tagged.js
var require_tagged = __commonJS((exports, module) => {
  class Tagged {
    constructor(tag, value, err) {
      this.tag = tag;
      this.value = value;
      this.err = err;
      if (typeof this.tag !== "number") {
        throw new Error("Invalid tag type (" + typeof this.tag + ")");
      }
      if (this.tag < 0 || (this.tag | 0) !== this.tag) {
        throw new Error("Tag must be a positive integer: " + this.tag);
      }
    }
    toString() {
      return `${this.tag}(${JSON.stringify(this.value)})`;
    }
    encodeCBOR(gen) {
      gen._pushTag(this.tag);
      return gen.pushAny(this.value);
    }
    convert(converters) {
      var er, f;
      f = converters != null ? converters[this.tag] : undefined;
      if (typeof f !== "function") {
        f = Tagged["_tag" + this.tag];
        if (typeof f !== "function") {
          return this;
        }
      }
      try {
        return f.call(Tagged, this.value);
      } catch (error) {
        er = error;
        this.err = er;
        return this;
      }
    }
  }
  module.exports = Tagged;
});

// node_modules/iso-url/src/url.js
var require_url = __commonJS((exports, module) => {
  var { URL: URL2, URLSearchParams, format } = import.meta.require("url");
  var defaultBase = "http://localhost";

  class URLWithLegacySupport extends URL2 {
    constructor(url = "", base = defaultBase) {
      super(url, base);
      this.path = this.pathname + this.search;
      this.auth = this.username && this.password ? this.username + ":" + this.password : null;
      this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
    }
    format() {
      return this.toString();
    }
  }
  module.exports = {
    URLWithLegacySupport,
    URLSearchParams,
    format,
    defaultBase
  };
});

// node_modules/iso-url/src/relative.js
var require_relative = __commonJS((exports, module) => {
  var { URLWithLegacySupport, format } = require_url();
  module.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {
    let protocol = location.protocol ? location.protocol.replace(":", "") : "http";
    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
    let urlParsed;
    try {
      urlParsed = new URLWithLegacySupport(url);
    } catch (err) {
      urlParsed = {};
    }
    const base = Object.assign({}, location, {
      protocol: protocol || urlParsed.protocol,
      host: location.host || urlParsed.host
    });
    return new URLWithLegacySupport(url, format(base)).toString();
  };
});

// node_modules/iso-url/index.js
var require_iso_url = __commonJS((exports, module) => {
  var {
    URLWithLegacySupport,
    format,
    URLSearchParams,
    defaultBase
  } = require_url();
  var relative = require_relative();
  module.exports = {
    URL: URLWithLegacySupport,
    URLSearchParams,
    format,
    relative,
    defaultBase
  };
});

// node_modules/borc/src/decoder.js
var require_decoder = __commonJS((exports, module) => {
  var { Buffer: Buffer3 } = import.meta.require("buffer");
  var ieee7542 = require_ieee754();
  var Bignumber = require_bignumber().BigNumber;
  var parser = require_decoder_asm();
  var utils = require_utils();
  var c = require_constants();
  var Simple = require_simple();
  var Tagged = require_tagged();
  var { URL: URL2 } = require_iso_url();

  class Decoder {
    constructor(opts) {
      opts = opts || {};
      if (!opts.size || opts.size < 65536) {
        opts.size = 65536;
      } else {
        opts.size = utils.nextPowerOf2(opts.size);
      }
      this._heap = new ArrayBuffer(opts.size);
      this._heap8 = new Uint8Array(this._heap);
      this._buffer = Buffer3.from(this._heap);
      this._reset();
      this._knownTags = Object.assign({
        0: (val) => new Date(val),
        1: (val) => new Date(val * 1000),
        2: (val) => utils.arrayBufferToBignumber(val),
        3: (val) => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),
        4: (v) => {
          return c.TEN.pow(v[0]).times(v[1]);
        },
        5: (v) => {
          return c.TWO.pow(v[0]).times(v[1]);
        },
        32: (val) => new URL2(val),
        35: (val) => new RegExp(val)
      }, opts.tags);
      this.parser = parser(global, {
        log: console.log.bind(console),
        pushInt: this.pushInt.bind(this),
        pushInt32: this.pushInt32.bind(this),
        pushInt32Neg: this.pushInt32Neg.bind(this),
        pushInt64: this.pushInt64.bind(this),
        pushInt64Neg: this.pushInt64Neg.bind(this),
        pushFloat: this.pushFloat.bind(this),
        pushFloatSingle: this.pushFloatSingle.bind(this),
        pushFloatDouble: this.pushFloatDouble.bind(this),
        pushTrue: this.pushTrue.bind(this),
        pushFalse: this.pushFalse.bind(this),
        pushUndefined: this.pushUndefined.bind(this),
        pushNull: this.pushNull.bind(this),
        pushInfinity: this.pushInfinity.bind(this),
        pushInfinityNeg: this.pushInfinityNeg.bind(this),
        pushNaN: this.pushNaN.bind(this),
        pushNaNNeg: this.pushNaNNeg.bind(this),
        pushArrayStart: this.pushArrayStart.bind(this),
        pushArrayStartFixed: this.pushArrayStartFixed.bind(this),
        pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),
        pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),
        pushObjectStart: this.pushObjectStart.bind(this),
        pushObjectStartFixed: this.pushObjectStartFixed.bind(this),
        pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),
        pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),
        pushByteString: this.pushByteString.bind(this),
        pushByteStringStart: this.pushByteStringStart.bind(this),
        pushUtf8String: this.pushUtf8String.bind(this),
        pushUtf8StringStart: this.pushUtf8StringStart.bind(this),
        pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),
        pushTagUnassigned: this.pushTagUnassigned.bind(this),
        pushTagStart: this.pushTagStart.bind(this),
        pushTagStart4: this.pushTagStart4.bind(this),
        pushTagStart8: this.pushTagStart8.bind(this),
        pushBreak: this.pushBreak.bind(this)
      }, this._heap);
    }
    get _depth() {
      return this._parents.length;
    }
    get _currentParent() {
      return this._parents[this._depth - 1];
    }
    get _ref() {
      return this._currentParent.ref;
    }
    _closeParent() {
      var p = this._parents.pop();
      if (p.length > 0) {
        throw new Error(`Missing ${p.length} elements`);
      }
      switch (p.type) {
        case c.PARENT.TAG:
          this._push(this.createTag(p.ref[0], p.ref[1]));
          break;
        case c.PARENT.BYTE_STRING:
          this._push(this.createByteString(p.ref, p.length));
          break;
        case c.PARENT.UTF8_STRING:
          this._push(this.createUtf8String(p.ref, p.length));
          break;
        case c.PARENT.MAP:
          if (p.values % 2 > 0) {
            throw new Error("Odd number of elements in the map");
          }
          this._push(this.createMap(p.ref, p.length));
          break;
        case c.PARENT.OBJECT:
          if (p.values % 2 > 0) {
            throw new Error("Odd number of elements in the map");
          }
          this._push(this.createObject(p.ref, p.length));
          break;
        case c.PARENT.ARRAY:
          this._push(this.createArray(p.ref, p.length));
          break;
        default:
          break;
      }
      if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {
        this._dec();
      }
    }
    _dec() {
      const p = this._currentParent;
      if (p.length < 0) {
        return;
      }
      p.length--;
      if (p.length === 0) {
        this._closeParent();
      }
    }
    _push(val, hasChildren) {
      const p = this._currentParent;
      p.values++;
      switch (p.type) {
        case c.PARENT.ARRAY:
        case c.PARENT.BYTE_STRING:
        case c.PARENT.UTF8_STRING:
          if (p.length > -1) {
            this._ref[this._ref.length - p.length] = val;
          } else {
            this._ref.push(val);
          }
          this._dec();
          break;
        case c.PARENT.OBJECT:
          if (p.tmpKey != null) {
            this._ref[p.tmpKey] = val;
            p.tmpKey = null;
            this._dec();
          } else {
            p.tmpKey = val;
            if (typeof p.tmpKey !== "string") {
              p.type = c.PARENT.MAP;
              p.ref = utils.buildMap(p.ref);
            }
          }
          break;
        case c.PARENT.MAP:
          if (p.tmpKey != null) {
            this._ref.set(p.tmpKey, val);
            p.tmpKey = null;
            this._dec();
          } else {
            p.tmpKey = val;
          }
          break;
        case c.PARENT.TAG:
          this._ref.push(val);
          if (!hasChildren) {
            this._dec();
          }
          break;
        default:
          throw new Error("Unknown parent type");
      }
    }
    _createParent(obj, type, len) {
      this._parents[this._depth] = {
        type,
        length: len,
        ref: obj,
        values: 0,
        tmpKey: null
      };
    }
    _reset() {
      this._res = [];
      this._parents = [{
        type: c.PARENT.ARRAY,
        length: -1,
        ref: this._res,
        values: 0,
        tmpKey: null
      }];
    }
    createTag(tagNumber, value) {
      const typ = this._knownTags[tagNumber];
      if (!typ) {
        return new Tagged(tagNumber, value);
      }
      return typ(value);
    }
    createMap(obj, len) {
      return obj;
    }
    createObject(obj, len) {
      return obj;
    }
    createArray(arr, len) {
      return arr;
    }
    createByteString(raw, len) {
      return Buffer3.concat(raw);
    }
    createByteStringFromHeap(start, end) {
      if (start === end) {
        return Buffer3.alloc(0);
      }
      return Buffer3.from(this._heap.slice(start, end));
    }
    createInt(val) {
      return val;
    }
    createInt32(f, g) {
      return utils.buildInt32(f, g);
    }
    createInt64(f1, f2, g1, g2) {
      return utils.buildInt64(f1, f2, g1, g2);
    }
    createFloat(val) {
      return val;
    }
    createFloatSingle(a, b, c2, d) {
      return ieee7542.read([a, b, c2, d], 0, false, 23, 4);
    }
    createFloatDouble(a, b, c2, d, e, f, g, h) {
      return ieee7542.read([a, b, c2, d, e, f, g, h], 0, false, 52, 8);
    }
    createInt32Neg(f, g) {
      return -1 - utils.buildInt32(f, g);
    }
    createInt64Neg(f1, f2, g1, g2) {
      const f = utils.buildInt32(f1, f2);
      const g = utils.buildInt32(g1, g2);
      if (f > c.MAX_SAFE_HIGH) {
        return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g));
      }
      return -1 - (f * c.SHIFT32 + g);
    }
    createTrue() {
      return true;
    }
    createFalse() {
      return false;
    }
    createNull() {
      return null;
    }
    createUndefined() {
      return;
    }
    createInfinity() {
      return Infinity;
    }
    createInfinityNeg() {
      return (-Infinity);
    }
    createNaN() {
      return NaN;
    }
    createNaNNeg() {
      return NaN;
    }
    createUtf8String(raw, len) {
      return raw.join("");
    }
    createUtf8StringFromHeap(start, end) {
      if (start === end) {
        return "";
      }
      return this._buffer.toString("utf8", start, end);
    }
    createSimpleUnassigned(val) {
      return new Simple(val);
    }
    pushInt(val) {
      this._push(this.createInt(val));
    }
    pushInt32(f, g) {
      this._push(this.createInt32(f, g));
    }
    pushInt64(f1, f2, g1, g2) {
      this._push(this.createInt64(f1, f2, g1, g2));
    }
    pushFloat(val) {
      this._push(this.createFloat(val));
    }
    pushFloatSingle(a, b, c2, d) {
      this._push(this.createFloatSingle(a, b, c2, d));
    }
    pushFloatDouble(a, b, c2, d, e, f, g, h) {
      this._push(this.createFloatDouble(a, b, c2, d, e, f, g, h));
    }
    pushInt32Neg(f, g) {
      this._push(this.createInt32Neg(f, g));
    }
    pushInt64Neg(f1, f2, g1, g2) {
      this._push(this.createInt64Neg(f1, f2, g1, g2));
    }
    pushTrue() {
      this._push(this.createTrue());
    }
    pushFalse() {
      this._push(this.createFalse());
    }
    pushNull() {
      this._push(this.createNull());
    }
    pushUndefined() {
      this._push(this.createUndefined());
    }
    pushInfinity() {
      this._push(this.createInfinity());
    }
    pushInfinityNeg() {
      this._push(this.createInfinityNeg());
    }
    pushNaN() {
      this._push(this.createNaN());
    }
    pushNaNNeg() {
      this._push(this.createNaNNeg());
    }
    pushArrayStart() {
      this._createParent([], c.PARENT.ARRAY, -1);
    }
    pushArrayStartFixed(len) {
      this._createArrayStartFixed(len);
    }
    pushArrayStartFixed32(len1, len2) {
      const len = utils.buildInt32(len1, len2);
      this._createArrayStartFixed(len);
    }
    pushArrayStartFixed64(len1, len2, len3, len4) {
      const len = utils.buildInt64(len1, len2, len3, len4);
      this._createArrayStartFixed(len);
    }
    pushObjectStart() {
      this._createObjectStartFixed(-1);
    }
    pushObjectStartFixed(len) {
      this._createObjectStartFixed(len);
    }
    pushObjectStartFixed32(len1, len2) {
      const len = utils.buildInt32(len1, len2);
      this._createObjectStartFixed(len);
    }
    pushObjectStartFixed64(len1, len2, len3, len4) {
      const len = utils.buildInt64(len1, len2, len3, len4);
      this._createObjectStartFixed(len);
    }
    pushByteStringStart() {
      this._parents[this._depth] = {
        type: c.PARENT.BYTE_STRING,
        length: -1,
        ref: [],
        values: 0,
        tmpKey: null
      };
    }
    pushByteString(start, end) {
      this._push(this.createByteStringFromHeap(start, end));
    }
    pushUtf8StringStart() {
      this._parents[this._depth] = {
        type: c.PARENT.UTF8_STRING,
        length: -1,
        ref: [],
        values: 0,
        tmpKey: null
      };
    }
    pushUtf8String(start, end) {
      this._push(this.createUtf8StringFromHeap(start, end));
    }
    pushSimpleUnassigned(val) {
      this._push(this.createSimpleUnassigned(val));
    }
    pushTagStart(tag) {
      this._parents[this._depth] = {
        type: c.PARENT.TAG,
        length: 1,
        ref: [tag]
      };
    }
    pushTagStart4(f, g) {
      this.pushTagStart(utils.buildInt32(f, g));
    }
    pushTagStart8(f1, f2, g1, g2) {
      this.pushTagStart(utils.buildInt64(f1, f2, g1, g2));
    }
    pushTagUnassigned(tagNumber) {
      this._push(this.createTag(tagNumber));
    }
    pushBreak() {
      if (this._currentParent.length > -1) {
        throw new Error("Unexpected break");
      }
      this._closeParent();
    }
    _createObjectStartFixed(len) {
      if (len === 0) {
        this._push(this.createObject({}));
        return;
      }
      this._createParent({}, c.PARENT.OBJECT, len);
    }
    _createArrayStartFixed(len) {
      if (len === 0) {
        this._push(this.createArray([]));
        return;
      }
      this._createParent(new Array(len), c.PARENT.ARRAY, len);
    }
    _decode(input) {
      if (input.byteLength === 0) {
        throw new Error("Input too short");
      }
      this._reset();
      this._heap8.set(input);
      const code = this.parser.parse(input.byteLength);
      if (this._depth > 1) {
        while (this._currentParent.length === 0) {
          this._closeParent();
        }
        if (this._depth > 1) {
          throw new Error("Undeterminated nesting");
        }
      }
      if (code > 0) {
        throw new Error("Failed to parse");
      }
      if (this._res.length === 0) {
        throw new Error("No valid result");
      }
    }
    decodeFirst(input) {
      this._decode(input);
      return this._res[0];
    }
    decodeAll(input) {
      this._decode(input);
      return this._res;
    }
    static decode(input, enc) {
      if (typeof input === "string") {
        input = Buffer3.from(input, enc || "hex");
      }
      const dec = new Decoder({ size: input.length });
      return dec.decodeFirst(input);
    }
    static decodeAll(input, enc) {
      if (typeof input === "string") {
        input = Buffer3.from(input, enc || "hex");
      }
      const dec = new Decoder({ size: input.length });
      return dec.decodeAll(input);
    }
  }
  Decoder.decodeFirst = Decoder.decode;
  module.exports = Decoder;
});

// node_modules/borc/src/diagnose.js
var require_diagnose = __commonJS((exports, module) => {
  var collectObject = function(val) {
    return (acc, key) => {
      if (acc) {
        return `${acc}, ${key}: ${val[key]}`;
      }
      return `${key}: ${val[key]}`;
    };
  };
  var { Buffer: Buffer3 } = import.meta.require("buffer");
  var Decoder = require_decoder();
  var utils = require_utils();

  class Diagnose extends Decoder {
    createTag(tagNumber, value) {
      return `${tagNumber}(${value})`;
    }
    createInt(val) {
      return super.createInt(val).toString();
    }
    createInt32(f, g) {
      return super.createInt32(f, g).toString();
    }
    createInt64(f1, f2, g1, g2) {
      return super.createInt64(f1, f2, g1, g2).toString();
    }
    createInt32Neg(f, g) {
      return super.createInt32Neg(f, g).toString();
    }
    createInt64Neg(f1, f2, g1, g2) {
      return super.createInt64Neg(f1, f2, g1, g2).toString();
    }
    createTrue() {
      return "true";
    }
    createFalse() {
      return "false";
    }
    createFloat(val) {
      const fl = super.createFloat(val);
      if (utils.isNegativeZero(val)) {
        return "-0_1";
      }
      return `${fl}_1`;
    }
    createFloatSingle(a, b, c, d) {
      const fl = super.createFloatSingle(a, b, c, d);
      return `${fl}_2`;
    }
    createFloatDouble(a, b, c, d, e, f, g, h) {
      const fl = super.createFloatDouble(a, b, c, d, e, f, g, h);
      return `${fl}_3`;
    }
    createByteString(raw, len) {
      const val = raw.join(", ");
      if (len === -1) {
        return `(_ ${val})`;
      }
      return `h'${val}`;
    }
    createByteStringFromHeap(start, end) {
      const val = Buffer3.from(super.createByteStringFromHeap(start, end)).toString("hex");
      return `h'${val}'`;
    }
    createInfinity() {
      return "Infinity_1";
    }
    createInfinityNeg() {
      return "-Infinity_1";
    }
    createNaN() {
      return "NaN_1";
    }
    createNaNNeg() {
      return "-NaN_1";
    }
    createNull() {
      return "null";
    }
    createUndefined() {
      return "undefined";
    }
    createSimpleUnassigned(val) {
      return `simple(${val})`;
    }
    createArray(arr, len) {
      const val = super.createArray(arr, len);
      if (len === -1) {
        return `[_ ${val.join(", ")}]`;
      }
      return `[${val.join(", ")}]`;
    }
    createMap(map, len) {
      const val = super.createMap(map);
      const list = Array.from(val.keys()).reduce(collectObject(val), "");
      if (len === -1) {
        return `{_ ${list}}`;
      }
      return `{${list}}`;
    }
    createObject(obj, len) {
      const val = super.createObject(obj);
      const map = Object.keys(val).reduce(collectObject(val), "");
      if (len === -1) {
        return `{_ ${map}}`;
      }
      return `{${map}}`;
    }
    createUtf8String(raw, len) {
      const val = raw.join(", ");
      if (len === -1) {
        return `(_ ${val})`;
      }
      return `"${val}"`;
    }
    createUtf8StringFromHeap(start, end) {
      const val = Buffer3.from(super.createUtf8StringFromHeap(start, end)).toString("utf8");
      return `"${val}"`;
    }
    static diagnose(input, enc) {
      if (typeof input === "string") {
        input = Buffer3.from(input, enc || "hex");
      }
      const dec = new Diagnose;
      return dec.decodeFirst(input);
    }
  }
  module.exports = Diagnose;
});

// node_modules/borc/src/encoder.js
var require_encoder = __commonJS((exports, module) => {
  var toType = function(obj) {
    return {}.toString.call(obj).slice(8, -1);
  };
  var { Buffer: Buffer3 } = import.meta.require("buffer");
  var { URL: URL2 } = require_iso_url();
  var Bignumber = require_bignumber().BigNumber;
  var utils = require_utils();
  var constants = require_constants();
  var MT = constants.MT;
  var NUMBYTES = constants.NUMBYTES;
  var SHIFT32 = constants.SHIFT32;
  var SYMS = constants.SYMS;
  var TAG = constants.TAG;
  var HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;
  var FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;
  var DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;
  var TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;
  var FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;
  var UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;
  var NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;
  var MAXINT_BN = new Bignumber("0x20000000000000");
  var BUF_NAN = Buffer3.from("f97e00", "hex");
  var BUF_INF_NEG = Buffer3.from("f9fc00", "hex");
  var BUF_INF_POS = Buffer3.from("f97c00", "hex");

  class Encoder {
    constructor(options) {
      options = options || {};
      this.streaming = typeof options.stream === "function";
      this.onData = options.stream;
      this.semanticTypes = [
        [URL2, this._pushUrl],
        [Bignumber, this._pushBigNumber]
      ];
      const addTypes = options.genTypes || [];
      const len = addTypes.length;
      for (let i = 0;i < len; i++) {
        this.addSemanticType(addTypes[i][0], addTypes[i][1]);
      }
      this._reset();
    }
    addSemanticType(type, fun) {
      const len = this.semanticTypes.length;
      for (let i = 0;i < len; i++) {
        const typ = this.semanticTypes[i][0];
        if (typ === type) {
          const old = this.semanticTypes[i][1];
          this.semanticTypes[i][1] = fun;
          return old;
        }
      }
      this.semanticTypes.push([type, fun]);
      return null;
    }
    push(val) {
      if (!val) {
        return true;
      }
      this.result[this.offset] = val;
      this.resultMethod[this.offset] = 0;
      this.resultLength[this.offset] = val.length;
      this.offset++;
      if (this.streaming) {
        this.onData(this.finalize());
      }
      return true;
    }
    pushWrite(val, method, len) {
      this.result[this.offset] = val;
      this.resultMethod[this.offset] = method;
      this.resultLength[this.offset] = len;
      this.offset++;
      if (this.streaming) {
        this.onData(this.finalize());
      }
      return true;
    }
    _pushUInt8(val) {
      return this.pushWrite(val, 1, 1);
    }
    _pushUInt16BE(val) {
      return this.pushWrite(val, 2, 2);
    }
    _pushUInt32BE(val) {
      return this.pushWrite(val, 3, 4);
    }
    _pushDoubleBE(val) {
      return this.pushWrite(val, 4, 8);
    }
    _pushNaN() {
      return this.push(BUF_NAN);
    }
    _pushInfinity(obj) {
      const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
      return this.push(half);
    }
    _pushFloat(obj) {
      const b2 = Buffer3.allocUnsafe(2);
      if (utils.writeHalf(b2, obj)) {
        if (utils.parseHalf(b2) === obj) {
          return this._pushUInt8(HALF) && this.push(b2);
        }
      }
      const b4 = Buffer3.allocUnsafe(4);
      b4.writeFloatBE(obj, 0);
      if (b4.readFloatBE(0) === obj) {
        return this._pushUInt8(FLOAT) && this.push(b4);
      }
      return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
    }
    _pushInt(obj, mt, orig) {
      const m = mt << 5;
      if (obj < 24) {
        return this._pushUInt8(m | obj);
      }
      if (obj <= 255) {
        return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);
      }
      if (obj <= 65535) {
        return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);
      }
      if (obj <= 4294967295) {
        return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
      }
      if (obj <= Number.MAX_SAFE_INTEGER) {
        return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);
      }
      if (mt === MT.NEG_INT) {
        return this._pushFloat(orig);
      }
      return this._pushFloat(obj);
    }
    _pushIntNum(obj) {
      if (obj < 0) {
        return this._pushInt(-obj - 1, MT.NEG_INT, obj);
      } else {
        return this._pushInt(obj, MT.POS_INT);
      }
    }
    _pushNumber(obj) {
      switch (false) {
        case obj === obj:
          return this._pushNaN(obj);
        case isFinite(obj):
          return this._pushInfinity(obj);
        case obj % 1 !== 0:
          return this._pushIntNum(obj);
        default:
          return this._pushFloat(obj);
      }
    }
    _pushString(obj) {
      const len = Buffer3.byteLength(obj, "utf8");
      return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len);
    }
    _pushBoolean(obj) {
      return this._pushUInt8(obj ? TRUE : FALSE);
    }
    _pushUndefined(obj) {
      return this._pushUInt8(UNDEFINED);
    }
    _pushArray(gen, obj) {
      const len = obj.length;
      if (!gen._pushInt(len, MT.ARRAY)) {
        return false;
      }
      for (let j = 0;j < len; j++) {
        if (!gen.pushAny(obj[j])) {
          return false;
        }
      }
      return true;
    }
    _pushTag(tag) {
      return this._pushInt(tag, MT.TAG);
    }
    _pushDate(gen, obj) {
      return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1000));
    }
    _pushBuffer(gen, obj) {
      return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
    }
    _pushNoFilter(gen, obj) {
      return gen._pushBuffer(gen, obj.slice());
    }
    _pushRegexp(gen, obj) {
      return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
    }
    _pushSet(gen, obj) {
      if (!gen._pushInt(obj.size, MT.ARRAY)) {
        return false;
      }
      for (const x of obj) {
        if (!gen.pushAny(x)) {
          return false;
        }
      }
      return true;
    }
    _pushUrl(gen, obj) {
      return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());
    }
    _pushBigint(obj) {
      let tag = TAG.POS_BIGINT;
      if (obj.isNegative()) {
        obj = obj.negated().minus(1);
        tag = TAG.NEG_BIGINT;
      }
      let str = obj.toString(16);
      if (str.length % 2) {
        str = "0" + str;
      }
      const buf = Buffer3.from(str, "hex");
      return this._pushTag(tag) && this._pushBuffer(this, buf);
    }
    _pushBigNumber(gen, obj) {
      if (obj.isNaN()) {
        return gen._pushNaN();
      }
      if (!obj.isFinite()) {
        return gen._pushInfinity(obj.isNegative() ? (-Infinity) : Infinity);
      }
      if (obj.isInteger()) {
        return gen._pushBigint(obj);
      }
      if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {
        return false;
      }
      const dec = obj.decimalPlaces();
      const slide = obj.multipliedBy(new Bignumber(10).pow(dec));
      if (!gen._pushIntNum(-dec)) {
        return false;
      }
      if (slide.abs().isLessThan(MAXINT_BN)) {
        return gen._pushIntNum(slide.toNumber());
      } else {
        return gen._pushBigint(slide);
      }
    }
    _pushMap(gen, obj) {
      if (!gen._pushInt(obj.size, MT.MAP)) {
        return false;
      }
      return this._pushRawMap(obj.size, Array.from(obj));
    }
    _pushObject(obj) {
      if (!obj) {
        return this._pushUInt8(NULL);
      }
      var len = this.semanticTypes.length;
      for (var i = 0;i < len; i++) {
        if (obj instanceof this.semanticTypes[i][0]) {
          return this.semanticTypes[i][1].call(obj, this, obj);
        }
      }
      var f = obj.encodeCBOR;
      if (typeof f === "function") {
        return f.call(obj, this);
      }
      var keys = Object.keys(obj);
      var keyLength = keys.length;
      if (!this._pushInt(keyLength, MT.MAP)) {
        return false;
      }
      return this._pushRawMap(keyLength, keys.map((k) => [k, obj[k]]));
    }
    _pushRawMap(len, map) {
      map = map.map(function(a) {
        a[0] = Encoder.encode(a[0]);
        return a;
      }).sort(utils.keySorter);
      for (var j = 0;j < len; j++) {
        if (!this.push(map[j][0])) {
          return false;
        }
        if (!this.pushAny(map[j][1])) {
          return false;
        }
      }
      return true;
    }
    write(obj) {
      return this.pushAny(obj);
    }
    pushAny(obj) {
      var typ = toType(obj);
      switch (typ) {
        case "Number":
          return this._pushNumber(obj);
        case "String":
          return this._pushString(obj);
        case "Boolean":
          return this._pushBoolean(obj);
        case "Object":
          return this._pushObject(obj);
        case "Array":
          return this._pushArray(this, obj);
        case "Uint8Array":
          return this._pushBuffer(this, Buffer3.isBuffer(obj) ? obj : Buffer3.from(obj));
        case "Null":
          return this._pushUInt8(NULL);
        case "Undefined":
          return this._pushUndefined(obj);
        case "Map":
          return this._pushMap(this, obj);
        case "Set":
          return this._pushSet(this, obj);
        case "URL":
          return this._pushUrl(this, obj);
        case "BigNumber":
          return this._pushBigNumber(this, obj);
        case "Date":
          return this._pushDate(this, obj);
        case "RegExp":
          return this._pushRegexp(this, obj);
        case "Symbol":
          switch (obj) {
            case SYMS.NULL:
              return this._pushObject(null);
            case SYMS.UNDEFINED:
              return this._pushUndefined(undefined);
            default:
              throw new Error("Unknown symbol: " + obj.toString());
          }
        default:
          throw new Error("Unknown type: " + typeof obj + ", " + (obj ? obj.toString() : ""));
      }
    }
    finalize() {
      if (this.offset === 0) {
        return null;
      }
      var result = this.result;
      var resultLength = this.resultLength;
      var resultMethod = this.resultMethod;
      var offset = this.offset;
      var size = 0;
      var i = 0;
      for (;i < offset; i++) {
        size += resultLength[i];
      }
      var res = Buffer3.allocUnsafe(size);
      var index = 0;
      var length = 0;
      for (i = 0;i < offset; i++) {
        length = resultLength[i];
        switch (resultMethod[i]) {
          case 0:
            result[i].copy(res, index);
            break;
          case 1:
            res.writeUInt8(result[i], index, true);
            break;
          case 2:
            res.writeUInt16BE(result[i], index, true);
            break;
          case 3:
            res.writeUInt32BE(result[i], index, true);
            break;
          case 4:
            res.writeDoubleBE(result[i], index, true);
            break;
          case 5:
            res.write(result[i], index, length, "utf8");
            break;
          default:
            throw new Error("unkown method");
        }
        index += length;
      }
      var tmp = res;
      this._reset();
      return tmp;
    }
    _reset() {
      this.result = [];
      this.resultMethod = [];
      this.resultLength = [];
      this.offset = 0;
    }
    static encode(o) {
      const enc = new Encoder;
      const ret2 = enc.pushAny(o);
      if (!ret2) {
        throw new Error("Failed to encode input");
      }
      return enc.finalize();
    }
  }
  module.exports = Encoder;
});

// node_modules/borc/src/index.js
var require_src = __commonJS((exports) => {
  exports.Diagnose = require_diagnose();
  exports.Decoder = require_decoder();
  exports.Encoder = require_encoder();
  exports.Simple = require_simple();
  exports.Tagged = require_tagged();
  exports.decodeAll = exports.Decoder.decodeAll;
  exports.decodeFirst = exports.Decoder.decodeFirst;
  exports.diagnose = exports.Diagnose.diagnose;
  exports.encode = exports.Encoder.encode;
  exports.decode = exports.Decoder.decode;
  exports.leveldb = {
    decode: exports.Decoder.decodeAll,
    encode: exports.Encoder.encode,
    buffer: true,
    name: "cbor"
  };
});

// node_modules/@dfinity/agent/lib/esm/utils/buffer.js
function concat2(...buffers) {
  const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));
  let index = 0;
  for (const b of buffers) {
    result.set(new Uint8Array(b), index);
    index += b.byteLength;
  }
  return result.buffer;
}
function toHex(buffer) {
  return [...new Uint8Array(buffer)].map((x) => x.toString(16).padStart(2, "0")).join("");
}
function fromHex(hex) {
  if (!hexRe.test(hex)) {
    throw new Error("Invalid hexadecimal string.");
  }
  const buffer = [...hex].reduce((acc, curr, i) => {
    acc[i / 2 | 0] = (acc[i / 2 | 0] || "") + curr;
    return acc;
  }, []).map((x) => Number.parseInt(x, 16));
  return new Uint8Array(buffer).buffer;
}
function compare3(b1, b2) {
  if (b1.byteLength !== b2.byteLength) {
    return b1.byteLength - b2.byteLength;
  }
  const u1 = new Uint8Array(b1);
  const u2 = new Uint8Array(b2);
  for (let i = 0;i < u1.length; i++) {
    if (u1[i] !== u2[i]) {
      return u1[i] - u2[i];
    }
  }
  return 0;
}
var hexRe;
var init_buffer = __esm(() => {
  hexRe = new RegExp(/^([0-9A-F]{2})*$/i);
});

// node_modules/@dfinity/agent/lib/esm/request_id.js
function hash(data) {
  return import_js_sha256.sha256.create().update(new Uint8Array(data)).arrayBuffer();
}
function hashValue(value) {
  if (value instanceof import_borc.default.Tagged) {
    return hashValue(value.value);
  } else if (typeof value === "string") {
    return hashString(value);
  } else if (typeof value === "number") {
    return hash(candid.lebEncode(value));
  } else if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
    return hash(value);
  } else if (Array.isArray(value)) {
    const vals = value.map(hashValue);
    return hash(concat2(...vals));
  } else if (value && typeof value === "object" && value._isPrincipal) {
    return hash(value.toUint8Array());
  } else if (typeof value === "object" && value !== null && typeof value.toHash === "function") {
    return hashValue(value.toHash());
  } else if (typeof value === "bigint") {
    return hash(candid.lebEncode(value));
  }
  throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value}`), {
    value
  });
}
function requestIdOf(request) {
  const hashed = Object.entries(request).filter(([, value]) => value !== undefined).map(([key, value]) => {
    const hashedKey = hashString(key);
    const hashedValue = hashValue(value);
    return [hashedKey, hashedValue];
  });
  const traversed = hashed;
  const sorted = traversed.sort(([k1], [k2]) => {
    return compare3(k1, k2);
  });
  const concatenated = concat2(...sorted.map((x) => concat2(...x)));
  const requestId = hash(concatenated);
  return requestId;
}
var candid, import_borc, import_js_sha256, hashString;
var init_request_id = __esm(() => {
  candid = __toESM(require_cjs2(), 1);
  import_borc = __toESM(require_src(), 1);
  import_js_sha256 = __toESM(require_sha256(), 1);
  init_buffer();
  hashString = (value) => {
    const encoded = new TextEncoder().encode(value);
    return hash(encoded);
  };
});

// node_modules/simple-cbor/src/value.js
var require_value = __commonJS((exports) => {
  var _concat = function(a, ...args) {
    const newBuffer = new Uint8Array(a.byteLength + args.reduce((acc, b) => acc + b.byteLength, 0));
    newBuffer.set(new Uint8Array(a), 0);
    let i = a.byteLength;
    for (const b of args) {
      newBuffer.set(new Uint8Array(b), i);
      i += b.byteLength;
    }
    return newBuffer.buffer;
  };
  var _serializeValue = function(major, minor, value) {
    value = value.replace(/[^0-9a-fA-F]/g, "");
    const length = 2 ** (minor - 24);
    value = value.slice(-length * 2).padStart(length * 2, "0");
    const bytes2 = [(major << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));
    return new Uint8Array(bytes2).buffer;
  };
  var _serializeNumber = function(major, value) {
    if (value < 24) {
      return new Uint8Array([(major << 5) + value]).buffer;
    } else {
      const minor = value <= 255 ? 24 : value <= 65535 ? 25 : value <= 4294967295 ? 26 : 27;
      return _serializeValue(major, minor, value.toString(16));
    }
  };
  var _serializeString = function(str) {
    const utf8 = [];
    for (let i = 0;i < str.length; i++) {
      let charcode = str.charCodeAt(i);
      if (charcode < 128) {
        utf8.push(charcode);
      } else if (charcode < 2048) {
        utf8.push(192 | charcode >> 6, 128 | charcode & 63);
      } else if (charcode < 55296 || charcode >= 57344) {
        utf8.push(224 | charcode >> 12, 128 | charcode >> 6 & 63, 128 | charcode & 63);
      } else {
        i++;
        charcode = (charcode & 1023) << 10 | str.charCodeAt(i) & 1023;
        utf8.push(240 | charcode >> 18, 128 | charcode >> 12 & 63, 128 | charcode >> 6 & 63, 128 | charcode & 63);
      }
    }
    return _concat(new Uint8Array(_serializeNumber(3, str.length)), new Uint8Array(utf8));
  };
  var tagged = function(tag, value) {
    if (tag == 14277111) {
      return _concat(new Uint8Array([217, 217, 247]), value);
    }
    if (tag < 24) {
      return _concat(new Uint8Array([(6 << 5) + tag]), value);
    } else {
      const minor = tag <= 255 ? 24 : tag <= 65535 ? 25 : tag <= 4294967295 ? 26 : 27;
      const length = 2 ** (minor - 24);
      const value2 = tag.toString(16).slice(-length * 2).padStart(length * 2, "0");
      const bytes2 = [(6 << 5) + minor].concat(value2.match(/../g).map((byte) => parseInt(byte, 16)));
      return new Uint8Array(bytes2).buffer;
    }
  };
  var raw = function(bytes2) {
    return new Uint8Array(bytes2).buffer;
  };
  var uSmall = function(n) {
    if (isNaN(n)) {
      throw new RangeError("Invalid number.");
    }
    n = Math.min(Math.max(0, n), 23);
    const bytes2 = [(0 << 5) + n];
    return new Uint8Array(bytes2).buffer;
  };
  var u8 = function(u82, radix) {
    u82 = parseInt("" + u82, radix);
    if (isNaN(u82)) {
      throw new RangeError("Invalid number.");
    }
    u82 = Math.min(Math.max(0, u82), 255);
    u82 = u82.toString(16);
    return _serializeValue(0, 24, u82);
  };
  var u16 = function(u162, radix) {
    u162 = parseInt("" + u162, radix);
    if (isNaN(u162)) {
      throw new RangeError("Invalid number.");
    }
    u162 = Math.min(Math.max(0, u162), 65535);
    u162 = u162.toString(16);
    return _serializeValue(0, 25, u162);
  };
  var u32 = function(u322, radix) {
    u322 = parseInt("" + u322, radix);
    if (isNaN(u322)) {
      throw new RangeError("Invalid number.");
    }
    u322 = Math.min(Math.max(0, u322), 4294967295);
    u322 = u322.toString(16);
    return _serializeValue(0, 26, u322);
  };
  var u64 = function(u642, radix) {
    if (typeof u642 == "string" && radix == 16) {
      if (u642.match(/[^0-9a-fA-F]/)) {
        throw new RangeError("Invalid number.");
      }
      return _serializeValue(0, 27, u642);
    }
    u642 = parseInt("" + u642, radix);
    if (isNaN(u642)) {
      throw new RangeError("Invalid number.");
    }
    u642 = Math.min(Math.max(0, u642), MAX_U64_NUMBER);
    u642 = u642.toString(16);
    return _serializeValue(0, 27, u642);
  };
  var iSmall = function(n) {
    if (isNaN(n)) {
      throw new RangeError("Invalid number.");
    }
    if (n === 0) {
      return uSmall(0);
    }
    n = Math.min(Math.max(0, -n), 24) - 1;
    const bytes2 = [(1 << 5) + n];
    return new Uint8Array(bytes2).buffer;
  };
  var i8 = function(i82, radix) {
    i82 = parseInt("" + i82, radix);
    if (isNaN(i82)) {
      throw new RangeError("Invalid number.");
    }
    i82 = Math.min(Math.max(0, -i82 - 1), 255);
    i82 = i82.toString(16);
    return _serializeValue(1, 24, i82);
  };
  var i16 = function(i162, radix) {
    i162 = parseInt("" + i162, radix);
    if (isNaN(i162)) {
      throw new RangeError("Invalid number.");
    }
    i162 = Math.min(Math.max(0, -i162 - 1), 65535);
    i162 = i162.toString(16);
    return _serializeValue(1, 25, i162);
  };
  var i32 = function(i322, radix) {
    i322 = parseInt("" + i322, radix);
    if (isNaN(i322)) {
      throw new RangeError("Invalid number.");
    }
    i322 = Math.min(Math.max(0, -i322 - 1), 4294967295);
    i322 = i322.toString(16);
    return _serializeValue(1, 26, i322);
  };
  var i64 = function(i642, radix) {
    if (typeof i642 == "string" && radix == 16) {
      if (i642.startsWith("-")) {
        i642 = i642.slice(1);
      } else {
        i642 = "0";
      }
      if (i642.match(/[^0-9a-fA-F]/) || i642.length > 16) {
        throw new RangeError("Invalid number.");
      }
      let done = false;
      let newI64 = i642.split("").reduceRight((acc, x) => {
        if (done) {
          return x + acc;
        }
        let n = parseInt(x, 16) - 1;
        if (n >= 0) {
          done = true;
          return n.toString(16) + acc;
        } else {
          return "f" + acc;
        }
      }, "");
      if (!done) {
        return u64(0);
      }
      return _serializeValue(1, 27, newI64);
    }
    i642 = parseInt("" + i642, radix);
    if (isNaN(i642)) {
      throw new RangeError("Invalid number.");
    }
    i642 = Math.min(Math.max(0, -i642 - 1), 9007199254740992);
    i642 = i642.toString(16);
    return _serializeValue(1, 27, i642);
  };
  var number = function(n) {
    if (n >= 0) {
      if (n < 24) {
        return uSmall(n);
      } else if (n <= 255) {
        return u8(n);
      } else if (n <= 65535) {
        return u16(n);
      } else if (n <= 4294967295) {
        return u32(n);
      } else {
        return u64(n);
      }
    } else {
      if (n >= -24) {
        return iSmall(n);
      } else if (n >= -255) {
        return i8(n);
      } else if (n >= -65535) {
        return i16(n);
      } else if (n >= -4294967295) {
        return i32(n);
      } else {
        return i64(n);
      }
    }
  };
  var bytes = function(bytes2) {
    return _concat(_serializeNumber(2, bytes2.byteLength), bytes2);
  };
  var string = function(str) {
    return _serializeString(str);
  };
  var array = function(items) {
    return _concat(_serializeNumber(4, items.length), ...items);
  };
  var map = function(items, stable = false) {
    if (!(items instanceof Map)) {
      items = new Map(Object.entries(items));
    }
    let entries = Array.from(items.entries());
    if (stable) {
      entries = entries.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));
    }
    return _concat(_serializeNumber(5, items.size), ...entries.map(([k, v]) => _concat(_serializeString(k), v)));
  };
  var singleFloat = function(f) {
    const single = new Float32Array([f]);
    return _concat(new Uint8Array([(7 << 5) + 26]), new Uint8Array(single.buffer));
  };
  var doubleFloat = function(f) {
    const single = new Float64Array([f]);
    return _concat(new Uint8Array([(7 << 5) + 27]), new Uint8Array(single.buffer));
  };
  var bool = function(v) {
    return v ? true_() : false_();
  };
  var true_ = function() {
    return raw(new Uint8Array([(7 << 5) + 21]));
  };
  var false_ = function() {
    return raw(new Uint8Array([(7 << 5) + 20]));
  };
  var null_ = function() {
    return raw(new Uint8Array([(7 << 5) + 22]));
  };
  var undefined_ = function() {
    return raw(new Uint8Array([(7 << 5) + 23]));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MAX_U64_NUMBER = 9007199254740992;
  exports.tagged = tagged;
  exports.raw = raw;
  exports.uSmall = uSmall;
  exports.u8 = u8;
  exports.u16 = u16;
  exports.u32 = u32;
  exports.u64 = u64;
  exports.iSmall = iSmall;
  exports.i8 = i8;
  exports.i16 = i16;
  exports.i32 = i32;
  exports.i64 = i64;
  exports.number = number;
  exports.bytes = bytes;
  exports.string = string;
  exports.array = array;
  exports.map = map;
  exports.singleFloat = singleFloat;
  exports.doubleFloat = doubleFloat;
  exports.bool = bool;
  exports.true_ = true_;
  exports.false_ = false_;
  exports.null_ = null_;
  exports.undefined_ = undefined_;
});

// node_modules/simple-cbor/src/serializer.js
var require_serializer = __commonJS((exports) => {
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var cbor = __importStar(require_value());
  var BufferClasses = [
    ArrayBuffer,
    Uint8Array,
    Uint16Array,
    Uint32Array,
    Int8Array,
    Int16Array,
    Int32Array,
    Float32Array,
    Float64Array
  ];

  class JsonDefaultCborEncoder {
    constructor(_serializer, _stable = false) {
      this._serializer = _serializer;
      this._stable = _stable;
      this.name = "jsonDefault";
      this.priority = -100;
    }
    match(value) {
      return ["undefined", "boolean", "number", "string", "object"].indexOf(typeof value) != -1;
    }
    encode(value) {
      switch (typeof value) {
        case "undefined":
          return cbor.undefined_();
        case "boolean":
          return cbor.bool(value);
        case "number":
          if (Math.floor(value) === value) {
            return cbor.number(value);
          } else {
            return cbor.doubleFloat(value);
          }
        case "string":
          return cbor.string(value);
        case "object":
          if (value === null) {
            return cbor.null_();
          } else if (Array.isArray(value)) {
            return cbor.array(value.map((x) => this._serializer.serializeValue(x)));
          } else if (BufferClasses.find((x) => value instanceof x)) {
            return cbor.bytes(value.buffer);
          } else if (Object.getOwnPropertyNames(value).indexOf("toJSON") !== -1) {
            return this.encode(value.toJSON());
          } else if (value instanceof Map) {
            const m = new Map;
            for (const [key, item] of value.entries()) {
              m.set(key, this._serializer.serializeValue(item));
            }
            return cbor.map(m, this._stable);
          } else {
            const m = new Map;
            for (const [key, item] of Object.entries(value)) {
              m.set(key, this._serializer.serializeValue(item));
            }
            return cbor.map(m, this._stable);
          }
        default:
          throw new Error("Invalid value.");
      }
    }
  }
  exports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;

  class ToCborEncoder {
    constructor() {
      this.name = "cborEncoder";
      this.priority = -90;
    }
    match(value) {
      return typeof value == "object" && typeof value["toCBOR"] == "function";
    }
    encode(value) {
      return value.toCBOR();
    }
  }
  exports.ToCborEncoder = ToCborEncoder;

  class CborSerializer {
    constructor() {
      this._encoders = new Set;
    }
    static withDefaultEncoders(stable = false) {
      const s2 = new this;
      s2.addEncoder(new JsonDefaultCborEncoder(s2, stable));
      s2.addEncoder(new ToCborEncoder);
      return s2;
    }
    removeEncoder(name) {
      for (const encoder of this._encoders.values()) {
        if (encoder.name == name) {
          this._encoders.delete(encoder);
        }
      }
    }
    addEncoder(encoder) {
      this._encoders.add(encoder);
    }
    getEncoderFor(value) {
      let chosenEncoder = null;
      for (const encoder of this._encoders) {
        if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {
          if (encoder.match(value)) {
            chosenEncoder = encoder;
          }
        }
      }
      if (chosenEncoder === null) {
        throw new Error("Could not find an encoder for value.");
      }
      return chosenEncoder;
    }
    serializeValue(value) {
      return this.getEncoderFor(value).encode(value);
    }
    serialize(value) {
      return this.serializeValue(value);
    }
  }
  exports.CborSerializer = CborSerializer;

  class SelfDescribeCborSerializer extends CborSerializer {
    serialize(value) {
      return cbor.raw(new Uint8Array([
        ...new Uint8Array([217, 217, 247]),
        ...new Uint8Array(super.serializeValue(value))
      ]));
    }
  }
  exports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;
});

// node_modules/simple-cbor/src/index.js
var require_src2 = __commonJS((exports) => {
  var __export2 = function(m) {
    for (var p in m)
      if (!exports.hasOwnProperty(p))
        exports[p] = m[p];
  };
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __export2(require_serializer());
  var value = __importStar(require_value());
  exports.value = value;
});

// node_modules/@dfinity/agent/lib/esm/cbor.js
var exports_cbor = {};
__export(exports_cbor, {
  encode: () => {
    {
      return encode;
    }
  },
  decode: () => {
    {
      return decode;
    }
  },
  CborTag: () => {
    {
      return CborTag;
    }
  }
});
function encode(value2) {
  return serializer.serialize(value2);
}
function decode(input) {
  const buffer4 = new Uint8Array(input);
  const decoder = new Uint8ArrayDecoder({
    size: buffer4.byteLength,
    tags: {
      2: (val) => decodePositiveBigInt(val),
      3: (val) => -decodePositiveBigInt(val),
      [CborTag.Semantic]: (value2) => value2
    }
  });
  return decoder.decodeFirst(buffer4);
}

class PrincipalEncoder {
  get name() {
    return "Principal";
  }
  get priority() {
    return 0;
  }
  match(value2) {
    return value2 && value2._isPrincipal === true;
  }
  encode(v) {
    return cbor.value.bytes(v.toUint8Array());
  }
}

class BufferEncoder {
  get name() {
    return "Buffer";
  }
  get priority() {
    return 1;
  }
  match(value2) {
    return value2 instanceof ArrayBuffer || ArrayBuffer.isView(value2);
  }
  encode(v) {
    return cbor.value.bytes(new Uint8Array(v));
  }
}

class BigIntEncoder {
  get name() {
    return "BigInt";
  }
  get priority() {
    return 1;
  }
  match(value2) {
    return typeof value2 === `bigint`;
  }
  encode(v) {
    if (v > BigInt(0)) {
      return cbor.value.tagged(2, cbor.value.bytes(fromHex(v.toString(16))));
    } else {
      return cbor.value.tagged(3, cbor.value.bytes(fromHex((BigInt("-1") * v).toString(16))));
    }
  }
}

class Uint8ArrayDecoder extends import_borc2.default.Decoder {
  createByteString(raw) {
    return concat2(...raw);
  }
  createByteStringFromHeap(start, end) {
    if (start === end) {
      return new ArrayBuffer(0);
    }
    return new Uint8Array(this._heap.slice(start, end));
  }
}
var import_borc2, cbor, import_simple_cbor, decodePositiveBigInt, serializer, CborTag;
var init_cbor = __esm(() => {
  import_borc2 = __toESM(require_src(), 1);
  cbor = __toESM(require_src2(), 1);
  import_simple_cbor = __toESM(require_src2(), 1);
  init_buffer();
  decodePositiveBigInt = function(buf) {
    const len = buf.byteLength;
    let res = BigInt(0);
    for (let i = 0;i < len; i++) {
      res = res * BigInt(256) + BigInt(buf[i]);
    }
    return res;
  };
  serializer = import_simple_cbor.SelfDescribeCborSerializer.withDefaultEncoders(true);
  serializer.addEncoder(new PrincipalEncoder);
  serializer.addEncoder(new BufferEncoder);
  serializer.addEncoder(new BigIntEncoder);
  (function(CborTag2) {
    CborTag2[CborTag2["Uint64LittleEndian"] = 71] = "Uint64LittleEndian";
    CborTag2[CborTag2["Semantic"] = 55799] = "Semantic";
  })(CborTag || (CborTag = {}));
});

// node_modules/base64-arraybuffer/lib/base64-arraybuffer.js
var require_base64_arraybuffer = __commonJS((exports) => {
  (function() {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = new Uint8Array(256);
    for (var i = 0;i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }
    exports.encode = function(arraybuffer) {
      var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base642 = "";
      for (i2 = 0;i2 < len; i2 += 3) {
        base642 += chars[bytes[i2] >> 2];
        base642 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
        base642 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
        base642 += chars[bytes[i2 + 2] & 63];
      }
      if (len % 3 === 2) {
        base642 = base642.substring(0, base642.length - 1) + "=";
      } else if (len % 3 === 1) {
        base642 = base642.substring(0, base642.length - 2) + "==";
      }
      return base642;
    };
    exports.decode = function(base642) {
      var bufferLength = base642.length * 0.75, len = base642.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base642[base642.length - 1] === "=") {
        bufferLength--;
        if (base642[base642.length - 2] === "=") {
          bufferLength--;
        }
      }
      var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
      for (i2 = 0;i2 < len; i2 += 4) {
        encoded1 = lookup[base642.charCodeAt(i2)];
        encoded2 = lookup[base642.charCodeAt(i2 + 1)];
        encoded3 = lookup[base642.charCodeAt(i2 + 2)];
        encoded4 = lookup[base642.charCodeAt(i2 + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
  })();
});

// node_modules/@dfinity/agent/lib/esm/vendor/bls/wasm.js
var wasmBytesBase64;
var init_wasm = __esm(() => {
  wasmBytesBase64 = `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akE4ENABGiACQbgDakEBNgIAIAJBwANqQTgQ0AEaIAJB+ANqQQE2AgAgAkGABGpBOBDQARogAkEBNgK4BCACQcAEakE4ENABGiACQfgEakEBNgIAIAJBgAVqQTgQ0AEaIAJBuAVqQQE2AgAgAkHABWpBOBDQARogAkH4BWpBATYCACACQYAGakE4ENABGiACQQE2ArgGIAJBwAZqQTgQ0AEaIAJB+AZqQQE2AgAgAkGAB2pBOBDQARogAkG4B2pBATYCACACQcAHakE4ENABGiACQfgHakEBNgIAIAIgARAYAkAgASgCgAZBBEYNACAAKAKABkEERg0AIAJBgARqIgMgAEGAAmoQlgEgAyABQYACahAYDAYLIAJBwAxqIgdBOBDQARogAkEBNgL4DCACQYANakE4ENABGiACQbgNakEBNgIAIAJBgAhqIgRBOBDQARogAkEBNgK4CCACQcAIakE4ENABGiACQfgIakEBNgIAIAJBgApqIgMgAEGAA2oiBRBeIAQgAxCZASADIAFBgANqIgYQXiAEIAMQESAHELYBIAEoAoAGQQRHDQMMBAsgACABEAMMBgsgAkHADGoiAyABQYAFahBeIAJBgAxqIgQgA0HAABDRARogAkGABmogBBCnAQsgAkGABmoQZCACQYAIaiIDIAIQlgEgAxArIAJBgAJqIgQgAxCXASAGIAQQlgEgAkGABGoiByADEJYBIAMgABCWASADIAUQlwEgAxCwASACQYAKaiIEIAEQlgEgBCABQYAEahCXASAEELABIAMgBBAYIAcgAxCXASADIAUQlgECQCABKAKABkECRwRAIAJBwAxqIgMgAUGABWoQXiACQYAIaiADEKYBDAELIAJBwAxqIgMgAUGABWoQXiACQYAMaiIBIANBwAAQ0QEaIAJBgAhqIAEQpwELIAJBgAhqIgEQZCACQYAKaiIDIAEQlgEgAxArIAUgAkGABGoQlgEgBSADEJcBIAJBgAZqIgQgAxCXASABEGQgBiABEJcBIAQQsAEgBBBkIAAgAhCWASAAIAQQlwEMAwsgAkGACmoiAyAFEF4gAkHADGoiBCADEJkBIAMgAUGAAmoQXiAEIAMQEQsgACgCgAZBBEcEQCACQYAKaiIDIABBgAJqEF4gAkHADGoiBCADEJkBIAMgBhBeIAQgAxARCyACQYAEaiIDIAJB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AEHcu8AAKAIAQX4gA0EDdndxNgIACyAAIAEQoAEgAEH0vsAAKAIARw0BQey+wAAgATYCAAsPCyABQYACTwRAIAAgARAWDwsgAUEDdiICQQN0QeS7wABqIQECf0Hcu8AAKAIAIgNBASACdCICcQRAIAEoAggMAQtB3LvAACACIANyNgIAIAELIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIC+UDAQN/IwBB0CJrIgMkACADQcAWaiIEQcitwAAQSSADQcgcaiIFQYCuwAAQSSADQQhqIAQgBRBLIANBiAFqQTgQ0AEaIANBwAFqQTgQ0AEaIANB+AFqED0CQCACEIYBBEAgABBVDAELIANB+ARqIgQQPSAEIAEQfSAEEEcgA0H4B2oiARBnIAEgAhB4IAEQRiADQcgcaiICIAEQkAEgA0G4CWogAhCQASACIANBuAhqEJABIANB+AlqIAIQkAEgA0G4CmoiARA9IANBuA1qEFUgASAEEH0gA0HAE2oiARA9IAEgBBB9IAEQogEgA0HAAWogA0GIAWoQUEECayECA0AgAkEBakEBTQRAIANBuA1qIgEQngEgACABQYgGENEBGgUgA0G4DWoQGiADQcAWaiADQbgKaiADQbgJaiADQfgJahALAkACQAJAIANBwAFqIAIQUyADQYgBaiACEFNrQQFqDgMBAgACCyADQcgcaiIBIANBuApqIANB+ARqIANBuAlqIANB+AlqEAogA0HAFmogARADDAELIANByBxqIgEgA0G4CmogA0HAE2ogA0G4CWogA0H4CWoQCiADQcAWaiABEAMLIAJBAWshAiADQbgNaiADQcAWahABDAELCwsgA0HQImokAAvBAwEVfwNAIANBwAFGBEACQCAAQShqIQsgAEEUaigCACIMIQggAEEQaigCACINIQIgAEEMaigCACIOIQEgACgCCCIPIQMgAEEYaigCACIQIQogAEEcaigCACIRIQQgAEEgaigCACISIQcgAEEkaigCACITIQYDQCAHIQkgBCEHIAohBCAFQYACRg0BIAEgAnEhFCABIAJzIRUgBSALaigCACAFQcCiwABqKAIAIAkgBEF/c3EgBCAHcXIgBmogBEEadyAEQRV3cyAEQQd3c2pqaiIGIAhqIQogBUEEaiEFIAIhCCABIQIgAyIBQR53IAFBE3dzIAFBCndzIBQgASAVcXNqIAZqIQMgCSEGDAALAAsFIAAgA2oiAkHoAGogAkEoaigCACACQcwAaigCACACQeAAaigCACIBQQ93IAFBDXdzIAFBCnZzamogAkEsaigCACIBQRl3IAFBDndzIAFBA3ZzajYCACADQQRqIQMMAQsLIAAgBiATajYCJCAAIAkgEmo2AiAgACAHIBFqNgIcIAAgBCAQajYCGCAAIAggDGo2AhQgACACIA1qNgIQIAAgASAOajYCDCAAIAMgD2o2AggL5AEBAn8jAEGAA2siAyQAIAMQPSAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbyAAIAFBgANqIAJBAXNBAWtBH3YQbyAAIAFBgAZqIAJBAnNBAWtBH3YQbyAAIAFBgAlqIAJBA3NBAWtBH3YQbyAAIAFBgAxqIAJBBHNBAWtBH3YQbyAAIAFBgA9qIAJBBXNBAWtBH3YQbyAAIAFBgBJqIAJBBnNBAWtBH3YQbyAAIAFBgBVqIAJBB3NBAWtBH3YQbyADIAAQfSADEKIBIAAgAyAEQQFxEG8gA0GAA2okAAvlAwEIfyMAQZAGayICJAAgAEFAayEIAkAgAUH4AGooAgAgASgCOGqsIABB+ABqKAIAIgcgACgCOCIEaqx+Qv///w9XDQAgBEEBSgR/IAAQHiAAKAJ4BSAHC0EBTA0AIAgQHgsgAkHYpMAAEEkgAkE4aiIHQfAAENABGiACIQNBACECA0AgAkE4RgRAAkAgB0E4aiEEQQAhAgNAIAJBOEYNASACIARqIAIgA2opAwA3AwAgAkEIaiECDAALAAsFIAIgB2pCADcDACACQQhqIQIMAQsLIANBqAFqIgYgABBdIANB4AFqIgUgARBdIANBmAJqIgIgACABEAUgA0GIA2oiBCAIIAFBQGsiARAFIAYgCBBgIAYQQiAFIAEQYCAFEEIgA0H4A2oiCSAGIAUQBUEAIQEgA0HoBGoiBkHwABDQASEFA0AgAUHwAEcEQCABIAVqIAEgAmopAwA3AwAgAUEIaiEBDAELCyAGIAQQYkEAIQEDQCABQfAARwRAIAEgBGoiBSABIAdqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAiAEEGIgAhBIIAkgBhBjIAkQSCADQdgFaiIBIAIQayAAIAEQaiAAQQM2AjggASAJEGsgCCABEGogAEECNgJ4IANBkAZqJAALowIBCH8jAEGABmsiAiQAIAIgAEGAAWoiBxBeIAJBgAFqIgQgBxBeIAQQLSACQYACaiIFIAIQXiAFIABBgAJqIgMQESACQYADaiIBIAMQXiABEC0gAyAEEJkBIAMgBBCaASADEKkBIAMQuAEgAxC4ASADEKkBIAFBDBCrASABEHwgARCpASACQYAEaiIIIAEQXiAIIAMQESACQYAFaiIGIAQQXiAGIAEQmgEgBhCpASADIAUQESAFIAEQmQEgBSABEJoBIAEgBRCaASABEKkBIAQgARB7IAQQqQEgBiAEEBEgBiAIEJoBIAUgABCZASAFIAIQESAAIAQQmQEgABCpASAAIAUQESAAELgBIAAQqQEgByAGEJkBIAcQqQEgAkGABmokAAu8AgEGfyMAQYAIayIBJAAgASAAEIwBIAFBgAJqIgMgAEGABGoiBRCMASABQYAEaiIEIABBgAJqIgYQjAEgAUGABmoiAkE4ENABGiABQQE2ArgGIAFBwAZqQTgQ0AEaIAFB+AZqQQE2AgAgAUGAB2pBOBDQARogAUG4B2pBATYCACABQcAHakE4ENABGiABQfgHakEBNgIAIAAQISACIAAQlgEgAiAAEJcBIAAgAhCXASAAELABIAEQyQEgARCzASAAIAEQlwEgAxAhIAMQZCACIAMQlgEgAiADEJcBIAMgAhCXASADELABIAQQISACIAQQlgEgAiAEEJcBIAQgAhCXASAEELABIAYQsgEgBhCzASAFEMkBIAUQswEgBiADEJcBIAUgBBCXASAAQQU2AoAGIAAQnAEgAUGACGokAAv/AQEHfyMAQcACayIBJAAgASAAQUBrIgYQkAEgARBMIAFBQGsiAyAGEJABIAMgAEGAAWoiAhBKIAFBgAFqIgQgAhCQASAEEEwgAiABEK4BIAIgARB3IAIQQiACEIIBIAIQggEgAhBCIARBDBA0IAFBwAFqIgcgBBCQASAHIAIQSiABQYACaiIFIAEQkAEgBSAEEHcgBRBCIAIgAxBKIAMgBBCuASADIAQQdyAEIAMQdyABIAQQfiABEEIgBSABEEogBSAHEHcgAyAAEK4BIAMgBhBKIAAgARCuASAAEEIgACADEEogABCCASAAEEIgBiAFEK4BIAYQQiABQcACaiQAC84CAgd/An4CQAJAAkBBDSABQTpuIgJrIgRBDU0EQEEMIAJrIgNBDk8NASAAIAAgA0EDdGopAwBBOiABIAJBOmxrIgNrrSIKhyAAIARBA3RqKQMAIAOtIgmGhDcDaCAEQQ1rIQUgAEHgAGohBCACQQFqIQZBACACQQN0ayEHQQshAwNAAkAgA0ECaiAGTQRAIAFBrAZPDQEgACACQQN0aiAAKQMAIAmGQv//////////A4M3AwADQCACRQ0HIABCADcDACACQQFrIQIgAEEIaiEADAALAAsgAyAFakEOTw0EIAQgBCAHaiIIQQhrKQMAIAqHIAgpAwAgCYZC//////////8Dg4Q3AwAgA0EBayEDIARBCGshBAwBCwsgAkEOQYCywAAQOwALIARBDkHQscAAEDsACyADQQ5B4LHAABA7AAtBf0EOQfCxwAAQOwALC6cCAQR/IABCADcCECAAAn9BACABQYACSQ0AGkEfIAFB////B0sNABogAUEGIAFBCHZnIgNrdkEBcSADQQF0a0E+agsiBDYCHCAEQQJ0Qey9wABqIQMgACECAkACQAJAAkBB4LvAACgCACIAQQEgBHQiBXEEQCADKAIAIQMgBBCfASEAIAMQywEgAUcNASADIQAMAgtB4LvAACAAIAVyNgIAIAMgAjYCAAwDCyABIAB0IQQDQCADIARBHXZBBHFqQRBqIgUoAgAiAEUNAiAEQQF0IQQgACIDEMsBIAFHDQALCyAAKAIIIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCCACQQA2AhgPCyAFIAI2AgALIAIgAzYCGCACIAI2AgggAiACNgIMC7YCAQV/IAAoAhghBAJAAkAgACAAKAIMRgRAIABBFEEQIABBFGoiASgCACIDG2ooAgAiAg0BQQAhAQwCCyAAKAIIIgIgACgCDCIBNgIMIAEgAjYCCAwBCyABIABBEGogAxshAwNAIAMhBSACIgFBFGoiAygCACICRQRAIAFBEGohAyABKAIQIQILIAINAAsgBUEANgIACwJAIARFDQACQCAAIAAoAhxBAnRB7L3AAGoiAigCAEcEQCAEQRBBFCAEKAIQIABGG2ogATYCACABDQEMAgsgAiABNgIAIAENAEHgu8AAQeC7wAAoAgBBfiAAKAIcd3E2AgAPCyABIAQ2AhggACgCECICBEAgASACNgIQIAIgATYCGAsgAEEUaigCACIARQ0AIAFBFGogADYCACAAIAE2AhgLC+UBAQZ/IwBBgARrIgIkACACIAAQXiACQYABaiIFIABBgAFqIgYQXiACQYACaiIDQTgQ0AEaIAJBATYCuAIgAkHAAmpBOBDQARogAkH4AmpBATYCACACQYADaiIEIAYQXiACIAEQESAFIAFBgAFqIgcQESADIAcQmQEgAyABEJoBIAQgABCaASADEKkBIAQQqQEgBCADEBEgAyACEJkBIAMQNiAEIAMQmgEgBBCpASADIAUQmQEgAxA2IAYgBBCZASAGIAMQmgEgBRB8IAAgBRCZASAAIAIQmgEgABCwASACQYAEaiQAC28BDH9BjL/AACgCACICRQRAQZy/wABB/x82AgBBAA8LQYS/wAAhBgNAIAIiASgCCCECIAEoAgQhAyABKAIAIQQgAUEMaigCABogASEGIAVBAWohBSACDQALQZy/wAAgBUH/HyAFQf8fSxs2AgBBAAuAAgEGfyMAQYAIayIBJAAgACgCgAZBAUcEQCABIAAQjAEgAUGAAmoiAiAAQYACaiIEEIwBIAFBgARqIgUgAEGABGoiAxCMASABQYAGaiIGIAAQjAEgARAhIAIgAxAYIAIQswEgAhCwASAFECEgBiAEEBggBhCzASADIAAQlwEgAyAEEJcBIAMQsAEgAxAhIAAgARCWASABIAIQlwEgARCwASABIAUQlwEgASAGEJcBIAEQsAEgARArIAIQZCAFEGQgACACEJcBIAQgBRCWASAEIAYQlwEgAyABEJcBIABBBEEFIAAoAoAGQX5xQQJGGzYCgAYgABCdAQsgAUGACGokAAuZAgEBfyMAQYANayIDJAAgAyABEGkgAxCdASADQYgGaiIBIAIQXSABEEIgA0HABmoiAiABEF0gAkEDECkaIAIQQiADQfgGaiADEGkCQCACEFdFBEAgA0HABmoQKkECayECA0AgAkEBakEBTQRAIANB+AZqIgEQnAEMAwUgA0H4BmoQEwJAAkACQCADQcAGaiACEFMgA0GIBmogAhBTa0EBag4DAQIAAgsgA0H4BmogAxAHDAELIAMQngEgA0H4BmogAxAHIAMQngELIAJBAWshAgwBCwALAAsgA0H4BmoiARC3ASABQYABahC2ASABQYACahCxASABQYAEahCxASABQQE2AoAGCyAAIAFBiAYQ0QEaIANBgA1qJAALhgICBH8BfiMAQTBrIgIkACABQQRqIQQgASgCBEUEQCABKAIAIQMgAkEQaiIFQQA2AgAgAkIBNwMIIAIgAkEIajYCFCACQShqIANBEGopAgA3AwAgAkEgaiADQQhqKQIANwMAIAIgAykCADcDGCACQRRqIAJBGGoQDBogBEEIaiAFKAIANgIAIAQgAikDCDcCAAsgAkEgaiIDIARBCGooAgA2AgAgAUEMakEANgIAIAQpAgAhBiABQgE3AgQgAiAGNwMYQQxBBBC5ASIBRQRAQQxBBBDPAQALIAEgAikDGDcCACABQQhqIAMoAgA2AgAgAEGEt8AANgIEIAAgATYCACACQTBqJAAL5AEBAn8jAEHAAWsiAyQAIAMQZyAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbiAAIAFBwAFqIAJBAXNBAWtBH3YQbiAAIAFBgANqIAJBAnNBAWtBH3YQbiAAIAFBwARqIAJBA3NBAWtBH3YQbiAAIAFBgAZqIAJBBHNBAWtBH3YQbiAAIAFBwAdqIAJBBXNBAWtBH3YQbiAAIAFBgAlqIAJBBnNBAWtBH3YQbiAAIAFBwApqIAJBB3NBAWtBH3YQbiADIAAQeCADEKQBIAAgAyAEQQFxEG4gA0HAAWokAAvDAwIGfwN+IwBB8ABrIgEkACABQcCywAAQSSABQThqIAEQXSAAEEICQAJAAkAgAQJ/IAAoAjgiAkEQTARAIAJBAWsQNQwBCyABKQMwIghCAXwiByAIVA0BIAApAzAiCEKAgICAgICAgIB/USAHQn9RcQ0CIAFBOGoiAiAIIAd/pxApIQcgASABKQNoIAdCOoZ8NwNoIAAgAhBhIAAQQkECCyIEECgDQCAERQ0DQQAhAyABIAEpAwgiCEI5hkKAgICAgICAgAKDIAEpAwBCAYeEIgc3AwAgACkDACAHfSEHIABBCGohBSAAIAFBOGoiAkEBA38gAiADaiAHQv//////////A4M3AwAgB0I6hyEHIANBKEYEfyABIAEpAzBCAYciCDcDMCACIAApAzAgCH0gB3wiBzcDMCAHQj+IpwUgASADaiIGQQhqIAhCAYcgBkEQaikDACIIQjmGQoCAgICAgICAAoOEIgk3AwAgAyAFaikDACAHfCAJfSEHIANBCGohAwwBCwtrEDAgBEEBayEEDAALAAtB4LPAAEEZQcSzwAAQWQALQYC0wABBH0HEs8AAEFkACyAAQQE2AjggAUHwAGokAAvuAQECfyMAQbABayIDJAAgA0EwENABIQMCQAJAA0AgAkEwRgRAIANBMGogAxBwIAFBMGohAUEAIQIDQCACQTBGDQMgAkEwRg0EIAIgA2ogASACai0AADoAACACQQFqIQIMAAsACyACQeAARwRAIAIgA2ogASACai0AADoAACACQQFqIQIMAQsLQeAAQeAAQYCmwAAQOwALIANB8ABqIgEgAxBwIABBOBDQASIAQQE2AjggAEFAa0E4ENABIABB+ABqQQE2AgAgACABEK4BIANBMGoQrgEgA0GwAWokAA8LIAJBMGpB4ABBkKbAABA7AAuPAgEDfyMAQSBrIgUkAEEBIQZB2LvAAEHYu8AAKAIAIgdBAWo2AgACQEGgv8AALQAABEBBpL/AACgCAEEBaiEGDAELQaC/wABBAToAAAtBpL/AACAGNgIAAkACQCAHQQBIIAZBAktyDQAgBSAEOgAYIAUgAzYCFCAFIAI2AhBBzLvAACgCACICQQBIDQBBzLvAACACQQFqIgI2AgBBzLvAAEHUu8AAKAIAIgMEf0HQu8AAKAIAIAUgACABKAIQEQAAIAUgBSkDADcDCCAFQQhqIAMoAhQRAABBzLvAACgCAAUgAgtBAWs2AgAgBkEBSw0AIAQNAQsACyMAQRBrIgIkACACIAE2AgwgAiAANgIIAAucAQEEfyMAQYADayICJAAgAiAAEF4gAkGAAWoiASAAQYABaiIEEF4gAkGAAmoiAyAAEF4gAyAEEBEgAiAEEJoBIAEQfCABIAAQmgEgAhCpASABEKkBIAAgAhCZASAAIAEQESABIAMQmQEgARB8IAEgAxCaASABEKkBIAEQNiAAIAEQmgEgAxC4ASAEIAMQmQEgABCwASACQYADaiQAC7kBAQJ/IwBBIGsiAyQAAkAgASABIAJqIgFLDQAgAEEEaigCACICQQF0IgQgASABIARJGyIBQQggAUEISxshAQJAIAIEQCADQRhqQQE2AgAgAyACNgIUIAMgACgCADYCEAwBCyADQQA2AhALIAMgASADQRBqECYgAygCAARAIANBCGooAgAiAEUNASADKAIEIAAQzwEACyADKAIEIQIgAEEEaiABNgIAIAAgAjYCACADQSBqJAAPCxBlAAusAQECfyMAQYADayIDJAAgA0EIaiABEJABAkAgAgRAIANBCGogAhCuAQwBCyADQQhqEDoLIANByABqIgJB8LTAABBJIANBgAFqIAIQjgEgA0HAAWoiAiADQQhqIgQQkAEgAhBMIAIgARBKIAAgARCQASAAIAQQSiADQYACaiACEJABIAAQViEBIANBwAJqIgIgABCQASACEEMgAhBCIAAgAiABEHIgA0GAA2okAAueAQEFfyMAQYABayICJAAgAkE4ENABIgJBATYCOCACQUBrIgNBOBDQARogAkEBNgJ4IAIgABCuASACIAFBgAFqIgUQSiADIAEQrgEgAyAAQYABaiIGEEoCQCACIAMQWEUNACACIABBQGsQrgEgAiAFEEogAkFAayIAIAFBQGsQrgEgACAGEEogAiAAEFhFDQBBASEECyACQYABaiQAIAQLpwEBA38jAEEwayICJAAgAUEEaiEDIAEoAgRFBEAgASgCACEBIAJBEGoiBEEANgIAIAJCATcDCCACIAJBCGo2AhQgAkEoaiABQRBqKQIANwMAIAJBIGogAUEIaikCADcDACACIAEpAgA3AxggAkEUaiACQRhqEAwaIANBCGogBCgCADYCACADIAIpAwg3AgALIABBhLfAADYCBCAAIAM2AgAgAkEwaiQAC5UBAQJ/AkACQAJAAkACfwJAAkACf0EBIgMgAUEASA0AGiACKAIAIgRFDQEgAigCBCICDQQgAQ0CQQEMAwshA0EAIQEMBgsgAQ0AQQEMAQsgAUEBELkBCyICRQ0BDAILIAQgARCsASICDQELIAAgATYCBEEBIQEMAQsgACACNgIEQQAhAwsgACADNgIAIABBCGogATYCAAvvMwISfwV+IwBBMGsiDiQAIA5BEGogACABEFsgDiAOKAIUIgA2AhwgDiAOKAIQIgg2AhggDkEIaiACIAMQWyAOIA4oAgwiATYCJCAOIA4oAggiAzYCICAOIAQgBRBbIA4gDigCBCIFNgIsIA4gDigCACINNgIoIAAhBCMAQZAVayICJAAjAEGwBmsiCiQAIApBEGpBOBDQARogCkHQAGpBOBDQASEVIApBiAFqQQE2AgAgCkEBNgJIIApBkAFqIgBB2KTAABBJIAAQKiEPIApByAFqIhNBgAIQ0AEaIApByANqQYABENABGiMAQdAAayIRJAAgEUEQakHAABDQARogASEJQQAhACMAQYAEayIHJAAgB0EvakGBAhDQARogB0GwAmpBwAAQ0AEaIAdB8AJqQcAAENABGiAHQbADakHAABDQARogByAPQf8AakEDdkEBaiISQQF0IgFBCHQgAUGA/gNxQQh2cjsALCABQQFrQQV2QQFqIQsCQANAIAYgB2pBLmogADoAACAGQStGBEAgB0EsaiIGQS5qQSs6AAAgB0EgaiAGQS8QX0EAIQAgB0GwAmpBwAAgAyAJIAcoAiAgBygCJBAGIAdBADoA+AMgByALNgL0A0EAIAFrIRQgB0EBNgLwAyAGQSxqIRYMAgsgBkGBAkcEQCAGQcClwABqLQAAIQAgBkEBaiEGDAELCyAGQQNqQYQCQfCrwAAQOwALA0ACQCAHQRhqIQlBACEGQQAhCwJAIAdB8ANqIgMtAAgNACADKAIAIgsgAygCBCIXSw0AIAsgF08EQEEBIQYgA0EBOgAIDAELQQEhBiADIAtBAWo2AgALIAkgCzYCBCAJIAY2AgACQCAHKAIYBEAgBygCHCEDQQAhBgNAIAZBIEYEQCAHIAM6ACxBACEGAkACQANAIAZBK0YEQCAWQSs6AAAjAEEQayIDJAAgA0EIaiAHQbADakHAAEEgEIEBIAMoAgwhCSAHQRBqIgYgAygCCDYCACAGIAk2AgQgA0EQaiQAIAcoAhQhAyAHKAIQIQkgB0EIaiAHQSxqQS0QX0EAIQYgB0HwAmpBACAJIAMgBygCCCAHKAIMEAZBAEGAAiAAayIDIANBgAJLGyEDIAAgE2ohCSAAIBRqIQsDQCAGQSBGDQggBkHAAEYNBCADIAZGDQMgBiAJaiAHQfACaiAGai0AADoAACAGQQFqIgYgC2oNAAsgASEADAkLIAZBgwJHBEAgBiAHakEtaiAGQcClwABqLQAAOgAAIAZBAWohBgwBCwsgBkEBakGEAkGwrMAAEDsACyAAIAZqQYACQYCtwAAQOwALQcAAQcAAQfCswAAQOwALIAZBwABHBEAgB0HwAmogBmoiCSAJLQAAIAdBsAJqIAZqLQAAcyIJOgAAIAdBsANqIAZqIAk6AAAgBkEBaiEGDAELC0HAAEHAAEGgrMAAEDsACyAHQYAEaiQADAELIAAgBmohAAwBCwsgEUHQAGokACASQQN0IA9rIQlBACEAAkACQANAIABBAkcEQCAAQQFqIApByAFqIBBqIQZBACEDAkADQCADIBJGDQEgAyAQaiIHQf8BSw0EIANBgAFHBEAgCkHIA2ogA2ogAyAGai0AADoAACADQQFqIQMMAQsLQYABQYABQaClwAAQOwALIwBBEGsiAyQAIANBCGogCkHIA2pBgAEgEhCBASADKAIMIQYgCkEIaiIHIAMoAgg2AgAgByAGNgIEIANBEGokACAKKAIIIQMgCigCDCELIApBwAVqIg9B8AAQ0AEhBgNAIAsEQCAGQQgQFSAGIAYpAwAgAzEAAHw3AwAgC0EBayELIANBAWohAwwBCwsgCkGIBWohEyMAQeABayILJAAgDxBIIAsgCkGQAWoQLiALQfAAakHwABDQARogCyAJIgMQFQNAIAtB8ABqIQZBACEHA0AgB0HwAEcEQCAGIAdqIAcgD2opAwA3AwAgB0EIaiEHDAELCyAGIAsQYyAGEEhBACEHQgAhGCAGKQMIIA8pAwCFIhlCAYZCAYchG0F/IAspA9gBQj+Hp2usIRwDfiAHQfAARgR+IBgFIAcgD2oiESARKQMAIhogGYUgBiAHaikDACAahSAcg4UiGiAbhTcDACAYIBqFIRggB0EIaiEHDAELCxogAwRAQQAhBkEAIQdBACERAkACQANAIAZB6ABGBEAgC0HoAGogCykDaEIBhzcDACALQfAAaiEGA0AgB0UNBCAGQgA3AwAgB0EBayEHIAZBCGohBgwACwALIAZB8ABGDQEgBkHwAEcEQCAGIAtqIhQgFEEIaikDAEI5hkL//////////wODIBQpAwBCAYeENwMAIBFBAWohESAGQQhqIQYMAQsLQQ5BDkGgssAAEDsACyARQQ5BkLLAABA7AAsgA0EBayEDDAEFIBMgDxBdIAtB4AFqJAALCyAKQcgEaiIDIBMQjgEgCkEQaiAAQQZ0aiADQcAAENEBGiAQIBJqIRAhAAwBCwsgAiAKQRBqEAIgCkHIAWoiACAVEAIgAiAAEAkjAEGAAmsiACQAIABBCGoiAUHYgcAAEEkgAEFAayIDIAIgARC9ASACIAMQeCAAQYACaiQAIAIQRiAKQbAGaiQADAELIAdBgAJBkKXAABA7AAsgAkHAAWohASMAQeACayIAJAAgAEEwENABIgBBMGpB0IDAABBJAkACQAJAAkADQAJAIAxBMEYEQCAAIAAtAABBH3E6AAAgAEHoAGogABC+ASAEDQFBAEEAQZiBwAAQOwALIAQgDEYNAiAAIAxqIAggDGotAAA6AAAgDEEBaiEMDAELC0EAIQwgCCwAACIJQQBIDQIgCEEwaiEDIARBMCAEQTBLG0EwayEIA0AgDEEwRgRAIABBoAFqIgQgABC+ASMAQYABayIDJAAgARBnIAEgAEHoAGoQwAEgAUFAayIIIAQQwAEgAUGAAWoQygEgARBCIAMgARBPIANBQGsiBCAIEJABIAQQTCAEIAMQWEUEQCABEJIBCyADQYABaiQADAULIAggDEYNAiAAIAxqIAMgDGotAAA6AAAgDEEBaiEMDAALAAsgBCAEQYiBwAAQOwALIAxBMGogBEGogcAAEDsACyMAQcABayIDJAAgAEGgAWoiBBBnIANBOBDQASIDQQE2AjggBCAAQegAahDAASAEEEIgBEGAAWoQygEgA0FAayIIIAQQTwJAAkACQCAIIAMQWkEBRgRAIANBgAFqIgggA0FAayADECMgCBBWDQEMAgsgBBCSAQwCCyADQYABaiIIEEMgCBBCCyAEQUBrIANBgAFqEK4BCyADQcABaiQAIAlBIHEiA0EAIABB4AFqEE0iBEEBRxtBASADIARBAUdyGwRAIABBoAFqEKQBCyABIABBoAFqQcABENEBGgsgAEHgAmokAAJ/QQAhAyMAQcAFayIAJAACQCABEIYBDQAgAEEIaiIIQZCtwAAQSSAAQYAEaiIEQbiuwAAQSSAAQUBrIgkgBBCOASAAQYABaiIEEGcgBCABEHggBCAJEEogAEHAAmoiBCABIAgQvQEgASAEECQNACAAQYAEaiIEIABBwAJqIgEgAEEIahC9ASABIARBwAEQ0QEaIAEQpAEgAEGAAWogARAkRQ0AQQEhAwsgAEHABWokAEF/IANFDQAaIAJBwAFqEKQBIAJBgANqIQhBACEAIwBB4ARrIgEkACABQeAAENABIQECQCAFBEADQCAAQeAARgRAIAEgAS0AAEEfcToAACABQeAAaiABEB9BACEAAkAgDSwAACILQQBOBEAgDUHgAGohAyAFQeAAIAVB4ABLG0HgAGshBANAIABB4ABGBEAgAUHgAWoiACABEB8gCCABQeAAaiAAED8MAwsgACAERwRA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AWoQmQEgACAEEBEgAEGAAWoiASAFQYABahCZASABIAgQESAAIAEQeg0BC0EADAELQQELIQEgAEGAAmokACANQcAHaiQAQX8gAUUNABojAEHgA2siACQAIABBgAFqIgFBwKjAABBJIABBuAFqIgNB+KjAABBJIAAgASADEEsgAEHwAmoiAUGwqcAAEEkgAEGoA2oiA0HoqcAAEEkgAEHwAWoiBCABIAMQSyACQYAGaiIBIAAgBBA/IABB4ANqJAAgAkGACWohByACQYADaiEIIwBBkDRrIgAkACAAQYAoaiIDQcitwAAQSSAAQYguaiIEQYCuwAAQSSAAIAMgBBBLIABBgAFqQTgQ0AEaIABBuAFqQTgQ0AEaIABB8AFqED0CQCACQcABaiIEEIYBRQRAIAIQhgEEQCAHIAEgBBAODAILIABB8ARqIgMQPSADIAEQfSADEEcgAEHwB2oiBRBnIAUgBBB4IAUQRiAAQbAJaiIEED0gBCAIEH0gBBBHIABBsAxqIggQZyAIIAIQeCAIEEYgAEGILmoiASAFEJABIABB8A1qIAEQkAEgASAAQbAIahCQASAAQbAOaiABEJABIAEgCBCQASAAQfAOaiABEJABIAEgAEHwDGoQkAEgAEGwD2ogARCQASAAQfAPaiIBED0gAEHwEmoiBRA9IABB8BVqEFUgASADEH0gBSAEEH0gAEH4G2oiARA9IAEgAxB9IAEQogEgAEH4HmoiARA9IAEgBBB9IAEQogEgAEG4AWogAEGAAWoQUEECayEBA0AgAUEBakEBTQRAIABB8BVqIgEQngEgByABQYgGENEBGgwDBSAAQfAVaiIEEBogAEH4IWoiAyAAQfAPaiAAQfANaiAAQbAOahALIABBgChqIgUgAEHwEmogAEHwDmogAEGwD2oQCyADIAUQAyAEIAMQAQJAAkACQCAAQbgBaiABEFMgAEGAAWogARBTa0EBag4DAQIAAgsgAEGILmoiAyAAQfAPaiAAQfAEaiAAQfANaiAAQbAOahAKIABB+CFqIgQgA0GIBhDRARogAyAAQfASaiAAQbAJaiAAQfAOaiAAQbAPahAKIAQgAxADIABB8BVqIAQQAQwBCyAAQYguaiIDIABB8A9qIABB+BtqIABB8A1qIABBsA5qEAogAEH4IWoiBCADQYgGENEBGiADIABB8BJqIABB+B5qIABB8A5qIABBsA9qEAogBCADEAMgAEHwFWogBBABCyABQQFrIQEMAQsACwALIAcgCCACEA4LIABBkDRqJAAjAEHgH2siCCQAIAhB0BNqIgFByK3AABBJIAhB2BlqIg1BgK7AABBJIAggASANEEsgCEGAAWoiC0GQrcAAEEkgAkGID2oiACAHEGkgCEG4AWoiBSAAEGkjAEGACGsiAyQAIAMgBRCMASADQYACaiIJIAVBgAJqIg8QjAEgA0GABGoiCiAFEIwBIANBgAZqIgRBOBDQARogA0EBNgK4BiADQcAGakE4ENABGiADQfgGakEBNgIAIANBgAdqQTgQ0AEaIANBuAdqQQE2AgAgA0HAB2pBOBDQARogA0H4B2pBATYCACAFEJ0BIAMQISAJIAVBgARqIgwQGCAJEGQgAyAJEHkgAxCwASAJIAwQlgEgCRAhIAkQZCAKIA8QGCAJIAoQeSAJELABIAogDxCWASAKECEgBCAFEJYBIAQgDBAYIAogBBB5IAoQsAEgBCAPEJYBIAQgChAYIAQQZCAFIAMQGCAEIAUQlwEgDCAJEBggDBBkIAQgDBCXASAEELABIwBBgAJrIgYkACAGIAQQXiAGQYABaiIQIARBgAFqIhIQXiAGEC0gEBAtIBAQfCAQEKkBIAYgEBB7IAYQPiAEIAYQESAGEDYgBhCpASASIAYQESAGQYACaiQAIAUgAxCWASAFIAQQGCAPIAkQlgEgDyAEEBggDCAKEJYBIAwgBBAYIAVBBTYCgAYgA0GACGokACAAEJ4BIAAgBRAHIAUgABBtIAAgCBAyIAAgCBAyIAAgBRAHIAhBwAdqIgQgABBpIAQQEyAEIAAQByANIAAgCxAbIAhByA1qIgMgDRBpIAMQngEgASAAEGkgARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gASAIEDIgACADEG0gACABEAcgDSAAIAsQGyADIA0QbSANIAMgCxAbIAMgDRBtIAEgABBtIAEgCBAyIAEgCBAyIAMgARAHIAEgABBtIAEQngEgACADEG0gACABEAcgACAEEAcgABCcASAIQeAfaiQAIAcgAEGIBhDRARpBACEAIwBBgAJrIgEkACABEGwCQCAHIAEQegR/IAdBgAFqIAFBgAFqEHoFQQALRQ0AIAdBgAJqEIcBRQ0AIAdBgARqEIcBIQALIAFBgAJqJABBACAADQAaQX8LIAJBkBVqJAAgDkEoahC0ASAOQSBqELQBIA5BGGoQtAEgDkEwaiQAC58BAgJ/BX4gAEEwaiICKQMAIAFBP3GtIgSGIQUgACkDKCIGQTogAWtBP3GtIgiHIQdBBiEBA38gAiAFIAeENwMAIAFBAU0EfyAAIAApAwAgBIZC//////////8DgzcDACAAKQMwQiSHpwUgAUEBayEBIAJBEGsiA0EIaiECIAYgBIZC//////////8DgyEHIAMpAwAiBiAIhyEFDAELCxoLiAECA34DfyMAQRBrIgUkAAN+IAZBOEYEfiAFQRBqJAAgAwUgBSAAIAZqIgcpAwAiAiACQj+HIAGsIgIgAkI/hxAvIAcgBSkDACIEIAN8IgJC//////////8DgzcDACACIARUrSAFQQhqKQMAIANCP4d8fEIGhiACQjqIhCEDIAZBCGohBgwBCwsLigECA38BfiMAQUBqIgIkACACQQhqIgEgABBdIAEQQiACQThqIQFBBiEDQdwCIQACQAJAA0AgA0EATgRAIAEpAwAiBEIAUg0CIAFBCGshASAAQTprIQAgA0EBayEDDAELC0EAIQAMAQsDQCAEUA0BIABBAWohACAEQgJ/IQQMAAsACyACQUBrJAAgAAuHAQEDfyMAQYACayIBJAAgABCwASABIAAQXiABQYABaiICQTgQ0AEaIAFBATYCuAEgAUHAAWpBOBDQARogAUH4AWpBATYCACABIABBgAFqIgMQmgEgARA2IAIgARCZASACIAMQmgEgAyABEJkBIAMgABCaASAAIAIQmQEgABCwASABQYACaiQAC30CBH4BfyABQT9xrSECQTogAWtBP3GtIQRBACEBIAApAwAiBSEDA38gAUEwRgR/IAAgACkDMCAChzcDMCAFQn8gAoZCf4WDpwUgACABaiIGIAMgAocgBkEIaikDACIDIASGQv//////////A4OENwMAIAFBCGohAQwBCwsaC2kBBH8jAEHAAWsiASQAIAEgABCQASABQUBrIgIgABCQASABQYABaiIDIABBQGsiBBCQASABIAQQdyACIAAQdyACEEIgBCACEEogAxBDIAAgAxB3IAEQQiAAEEIgACABEEogAUHAAWokAAuCAQIBfwF+IABB8AAQ0AEhAANAIAJBOEYEQAJAIAAgASkDMCIDQjqHNwM4IAAgA0L//////////wODNwMwIABBQGshAEEAIQIDQCACQTBGDQEgACACakIANwMAIAJBCGohAgwACwALBSAAIAJqIAEgAmopAwA3AwAgAkEIaiECDAELCwtuAQZ+IAAgA0L/////D4MiBSABQv////8PgyIGfiIHIAUgAUIgiCIIfiIJIAYgA0IgiCIGfnwiBUIghnwiCjcDACAAIAcgClatIAYgCH4gBSAJVK1CIIYgBUIgiIR8fCABIAR+IAIgA358fDcDCAtqAgF/BX4gASkDCCAAKQMAhSIGQgGGQgGHIQdBACACa6whCAN+IANBOEYEfiAFBSAAIANqIgIgAikDACIEIAaFIAEgA2opAwAgBIUgCIOFIgQgB4U3AwAgBCAFhSEFIANBCGohAwwBCwsaC18CAX8EfkIBIQNBMCECA38gAkF4RgR/IARCAYYgA3ynQQFrBSABIAJqKQMAIgUgACACaikDACIGfUI6hyADgyAEhCEEIAJBCGshAiAFIAaFQgF9QjqHIAODIQMMAQsLC2kBBH8jAEGAAmsiAiQAIAIgARBeIAJBgAFqIgMgARBeIAIQLSADIAIQESAAIAMQmAEgAEGAAmoiBCADEJgBIABBgARqIgUgAxCYASAEIAEQpgEgBSACEKYBIABBBTYCgAYgAkGAAmokAAtiAQJ/IwBBQGoiAiQAIAAQQiACIAAQkAECQCABBEAgACABEK4BDAELIAAQOgtBACEBA0AgA0UEQCAAEExBASABQQFqIAFBAUYiAxshAQwBCwsgACACEEogABAeIAJBQGskAAtnAQJ/IwBBQGoiAyQAAkAgASABQR91IgJqIAJzIgIgACgCOGxBgICAEE4EQCADIAIQOSAAIAMQSgwBCyAAIAIQKRogACAAKAI4IAJsNgI4CyABQQBIBEAgABBDIAAQQgsgA0FAayQAC2cAIABBAXYgAHIiAEECdiAAciIAQQR2IAByIgBBCHYgAHIiAEEQdiAAciIAIABBAXZB1arVqgVxayIAQQJ2QbPmzJkDcSAAQbPmzJkDcWoiAEEEdiAAakGPnrz4AHFBgYKECGxBGHYLYQEDfyMAQYABayIBJAAgASAAEJABIAFBQGsiAkE4ENABGiABQQE2AnggASAAQUBrIgMQdyABEEMgAiABEK4BIAIgAxB3IAMgARCuASADIAAQdyAAIAIQrgEgAUGAAWokAAtVAgJ/AX4jAEHwAGsiASQAIAFBwLLAABBJIAApAwAhAyABQThqIgIgABBdIABBARAsIAIgARBgIAIQQiACQQEQLCAAIAIgA0ICgacQMCABQfAAaiQAC5gBAQZ/IwBBwAFrIgMkACAAIAEQXiAAEC0gA0GIAWoiBkHop8AAEEkjAEFAaiIEJAAgA0EIaiICQTgQ0AEiBUEBNgI4IAVBQGtBOBDQASAFQfgAakEBNgIAIAQgBhCOASAFIAQQrgEQwQEgBEFAayQAIAIQqQEgAhB8IAIQqQEgACABEBEgACACEJoBIAAQtQEgA0HAAWokAAtZAQJ/IwBBQGoiAyQAIABBOBDQASIAQQE2AjgCQCABQQBOBEAgACABEJMBDAELIANBCGoiAkHAssAAEEkgAiABEJMBIAIQQiAAIAIQagsgABBUIANBQGskAAu9CAEKfyMAQYABayIHJAAgB0EIaiIDQcCywAAQSSADQQEQlAECQAJAA0AgAUEwRgRAIANBMGogAykDMEIBhzcDACADQThqIQEDQCACRQ0EIAFCADcDACACQQFrIQIgAUEIaiEBDAALAAsgAUE4Rg0BIAFBOEcEQCABIANqIAEgA2oiBEEIaikDAEI5hkL//////////wODIAQpAwBCAYeENwMAIAVBAWohBSABQQhqIQEMAQsLQQdBB0GEm8AAEDsACyAFQQdB9JrAABA7AAsgA0EBEJQBIANBARAsIAdBQGshBUEAIQIjAEGgCmsiASQAIAFBOBDQASIBQUBrQTgQ0AEhBiABQYABakE4ENABGiABQcABakE4ENABGiABQYACakE4ENABGiABQcACakE4ENABGiABQYADakE4ENABGiABQcADakE4ENABGiABQYAEakE4ENABGiABQcAEakE4ENABGiABQYAFakE4ENABGiABQcAFakE4ENABGiABQYAGakE4ENABGiABQcAGakE4ENABGiABQYAHakE4ENABGiABQcAHakE4ENABGiABQfgHakEBNgIAIAFBuAdqQQE2AgAgAUH4BmpBATYCACABQbgGakEBNgIAIAFB+AVqQQE2AgAgAUG4BWpBATYCACABQfgEakEBNgIAIAFBuARqQQE2AgAgAUH4A2pBATYCACABQbgDakEBNgIAIAFB+AJqQQE2AgAgAUG4AmpBATYCACABQfgBakEBNgIAIAFBuAFqQQE2AgAgAUH4AGpBATYCACABQQE2AjggAUGBCGpB5wAQ0AEaIAFB6AhqIgQgABCQASAEEEIgAUGoCWoiBCADEF0gBBBCIAQQKkEDaiIIQQJ2IgNBAWohCQJAA0AgAiAJRgRAIAEQygEgBiABQegIahCuASABQeAJakE4ENABGiABQQE2ApgKQYB5IQIMAgsgAUGoCWoiBCAEQQQQjwEiChCUASAEEEIgAkHnAEcEQCABQYEIaiACaiAKOgAAIAFBqAlqQQQQLCACQQFqIQIMAQsLQecAQecAQaC0wAAQOwALA0AgAgRAIAFB4AlqIgQgASACaiIGQcAHahCuASAGQYAIaiIGIAQQrgEgBiABQegIahBKIAJBQGshAgwBCwsCQAJAAkACQCAIQZwDSQRAIAFBgQhqIANqLAAAIgJBEE8NASAFIAEgAkEGdGoQkAEgA0EBayICQeYASyEEA0AgAkF/Rg0DIAUQTCAFEEwgBRBMIAUQTCAEDQQgAUGBCGogAmotAAAiA0EQSQRAIAUgASADQQZ0ahBKIAJBAWshAgwBCwsgA0EYdEEYdUEQQeC0wAAQOwALIANB5wBBsLTAABA7AAsgAkEQQcC0wAAQOwALIAUQHiABQaAKaiQADAELIAJB5wBB0LTAABA7AAsgACAFEK4BIAdBgAFqJAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQE2AgAgA0ICNwIMIANB2LjAADYCCCADQQE2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEGYAC2UBAn8gACAAKAIAIgJBCGoiAzYCACAAIAJBA3ZBPHFqQShqIgIgAUH/AXEgAigCAEEIdHI2AgACQAJAIANFBEAgAEEANgIAIAAgACgCBEEBajYCBAwBCyADQf8DcQ0BCyAAEA8LC1wAIABBOBDQASIAQQE2AjggAEFAa0E4ENABGiAAQfgAakEBNgIAIABBgAFqEFEgAEGAAmpBOBDQARogAEG4AmpBATYCACAAQcACakE4ENABGiAAQfgCakEBNgIAC1sBA38jAEGAAWsiASQAIAAQqQEgASAAEJABIAFBQGsiAiAAQUBrIgMQkAEgARBMIAIQTCABIAIQdyABQQAQMyAAIAEQSiABEEMgARBCIAMgARBKIAFBgAFqJAALYQEBfyMAQYACayIDJAAgABA9IAAgARCZASAAQYABaiIBIAIQmQEgAEGAAmoQtwEgABCpASADIAAQOCADQYABaiICIAEQXiACEC0gAiADEHpFBEAgABCbAQsgA0GAAmokAAtUAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqIAJBCGoQDCACQSBqJAALZwAjAEEwayIBJABBpLvAAC0AAARAIAFBHGpBATYCACABQgI3AgwgAUGQtsAANgIIIAFBATYCJCABIAA2AiwgASABQSBqNgIYIAEgAUEsajYCICABQQhqQbi2wAAQZgALIAFBMGokAAtiAgF+An8gACkDACEBA34gACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkEoRgR+IAAgACkDMCABfCIBNwMwIAFCJIcFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLGgt8AQV/IwBBQGoiAyQAIANBCGoiAkHAssAAEEkgAiAAKAI4QQFrEDUiBBAoA0AgAUE4RwRAIAAgAWoiBSABIAJqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAEEBIARBAWp0IgI2AjggAkH///8PSgRAIAAQHgsgA0FAayQAC3sBAn8gAEEoaiECA0AgAUGAAkYEQCAAQufMp9DW0Ouzu383AgggAEIANwIAIABBIGpCq7OP/JGjs/DbADcCACAAQRhqQv+kuYjFkdqCm383AgAgAEEQakLy5rvjo6f9p6V/NwIABSABIAJqQQA2AgAgAUEEaiEBDAELCwtUACAAQTgQ0AEiAEEBNgI4IABBQGtBOBDQARogAEH4AGpBATYCACAAQYABakE4ENABGiAAQbgBakEBNgIAIABBwAFqQTgQ0AEaIABB+AFqQQE2AgALWAECfyMAQUBqIgEkAAJAIAAQhgENACABQQEQOSAAQYABaiICIAEQWA0AIAJBABAzIAAgAhBKIAAQHiAAQUBrIgAgAhBKIAAQHiACIAEQrgELIAFBQGskAAtZAQJ/IwBBgAFrIgEkAAJAIAAQigENACABEFEgAEGAAmoiAiABEHoNACACED4gACACEBEgABC1ASAAQYABaiIAIAIQESAAELUBIAIgARCZAQsgAUGAAWokAAtbAgF+An8gACkDACEBA0AgACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkHgAEYEQCAAIAApA2ggAXw3A2gFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLC08BAX8gAEE4ENABGgJAA0AgAkEHRwRAIAJBB0YNAiAAIAEpAwA3AwAgAEEIaiEAIAFBCGohASACQQFqIQIMAQsLDwtBB0EHQeSawAAQOwALVAECfyMAQbABayICJAAgATQCOCAANAI4fkL///8PVQRAIAAQHgsgAkEIaiIDIAAgARAFIAJB+ABqIgEgAxBrIAAgARBqIABBAjYCOCACQbABaiQAC1EBAn8jAEFAaiIDJAAgAEE4ENABIgBBATYCOCAAQUBrQTgQ0AEgAEH4AGpBATYCACADIAEQjgEgACADEK4BIAMgAhCOASADEK4BIANBQGskAAvwDAIRfwh+IwBBsAFrIg8kACAANAI4IhIgEn5C////D1YEQCAAEB4LIwBB0AFrIgEkACAPQQhqIgZBCGpB0AAQ0AEaIAFBwAFqIAApAwAiFyAXQj+HIhYgFyAWEC8gBiABKQPAASISQv//////////A4M3AwAgAUHIAWopAwAiFUIGhiASQjqIhCETIBVCOoghGCAAQQhqIgwhDSAAIQlBASEKQQEhBwJAA0AgCkEERgRAIABBGGohCiAAQRBqIQkgAEEoaiEMIAApAzAhF0EHIQUgAUHIAGohCwNAIAVBC0kEQCABQUBrIAVBA3QiCCAAakEwaykDACISIBJCP4cgFyAXQj+HIhYQLyAFQQFqIg1BAXYhByALKQMAIRUgASkDQCESIAkhAiAMIQQgBUEFayIOIQMDQCADIAdJBEAgASACKQMAIhQgFEI/hyAEKQMAIhQgFEI/hxAvIAEpAwAiFCASfCISIBRUrSABQQhqKQMAIBV8fCEVIAJBCGohAiAEQQhrIQQgA0EBaiEDDAELCyAGIAhqIBJCAYYiFCATfCITQv//////////A4M3AwAgAUEwaiAAIA5BA3RqKQMAIhkgGUI/hyAXIBYQLyATIBRU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aikDADcDACACQQhqIQIMAQsLC4QJAg1/Cn4jAEFAaiILJAAgC0EIaiIJQcCywAAQSSMAQZACayICJAAgAEEwENABIQogAkHoAGpB8AAQ0AEaIAJB4AFqQTAQ0AEaIAoQcSACIAEiDCkDACIQQv3/8//P///5AX5C//////////8DgyISNwPYASACQdgAaiASQgAgCSkDACIXIBdCP4ciGBAvIBAgAikDWCIPfCITIA9UrSACQeAAaikDACAQQj+HfHwiEEI6hyABKQMIIg9CP4d8IA8gEEIGhiATQjqIhCITfCIQIBNUrXwhD0EBIQBCACETAkACQANAAkAgAEEHRgRAQQYhB0EAIQhBByEADAELIABBAXYiAUEBaiEGIAggAWshAyABQQN0IgFBCGohBCAHIAFrIQUgAkHIAGogCSAAQQN0Ig1qKQMAIhUgFUI/hyIWIBJCABAvIAJB0ABqKQMAIBAgECATfCIRVq0gDyAUfHx8IBEgAikDSHwiDyARVK18IRAgAEEBaiEBA0AgACAGTQRAIAJB2AFqIA1qIA9C/f/z/8////kBfkL//////////wODIhE3AwAgAkE4aiARQgAgFyAYEC8gAkEoaiARQgAgFSAWEC8gAkHoAGogAEEEdGoiACACQTBqKQMAIhE3AwggACACKQMoIhU3AwAgDyACKQM4IhZ8Ig8gFlStIAJBQGspAwAgEHx8IhBCOocgDCABQQN0aikDACIWQj+HfCAWIBBCBoYgD0I6iIQiD3wiECAPVK18IQ8gEyAVfCITIBVUrSARIBR8fCEUIAdBCGohByAIQQFqIQggASEADAMLIANBB08NAyACQRhqIAQgCWopAwAgBSAJaikDAH0iESARQj+HIAJB2AFqIg4gBWopAwAgBCAOaikDAH0iESARQj+HEC8gAikDGCIRIA98Ig8gEVStIAJBIGopAwAgEHx8IRAgBkEBaiEGIARBCGohBCAFQQhrIQUgA0EBayEDDAALAAsLA0ACQAJAIABBDUcEQCAHIABBAXYiBmshAyAIIAZBA3QiAWshBCABQQhqIQUgDyAUfCAQIBN8Ig8gEFStfCEQIABBAWohAQNAIAZBBUsNAyADQQdPDQIgAkEIaiAFIAlqKQMAIAQgCWpBMGopAwB9IhIgEkI/hyACIARqQYgCaikDACACQdgBaiAFaikDAH0iEiASQj+HEC8gAikDCCISIA98Ig8gElStIAJBEGopAwAgEHx8IRAgBkEBaiEGIARBCGshBCADQQFrIQMgBUEIaiEFDAALAAsgCiAQQv//////////A4M3AzAgAkGQAmokAAwECyADQQdBpJzAABA7AAsgAEEDdCAKakE4ayAPQv//////////A4M3AwAgEEI6hyAMIAFBA3RqKQMAIhJCP4d8IBIgEEIGhiAPQjqIhCIPfCIQIA9UrXwhDyAUIABBBHQgAmpBCGoiAEEIaikDAH0gEyAAKQMAIhJUrX0hFCAIQQhqIQggB0EBaiEHIBMgEn0hEyABIQAMAAsACyADQQdBlJzAABA7AAsgC0FAayQACy4BAX8jAEGAAWsiASQAIAAQRSABEFEgACABEJkBIABBgAFqELYBIAFBgAFqJAALMwAgACABEJYBIABBgAJqIAFBgAJqEJYBIABBgARqIAFBgARqEJYBIAAgASgCgAY2AoAGCygAIAAgASACEHIgAEFAayABQUBrIAIQciAAQYABaiABQYABaiACEHILLQAgACABIAIQjQEgAEGAAWogAUGAAWogAhCNASAAQYACaiABQYACaiACEI0BCycBAn8jAEFAaiICJAAgAkEIaiIDIAEQvgEgACADEI4BIAJBQGskAAsiAQF/A0AgAUE4RwRAIAAgAWpCADcDACABQQhqIQEMAQsLCyUAIAAgASACEDAgAEEAIAJrIAAoAjgiACABKAI4c3EgAHM2AjgLJwAgACAAKAIEQQFxIAFyQQJyNgIEIAAgAWoiACAAKAIEQQFyNgIECyMAA0AgAgRAIAAgAS0AABA8IAJBAWshAiABQQFqIQEMAQsLCywAIAAQiwEgACABEJYBIABBgAJqIAIQlgEgAEGABGogAxCWASAAQQU2AoAGCyMBAX8jAEFAaiIBJAAgASAAEJABIAEQHiABEFcgAUFAayQACykAIAAgARBgIAAgACgCOCABKAI4aiIBNgI4IAFB////D0oEQCAAEB4LCyUAIAAgARCuASAAQUBrIAFBQGsQrgEgAEGAAWogAUGAAWoQrgELKAEBfyMAQYACayICJAAgAiABEIwBIAIQKyAAIAIQlwEgAkGAAmokAAscAQF/IAAgARBYBH8gAEFAayABQUBrEFgFQQALCycBAX8jAEGAAWsiAiQAIAIg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DCELDQALCyAMpyICQeMASwRAIABBAmsiACAGQQlqaiAMpyICIAJB//8DcUHkAG4iAkHkAGxrQf//A3FBAXRB6LjAAGovAAA7AAALAkAgAkEKTwRAIABBAmsiACAGQQlqaiACQQF0Qei4wABqLwAAOwAADAELIABBAWsiACAGQQlqaiACQTBqOgAACwJ/IAZBCWogAGohCEErQYCAxAAgASgCACIDQQFxIgIbIQQgAkEnIABrIglqIQJBlLjAAEEAIANBBHEbIQUCQAJAIAEoAghFBEBBASEAIAEgBCAFEFINAQwCCwJAAkACQAJAIAIgAUEMaigCACIDSQRAIAEtAABBCHENBEEAIQAgAyACayICIQNBASABLQAgIgcgB0EDRhtBA3FBAWsOAgECAwtBASEAIAEgBCAFEFINBAwFC0EAIQMgAiEADAELIAJBAXYhACACQQFqQQF2IQMLIABBAWohACABQRxqKAIAIQcgASgCBCECIAEoAhghCgJAA0AgAEEBayIARQ0BIAogAiAHKAIQEQQARQ0AC0EBDAQLQQEhACACQYCAxABGDQEgASAEIAUQUg0BIAEoAhggCCAJIAEoAhwoAgwRBQANASABKAIcIQQgASgCGCEBQQAhAAJ/A0AgAyAAIANGDQEaIABBAWohACABIAIgBCgCEBEEAEUNAAsgAEEBawsgA0khAAwBCyABKAIEIQcgAUEwNgIEIAEtACAhCkEBIQAgAUEBOgAgIAEgBCAFEFINAEEAIQAgAyACayICIQMCQAJAAkBBASABLQAgIgQgBEEDRhtBA3FBAWsOAgABAgtBACEDIAIhAAwBCyACQQF2IQAgAkEBakEBdiEDCyAAQQFqIQAgAUEcaigCACECIAEoAgQhBCABKAIYIQUCQANAIABBAWsiAEUNASAFIAQgAigCEBEEAEUNAAtBAQwDC0EBIQAgBEGAgMQARg0AIAEoAhggCCAJIAEoAhwoAgwRBQANACABKAIcIQAgASgCGCEFQQAhAgJAA0AgAiADRg0BIAJBAWohAiAFIAQgACgCEBEEAEUNAAtBASEAIAJBAWsgA0kNAQsgASAKOgAgIAEgBzYCBEEADAILIAAMAQsgASgCGCAIIAkgAUEcaigCACgCDBEFAAsgBkEwaiQACwsAIAAQNiAAELABCysCAX8BfkIBIQIDQCAAIAFq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AAANAEHgs8AAC8EHYXR0ZW1wdCB0byBkaXZpZGUgYnkgemVybwAAAAAAAABhdHRlbXB0IHRvIGRpdmlkZSB3aXRoIG92ZXJmbG93ALAZEAASAAAADAIAAA0AAACwGRAAEgAAABgCAAAmAAAAsBkQABIAAAAYAgAAIwAAALAZEAASAAAAHgIAABcAAACwGRAAEgAAAB4CAAAUAAAAqqr//////gHu//9UrP//AupBYg9rDyoBw5z9ShTOEwJLd2TXrEtDAu3pxpKm+V8Cox4RoAEAAAADAAAABAAAAAQAAAAEAAAABQAAAAYAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAoAAOsaEAAVAAAAABsQAA4AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnMgGxAAGAAAAEkBAAAJAAAAbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5yc0gbEAAcAAAARgIAAB8AAABIGxAAHAAAAEcCAAAeAAAABwAAAAwAAAAEAAAACAAAAAMAAAAIAAAABAAAAAkAAAAKAAAAEAAAAAQAAAALAAAADAAAAAMAAAAIAAAABAAAAA0AAAAOAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAA6BsQABEAAADMGxAAHAAAAAUCAAAFAAAAEAAAAAAAAAABAAAAEQAAAGluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAAkHBAAIAAAAEQcEAASAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5yc3JhbmdlIGVuZCBpbmRleCAAAABxHRAAEAAAADAdEAAiAAAAUh0QAB8AAABJAAAABQB7CXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS42MS4wIChmZTViMTNkNjggMjAyMi0wNS0xOCkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4SMC4yLjgxICgwNjJhYTVmNzAp`;
});

// node_modules/@dfinity/agent/lib/esm/vendor/bls/bls.js
function bls_init() {
  let ret2 = wasm2.bls_init();
  return ret2;
}
function bls_verify(sig, m, w) {
  const [ptr0, len0] = passArray8ToWasm0(sig, wasm2.__wbindgen_malloc);
  const [ptr1, len1] = passArray8ToWasm0(m, wasm2.__wbindgen_malloc);
  const [ptr2, len2] = passArray8ToWasm0(w, wasm2.__wbindgen_malloc);
  const ret2 = wasm2.bls_verify(ptr0, len0, ptr1, len1, ptr2, len2);
  return ret2;
}
async function load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
async function init() {
  const imports = {};
  const { instance, module } = await load(wasmBytes, imports);
  wasm2 = instance.exports;
  init.__wbindgen_wasm_module = module;
  return wasm2;
}
var base64Arraybuffer, getUint8Memory0, passArray8ToWasm0, wasm2, wasmBytes, cachegetUint8Memory0, bls_default;
var init_bls = __esm(() => {
  base64Arraybuffer = __toESM(require_base64_arraybuffer(), 1);
  init_wasm();
  getUint8Memory0 = function() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm2.memory.buffer) {
      cachegetUint8Memory0 = new Uint8Array(wasm2.memory.buffer);
    }
    return cachegetUint8Memory0;
  };
  passArray8ToWasm0 = function(arg, malloc) {
    const ptr = malloc(arg.length * 1);
    getUint8Memory0().set(arg, ptr / 1);
    return [ptr, arg.length];
  };
  wasmBytes = base64Arraybuffer.decode(wasmBytesBase64);
  cachegetUint8Memory0 = null;
  bls_default = init;
});

// node_modules/@dfinity/agent/lib/esm/utils/bls.js
async function blsVerify(pk, sig, msg) {
  if (!verify) {
    await bls_default();
    if (bls_init() !== 0) {
      throw new Error("Cannot initialize BLS");
    }
    verify = (pk1, sig1, msg1) => {
      return bls_verify(sig1, msg1, pk1) === 0;
    };
  }
  return verify(pk, sig, msg);
}
var verify;
var init_bls2 = __esm(() => {
  init_bls();
});

// node_modules/@dfinity/agent/lib/esm/certificate.js
async function reconstruct(t2) {
  switch (t2[0]) {
    case 0:
      return hash(domain_sep("ic-hashtree-empty"));
    case 4:
      return t2[1];
    case 3:
      return hash(concat2(domain_sep("ic-hashtree-leaf"), t2[1]));
    case 2:
      return hash(concat2(domain_sep("ic-hashtree-labeled"), t2[1], await reconstruct(t2[2])));
    case 1:
      return hash(concat2(domain_sep("ic-hashtree-fork"), await reconstruct(t2[1]), await reconstruct(t2[2])));
    default:
      throw new Error("unreachable");
  }
}
function lookup_path(path, tree) {
  if (path.length === 0) {
    switch (tree[0]) {
      case 3: {
        return new Uint8Array(tree[1]).buffer;
      }
      default: {
        return;
      }
    }
  }
  const label = typeof path[0] === "string" ? new TextEncoder().encode(path[0]) : path[0];
  const t2 = find_label(label, flatten_forks(tree));
  if (t2) {
    return lookup_path(path.slice(1), t2);
  }
}

class CertificateVerificationError extends AgentError {
  constructor(reason) {
    super(`Invalid certificate: ${reason}`);
  }
}

class Certificate {
  constructor(certificate, _rootKey, _canisterId, _blsVerify) {
    this._rootKey = _rootKey;
    this._canisterId = _canisterId;
    this._blsVerify = _blsVerify;
    this.cert = decode(new Uint8Array(certificate));
  }
  static async create(options) {
    let blsVerify2 = options.blsVerify;
    if (!blsVerify2) {
      blsVerify2 = blsVerify;
    }
    const cert = new Certificate(options.certificate, options.rootKey, options.canisterId, blsVerify2);
    await cert.verify();
    return cert;
  }
  lookup(path) {
    return lookup_path(path, this.cert.tree);
  }
  async verify() {
    const rootHash = await reconstruct(this.cert.tree);
    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);
    const sig = this.cert.signature;
    const key = extractDER(derKey);
    const msg = concat2(domain_sep("ic-state-root"), rootHash);
    let sigVer = false;
    try {
      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));
    } catch (err) {
      sigVer = false;
    }
    if (!sigVer) {
      throw new CertificateVerificationError("Signature verification failed");
    }
  }
  async _checkDelegationAndGetKey(d) {
    if (!d) {
      return this._rootKey;
    }
    const cert = await Certificate.create({
      certificate: d.certificate,
      rootKey: this._rootKey,
      canisterId: this._canisterId
    });
    const rangeLookup = cert.lookup(["subnet", d.subnet_id, "canister_ranges"]);
    if (!rangeLookup) {
      throw new CertificateVerificationError(`Could not find canister ranges for subnet 0x${toHex(d.subnet_id)}`);
    }
    const ranges_arr = decode(rangeLookup);
    const ranges = ranges_arr.map((v) => [
      principal2.Principal.fromUint8Array(v[0]),
      principal2.Principal.fromUint8Array(v[1])
    ]);
    const canisterInRange = ranges.some((r) => r[0].ltEq(this._canisterId) && r[1].gtEq(this._canisterId));
    if (!canisterInRange) {
      throw new CertificateVerificationError(`Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(d.subnet_id)}`);
    }
    const publicKeyLookup = cert.lookup(["subnet", d.subnet_id, "public_key"]);
    if (!publicKeyLookup) {
      throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);
    }
    return publicKeyLookup;
  }
}
var principal2, isBufferEqual, extractDER, domain_sep, flatten_forks, find_label, DER_PREFIX, KEY_LENGTH;
var init_certificate = __esm(() => {
  init_cbor();
  init_errors();
  init_request_id();
  init_buffer();
  principal2 = __toESM(require_cjs(), 1);
  init_bls2();
  isBufferEqual = function(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    const a8 = new Uint8Array(a);
    const b8 = new Uint8Array(b);
    for (let i = 0;i < a8.length; i++) {
      if (a8[i] !== b8[i]) {
        return false;
      }
    }
    return true;
  };
  extractDER = function(buf) {
    const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;
    if (buf.byteLength !== expectedLength) {
      throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);
    }
    const prefix = buf.slice(0, DER_PREFIX.byteLength);
    if (!isBufferEqual(prefix, DER_PREFIX)) {
      throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);
    }
    return buf.slice(DER_PREFIX.byteLength);
  };
  domain_sep = function(s2) {
    const len = new Uint8Array([s2.length]);
    const str = new TextEncoder().encode(s2);
    return concat2(len, str);
  };
  flatten_forks = function(t2) {
    switch (t2[0]) {
      case 0:
        return [];
      case 1:
        return flatten_forks(t2[1]).concat(flatten_forks(t2[2]));
      default:
        return [t2];
    }
  };
  find_label = function(l, trees) {
    if (trees.length === 0) {
      return;
    }
    for (const t2 of trees) {
      if (t2[0] === 2) {
        const p = t2[1];
        if (isBufferEqual(l, p)) {
          return t2[2];
        }
      }
    }
  };
  DER_PREFIX = fromHex("308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100");
  KEY_LENGTH = 96;
});

// node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js
var exports_canisterStatus = {};
__export(exports_canisterStatus, {
  request: () => {
    {
      return request;
    }
  },
  encodePath: () => {
    {
      return encodePath;
    }
  }
});
var candid3, principal3, request, encodePath, decodeHex, decodeLeb128, decodeCbor, decodeUtf8, decodeTime, decodeControllers;
var init_canisterStatus = __esm(() => {
  candid3 = __toESM(require_cjs2(), 1);
  principal3 = __toESM(require_cjs(), 1);
  init_errors();
  init_certificate();
  init_buffer();
  init_cbor();
  request = async (options) => {
    const { canisterId, agent, paths } = options;
    const uniquePaths = [...new Set(paths)];
    const encodedPaths = uniquePaths.map((path) => {
      return encodePath(path, canisterId);
    });
    const status = new Map;
    const promises = uniquePaths.map((path, index) => {
      return (async () => {
        var _a;
        try {
          const response = await agent.readState(canisterId, {
            paths: [encodedPaths[index]]
          });
          const cert = await Certificate.create({
            certificate: response.certificate,
            rootKey: agent.rootKey,
            canisterId
          });
          const data = cert.lookup(encodePath(uniquePaths[index], canisterId));
          if (!data) {
            console.warn(`Expected to find result for path ${path}, but instead found nothing.`);
            if (typeof path === "string") {
              status.set(path, null);
            } else {
              status.set(path.key, null);
            }
          } else {
            switch (path) {
              case "time": {
                status.set(path, decodeTime(data));
                break;
              }
              case "controllers": {
                status.set(path, decodeControllers(data));
                break;
              }
              case "module_hash": {
                status.set(path, decodeHex(data));
                break;
              }
              case "candid": {
                status.set(path, new TextDecoder().decode(data));
                break;
              }
              default: {
                if (typeof path !== "string" && ("key" in path) && ("path" in path)) {
                  switch (path.decodeStrategy) {
                    case "raw":
                      status.set(path.key, data);
                      break;
                    case "leb128": {
                      status.set(path.key, decodeLeb128(data));
                      break;
                    }
                    case "cbor": {
                      status.set(path.key, decodeCbor(data));
                      break;
                    }
                    case "hex": {
                      status.set(path.key, decodeHex(data));
                      break;
                    }
                    case "utf-8": {
                      status.set(path.key, decodeUtf8(data));
                    }
                  }
                }
              }
            }
          }
        } catch (error) {
          if ((_a = error === null || error === undefined ? undefined : error.message) === null || _a === undefined ? undefined : _a.includes("Invalid certificate")) {
            throw new AgentError(error.message);
          }
          if (typeof path !== "string" && ("key" in path) && ("path" in path)) {
            status.set(path.key, null);
          } else {
            status.set(path, null);
          }
          console.group();
          console.warn(`Expected to find result for path ${path}, but instead found nothing.`);
          console.warn(error);
          console.groupEnd();
        }
      })();
    });
    await Promise.all(promises);
    return status;
  };
  encodePath = (path, canisterId) => {
    const encoder = new TextEncoder;
    const encode2 = (arg) => {
      return new DataView(encoder.encode(arg).buffer).buffer;
    };
    const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;
    switch (path) {
      case "time":
        return [encode2("time")];
      case "controllers":
        return [encode2("canister"), canisterBuffer, encode2("controllers")];
      case "module_hash":
        return [encode2("canister"), canisterBuffer, encode2("module_hash")];
      case "subnet":
        return [encode2("subnet")];
      case "candid":
        return [encode2("canister"), canisterBuffer, encode2("metadata"), encode2("candid:service")];
      default: {
        if (("key" in path) && ("path" in path)) {
          if (typeof path["path"] === "string" || path["path"] instanceof ArrayBuffer) {
            const metaPath = path.path;
            const encoded = typeof metaPath === "string" ? encode2(metaPath) : metaPath;
            return [encode2("canister"), canisterBuffer, encode2("metadata"), encoded];
          } else {
            return path["path"];
          }
        }
      }
    }
    throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`);
  };
  decodeHex = (buf) => {
    return toHex(buf);
  };
  decodeLeb128 = (buf) => {
    return candid3.lebDecode(new candid3.PipeArrayBuffer(buf));
  };
  decodeCbor = (buf) => {
    return decode(buf);
  };
  decodeUtf8 = (buf) => {
    return new TextDecoder().decode(buf);
  };
  decodeTime = (buf) => {
    const decoded = decodeLeb128(buf);
    return new Date(Number(decoded / BigInt(1e6)));
  };
  decodeControllers = (buf) => {
    const [tag, ...controllersRaw] = decodeCbor(buf);
    return controllersRaw.map((buf2) => {
      return principal3.Principal.fromUint8Array(new Uint8Array(buf2));
    });
  };
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS((exports, module) => {
  (function(nacl) {
    var gf = function(init2) {
      var i, r = new Float64Array(16);
      if (init2)
        for (i = 0;i < init2.length; i++)
          r[i] = init2[i];
      return r;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y2 = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x2, i, h2, l) {
      x2[i] = h2 >> 24 & 255;
      x2[i + 1] = h2 >> 16 & 255;
      x2[i + 2] = h2 >> 8 & 255;
      x2[i + 3] = h2 & 255;
      x2[i + 4] = l >> 24 & 255;
      x2[i + 5] = l >> 16 & 255;
      x2[i + 6] = l >> 8 & 255;
      x2[i + 7] = l & 255;
    }
    function vn(x2, xi, y2, yi, n) {
      var i, d = 0;
      for (i = 0;i < n; i++)
        d |= x2[xi + i] ^ y2[yi + i];
      return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x2, xi, y2, yi) {
      return vn(x2, xi, y2, yi, 16);
    }
    function crypto_verify_32(x2, xi, y2, yi) {
      return vn(x2, xi, y2, yi, 32);
    }
    function core_salsa20(o, p, k2, c2) {
      var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0;i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x4 >>> 0 & 255;
      o[17] = x4 >>> 8 & 255;
      o[18] = x4 >>> 16 & 255;
      o[19] = x4 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p, k2, c2) {
      var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0;i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k2, c2) {
      core_salsa20(out, inp, k2, c2);
    }
    function crypto_core_hsalsa20(out, inp, k2, c2) {
      core_hsalsa20(out, inp, k2, c2);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c2, cpos, m, mpos, b2, n, k2) {
      var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
      var u, i;
      for (i = 0;i < 16; i++)
        z2[i] = 0;
      for (i = 0;i < 8; i++)
        z2[i] = n[i];
      while (b2 >= 64) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0;i < 64; i++)
          c2[cpos + i] = m[mpos + i] ^ x2[i];
        u = 1;
        for (i = 8;i < 16; i++) {
          u = u + (z2[i] & 255) | 0;
          z2[i] = u & 255;
          u >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0;i < b2; i++)
          c2[cpos + i] = m[mpos + i] ^ x2[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c2, cpos, b2, n, k2) {
      var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
      var u, i;
      for (i = 0;i < 16; i++)
        z2[i] = 0;
      for (i = 0;i < 8; i++)
        z2[i] = n[i];
      while (b2 >= 64) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0;i < 64; i++)
          c2[cpos + i] = x2[i];
        u = 1;
        for (i = 8;i < 16; i++) {
          u = u + (z2[i] & 255) | 0;
          z2[i] = u & 255;
          u >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0;i < b2; i++)
          c2[cpos + i] = x2[i];
      }
      return 0;
    }
    function crypto_stream(c2, cpos, d, n, k2) {
      var s2 = new Uint8Array(32);
      crypto_core_hsalsa20(s2, n, k2, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0;i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20(c2, cpos, d, sn, s2);
    }
    function crypto_stream_xor(c2, cpos, m, mpos, d, n, k2) {
      var s2 = new Uint8Array(32);
      crypto_core_hsalsa20(s2, n, k2, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0;i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c2, cpos, m, mpos, d, sn, s2);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c2;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes >= 16) {
        t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c2 = 0;
        d0 = c2;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c2 = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c2 += d0 >>> 13;
        d0 &= 8191;
        d1 = c2;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c2 = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c2 += d1 >>> 13;
        d1 &= 8191;
        d2 = c2;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c2 = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c2 += d2 >>> 13;
        d2 &= 8191;
        d3 = c2;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c2 = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c2 += d3 >>> 13;
        d3 &= 8191;
        d4 = c2;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c2 = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c2 += d4 >>> 13;
        d4 &= 8191;
        d5 = c2;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c2 = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c2 += d5 >>> 13;
        d5 &= 8191;
        d6 = c2;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c2 = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c2 += d6 >>> 13;
        d6 &= 8191;
        d7 = c2;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c2 = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c2 += d7 >>> 13;
        d7 &= 8191;
        d8 = c2;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c2 = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c2 += d8 >>> 13;
        d8 &= 8191;
        d9 = c2;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c2 = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c2 += d9 >>> 13;
        d9 &= 8191;
        c2 = (c2 << 2) + c2 | 0;
        c2 = c2 + d0 | 0;
        d0 = c2 & 8191;
        c2 = c2 >>> 13;
        d1 += c2;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g2 = new Uint16Array(10);
      var c2, mask, f, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (;i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c2 = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2;i < 10; i++) {
        this.h[i] += c2;
        c2 = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c2 * 5;
      c2 = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c2;
      c2 = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c2;
      g2[0] = this.h[0] + 5;
      c2 = g2[0] >>> 13;
      g2[0] &= 8191;
      for (i = 1;i < 10; i++) {
        g2[i] = this.h[i] + c2;
        c2 = g2[i] >>> 13;
        g2[i] &= 8191;
      }
      g2[9] -= 1 << 13;
      mask = (c2 ^ 1) - 1;
      for (i = 0;i < 10; i++)
        g2[i] &= mask;
      mask = ~mask;
      for (i = 0;i < 10; i++)
        this.h[i] = this.h[i] & mask | g2[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f = this.h[0] + this.pad[0];
      this.h[0] = f & 65535;
      for (i = 1;i < 8; i++) {
        f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
        this.h[i] = f & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (i = 0;i < want; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0;i < bytes; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k2) {
      var s2 = new poly1305(k2);
      s2.update(m, mpos, n);
      s2.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h2, hpos, m, mpos, n, k2) {
      var x2 = new Uint8Array(16);
      crypto_onetimeauth(x2, 0, m, mpos, n, k2);
      return crypto_verify_16(h2, hpos, x2, 0);
    }
    function crypto_secretbox(c2, m, d, n, k2) {
      var i;
      if (d < 32)
        return -1;
      crypto_stream_xor(c2, 0, m, 0, d, n, k2);
      crypto_onetimeauth(c2, 16, c2, 32, d - 32, c2);
      for (i = 0;i < 16; i++)
        c2[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m, c2, d, n, k2) {
      var i;
      var x2 = new Uint8Array(32);
      if (d < 32)
        return -1;
      crypto_stream(x2, 0, 32, n, k2);
      if (crypto_onetimeauth_verify(c2, 16, c2, 32, d - 32, x2) !== 0)
        return -1;
      crypto_stream_xor(m, 0, c2, 0, d, n, k2);
      for (i = 0;i < 32; i++)
        m[i] = 0;
      return 0;
    }
    function set25519(r, a) {
      var i;
      for (i = 0;i < 16; i++)
        r[i] = a[i] | 0;
    }
    function car25519(o) {
      var i, v, c2 = 1;
      for (i = 0;i < 16; i++) {
        v = o[i] + c2 + 65535;
        c2 = Math.floor(v / 65536);
        o[i] = v - c2 * 65536;
      }
      o[0] += c2 - 1 + 37 * (c2 - 1);
    }
    function sel25519(p, q2, b2) {
      var t2, c2 = ~(b2 - 1);
      for (var i = 0;i < 16; i++) {
        t2 = c2 & (p[i] ^ q2[i]);
        p[i] ^= t2;
        q2[i] ^= t2;
      }
    }
    function pack25519(o, n) {
      var i, j2, b2;
      var m = gf(), t2 = gf();
      for (i = 0;i < 16; i++)
        t2[i] = n[i];
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (j2 = 0;j2 < 2; j2++) {
        m[0] = t2[0] - 65517;
        for (i = 1;i < 15; i++) {
          m[i] = t2[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t2[15] - 32767 - (m[14] >> 16 & 1);
        b2 = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t2, m, 1 - b2);
      }
      for (i = 0;i < 16; i++) {
        o[2 * i] = t2[i] & 255;
        o[2 * i + 1] = t2[i] >> 8;
      }
    }
    function neq25519(a, b2) {
      var c2 = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c2, a);
      pack25519(d, b2);
      return crypto_verify_32(c2, 0, d, 0);
    }
    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0;i < 16; i++)
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A2(o, a, b2) {
      for (var i = 0;i < 16; i++)
        o[i] = a[i] + b2[i];
    }
    function Z2(o, a, b2) {
      for (var i = 0;i < 16; i++)
        o[i] = a[i] - b2[i];
    }
    function M2(o, a, b2) {
      var v, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b22;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b22;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b22;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b22;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b22;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b22;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b22;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b22;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b22;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b22;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b22;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b22;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b22;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b22;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b22;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b22;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v = t0 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t0 = v - c2 * 65536;
      v = t1 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t1 = v - c2 * 65536;
      v = t2 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t2 = v - c2 * 65536;
      v = t3 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t3 = v - c2 * 65536;
      v = t4 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t4 = v - c2 * 65536;
      v = t5 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t5 = v - c2 * 65536;
      v = t6 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t6 = v - c2 * 65536;
      v = t7 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t7 = v - c2 * 65536;
      v = t8 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t8 = v - c2 * 65536;
      v = t9 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t9 = v - c2 * 65536;
      v = t10 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t10 = v - c2 * 65536;
      v = t11 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t11 = v - c2 * 65536;
      v = t12 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t12 = v - c2 * 65536;
      v = t13 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t13 = v - c2 * 65536;
      v = t14 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t14 = v - c2 * 65536;
      v = t15 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t15 = v - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v = t0 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t0 = v - c2 * 65536;
      v = t1 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t1 = v - c2 * 65536;
      v = t2 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t2 = v - c2 * 65536;
      v = t3 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t3 = v - c2 * 65536;
      v = t4 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t4 = v - c2 * 65536;
      v = t5 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t5 = v - c2 * 65536;
      v = t6 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t6 = v - c2 * 65536;
      v = t7 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t7 = v - c2 * 65536;
      v = t8 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t8 = v - c2 * 65536;
      v = t9 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t9 = v - c2 * 65536;
      v = t10 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t10 = v - c2 * 65536;
      v = t11 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t11 = v - c2 * 65536;
      v = t12 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t12 = v - c2 * 65536;
      v = t13 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t13 = v - c2 * 65536;
      v = t14 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t14 = v - c2 * 65536;
      v = t15 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t15 = v - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S2(o, a) {
      M2(o, a, a);
    }
    function inv25519(o, i) {
      var c2 = gf();
      var a;
      for (a = 0;a < 16; a++)
        c2[a] = i[a];
      for (a = 253;a >= 0; a--) {
        S2(c2, c2);
        if (a !== 2 && a !== 4)
          M2(c2, c2, i);
      }
      for (a = 0;a < 16; a++)
        o[a] = c2[a];
    }
    function pow2523(o, i) {
      var c2 = gf();
      var a;
      for (a = 0;a < 16; a++)
        c2[a] = i[a];
      for (a = 250;a >= 0; a--) {
        S2(c2, c2);
        if (a !== 1)
          M2(c2, c2, i);
      }
      for (a = 0;a < 16; a++)
        o[a] = c2[a];
    }
    function crypto_scalarmult(q2, n, p) {
      var z2 = new Uint8Array(32);
      var x2 = new Float64Array(80), r, i;
      var a = gf(), b2 = gf(), c2 = gf(), d = gf(), e = gf(), f = gf();
      for (i = 0;i < 31; i++)
        z2[i] = n[i];
      z2[31] = n[31] & 127 | 64;
      z2[0] &= 248;
      unpack25519(x2, p);
      for (i = 0;i < 16; i++) {
        b2[i] = x2[i];
        d[i] = a[i] = c2[i] = 0;
      }
      a[0] = d[0] = 1;
      for (i = 254;i >= 0; --i) {
        r = z2[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b2, r);
        sel25519(c2, d, r);
        A2(e, a, c2);
        Z2(a, a, c2);
        A2(c2, b2, d);
        Z2(b2, b2, d);
        S2(d, e);
        S2(f, a);
        M2(a, c2, a);
        M2(c2, b2, e);
        A2(e, a, c2);
        Z2(a, a, c2);
        S2(b2, a);
        Z2(c2, d, f);
        M2(a, c2, _121665);
        A2(a, a, d);
        M2(c2, c2, a);
        M2(a, d, f);
        M2(d, b2, x2);
        S2(b2, e);
        sel25519(a, b2, r);
        sel25519(c2, d, r);
      }
      for (i = 0;i < 16; i++) {
        x2[i + 16] = a[i];
        x2[i + 32] = c2[i];
        x2[i + 48] = b2[i];
        x2[i + 64] = d[i];
      }
      var x32 = x2.subarray(32);
      var x16 = x2.subarray(16);
      inv25519(x32, x32);
      M2(x16, x16, x32);
      pack25519(q2, x16);
      return 0;
    }
    function crypto_scalarmult_base(q2, n) {
      return crypto_scalarmult(q2, n, _9);
    }
    function crypto_box_keypair(y2, x2) {
      randombytes(x2, 32);
      return crypto_scalarmult_base(y2, x2);
    }
    function crypto_box_beforenm(k2, y2, x2) {
      var s2 = new Uint8Array(32);
      crypto_scalarmult(s2, x2, y2);
      return crypto_core_hsalsa20(k2, _0, s2, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c2, m, d, n, y2, x2) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x2);
      return crypto_box_afternm(c2, m, d, n, k2);
    }
    function crypto_box_open(m, c2, d, n, y2, x2) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x2);
      return crypto_box_open_afternm(m, c2, d, n, k2);
    }
    var K2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j2, h2, l, a, b2, c2, d;
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0;i < 16; i++) {
          j2 = 8 * i + pos;
          wh[i] = m[j2 + 0] << 24 | m[j2 + 1] << 16 | m[j2 + 2] << 8 | m[j2 + 3];
          wl[i] = m[j2 + 4] << 24 | m[j2 + 5] << 16 | m[j2 + 6] << 8 | m[j2 + 7];
        }
        for (i = 0;i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h2 = ah7;
          l = al7;
          a = l & 65535;
          b2 = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          h2 = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          h2 = K2[i * 2];
          l = K2[i * 2 + 1];
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          h2 = wh[i % 16];
          l = wl[i % 16];
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d += c2 >>> 16;
          th = c2 & 65535 | d << 16;
          tl = a & 65535 | b2 << 16;
          h2 = th;
          l = tl;
          a = l & 65535;
          b2 = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d += c2 >>> 16;
          bh7 = c2 & 65535 | d << 16;
          bl7 = a & 65535 | b2 << 16;
          h2 = bh3;
          l = bl3;
          a = l & 65535;
          b2 = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = th;
          l = tl;
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d += c2 >>> 16;
          bh3 = c2 & 65535 | d << 16;
          bl3 = a & 65535 | b2 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j2 = 0;j2 < 16; j2++) {
              h2 = wh[j2];
              l = wl[j2];
              a = l & 65535;
              b2 = l >>> 16;
              c2 = h2 & 65535;
              d = h2 >>> 16;
              h2 = wh[(j2 + 9) % 16];
              l = wl[(j2 + 9) % 16];
              a += l & 65535;
              b2 += l >>> 16;
              c2 += h2 & 65535;
              d += h2 >>> 16;
              th = wh[(j2 + 1) % 16];
              tl = wl[(j2 + 1) % 16];
              h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l & 65535;
              b2 += l >>> 16;
              c2 += h2 & 65535;
              d += h2 >>> 16;
              th = wh[(j2 + 14) % 16];
              tl = wl[(j2 + 14) % 16];
              h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l & 65535;
              b2 += l >>> 16;
              c2 += h2 & 65535;
              d += h2 >>> 16;
              b2 += a >>> 16;
              c2 += b2 >>> 16;
              d += c2 >>> 16;
              wh[j2] = c2 & 65535 | d << 16;
              wl[j2] = a & 65535 | b2 << 16;
            }
          }
        }
        h2 = ah0;
        l = al0;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[0];
        l = hl[0];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[0] = ah0 = c2 & 65535 | d << 16;
        hl[0] = al0 = a & 65535 | b2 << 16;
        h2 = ah1;
        l = al1;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[1];
        l = hl[1];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[1] = ah1 = c2 & 65535 | d << 16;
        hl[1] = al1 = a & 65535 | b2 << 16;
        h2 = ah2;
        l = al2;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[2];
        l = hl[2];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[2] = ah2 = c2 & 65535 | d << 16;
        hl[2] = al2 = a & 65535 | b2 << 16;
        h2 = ah3;
        l = al3;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[3];
        l = hl[3];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[3] = ah3 = c2 & 65535 | d << 16;
        hl[3] = al3 = a & 65535 | b2 << 16;
        h2 = ah4;
        l = al4;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[4];
        l = hl[4];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[4] = ah4 = c2 & 65535 | d << 16;
        hl[4] = al4 = a & 65535 | b2 << 16;
        h2 = ah5;
        l = al5;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[5];
        l = hl[5];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[5] = ah5 = c2 & 65535 | d << 16;
        hl[5] = al5 = a & 65535 | b2 << 16;
        h2 = ah6;
        l = al6;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[6];
        l = hl[6];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[6] = ah6 = c2 & 65535 | d << 16;
        hl[6] = al6 = a & 65535 | b2 << 16;
        h2 = ah7;
        l = al7;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[7];
        l = hl[7];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[7] = ah7 = c2 & 65535 | d << 16;
        hl[7] = al7 = a & 65535 | b2 << 16;
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8), hl = new Int32Array(8), x2 = new Uint8Array(256), i, b2 = n;
      hh[0] = 1779033703;
      hh[1] = 3144134277;
      hh[2] = 1013904242;
      hh[3] = 2773480762;
      hh[4] = 1359893119;
      hh[5] = 2600822924;
      hh[6] = 528734635;
      hh[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;
      for (i = 0;i < n; i++)
        x2[i] = m[b2 - n + i];
      x2[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x2[n - 9] = 0;
      ts64(x2, n - 8, b2 / 536870912 | 0, b2 << 3);
      crypto_hashblocks_hl(hh, hl, x2, n);
      for (i = 0;i < 8; i++)
        ts64(out, 8 * i, hh[i], hl[i]);
      return 0;
    }
    function add(p, q2) {
      var a = gf(), b2 = gf(), c2 = gf(), d = gf(), e = gf(), f = gf(), g2 = gf(), h2 = gf(), t2 = gf();
      Z2(a, p[1], p[0]);
      Z2(t2, q2[1], q2[0]);
      M2(a, a, t2);
      A2(b2, p[0], p[1]);
      A2(t2, q2[0], q2[1]);
      M2(b2, b2, t2);
      M2(c2, p[3], q2[3]);
      M2(c2, c2, D22);
      M2(d, p[2], q2[2]);
      A2(d, d, d);
      Z2(e, b2, a);
      Z2(f, d, c2);
      A2(g2, d, c2);
      A2(h2, b2, a);
      M2(p[0], e, f);
      M2(p[1], h2, g2);
      M2(p[2], g2, f);
      M2(p[3], e, h2);
    }
    function cswap(p, q2, b2) {
      var i;
      for (i = 0;i < 4; i++) {
        sel25519(p[i], q2[i], b2);
      }
    }
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M2(tx, p[0], zi);
      M2(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q2, s2) {
      var b2, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255;i >= 0; --i) {
        b2 = s2[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q2, b2);
        add(q2, p);
        add(p, p);
        cswap(p, q2, b2);
      }
    }
    function scalarbase(p, s2) {
      var q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X2);
      set25519(q2[1], Y2);
      set25519(q2[2], gf1);
      M2(q2[3], X2, Y2);
      scalarmult(p, q2, s2);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;
      if (!seeded)
        randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i = 0;i < 32; i++)
        sk[i + 32] = pk[i];
      return 0;
    }
    var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r, x2) {
      var carry, i, j2, k2;
      for (i = 63;i >= 32; --i) {
        carry = 0;
        for (j2 = i - 32, k2 = i - 12;j2 < k2; ++j2) {
          x2[j2] += carry - 16 * x2[i] * L2[j2 - (i - 32)];
          carry = Math.floor((x2[j2] + 128) / 256);
          x2[j2] -= carry * 256;
        }
        x2[j2] += carry;
        x2[i] = 0;
      }
      carry = 0;
      for (j2 = 0;j2 < 32; j2++) {
        x2[j2] += carry - (x2[31] >> 4) * L2[j2];
        carry = x2[j2] >> 8;
        x2[j2] &= 255;
      }
      for (j2 = 0;j2 < 32; j2++)
        x2[j2] -= carry * L2[j2];
      for (i = 0;i < 32; i++) {
        x2[i + 1] += x2[i] >> 8;
        r[i] = x2[i] & 255;
      }
    }
    function reduce(r) {
      var x2 = new Float64Array(64), i;
      for (i = 0;i < 64; i++)
        x2[i] = r[i];
      for (i = 0;i < 64; i++)
        r[i] = 0;
      modL(r, x2);
    }
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64), h2 = new Uint8Array(64), r = new Uint8Array(64);
      var i, j2, x2 = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0;i < n; i++)
        sm[64 + i] = m[i];
      for (i = 0;i < 32; i++)
        sm[32 + i] = d[32 + i];
      crypto_hash(r, sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i = 32;i < 64; i++)
        sm[i] = sk[i];
      crypto_hash(h2, sm, n + 64);
      reduce(h2);
      for (i = 0;i < 64; i++)
        x2[i] = 0;
      for (i = 0;i < 32; i++)
        x2[i] = r[i];
      for (i = 0;i < 32; i++) {
        for (j2 = 0;j2 < 32; j2++) {
          x2[i + j2] += h2[i] * d[j2];
        }
      }
      modL(sm.subarray(32), x2);
      return smlen;
    }
    function unpackneg(r, p) {
      var t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S2(num, r[1]);
      M2(den, num, D2);
      Z2(num, num, r[2]);
      A2(den, r[2], den);
      S2(den2, den);
      S2(den4, den2);
      M2(den6, den4, den2);
      M2(t2, den6, num);
      M2(t2, t2, den);
      pow2523(t2, t2);
      M2(t2, t2, num);
      M2(t2, t2, den);
      M2(t2, t2, den);
      M2(r[0], t2, den);
      S2(chk, r[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num))
        M2(r[0], r[0], I2);
      S2(chk, r[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r[0]) === p[31] >> 7)
        Z2(r[0], gf0, r[0]);
      M2(r[3], r[0], r[1]);
      return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i;
      var t2 = new Uint8Array(32), h2 = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
      if (n < 64)
        return -1;
      if (unpackneg(q2, pk))
        return -1;
      for (i = 0;i < n; i++)
        m[i] = sm[i];
      for (i = 0;i < 32; i++)
        m[i + 32] = pk[i];
      crypto_hash(h2, m, n);
      reduce(h2);
      scalarmult(p, q2, h2);
      scalarbase(q2, sm.subarray(32));
      add(p, q2);
      pack(t2, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t2, 0)) {
        for (i = 0;i < n; i++)
          m[i] = 0;
        return -1;
      }
      for (i = 0;i < n; i++)
        m[i] = sm[i + 64];
      return n;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
      gf,
      D: D2,
      L: L2,
      pack25519,
      unpack25519,
      M: M2,
      A: A2,
      S: S2,
      Z: Z2,
      pow2523,
      add,
      set25519,
      modL,
      scalarmult,
      scalarbase
    };
    function checkLengths(k2, n) {
      if (k2.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      for (var i = 0;i < arguments.length; i++) {
        if (!(arguments[i] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0;i < arr.length; i++)
        arr[i] = 0;
    }
    nacl.randomBytes = function(n) {
      var b2 = new Uint8Array(n);
      randombytes(b2, n);
      return b2;
    };
    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c2 = new Uint8Array(m.length);
      for (var i = 0;i < msg.length; i++)
        m[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c2, m, m.length, nonce, key);
      return c2.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c2 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c2.length);
      for (var i = 0;i < box.length; i++)
        c2[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c2.length < 32)
        return null;
      if (crypto_secretbox_open(m, c2, c2.length, nonce, key) !== 0)
        return null;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q2, n, p);
      return q2;
    };
    nacl.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q2, n);
      return q2;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k2);
    };
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k2, publicKey, secretKey);
      return k2;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k2);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m = new Uint8Array(mlen);
      for (var i = 0;i < m.length; i++)
        m[i] = tmp[i];
      return m;
    };
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0;i < sig.length; i++)
        sig[i] = signedMsg[i];
      return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0;i < crypto_sign_BYTES; i++)
        sm[i] = sig[i];
      for (i = 0;i < msg.length; i++)
        sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0;i < pk.length; i++)
        pk[i] = secretKey[32 + i];
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0;i < 32; i++)
        sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h2 = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h2, msg, msg.length);
      return h2;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x2, y2) {
      checkArrayTypes(x2, y2);
      if (x2.length === 0 || y2.length === 0)
        return false;
      if (x2.length !== y2.length)
        return false;
      return vn(x2, 0, y2, 0, x2.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto2 && crypto2.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function(x2, n) {
          var i, v = new Uint8Array(n);
          for (i = 0;i < n; i += QUOTA) {
            crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0;i < n; i++)
            x2[i] = v[i];
          cleanup(v);
        });
      } else if (typeof require !== "undefined") {
        crypto2 = import.meta.require("crypto");
        if (crypto2 && crypto2.randomBytes) {
          nacl.setPRNG(function(x2, n) {
            var i, v = crypto2.randomBytes(n);
            for (i = 0;i < n; i++)
              x2[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();
  })(typeof module !== "undefined" && exports ? exports : self.nacl = self.nacl || {});
});

// node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = __commonJS((exports) => {
  var isFunction = function(value4) {
    return typeof value4 === "function";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isFunction = undefined;
  exports.isFunction = isFunction;
});

// node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS((exports) => {
  var createErrorClass = function(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createErrorClass = undefined;
  exports.createErrorClass = createErrorClass;
});

// node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnsubscriptionError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors6) {
      _super(this);
      this.message = errors6 ? errors6.length + " errors occurred during unsubscription:\n" + errors6.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors6;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS((exports) => {
  var arrRemove = function(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.arrRemove = undefined;
  exports.arrRemove = arrRemove;
});

// node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS((exports) => {
  var isSubscription = function(value4) {
    return value4 instanceof Subscription || value4 && ("closed" in value4) && isFunction_1.isFunction(value4.remove) && isFunction_1.isFunction(value4.add) && isFunction_1.isFunction(value4.unsubscribe);
  };
  var execFinalizer = function(finalizer) {
    if (isFunction_1.isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = undefined;
  var isFunction_1 = require_isFunction();
  var UnsubscriptionError_1 = require_UnsubscriptionError();
  var arrRemove_1 = require_arrRemove();
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors6;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next();!_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction_1.isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors6 = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next();!_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors6 = errors6 !== null && errors6 !== undefined ? errors6 : [];
                if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                  errors6 = __spreadArray(__spreadArray([], __read(errors6)), __read(err.errors));
                } else {
                  errors6.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                _b.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors6) {
          throw new UnsubscriptionError_1.UnsubscriptionError(errors6);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== undefined ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove_1.arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2;
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  exports.Subscription = Subscription;
  exports.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  exports.isSubscription = isSubscription;
});

// node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.config = undefined;
  exports.config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutProvider = undefined;
  exports.timeoutProvider = {
    setTimeout: function(handler, timeout2) {
      var args = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = exports.timeoutProvider.delegate;
      if (delegate === null || delegate === undefined ? undefined : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
      }
      return setTimeout.apply(undefined, __spreadArray([handler, timeout2], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = exports.timeoutProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS((exports) => {
  var reportUnhandledError = function(err) {
    timeoutProvider_1.timeoutProvider.setTimeout(function() {
      var onUnhandledError = config_1.config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportUnhandledError = undefined;
  var config_1 = require_config();
  var timeoutProvider_1 = require_timeoutProvider();
  exports.reportUnhandledError = reportUnhandledError;
});

// node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = __commonJS((exports) => {
  var noop = function() {
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noop = undefined;
  exports.noop = noop;
});

// node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS((exports) => {
  var errorNotification = function(error) {
    return createNotification("E", undefined, error);
  };
  var nextNotification = function(value4) {
    return createNotification("N", value4, undefined);
  };
  var createNotification = function(kind, value4, error) {
    return {
      kind,
      value: value4,
      error
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = undefined;
  exports.COMPLETE_NOTIFICATION = function() {
    return createNotification("C", undefined, undefined);
  }();
  exports.errorNotification = errorNotification;
  exports.nextNotification = nextNotification;
  exports.createNotification = createNotification;
});

// node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS((exports) => {
  var errorContext = function(cb) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context, errorThrown = _a.errorThrown, error = _a.error;
        context = null;
        if (errorThrown) {
          throw error;
        }
      }
    } else {
      cb();
    }
  };
  var captureError = function(err) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.captureError = exports.errorContext = undefined;
  var config_1 = require_config();
  var context = null;
  exports.errorContext = errorContext;
  exports.captureError = captureError;
});

// node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS((exports) => {
  var bind = function(fn, thisArg) {
    return _bind.call(fn, thisArg);
  };
  var handleUnhandledError = function(error) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      errorContext_1.captureError(error);
    } else {
      reportUnhandledError_1.reportUnhandledError(error);
    }
  };
  var defaultErrorHandler = function(err) {
    throw err;
  };
  var handleStoppedNotification = function(notification, subscriber) {
    var onStoppedNotification = config_1.config.onStoppedNotification;
    onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = undefined;
  var isFunction_1 = require_isFunction();
  var Subscription_1 = require_Subscription();
  var config_1 = require_config();
  var reportUnhandledError_1 = require_reportUnhandledError();
  var noop_1 = require_noop();
  var NotificationFactories_1 = require_NotificationFactories();
  var timeoutProvider_1 = require_timeoutProvider();
  var errorContext_1 = require_errorContext();
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (Subscription_1.isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = exports.EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value4) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.nextNotification(value4), this);
      } else {
        this._next(value4);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value4) {
      this.destination.next(value4);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription_1.Subscription);
  exports.Subscriber = Subscriber;
  var _bind = Function.prototype.bind;
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value4) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value4);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== undefined ? observerOrNext : undefined,
          error: error !== null && error !== undefined ? error : undefined,
          complete: complete !== null && complete !== undefined ? complete : undefined
        };
      } else {
        var context_1;
        if (_this && config_1.config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  exports.SafeSubscriber = SafeSubscriber;
  exports.EMPTY_OBSERVER = {
    closed: true,
    next: noop_1.noop,
    error: defaultErrorHandler,
    complete: noop_1.noop
  };
});

// node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observable = undefined;
  exports.observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
});

// node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS((exports) => {
  var identity2 = function(x2) {
    return x2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.identity = undefined;
  exports.identity = identity2;
});

// node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS((exports) => {
  var pipe = function() {
    var fns = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
  };
  var pipeFromArray = function(fns) {
    if (fns.length === 0) {
      return identity_1.identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pipeFromArray = exports.pipe = undefined;
  var identity_1 = require_identity();
  exports.pipe = pipe;
  exports.pipeFromArray = pipeFromArray;
});

// node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS((exports) => {
  var getPromiseCtor = function(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== undefined ? promiseCtor : config_1.config.Promise) !== null && _a !== undefined ? _a : Promise;
  };
  var isObserver = function(value4) {
    return value4 && isFunction_1.isFunction(value4.next) && isFunction_1.isFunction(value4.error) && isFunction_1.isFunction(value4.complete);
  };
  var isSubscriber = function(value4) {
    return value4 && value4 instanceof Subscriber_1.Subscriber || isObserver(value4) && Subscription_1.isSubscription(value4);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Observable = undefined;
  var Subscriber_1 = require_Subscriber();
  var Subscription_1 = require_Subscription();
  var observable_1 = require_observable();
  var pipe_1 = require_pipe();
  var config_1 = require_config();
  var isFunction_1 = require_isFunction();
  var errorContext_1 = require_errorContext();
  var Observable = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable = new Observable2;
      observable.source = this;
      observable.operator = operator;
      return observable;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
      errorContext_1.errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value4) {
            try {
              next(value4);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === undefined ? undefined : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable_1.observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipe_1.pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value4;
        _this.subscribe(function(x2) {
          return value4 = x2;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value4);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  exports.Observable = Observable;
});

// node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS((exports) => {
  var hasLift = function(source) {
    return isFunction_1.isFunction(source === null || source === undefined ? undefined : source.lift);
  };
  var operate = function(init2) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init2(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.operate = exports.hasLift = undefined;
  var isFunction_1 = require_isFunction();
  exports.hasLift = hasLift;
  exports.operate = operate;
});

// node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS((exports) => {
  var createOperatorSubscriber = function(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperatorSubscriber = exports.createOperatorSubscriber = undefined;
  var Subscriber_1 = require_Subscriber();
  exports.createOperatorSubscriber = createOperatorSubscriber;
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value4) {
        try {
          onNext(value4);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === undefined || _a.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber_1.Subscriber);
  exports.OperatorSubscriber = OperatorSubscriber;
});

// node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS((exports) => {
  var refCount = function() {
    return lift_1.operate(function(source, subscriber) {
      var connection = null;
      source._refCount++;
      var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, undefined, function() {
        if (!source || source._refCount <= 0 || 0 < --source._refCount) {
          connection = null;
          return;
        }
        var sharedConnection = source._connection;
        var conn = connection;
        connection = null;
        if (sharedConnection && (!conn || sharedConnection === conn)) {
          sharedConnection.unsubscribe();
        }
        subscriber.unsubscribe();
      });
      source.subscribe(refCounter);
      if (!refCounter.closed) {
        connection = source.connect();
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.refCount = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.refCount = refCount;
});

// node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectableObservable = undefined;
  var Observable_1 = require_Observable();
  var Subscription_1 = require_Subscription();
  var refCount_1 = require_refCount();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var lift_1 = require_lift();
  var ConnectableObservable = function(_super) {
    __extends(ConnectableObservable2, _super);
    function ConnectableObservable2(source, subjectFactory) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subjectFactory = subjectFactory;
      _this._subject = null;
      _this._refCount = 0;
      _this._connection = null;
      if (lift_1.hasLift(source)) {
        _this.lift = source.lift;
      }
      return _this;
    }
    ConnectableObservable2.prototype._subscribe = function(subscriber) {
      return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable2.prototype.getSubject = function() {
      var subject = this._subject;
      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }
      return this._subject;
    };
    ConnectableObservable2.prototype._teardown = function() {
      this._refCount = 0;
      var _connection = this._connection;
      this._subject = this._connection = null;
      _connection === null || _connection === undefined || _connection.unsubscribe();
    };
    ConnectableObservable2.prototype.connect = function() {
      var _this = this;
      var connection = this._connection;
      if (!connection) {
        connection = this._connection = new Subscription_1.Subscription;
        var subject_1 = this.getSubject();
        connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, undefined, function() {
          _this._teardown();
          subject_1.complete();
        }, function(err) {
          _this._teardown();
          subject_1.error(err);
        }, function() {
          return _this._teardown();
        })));
        if (connection.closed) {
          this._connection = null;
          connection = Subscription_1.Subscription.EMPTY;
        }
      }
      return connection;
    };
    ConnectableObservable2.prototype.refCount = function() {
      return refCount_1.refCount()(this);
    };
    return ConnectableObservable2;
  }(Observable_1.Observable);
  exports.ConnectableObservable = ConnectableObservable;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.performanceTimestampProvider = undefined;
  exports.performanceTimestampProvider = {
    now: function() {
      return (exports.performanceTimestampProvider.delegate || performance).now();
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrameProvider = undefined;
  var Subscription_1 = require_Subscription();
  exports.animationFrameProvider = {
    schedule: function(callback) {
      var request2 = requestAnimationFrame;
      var cancel = cancelAnimationFrame;
      var delegate = exports.animationFrameProvider.delegate;
      if (delegate) {
        request2 = delegate.requestAnimationFrame;
        cancel = delegate.cancelAnimationFrame;
      }
      var handle = request2(function(timestamp) {
        cancel = undefined;
        callback(timestamp);
      });
      return new Subscription_1.Subscription(function() {
        return cancel === null || cancel === undefined ? undefined : cancel(handle);
      });
    },
    requestAnimationFrame: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.requestAnimationFrame) || requestAnimationFrame).apply(undefined, __spreadArray([], __read(args)));
    },
    cancelAnimationFrame: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(undefined, __spreadArray([], __read(args)));
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS((exports) => {
  var animationFrames = function(timestampProvider) {
    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
  };
  var animationFramesFactory = function(timestampProvider) {
    return new Observable_1.Observable(function(subscriber) {
      var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
      var start = provider.now();
      var id = 0;
      var run = function() {
        if (!subscriber.closed) {
          id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
            id = 0;
            var now = provider.now();
            subscriber.next({
              timestamp: timestampProvider ? now : timestamp,
              elapsed: now - start
            });
            run();
          });
        }
      };
      run();
      return function() {
        if (id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        }
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrames = undefined;
  var Observable_1 = require_Observable();
  var performanceTimestampProvider_1 = require_performanceTimestampProvider();
  var animationFrameProvider_1 = require_animationFrameProvider();
  exports.animationFrames = animationFrames;
  var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
});

// node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ObjectUnsubscribedError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnonymousSubject = exports.Subject = undefined;
  var Observable_1 = require_Observable();
  var Subscription_1 = require_Subscription();
  var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
  var arrRemove_1 = require_arrRemove();
  var errorContext_1 = require_errorContext();
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError;
      }
    };
    Subject2.prototype.next = function(value4) {
      var _this = this;
      errorContext_1.errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next();!_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value4);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === undefined ? undefined : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return Subscription_1.EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription_1.Subscription(function() {
        _this.currentObservers = null;
        arrRemove_1.arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable = new Observable_1.Observable;
      observable.source = this;
      return observable;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable_1.Observable);
  exports.Subject = Subject;
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value4) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === undefined ? undefined : _a.next) === null || _b === undefined || _b.call(_a, value4);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === undefined ? undefined : _a.error) === null || _b === undefined || _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === undefined ? undefined : _a.complete) === null || _b === undefined || _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === undefined ? undefined : _a.subscribe(subscriber)) !== null && _b !== undefined ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);
  exports.AnonymousSubject = AnonymousSubject;
});

// node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BehaviorSubject = undefined;
  var Subject_1 = require_Subject();
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value4) {
      _super.prototype.next.call(this, this._value = value4);
    };
    return BehaviorSubject2;
  }(Subject_1.Subject);
  exports.BehaviorSubject = BehaviorSubject;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dateTimestampProvider = undefined;
  exports.dateTimestampProvider = {
    now: function() {
      return (exports.dateTimestampProvider.delegate || Date).now();
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplaySubject = undefined;
  var Subject_1 = require_Subject();
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var ReplaySubject = function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === undefined) {
        _bufferSize = Infinity;
      }
      if (_windowTime === undefined) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === undefined) {
        _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function(value4) {
      var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
      if (!isStopped) {
        _buffer.push(value4);
        !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value4);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
      var copy2 = _buffer.slice();
      for (var i = 0;i < copy2.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy2[i]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function() {
      var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now = _timestampProvider.now();
        var last = 0;
        for (var i = 1;i < _buffer.length && _buffer[i] <= now; i += 2) {
          last = i;
        }
        last && _buffer.splice(0, last + 1);
      }
    };
    return ReplaySubject2;
  }(Subject_1.Subject);
  exports.ReplaySubject = ReplaySubject;
});

// node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncSubject = undefined;
  var Subject_1 = require_Subject();
  var AsyncSubject = function(_super) {
    __extends(AsyncSubject2, _super);
    function AsyncSubject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._value = null;
      _this._hasValue = false;
      _this._isComplete = false;
      return _this;
    }
    AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped || _isComplete) {
        _hasValue && subscriber.next(_value);
        subscriber.complete();
      }
    };
    AsyncSubject2.prototype.next = function(value4) {
      if (!this.isStopped) {
        this._value = value4;
        this._hasValue = true;
      }
    };
    AsyncSubject2.prototype.complete = function() {
      var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
      if (!_isComplete) {
        this._isComplete = true;
        _hasValue && _super.prototype.next.call(this, _value);
        _super.prototype.complete.call(this);
      }
    };
    return AsyncSubject2;
  }(Subject_1.Subject);
  exports.AsyncSubject = AsyncSubject;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Action = undefined;
  var Subscription_1 = require_Subscription();
  var Action = function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return this;
    };
    return Action2;
  }(Subscription_1.Subscription);
  exports.Action = Action;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.intervalProvider = undefined;
  exports.intervalProvider = {
    setInterval: function(handler, timeout2) {
      var args = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = exports.intervalProvider.delegate;
      if (delegate === null || delegate === undefined ? undefined : delegate.setInterval) {
        return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
      }
      return setInterval.apply(undefined, __spreadArray([handler, timeout2], __read(args)));
    },
    clearInterval: function(handle) {
      var delegate = exports.intervalProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncAction = undefined;
  var Action_1 = require_Action();
  var intervalProvider_1 = require_intervalProvider();
  var arrRemove_1 = require_arrRemove();
  var AsyncAction = function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state, delay) {
      var _a;
      if (delay === undefined) {
        delay = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay);
      }
      this.pending = true;
      this.delay = delay;
      this.id = (_a = this.id) !== null && _a !== undefined ? _a : this.requestAsyncId(scheduler, this.id, delay);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null && this.delay === delay && this.pending === false) {
        return id;
      }
      if (id != null) {
        intervalProvider_1.intervalProvider.clearInterval(id);
      }
      return;
    };
    AsyncAction2.prototype.execute = function(state, delay) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error = this._execute(state, delay);
      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a = this, id = _a.id, scheduler = _a.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove_1.arrRemove(actions, this);
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action_1.Action);
  exports.AsyncAction = AsyncAction;
});

// node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS((exports) => {
  var findAndClearHandle = function(handle) {
    if (handle in activeHandles) {
      delete activeHandles[handle];
      return true;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TestTools = exports.Immediate = undefined;
  var nextHandle = 1;
  var resolved;
  var activeHandles = {};
  exports.Immediate = {
    setImmediate: function(cb) {
      var handle = nextHandle++;
      activeHandles[handle] = true;
      if (!resolved) {
        resolved = Promise.resolve();
      }
      resolved.then(function() {
        return findAndClearHandle(handle) && cb();
      });
      return handle;
    },
    clearImmediate: function(handle) {
      findAndClearHandle(handle);
    }
  };
  exports.TestTools = {
    pending: function() {
      return Object.keys(activeHandles).length;
    }
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.immediateProvider = undefined;
  var Immediate_1 = require_Immediate();
  var setImmediate2 = Immediate_1.Immediate.setImmediate;
  var clearImmediate = Immediate_1.Immediate.clearImmediate;
  exports.immediateProvider = {
    setImmediate: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.setImmediate) || setImmediate2).apply(undefined, __spreadArray([], __read(args)));
    },
    clearImmediate: function(handle) {
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearImmediate) || clearImmediate)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsapAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var immediateProvider_1 = require_immediateProvider();
  var AsapAction = function(_super) {
    __extends(AsapAction2, _super);
    function AsapAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
    };
    AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      var _a;
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null ? delay > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      }
      var actions = scheduler.actions;
      if (id != null && ((_a = actions[actions.length - 1]) === null || _a === undefined ? undefined : _a.id) !== id) {
        immediateProvider_1.immediateProvider.clearImmediate(id);
        if (scheduler._scheduled === id) {
          scheduler._scheduled = undefined;
        }
      }
      return;
    };
    return AsapAction2;
  }(AsyncAction_1.AsyncAction);
  exports.AsapAction = AsapAction;
});

// node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Scheduler = undefined;
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var Scheduler = function() {
    function Scheduler2(schedulerActionCtor, now) {
      if (now === undefined) {
        now = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }
    Scheduler2.prototype.schedule = function(work, delay, state) {
      if (delay === undefined) {
        delay = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };
    Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
    return Scheduler2;
  }();
  exports.Scheduler = Scheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncScheduler = undefined;
  var Scheduler_1 = require_Scheduler();
  var AsyncScheduler = function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === undefined) {
        now = Scheduler_1.Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error;
      this._active = true;
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsyncScheduler2;
  }(Scheduler_1.Scheduler);
  exports.AsyncScheduler = AsyncScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsapScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var AsapScheduler = function(_super) {
    __extends(AsapScheduler2, _super);
    function AsapScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = undefined;
      var actions = this.actions;
      var error;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsapScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.AsapScheduler = AsapScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.asap = exports.asapScheduler = undefined;
  var AsapAction_1 = require_AsapAction();
  var AsapScheduler_1 = require_AsapScheduler();
  exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
  exports.asap = exports.asapScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.async = exports.asyncScheduler = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var AsyncScheduler_1 = require_AsyncScheduler();
  exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
  exports.async = exports.asyncScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueueAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var QueueAction = function(_super) {
    __extends(QueueAction2, _super);
    function QueueAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    QueueAction2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay > 0) {
        return _super.prototype.schedule.call(this, state, delay);
      }
      this.delay = delay;
      this.state = state;
      this.scheduler.flush(this);
      return this;
    };
    QueueAction2.prototype.execute = function(state, delay) {
      return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
    };
    QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null && delay > 0 || delay == null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.flush(this);
      return 0;
    };
    return QueueAction2;
  }(AsyncAction_1.AsyncAction);
  exports.QueueAction = QueueAction;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueueScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var QueueScheduler = function(_super) {
    __extends(QueueScheduler2, _super);
    function QueueScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.QueueScheduler = QueueScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.queue = exports.queueScheduler = undefined;
  var QueueAction_1 = require_QueueAction();
  var QueueScheduler_1 = require_QueueScheduler();
  exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
  exports.queue = exports.queueScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnimationFrameAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var animationFrameProvider_1 = require_animationFrameProvider();
  var AnimationFrameAction = function(_super) {
    __extends(AnimationFrameAction2, _super);
    function AnimationFrameAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
        return scheduler.flush(undefined);
      }));
    };
    AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      var _a;
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null ? delay > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      }
      var actions = scheduler.actions;
      if (id != null && ((_a = actions[actions.length - 1]) === null || _a === undefined ? undefined : _a.id) !== id) {
        animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        scheduler._scheduled = undefined;
      }
      return;
    };
    return AnimationFrameAction2;
  }(AsyncAction_1.AsyncAction);
  exports.AnimationFrameAction = AnimationFrameAction;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnimationFrameScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var AnimationFrameScheduler = function(_super) {
    __extends(AnimationFrameScheduler2, _super);
    function AnimationFrameScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = undefined;
      var actions = this.actions;
      var error;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AnimationFrameScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.AnimationFrameScheduler = AnimationFrameScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrame = exports.animationFrameScheduler = undefined;
  var AnimationFrameAction_1 = require_AnimationFrameAction();
  var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
  exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
  exports.animationFrame = exports.animationFrameScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VirtualAction = exports.VirtualTimeScheduler = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var Subscription_1 = require_Subscription();
  var AsyncScheduler_1 = require_AsyncScheduler();
  var VirtualTimeScheduler = function(_super) {
    __extends(VirtualTimeScheduler2, _super);
    function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
      if (schedulerActionCtor === undefined) {
        schedulerActionCtor = VirtualAction;
      }
      if (maxFrames === undefined) {
        maxFrames = Infinity;
      }
      var _this = _super.call(this, schedulerActionCtor, function() {
        return _this.frame;
      }) || this;
      _this.maxFrames = maxFrames;
      _this.frame = 0;
      _this.index = -1;
      return _this;
    }
    VirtualTimeScheduler2.prototype.flush = function() {
      var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
      var error;
      var action;
      while ((action = actions[0]) && action.delay <= maxFrames) {
        actions.shift();
        this.frame = action.delay;
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      }
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    VirtualTimeScheduler2.frameTimeFactor = 10;
    return VirtualTimeScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.VirtualTimeScheduler = VirtualTimeScheduler;
  var VirtualAction = function(_super) {
    __extends(VirtualAction2, _super);
    function VirtualAction2(scheduler, work, index) {
      if (index === undefined) {
        index = scheduler.index += 1;
      }
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.index = index;
      _this.active = true;
      _this.index = scheduler.index = index;
      return _this;
    }
    VirtualAction2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (Number.isFinite(delay)) {
        if (!this.id) {
          return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
      } else {
        return Subscription_1.Subscription.EMPTY;
      }
    };
    VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      this.delay = scheduler.frame + delay;
      var actions = scheduler.actions;
      actions.push(this);
      actions.sort(VirtualAction2.sortActions);
      return 1;
    };
    VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return;
    };
    VirtualAction2.prototype._execute = function(state, delay) {
      if (this.active === true) {
        return _super.prototype._execute.call(this, state, delay);
      }
    };
    VirtualAction2.sortActions = function(a, b2) {
      if (a.delay === b2.delay) {
        if (a.index === b2.index) {
          return 0;
        } else if (a.index > b2.index) {
          return 1;
        } else {
          return -1;
        }
      } else if (a.delay > b2.delay) {
        return 1;
      } else {
        return -1;
      }
    };
    return VirtualAction2;
  }(AsyncAction_1.AsyncAction);
  exports.VirtualAction = VirtualAction;
});

// node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = __commonJS((exports) => {
  var empty = function(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
  };
  var emptyScheduled = function(scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      return scheduler.schedule(function() {
        return subscriber.complete();
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.empty = exports.EMPTY = undefined;
  var Observable_1 = require_Observable();
  exports.EMPTY = new Observable_1.Observable(function(subscriber) {
    return subscriber.complete();
  });
  exports.empty = empty;
});

// node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS((exports) => {
  var isScheduler = function(value4) {
    return value4 && isFunction_1.isFunction(value4.schedule);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isScheduler = undefined;
  var isFunction_1 = require_isFunction();
  exports.isScheduler = isScheduler;
});

// node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS((exports) => {
  var last = function(arr) {
    return arr[arr.length - 1];
  };
  var popResultSelector = function(args) {
    return isFunction_1.isFunction(last(args)) ? args.pop() : undefined;
  };
  var popScheduler = function(args) {
    return isScheduler_1.isScheduler(last(args)) ? args.pop() : undefined;
  };
  var popNumber = function(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.popNumber = exports.popScheduler = exports.popResultSelector = undefined;
  var isFunction_1 = require_isFunction();
  var isScheduler_1 = require_isScheduler();
  exports.popResultSelector = popResultSelector;
  exports.popScheduler = popScheduler;
  exports.popNumber = popNumber;
});

// node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isArrayLike = undefined;
  exports.isArrayLike = function(x2) {
    return x2 && typeof x2.length === "number" && typeof x2 !== "function";
  };
});

// node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS((exports) => {
  var isPromise = function(value4) {
    return isFunction_1.isFunction(value4 === null || value4 === undefined ? undefined : value4.then);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPromise = undefined;
  var isFunction_1 = require_isFunction();
  exports.isPromise = isPromise;
});

// node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS((exports) => {
  var isInteropObservable = function(input) {
    return isFunction_1.isFunction(input[observable_1.observable]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isInteropObservable = undefined;
  var observable_1 = require_observable();
  var isFunction_1 = require_isFunction();
  exports.isInteropObservable = isInteropObservable;
});

// node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS((exports) => {
  var isAsyncIterable = function(obj) {
    return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === undefined ? undefined : obj[Symbol.asyncIterator]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAsyncIterable = undefined;
  var isFunction_1 = require_isFunction();
  exports.isAsyncIterable = isAsyncIterable;
});

// node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS((exports) => {
  var createInvalidObservableTypeError = function(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createInvalidObservableTypeError = undefined;
  exports.createInvalidObservableTypeError = createInvalidObservableTypeError;
});

// node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS((exports) => {
  var getSymbolIterator = function() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iterator = exports.getSymbolIterator = undefined;
  exports.getSymbolIterator = getSymbolIterator;
  exports.iterator = getSymbolIterator();
});

// node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS((exports) => {
  var isIterable = function(input) {
    return isFunction_1.isFunction(input === null || input === undefined ? undefined : input[iterator_1.iterator]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isIterable = undefined;
  var iterator_1 = require_iterator();
  var isFunction_1 = require_isFunction();
  exports.isIterable = isIterable;
});

// node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS((exports) => {
  var readableStreamLikeToAsyncGenerator = function(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value4, done;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            if (false)
              ;
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value4 = _a.value, done = _a.done;
            if (!done)
              return [3, 5];
            return [4, __await(undefined)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value4)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  };
  var isReadableStreamLike = function(obj) {
    return isFunction_1.isFunction(obj === null || obj === undefined ? undefined : obj.getReader);
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y2, t2, g2;
    return g2 = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y2 = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g2[n])
        i[n] = function(v) {
          return new Promise(function(a, b2) {
            q2.push([n, v, a, b2]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g2[n](v));
      } catch (e) {
        settle(q2[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
    }
    function fulfill(value4) {
      resume("next", value4);
    }
    function reject(value4) {
      resume("throw", value4);
    }
    function settle(f, v) {
      if (f(v), q2.shift(), q2.length)
        resume(q2[0][0], q2[0][1]);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = undefined;
  var isFunction_1 = require_isFunction();
  exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
  exports.isReadableStreamLike = isReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS((exports) => {
  var innerFrom = function(input) {
    if (input instanceof Observable_1.Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return fromArrayLike2(input);
      }
      if (isPromise_1.isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable_1.isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  };
  var fromInteropObservable = function(obj) {
    return new Observable_1.Observable(function(subscriber) {
      var obs = obj[observable_1.observable]();
      if (isFunction_1.isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  };
  var fromArrayLike2 = function(array) {
    return new Observable_1.Observable(function(subscriber) {
      for (var i = 0;i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    });
  };
  var fromPromise = function(promise) {
    return new Observable_1.Observable(function(subscriber) {
      promise.then(function(value4) {
        if (!subscriber.closed) {
          subscriber.next(value4);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError_1.reportUnhandledError);
    });
  };
  var fromIterable = function(iterable) {
    return new Observable_1.Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next();!iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value4 = iterable_1_1.value;
          subscriber.next(value4);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  };
  var fromAsyncIterable = function(asyncIterable) {
    return new Observable_1.Observable(function(subscriber) {
      process2(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  };
  var fromReadableStreamLike = function(readableStream) {
    return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
  };
  var process2 = function(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, undefined, undefined, function() {
      var value4, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value4 = asyncIterable_1_1.value;
            subscriber.next(value4);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value4) {
      return value4 instanceof P2 ? value4 : new P2(function(resolve) {
        resolve(value4);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value4) {
        try {
          step(generator.next(value4));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value4) {
        try {
          step(generator["throw"](value4));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y2, t2, g2;
    return g2 = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y2 = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = undefined;
  var isArrayLike_1 = require_isArrayLike();
  var isPromise_1 = require_isPromise();
  var Observable_1 = require_Observable();
  var isInteropObservable_1 = require_isInteropObservable();
  var isAsyncIterable_1 = require_isAsyncIterable();
  var throwUnobservableError_1 = require_throwUnobservableError();
  var isIterable_1 = require_isIterable();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  var isFunction_1 = require_isFunction();
  var reportUnhandledError_1 = require_reportUnhandledError();
  var observable_1 = require_observable();
  exports.innerFrom = innerFrom;
  exports.fromInteropObservable = fromInteropObservable;
  exports.fromArrayLike = fromArrayLike2;
  exports.fromPromise = fromPromise;
  exports.fromIterable = fromIterable;
  exports.fromAsyncIterable = fromAsyncIterable;
  exports.fromReadableStreamLike = fromReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS((exports) => {
  var executeSchedule = function(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === undefined) {
      delay = 0;
    }
    if (repeat === undefined) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.executeSchedule = undefined;
  exports.executeSchedule = executeSchedule;
});

// node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS((exports) => {
  var observeOn = function(scheduler, delay) {
    if (delay === undefined) {
      delay = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value4);
        }, delay);
      }, function() {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay);
      }, function(err) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeOn = undefined;
  var executeSchedule_1 = require_executeSchedule();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.observeOn = observeOn;
});

// node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS((exports) => {
  var subscribeOn = function(scheduler, delay) {
    if (delay === undefined) {
      delay = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.subscribeOn = undefined;
  var lift_1 = require_lift();
  exports.subscribeOn = subscribeOn;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS((exports) => {
  var scheduleObservable = function(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleObservable = undefined;
  var innerFrom_1 = require_innerFrom();
  var observeOn_1 = require_observeOn();
  var subscribeOn_1 = require_subscribeOn();
  exports.scheduleObservable = scheduleObservable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS((exports) => {
  var schedulePromise = function(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.schedulePromise = undefined;
  var innerFrom_1 = require_innerFrom();
  var observeOn_1 = require_observeOn();
  var subscribeOn_1 = require_subscribeOn();
  exports.schedulePromise = schedulePromise;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS((exports) => {
  var scheduleArray = function(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var i = 0;
      return scheduler.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleArray = undefined;
  var Observable_1 = require_Observable();
  exports.scheduleArray = scheduleArray;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS((exports) => {
  var scheduleIterable = function(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var iterator;
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        iterator = input[iterator_1.iterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var _a;
          var value4;
          var done;
          try {
            _a = iterator.next(), value4 = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value4);
          }
        }, 0, true);
      });
      return function() {
        return isFunction_1.isFunction(iterator === null || iterator === undefined ? undefined : iterator.return) && iterator.return();
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleIterable = undefined;
  var Observable_1 = require_Observable();
  var iterator_1 = require_iterator();
  var isFunction_1 = require_isFunction();
  var executeSchedule_1 = require_executeSchedule();
  exports.scheduleIterable = scheduleIterable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS((exports) => {
  var scheduleAsyncIterable = function(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable_1.Observable(function(subscriber) {
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        var iterator = input[Symbol.asyncIterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleAsyncIterable = undefined;
  var Observable_1 = require_Observable();
  var executeSchedule_1 = require_executeSchedule();
  exports.scheduleAsyncIterable = scheduleAsyncIterable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS((exports) => {
  var scheduleReadableStreamLike = function(input, scheduler) {
    return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleReadableStreamLike = undefined;
  var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  exports.scheduleReadableStreamLike = scheduleReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS((exports) => {
  var scheduled = function(input, scheduler) {
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return scheduleObservable_1.scheduleObservable(input, scheduler);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return scheduleArray_1.scheduleArray(input, scheduler);
      }
      if (isPromise_1.isPromise(input)) {
        return schedulePromise_1.schedulePromise(input, scheduler);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable_1.isIterable(input)) {
        return scheduleIterable_1.scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduled = undefined;
  var scheduleObservable_1 = require_scheduleObservable();
  var schedulePromise_1 = require_schedulePromise();
  var scheduleArray_1 = require_scheduleArray();
  var scheduleIterable_1 = require_scheduleIterable();
  var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
  var isInteropObservable_1 = require_isInteropObservable();
  var isPromise_1 = require_isPromise();
  var isArrayLike_1 = require_isArrayLike();
  var isIterable_1 = require_isIterable();
  var isAsyncIterable_1 = require_isAsyncIterable();
  var throwUnobservableError_1 = require_throwUnobservableError();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
  exports.scheduled = scheduled;
});

// node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS((exports) => {
  var from2 = function(input, scheduler) {
    return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.from = undefined;
  var scheduled_1 = require_scheduled();
  var innerFrom_1 = require_innerFrom();
  exports.from = from2;
});

// node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS((exports) => {
  var of = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    return from_1.from(args, scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.of = undefined;
  var args_1 = require_args();
  var from_1 = require_from();
  exports.of = of;
});

// node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS((exports) => {
  var throwError = function(errorOrErrorFactory, scheduler) {
    var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
      return errorOrErrorFactory;
    };
    var init2 = function(subscriber) {
      return subscriber.error(errorFactory());
    };
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      return scheduler.schedule(init2, 0, subscriber);
    } : init2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throwError = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  exports.throwError = throwError;
});

// node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS((exports) => {
  var observeNotification = function(notification, observer) {
    var _a, _b, _c;
    var _d = notification, kind = _d.kind, value4 = _d.value, error = _d.error;
    if (typeof kind !== "string") {
      throw new TypeError('Invalid notification, missing "kind"');
    }
    kind === "N" ? (_a = observer.next) === null || _a === undefined || _a.call(observer, value4) : kind === "E" ? (_b = observer.error) === null || _b === undefined || _b.call(observer, error) : (_c = observer.complete) === null || _c === undefined || _c.call(observer);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeNotification = exports.Notification = exports.NotificationKind = undefined;
  var empty_1 = require_empty();
  var of_1 = require_of();
  var throwError_1 = require_throwError();
  var isFunction_1 = require_isFunction();
  var NotificationKind;
  (function(NotificationKind2) {
    NotificationKind2["NEXT"] = "N";
    NotificationKind2["ERROR"] = "E";
    NotificationKind2["COMPLETE"] = "C";
  })(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
  var Notification = function() {
    function Notification2(kind, value4, error) {
      this.kind = kind;
      this.value = value4;
      this.error = error;
      this.hasValue = kind === "N";
    }
    Notification2.prototype.observe = function(observer) {
      return observeNotification(this, observer);
    };
    Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
      var _a = this, kind = _a.kind, value4 = _a.value, error = _a.error;
      return kind === "N" ? nextHandler === null || nextHandler === undefined ? undefined : nextHandler(value4) : kind === "E" ? errorHandler === null || errorHandler === undefined ? undefined : errorHandler(error) : completeHandler === null || completeHandler === undefined ? undefined : completeHandler();
    };
    Notification2.prototype.accept = function(nextOrObserver, error, complete) {
      var _a;
      return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === undefined ? undefined : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
    };
    Notification2.prototype.toObservable = function() {
      var _a = this, kind = _a.kind, value4 = _a.value, error = _a.error;
      var result = kind === "N" ? of_1.of(value4) : kind === "E" ? throwError_1.throwError(function() {
        return error;
      }) : kind === "C" ? empty_1.EMPTY : 0;
      if (!result) {
        throw new TypeError("Unexpected notification kind " + kind);
      }
      return result;
    };
    Notification2.createNext = function(value4) {
      return new Notification2("N", value4);
    };
    Notification2.createError = function(err) {
      return new Notification2("E", undefined, err);
    };
    Notification2.createComplete = function() {
      return Notification2.completeNotification;
    };
    Notification2.completeNotification = new Notification2("C");
    return Notification2;
  }();
  exports.Notification = Notification;
  exports.observeNotification = observeNotification;
});

// node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS((exports) => {
  var isObservable = function(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObservable = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  exports.isObservable = isObservable;
});

// node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmptyError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS((exports) => {
  var lastValueFrom = function(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
      var _hasValue = false;
      var _value;
      source.subscribe({
        next: function(value4) {
          _value = value4;
          _hasValue = true;
        },
        error: reject,
        complete: function() {
          if (_hasValue) {
            resolve(_value);
          } else if (hasConfig) {
            resolve(config.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError);
          }
        }
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lastValueFrom = undefined;
  var EmptyError_1 = require_EmptyError();
  exports.lastValueFrom = lastValueFrom;
});

// node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS((exports) => {
  var firstValueFrom = function(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
      var subscriber = new Subscriber_1.SafeSubscriber({
        next: function(value4) {
          resolve(value4);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function() {
          if (hasConfig) {
            resolve(config.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError);
          }
        }
      });
      source.subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.firstValueFrom = undefined;
  var EmptyError_1 = require_EmptyError();
  var Subscriber_1 = require_Subscriber();
  exports.firstValueFrom = firstValueFrom;
});

// node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ArgumentOutOfRangeError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
    return function ArgumentOutOfRangeErrorImpl() {
      _super(this);
      this.name = "ArgumentOutOfRangeError";
      this.message = "argument out of range";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NotFoundError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
    return function NotFoundErrorImpl(message) {
      _super(this);
      this.name = "NotFoundError";
      this.message = message;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SequenceError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
    return function SequenceErrorImpl(message) {
      _super(this);
      this.name = "SequenceError";
      this.message = message;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS((exports) => {
  var isValidDate = function(value4) {
    return value4 instanceof Date && !isNaN(value4);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidDate = undefined;
  exports.isValidDate = isValidDate;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS((exports) => {
  var timeout2 = function(config, schedulerArg) {
    var _a = isDate_1.isValidDate(config) ? { first: config } : typeof config === "number" ? { each: config } : config, first = _a.first, each = _a.each, _b = _a.with, _with = _b === undefined ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === undefined ? schedulerArg !== null && schedulerArg !== undefined ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === undefined ? null : _d;
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return lift_1.operate(function(source, subscriber) {
      var originalSourceSubscription;
      var timerSubscription;
      var lastValue = null;
      var seen = 0;
      var startTimer = function(delay) {
        timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          try {
            originalSourceSubscription.unsubscribe();
            innerFrom_1.innerFrom(_with({
              meta,
              lastValue,
              seen
            })).subscribe(subscriber);
          } catch (err) {
            subscriber.error(err);
          }
        }, delay);
      };
      originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        timerSubscription === null || timerSubscription === undefined || timerSubscription.unsubscribe();
        seen++;
        subscriber.next(lastValue = value4);
        each > 0 && startTimer(each);
      }, undefined, undefined, function() {
        if (!(timerSubscription === null || timerSubscription === undefined ? undefined : timerSubscription.closed)) {
          timerSubscription === null || timerSubscription === undefined || timerSubscription.unsubscribe();
        }
        lastValue = null;
      }));
      !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
    });
  };
  var timeoutErrorFactory = function(info) {
    throw new exports.TimeoutError(info);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeout = exports.TimeoutError = undefined;
  var async_1 = require_async();
  var isDate_1 = require_isDate();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var createErrorClass_1 = require_createErrorClass();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var executeSchedule_1 = require_executeSchedule();
  exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
    return function TimeoutErrorImpl(info) {
      if (info === undefined) {
        info = null;
      }
      _super(this);
      this.message = "Timeout has occurred";
      this.name = "TimeoutError";
      this.info = info;
    };
  });
  exports.timeout = timeout2;
});

// node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS((exports) => {
  var map = function(project, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        subscriber.next(project.call(thisArg, value4, index++));
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.map = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.map = map;
});

// node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS((exports) => {
  var callOrApply = function(fn, args) {
    return isArray(args) ? fn.apply(undefined, __spreadArray([], __read(args))) : fn(args);
  };
  var mapOneOrManyArgs = function(fn) {
    return map_1.map(function(args) {
      return callOrApply(fn, args);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapOneOrManyArgs = undefined;
  var map_1 = require_map();
  var isArray = Array.isArray;
  exports.mapOneOrManyArgs = mapOneOrManyArgs;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS((exports) => {
  var bindCallbackInternals = function(isNodeStyle, callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
      if (isScheduler_1.isScheduler(resultSelector)) {
        scheduler = resultSelector;
      } else {
        return function() {
          var args = [];
          for (var _i = 0;_i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
        };
      }
    }
    if (scheduler) {
      return function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
      };
    }
    return function() {
      var _this = this;
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var subject = new AsyncSubject_1.AsyncSubject;
      var uninitialized = true;
      return new Observable_1.Observable(function(subscriber) {
        var subs = subject.subscribe(subscriber);
        if (uninitialized) {
          uninitialized = false;
          var isAsync_1 = false;
          var isComplete_1 = false;
          callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
            function() {
              var results = [];
              for (var _i2 = 0;_i2 < arguments.length; _i2++) {
                results[_i2] = arguments[_i2];
              }
              if (isNodeStyle) {
                var err = results.shift();
                if (err != null) {
                  subject.error(err);
                  return;
                }
              }
              subject.next(1 < results.length ? results : results[0]);
              isComplete_1 = true;
              if (isAsync_1) {
                subject.complete();
              }
            }
          ]));
          if (isComplete_1) {
            subject.complete();
          }
          isAsync_1 = true;
        }
        return subs;
      });
    };
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindCallbackInternals = undefined;
  var isScheduler_1 = require_isScheduler();
  var Observable_1 = require_Observable();
  var subscribeOn_1 = require_subscribeOn();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var observeOn_1 = require_observeOn();
  var AsyncSubject_1 = require_AsyncSubject();
  exports.bindCallbackInternals = bindCallbackInternals;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS((exports) => {
  var bindCallback = function(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindCallback = undefined;
  var bindCallbackInternals_1 = require_bindCallbackInternals();
  exports.bindCallback = bindCallback;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS((exports) => {
  var bindNodeCallback = function(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindNodeCallback = undefined;
  var bindCallbackInternals_1 = require_bindCallbackInternals();
  exports.bindNodeCallback = bindNodeCallback;
});

// node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS((exports) => {
  var argsArgArrayOrObject = function(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key) {
            return first_1[key];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  };
  var isPOJO = function(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsArgArrayOrObject = undefined;
  var isArray = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var getKeys = Object.keys;
  exports.argsArgArrayOrObject = argsArgArrayOrObject;
});

// node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS((exports) => {
  var createObject = function(keys, values) {
    return keys.reduce(function(result, key, i) {
      return result[key] = values[i], result;
    }, {});
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createObject = undefined;
  exports.createObject = createObject;
});

// node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS((exports) => {
  var combineLatest = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var resultSelector = args_1.popResultSelector(args);
    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
    if (observables.length === 0) {
      return from_1.from([], scheduler);
    }
    var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject_1.createObject(keys, values);
    } : identity_1.identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  };
  var combineLatestInit = function(observables, scheduler, valueTransform) {
    if (valueTransform === undefined) {
      valueTransform = identity_1.identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i2) {
          maybeSchedule(scheduler, function() {
            var source = from_1.from(observables[i2], scheduler);
            var hasFirstValue = false;
            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
              values[i2] = value4;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i = 0;i < length; i++) {
          _loop_1(i);
        }
      }, subscriber);
    };
  };
  var maybeSchedule = function(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule_1.executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestInit = exports.combineLatest = undefined;
  var Observable_1 = require_Observable();
  var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
  var from_1 = require_from();
  var identity_1 = require_identity();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var args_1 = require_args();
  var createObject_1 = require_createObject();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var executeSchedule_1 = require_executeSchedule();
  exports.combineLatest = combineLatest;
  exports.combineLatestInit = combineLatestInit;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS((exports) => {
  var mergeInternals = function(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer14 = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer14.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value4) {
      return active < concurrent ? doInnerSub(value4) : buffer14.push(value4);
    };
    var doInnerSub = function(value4) {
      expand && subscriber.next(value4);
      active++;
      var innerComplete = false;
      innerFrom_1.innerFrom(project(value4, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === undefined || onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, undefined, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer14.shift();
              if (innerSubScheduler) {
                executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer14.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === undefined || additionalFinalizer();
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeInternals = undefined;
  var innerFrom_1 = require_innerFrom();
  var executeSchedule_1 = require_executeSchedule();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.mergeInternals = mergeInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS((exports) => {
  var mergeMap = function(project, resultSelector, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap(function(a, i) {
        return map_1.map(function(b2, ii) {
          return resultSelector(a, b2, i, ii);
        })(innerFrom_1.innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeMap = undefined;
  var map_1 = require_map();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  var isFunction_1 = require_isFunction();
  exports.mergeMap = mergeMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS((exports) => {
  var mergeAll = function(concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeAll = undefined;
  var mergeMap_1 = require_mergeMap();
  var identity_1 = require_identity();
  exports.mergeAll = mergeAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS((exports) => {
  var concatAll = function() {
    return mergeAll_1.mergeAll(1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatAll = undefined;
  var mergeAll_1 = require_mergeAll();
  exports.concatAll = concatAll;
});

// node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS((exports) => {
  var concat3 = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = undefined;
  var concatAll_1 = require_concatAll();
  var args_1 = require_args();
  var from_1 = require_from();
  exports.concat = concat3;
});

// node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS((exports) => {
  var defer = function(observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defer = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  exports.defer = defer;
});

// node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS((exports) => {
  var connectable = function(source, config) {
    if (config === undefined) {
      config = DEFAULT_CONFIG;
    }
    var connection = null;
    var { connector, resetOnDisconnect: _a } = config, resetOnDisconnect = _a === undefined ? true : _a;
    var subject = connector();
    var result = new Observable_1.Observable(function(subscriber) {
      return subject.subscribe(subscriber);
    });
    result.connect = function() {
      if (!connection || connection.closed) {
        connection = defer_1.defer(function() {
          return source;
        }).subscribe(subject);
        if (resetOnDisconnect) {
          connection.add(function() {
            return subject = connector();
          });
        }
      }
      return connection;
    };
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.connectable = undefined;
  var Subject_1 = require_Subject();
  var Observable_1 = require_Observable();
  var defer_1 = require_defer();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject;
    },
    resetOnDisconnect: true
  };
  exports.connectable = connectable;
});

// node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS((exports) => {
  var forkJoin = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
    var result = new Observable_1.Observable(function(subscriber) {
      var length = sources.length;
      if (!length) {
        subscriber.complete();
        return;
      }
      var values = new Array(length);
      var remainingCompletions = length;
      var remainingEmissions = length;
      var _loop_1 = function(sourceIndex2) {
        var hasValue = false;
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
          if (!hasValue) {
            hasValue = true;
            remainingEmissions--;
          }
          values[sourceIndex2] = value4;
        }, function() {
          return remainingCompletions--;
        }, undefined, function() {
          if (!remainingCompletions || !hasValue) {
            if (!remainingEmissions) {
              subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
            }
            subscriber.complete();
          }
        }));
      };
      for (var sourceIndex = 0;sourceIndex < length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
    });
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.forkJoin = undefined;
  var Observable_1 = require_Observable();
  var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
  var innerFrom_1 = require_innerFrom();
  var args_1 = require_args();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var createObject_1 = require_createObject();
  exports.forkJoin = forkJoin;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS((exports) => {
  var fromEvent = function(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
      resultSelector = options;
      options = undefined;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
    if (!add) {
      if (isArrayLike_1.isArrayLike(target)) {
        return mergeMap_1.mergeMap(function(subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom_1.innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add(handler);
      return function() {
        return remove(handler);
      };
    });
  };
  var toCommonHandlerRegistry = function(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  };
  var isNodeStyleEventEmitter = function(target) {
    return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
  };
  var isJQueryStyleEventEmitter = function(target) {
    return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
  };
  var isEventTarget = function(target) {
    return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromEvent = undefined;
  var innerFrom_1 = require_innerFrom();
  var Observable_1 = require_Observable();
  var mergeMap_1 = require_mergeMap();
  var isArrayLike_1 = require_isArrayLike();
  var isFunction_1 = require_isFunction();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  exports.fromEvent = fromEvent;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS((exports) => {
  var fromEventPattern = function(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
      return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var e = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          e[_i] = arguments[_i];
        }
        return subscriber.next(e.length === 1 ? e[0] : e);
      };
      var retValue = addHandler(handler);
      return isFunction_1.isFunction(removeHandler) ? function() {
        return removeHandler(handler, retValue);
      } : undefined;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromEventPattern = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  exports.fromEventPattern = fromEventPattern;
});

// node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS((exports) => {
  var generate = function(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
    var _a, _b;
    var resultSelector;
    var initialState;
    if (arguments.length === 1) {
      _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === undefined ? identity_1.identity : _b, scheduler = _a.scheduler;
    } else {
      initialState = initialStateOrOptions;
      if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrScheduler;
      } else {
        resultSelector = resultSelectorOrScheduler;
      }
    }
    function gen() {
      var state;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            state = initialState;
            _a2.label = 1;
          case 1:
            if (!(!condition || condition(state)))
              return [3, 4];
            return [4, resultSelector(state)];
          case 2:
            _a2.sent();
            _a2.label = 3;
          case 3:
            state = iterate(state);
            return [3, 1];
          case 4:
            return [2];
        }
      });
    }
    return defer_1.defer(scheduler ? function() {
      return scheduleIterable_1.scheduleIterable(gen(), scheduler);
    } : gen);
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y2, t2, g2;
    return g2 = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y2 = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generate = undefined;
  var identity_1 = require_identity();
  var isScheduler_1 = require_isScheduler();
  var defer_1 = require_defer();
  var scheduleIterable_1 = require_scheduleIterable();
  exports.generate = generate;
});

// node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS((exports) => {
  var iif = function(condition, trueResult, falseResult) {
    return defer_1.defer(function() {
      return condition() ? trueResult : falseResult;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iif = undefined;
  var defer_1 = require_defer();
  exports.iif = iif;
});

// node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS((exports) => {
  var timer = function(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === undefined) {
      dueTime = 0;
    }
    if (scheduler === undefined) {
      scheduler = async_1.async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler_1.isScheduler(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable_1.Observable(function(subscriber) {
      var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n++);
          if (0 <= intervalDuration) {
            this.schedule(undefined, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timer = undefined;
  var Observable_1 = require_Observable();
  var async_1 = require_async();
  var isScheduler_1 = require_isScheduler();
  var isDate_1 = require_isDate();
  exports.timer = timer;
});

// node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS((exports) => {
  var interval = function(period, scheduler) {
    if (period === undefined) {
      period = 0;
    }
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    if (period < 0) {
      period = 0;
    }
    return timer_1.timer(period, period, scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = undefined;
  var async_1 = require_async();
  var timer_1 = require_timer();
  exports.interval = interval;
});

// node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS((exports) => {
  var merge = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var concurrent = args_1.popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var mergeAll_1 = require_mergeAll();
  var innerFrom_1 = require_innerFrom();
  var empty_1 = require_empty();
  var args_1 = require_args();
  var from_1 = require_from();
  exports.merge = merge;
});

// node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS((exports) => {
  var never = function() {
    return exports.NEVER;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.never = exports.NEVER = undefined;
  var Observable_1 = require_Observable();
  var noop_1 = require_noop();
  exports.NEVER = new Observable_1.Observable(noop_1.noop);
  exports.never = never;
});

// node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS((exports) => {
  var argsOrArgArray = function(args) {
    return args.length === 1 && isArray(args[0]) ? args[0] : args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsOrArgArray = undefined;
  var isArray = Array.isArray;
  exports.argsOrArgArray = argsOrArgArray;
});

// node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS((exports) => {
  var onErrorResumeNext = function() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return new Observable_1.Observable(function(subscriber) {
      var sourceIndex = 0;
      var subscribeNext = function() {
        if (sourceIndex < nextSources.length) {
          var nextSource = undefined;
          try {
            nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
          } catch (err) {
            subscribeNext();
            return;
          }
          var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, undefined, noop_1.noop, noop_1.noop);
          nextSource.subscribe(innerSubscriber);
          innerSubscriber.add(subscribeNext);
        } else {
          subscriber.complete();
        }
      };
      subscribeNext();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.onErrorResumeNext = undefined;
  var Observable_1 = require_Observable();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  exports.onErrorResumeNext = onErrorResumeNext;
});

// node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS((exports) => {
  var pairs = function(obj, scheduler) {
    return from_1.from(Object.entries(obj), scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pairs = undefined;
  var from_1 = require_from();
  exports.pairs = pairs;
});

// node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS((exports) => {
  var not = function(pred, thisArg) {
    return function(value4, index) {
      return !pred.call(thisArg, value4, index);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.not = undefined;
  exports.not = not;
});

// node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS((exports) => {
  var filter = function(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return predicate.call(thisArg, value4, index++) && subscriber.next(value4);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filter = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.filter = filter;
});

// node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS((exports) => {
  var partition = function(source, predicate, thisArg) {
    return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.partition = undefined;
  var not_1 = require_not();
  var filter_1 = require_filter();
  var innerFrom_1 = require_innerFrom();
  exports.partition = partition;
});

// node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS((exports) => {
  var race = function() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    sources = argsOrArgArray_1.argsOrArgArray(sources);
    return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
  };
  var raceInit = function(sources) {
    return function(subscriber) {
      var subscriptions = [];
      var _loop_1 = function(i2) {
        subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
          if (subscriptions) {
            for (var s2 = 0;s2 < subscriptions.length; s2++) {
              s2 !== i2 && subscriptions[s2].unsubscribe();
            }
            subscriptions = null;
          }
          subscriber.next(value4);
        })));
      };
      for (var i = 0;subscriptions && !subscriber.closed && i < sources.length; i++) {
        _loop_1(i);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.raceInit = exports.race = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.race = race;
  exports.raceInit = raceInit;
});

// node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS((exports) => {
  var range = function(start, count, scheduler) {
    if (count == null) {
      count = start;
      start = 0;
    }
    if (count <= 0) {
      return empty_1.EMPTY;
    }
    var end = count + start;
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      var n = start;
      return scheduler.schedule(function() {
        if (n < end) {
          subscriber.next(n++);
          this.schedule();
        } else {
          subscriber.complete();
        }
      });
    } : function(subscriber) {
      var n = start;
      while (n < end && !subscriber.closed) {
        subscriber.next(n++);
      }
      subscriber.complete();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.range = undefined;
  var Observable_1 = require_Observable();
  var empty_1 = require_empty();
  exports.range = range;
});

// node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS((exports) => {
  var using = function(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      var resource = resourceFactory();
      var result = observableFactory(resource);
      var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
      source.subscribe(subscriber);
      return function() {
        if (resource) {
          resource.unsubscribe();
        }
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.using = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var empty_1 = require_empty();
  exports.using = using;
});

// node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS((exports) => {
  var zip = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    var sources = argsOrArgArray_1.argsOrArgArray(args);
    return sources.length ? new Observable_1.Observable(function(subscriber) {
      var buffers = sources.map(function() {
        return [];
      });
      var completed = sources.map(function() {
        return false;
      });
      subscriber.add(function() {
        buffers = completed = null;
      });
      var _loop_1 = function(sourceIndex2) {
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
          buffers[sourceIndex2].push(value4);
          if (buffers.every(function(buffer14) {
            return buffer14.length;
          })) {
            var result = buffers.map(function(buffer14) {
              return buffer14.shift();
            });
            subscriber.next(resultSelector ? resultSelector.apply(undefined, __spreadArray([], __read(result))) : result);
            if (buffers.some(function(buffer14, i) {
              return !buffer14.length && completed[i];
            })) {
              subscriber.complete();
            }
          }
        }, function() {
          completed[sourceIndex2] = true;
          !buffers[sourceIndex2].length && subscriber.complete();
        }));
      };
      for (var sourceIndex = 0;!subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
      return function() {
        buffers = completed = null;
      };
    }) : empty_1.EMPTY;
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zip = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var empty_1 = require_empty();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var args_1 = require_args();
  exports.zip = zip;
});

// node_modules/rxjs/dist/cjs/internal/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS((exports) => {
  var audit = function(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var isComplete = false;
      var endDuration = function() {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value4 = lastValue;
          lastValue = null;
          subscriber.next(value4);
        }
        isComplete && subscriber.complete();
      };
      var cleanupDuration = function() {
        durationSubscriber = null;
        isComplete && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        hasValue = true;
        lastValue = value4;
        if (!durationSubscriber) {
          innerFrom_1.innerFrom(durationSelector(value4)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
        }
      }, function() {
        isComplete = true;
        (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.audit = undefined;
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.audit = audit;
});

// node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS((exports) => {
  var auditTime = function(duration, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return audit_1.audit(function() {
      return timer_1.timer(duration, scheduler);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.auditTime = undefined;
  var async_1 = require_async();
  var audit_1 = require_audit();
  var timer_1 = require_timer();
  exports.auditTime = auditTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer2 = __commonJS((exports) => {
  var buffer14 = function(closingNotifier) {
    return lift_1.operate(function(source, subscriber) {
      var currentBuffer = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return currentBuffer.push(value4);
      }, function() {
        subscriber.next(currentBuffer);
        subscriber.complete();
      }));
      innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        var b2 = currentBuffer;
        currentBuffer = [];
        subscriber.next(b2);
      }, noop_1.noop));
      return function() {
        currentBuffer = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buffer = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.buffer = buffer14;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS((exports) => {
  var bufferCount = function(bufferSize, startBufferEvery) {
    if (startBufferEvery === undefined) {
      startBufferEvery = null;
    }
    startBufferEvery = startBufferEvery !== null && startBufferEvery !== undefined ? startBufferEvery : bufferSize;
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      var count = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var e_1, _a, e_2, _b;
        var toEmit = null;
        if (count++ % startBufferEvery === 0) {
          buffers.push([]);
        }
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next();!buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer14 = buffers_1_1.value;
            buffer14.push(value4);
            if (bufferSize <= buffer14.length) {
              toEmit = toEmit !== null && toEmit !== undefined ? toEmit : [];
              toEmit.push(buffer14);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
              _a.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (toEmit) {
          try {
            for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next();!toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
              var buffer14 = toEmit_1_1.value;
              arrRemove_1.arrRemove(buffers, buffer14);
              subscriber.next(buffer14);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                _b.call(toEmit_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      }, function() {
        var e_3, _a;
        try {
          for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next();!buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
            var buffer14 = buffers_2_1.value;
            subscriber.next(buffer14);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
              _a.call(buffers_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        subscriber.complete();
      }, undefined, function() {
        buffers = null;
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferCount = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  exports.bufferCount = bufferCount;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS((exports) => {
  var bufferTime = function(bufferTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== undefined ? _a : async_1.asyncScheduler;
    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== undefined ? _b : null;
    var maxBufferSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var bufferRecords = [];
      var restartOnEmit = false;
      var emit = function(record) {
        var { buffer: buffer14, subs } = record;
        subs.unsubscribe();
        arrRemove_1.arrRemove(bufferRecords, record);
        subscriber.next(buffer14);
        restartOnEmit && startBuffer();
      };
      var startBuffer = function() {
        if (bufferRecords) {
          var subs = new Subscription_1.Subscription;
          subscriber.add(subs);
          var buffer14 = [];
          var record_1 = {
            buffer: buffer14,
            subs
          };
          bufferRecords.push(record_1);
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return emit(record_1);
          }, bufferTimeSpan);
        }
      };
      if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
      } else {
        restartOnEmit = true;
      }
      startBuffer();
      var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var e_1, _a2;
        var recordsCopy = bufferRecords.slice();
        try {
          for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next();!recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
            var record = recordsCopy_1_1.value;
            var buffer14 = record.buffer;
            buffer14.push(value4);
            maxBufferSize <= buffer14.length && emit(record);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
              _a2.call(recordsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (bufferRecords === null || bufferRecords === undefined ? undefined : bufferRecords.length) {
          subscriber.next(bufferRecords.shift().buffer);
        }
        bufferTimeSubscriber === null || bufferTimeSubscriber === undefined || bufferTimeSubscriber.unsubscribe();
        subscriber.complete();
        subscriber.unsubscribe();
      }, undefined, function() {
        return bufferRecords = null;
      });
      source.subscribe(bufferTimeSubscriber);
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferTime = undefined;
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  var async_1 = require_async();
  var args_1 = require_args();
  var executeSchedule_1 = require_executeSchedule();
  exports.bufferTime = bufferTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS((exports) => {
  var bufferToggle = function(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var buffer14 = [];
        buffers.push(buffer14);
        var closingSubscription = new Subscription_1.Subscription;
        var emitBuffer = function() {
          arrRemove_1.arrRemove(buffers, buffer14);
          subscriber.next(buffer14);
          closingSubscription.unsubscribe();
        };
        closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var e_1, _a;
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next();!buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer14 = buffers_1_1.value;
            buffer14.push(value4);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
              _a.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (buffers.length > 0) {
          subscriber.next(buffers.shift());
        }
        subscriber.complete();
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferToggle = undefined;
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var arrRemove_1 = require_arrRemove();
  exports.bufferToggle = bufferToggle;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS((exports) => {
  var bufferWhen = function(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffer14 = null;
      var closingSubscriber = null;
      var openBuffer = function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        var b2 = buffer14;
        buffer14 = [];
        b2 && subscriber.next(b2);
        innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
      };
      openBuffer();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return buffer14 === null || buffer14 === undefined ? undefined : buffer14.push(value4);
      }, function() {
        buffer14 && subscriber.next(buffer14);
        subscriber.complete();
      }, undefined, function() {
        return buffer14 = closingSubscriber = null;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferWhen = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.bufferWhen = bufferWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS((exports) => {
  var catchError = function(selector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function(err) {
        handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.catchError = undefined;
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var lift_1 = require_lift();
  exports.catchError = catchError;
});

// node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS((exports) => {
  var scanInternals = function(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state = seed;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var i = index++;
        state = hasState ? accumulator(state, value4, i) : (hasState = true, value4);
        emitOnNext && subscriber.next(state);
      }, emitBeforeComplete && function() {
        hasState && subscriber.next(state);
        subscriber.complete();
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scanInternals = undefined;
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.scanInternals = scanInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS((exports) => {
  var reduce = function(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reduce = undefined;
  var scanInternals_1 = require_scanInternals();
  var lift_1 = require_lift();
  exports.reduce = reduce;
});

// node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS((exports) => {
  var toArray = function() {
    return lift_1.operate(function(source, subscriber) {
      reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toArray = undefined;
  var reduce_1 = require_reduce();
  var lift_1 = require_lift();
  var arrReducer = function(arr, value4) {
    return arr.push(value4), arr;
  };
  exports.toArray = toArray;
});

// node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS((exports) => {
  var joinAllInternals = function(joinFn, project) {
    return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
      return joinFn(sources);
    }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.joinAllInternals = undefined;
  var identity_1 = require_identity();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var pipe_1 = require_pipe();
  var mergeMap_1 = require_mergeMap();
  var toArray_1 = require_toArray();
  exports.joinAllInternals = joinAllInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS((exports) => {
  var combineLatestAll = function(project) {
    return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestAll = undefined;
  var combineLatest_1 = require_combineLatest();
  var joinAllInternals_1 = require_joinAllInternals();
  exports.combineLatestAll = combineLatestAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineAll = undefined;
  var combineLatestAll_1 = require_combineLatestAll();
  exports.combineAll = combineLatestAll_1.combineLatestAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS((exports) => {
  var combineLatest = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    return resultSelector ? pipe_1.pipe(combineLatest.apply(undefined, __spreadArray([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
      combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatest = undefined;
  var combineLatest_1 = require_combineLatest();
  var lift_1 = require_lift();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var pipe_1 = require_pipe();
  var args_1 = require_args();
  exports.combineLatest = combineLatest;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS((exports) => {
  var combineLatestWith = function() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return combineLatest_1.combineLatest.apply(undefined, __spreadArray([], __read(otherSources)));
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestWith = undefined;
  var combineLatest_1 = require_combineLatest2();
  exports.combineLatestWith = combineLatestWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS((exports) => {
  var concatMap = function(project, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatMap = undefined;
  var mergeMap_1 = require_mergeMap();
  var isFunction_1 = require_isFunction();
  exports.concatMap = concatMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS((exports) => {
  var concatMapTo = function(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
      return innerObservable;
    }, resultSelector) : concatMap_1.concatMap(function() {
      return innerObservable;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatMapTo = undefined;
  var concatMap_1 = require_concatMap();
  var isFunction_1 = require_isFunction();
  exports.concatMapTo = concatMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS((exports) => {
  var concat3 = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    return lift_1.operate(function(source, subscriber) {
      concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = undefined;
  var lift_1 = require_lift();
  var concatAll_1 = require_concatAll();
  var args_1 = require_args();
  var from_1 = require_from();
  exports.concat = concat3;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS((exports) => {
  var concatWith = function() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return concat_1.concat.apply(undefined, __spreadArray([], __read(otherSources)));
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatWith = undefined;
  var concat_1 = require_concat2();
  exports.concatWith = concatWith;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS((exports) => {
  var fromSubscribable = function(subscribable) {
    return new Observable_1.Observable(function(subscriber) {
      return subscribable.subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromSubscribable = undefined;
  var Observable_1 = require_Observable();
  exports.fromSubscribable = fromSubscribable;
});

// node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = __commonJS((exports) => {
  var connect = function(selector, config) {
    if (config === undefined) {
      config = DEFAULT_CONFIG;
    }
    var connector = config.connector;
    return lift_1.operate(function(source, subscriber) {
      var subject = connector();
      innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
      subscriber.add(source.subscribe(subject));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.connect = undefined;
  var Subject_1 = require_Subject();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var fromSubscribable_1 = require_fromSubscribable();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject;
    }
  };
  exports.connect = connect;
});

// node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS((exports) => {
  var count = function(predicate) {
    return reduce_1.reduce(function(total, value4, i) {
      return !predicate || predicate(value4, i) ? total + 1 : total;
    }, 0);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.count = undefined;
  var reduce_1 = require_reduce();
  exports.count = count;
});

// node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS((exports) => {
  var debounce = function(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var emit = function() {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value4 = lastValue;
          lastValue = null;
          subscriber.next(value4);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        hasValue = true;
        lastValue = value4;
        durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
        innerFrom_1.innerFrom(durationSelector(value4)).subscribe(durationSubscriber);
      }, function() {
        emit();
        subscriber.complete();
      }, undefined, function() {
        lastValue = durationSubscriber = null;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debounce = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.debounce = debounce;
});

// node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS((exports) => {
  var debounceTime = function(dueTime, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var activeTask = null;
      var lastValue = null;
      var lastTime = null;
      var emit = function() {
        if (activeTask) {
          activeTask.unsubscribe();
          activeTask = null;
          var value4 = lastValue;
          lastValue = null;
          subscriber.next(value4);
        }
      };
      function emitWhenIdle() {
        var targetTime = lastTime + dueTime;
        var now = scheduler.now();
        if (now < targetTime) {
          activeTask = this.schedule(undefined, targetTime - now);
          subscriber.add(activeTask);
          return;
        }
        emit();
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        lastValue = value4;
        lastTime = scheduler.now();
        if (!activeTask) {
          activeTask = scheduler.schedule(emitWhenIdle, dueTime);
          subscriber.add(activeTask);
        }
      }, function() {
        emit();
        subscriber.complete();
      }, undefined, function() {
        lastValue = activeTask = null;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debounceTime = undefined;
  var async_1 = require_async();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.debounceTime = debounceTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS((exports) => {
  var defaultIfEmpty = function(defaultValue) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        hasValue = true;
        subscriber.next(value4);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultIfEmpty = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.defaultIfEmpty = defaultIfEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS((exports) => {
  var take = function(count) {
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        if (++seen <= count) {
          subscriber.next(value4);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.take = undefined;
  var empty_1 = require_empty();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.take = take;
});

// node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS((exports) => {
  var ignoreElements = function() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ignoreElements = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  exports.ignoreElements = ignoreElements;
});

// node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS((exports) => {
  var mapTo = function(value4) {
    return map_1.map(function() {
      return value4;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapTo = undefined;
  var map_1 = require_map();
  exports.mapTo = mapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS((exports) => {
  var delayWhen = function(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
      return function(source) {
        return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
      };
    }
    return mergeMap_1.mergeMap(function(value4, index) {
      return innerFrom_1.innerFrom(delayDurationSelector(value4, index)).pipe(take_1.take(1), mapTo_1.mapTo(value4));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delayWhen = undefined;
  var concat_1 = require_concat();
  var take_1 = require_take();
  var ignoreElements_1 = require_ignoreElements();
  var mapTo_1 = require_mapTo();
  var mergeMap_1 = require_mergeMap();
  var innerFrom_1 = require_innerFrom();
  exports.delayWhen = delayWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS((exports) => {
  var delay = function(due, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    var duration = timer_1.timer(due, scheduler);
    return delayWhen_1.delayWhen(function() {
      return duration;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = undefined;
  var async_1 = require_async();
  var delayWhen_1 = require_delayWhen();
  var timer_1 = require_timer();
  exports.delay = delay;
});

// node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS((exports) => {
  var dematerialize = function() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
        return Notification_1.observeNotification(notification, subscriber);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dematerialize = undefined;
  var Notification_1 = require_Notification();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.dematerialize = dematerialize;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS((exports) => {
  var distinct = function(keySelector, flushes) {
    return lift_1.operate(function(source, subscriber) {
      var distinctKeys = new Set;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var key = keySelector ? keySelector(value4) : value4;
        if (!distinctKeys.has(key)) {
          distinctKeys.add(key);
          subscriber.next(value4);
        }
      }));
      flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return distinctKeys.clear();
      }, noop_1.noop));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinct = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  exports.distinct = distinct;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS((exports) => {
  var distinctUntilChanged = function(comparator, keySelector) {
    if (keySelector === undefined) {
      keySelector = identity_1.identity;
    }
    comparator = comparator !== null && comparator !== undefined ? comparator : defaultCompare;
    return lift_1.operate(function(source, subscriber) {
      var previousKey;
      var first = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var currentKey = keySelector(value4);
        if (first || !comparator(previousKey, currentKey)) {
          first = false;
          previousKey = currentKey;
          subscriber.next(value4);
        }
      }));
    });
  };
  var defaultCompare = function(a, b2) {
    return a === b2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinctUntilChanged = undefined;
  var identity_1 = require_identity();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.distinctUntilChanged = distinctUntilChanged;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS((exports) => {
  var distinctUntilKeyChanged = function(key, compare4) {
    return distinctUntilChanged_1.distinctUntilChanged(function(x2, y2) {
      return compare4 ? compare4(x2[key], y2[key]) : x2[key] === y2[key];
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinctUntilKeyChanged = undefined;
  var distinctUntilChanged_1 = require_distinctUntilChanged();
  exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
});

// node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS((exports) => {
  var throwIfEmpty = function(errorFactory) {
    if (errorFactory === undefined) {
      errorFactory = defaultErrorFactory;
    }
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        hasValue = true;
        subscriber.next(value4);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  };
  var defaultErrorFactory = function() {
    return new EmptyError_1.EmptyError;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throwIfEmpty = undefined;
  var EmptyError_1 = require_EmptyError();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.throwIfEmpty = throwIfEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS((exports) => {
  var elementAt = function(index, defaultValue) {
    if (index < 0) {
      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    }
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(filter_1.filter(function(v, i) {
        return i === index;
      }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.elementAt = undefined;
  var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
  var filter_1 = require_filter();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var take_1 = require_take();
  exports.elementAt = elementAt;
});

// node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS((exports) => {
  var endWith = function() {
    var values = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    return function(source) {
      return concat_1.concat(source, of_1.of.apply(undefined, __spreadArray([], __read(values))));
    };
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.endWith = undefined;
  var concat_1 = require_concat();
  var of_1 = require_of();
  exports.endWith = endWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS((exports) => {
  var every = function(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        if (!predicate.call(thisArg, value4, index++, source)) {
          subscriber.next(false);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.every = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.every = every;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS((exports) => {
  var exhaustMap = function(project, resultSelector) {
    if (resultSelector) {
      return function(source) {
        return source.pipe(exhaustMap(function(a, i) {
          return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function(b2, ii) {
            return resultSelector(a, b2, i, ii);
          }));
        }));
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      var innerSub = null;
      var isComplete = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
        if (!innerSub) {
          innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
            innerSub = null;
            isComplete && subscriber.complete();
          });
          innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
        }
      }, function() {
        isComplete = true;
        !innerSub && subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaustMap = undefined;
  var map_1 = require_map();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.exhaustMap = exhaustMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS((exports) => {
  var exhaustAll = function() {
    return exhaustMap_1.exhaustMap(identity_1.identity);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaustAll = undefined;
  var exhaustMap_1 = require_exhaustMap();
  var identity_1 = require_identity();
  exports.exhaustAll = exhaustAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaust = undefined;
  var exhaustAll_1 = require_exhaustAll();
  exports.exhaust = exhaustAll_1.exhaustAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS((exports) => {
  var expand = function(project, concurrent, scheduler) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.expand = undefined;
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  exports.expand = expand;
});

// node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS((exports) => {
  var finalize = function(callback) {
    return lift_1.operate(function(source, subscriber) {
      try {
        source.subscribe(subscriber);
      } finally {
        subscriber.add(callback);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.finalize = undefined;
  var lift_1 = require_lift();
  exports.finalize = finalize;
});

// node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS((exports) => {
  var find = function(predicate, thisArg) {
    return lift_1.operate(createFind(predicate, thisArg, "value"));
  };
  var createFind = function(predicate, thisArg, emit) {
    var findIndex = emit === "index";
    return function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var i = index++;
        if (predicate.call(thisArg, value4, i, source)) {
          subscriber.next(findIndex ? i : value4);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(findIndex ? -1 : undefined);
        subscriber.complete();
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFind = exports.find = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.find = find;
  exports.createFind = createFind;
});

// node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS((exports) => {
  var findIndex = function(predicate, thisArg) {
    return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.findIndex = undefined;
  var lift_1 = require_lift();
  var find_1 = require_find();
  exports.findIndex = findIndex;
});

// node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS((exports) => {
  var first = function(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError;
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.first = undefined;
  var EmptyError_1 = require_EmptyError();
  var filter_1 = require_filter();
  var take_1 = require_take();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var identity_1 = require_identity();
  exports.first = first;
});

// node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS((exports) => {
  var groupBy = function(keySelector, elementOrOptions, duration, connector) {
    return lift_1.operate(function(source, subscriber) {
      var element;
      if (!elementOrOptions || typeof elementOrOptions === "function") {
        element = elementOrOptions;
      } else {
        duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
      }
      var groups = new Map;
      var notify = function(cb) {
        groups.forEach(cb);
        cb(subscriber);
      };
      var handleError = function(err) {
        return notify(function(consumer) {
          return consumer.error(err);
        });
      };
      var activeGroups = 0;
      var teardownAttempted = false;
      var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value4) {
        try {
          var key_1 = keySelector(value4);
          var group_1 = groups.get(key_1);
          if (!group_1) {
            groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject);
            var grouped = createGroupedObservable(key_1, group_1);
            subscriber.next(grouped);
            if (duration) {
              var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                group_1.complete();
                durationSubscriber_1 === null || durationSubscriber_1 === undefined || durationSubscriber_1.unsubscribe();
              }, undefined, undefined, function() {
                return groups.delete(key_1);
              });
              groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
            }
          }
          group_1.next(element ? element(value4) : value4);
        } catch (err) {
          handleError(err);
        }
      }, function() {
        return notify(function(consumer) {
          return consumer.complete();
        });
      }, handleError, function() {
        return groups.clear();
      }, function() {
        teardownAttempted = true;
        return activeGroups === 0;
      });
      source.subscribe(groupBySourceSubscriber);
      function createGroupedObservable(key, groupSubject) {
        var result = new Observable_1.Observable(function(groupSubscriber) {
          activeGroups++;
          var innerSub = groupSubject.subscribe(groupSubscriber);
          return function() {
            innerSub.unsubscribe();
            --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
          };
        });
        result.key = key;
        return result;
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.groupBy = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.groupBy = groupBy;
});

// node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS((exports) => {
  var isEmpty = function() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        subscriber.next(false);
        subscriber.complete();
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEmpty = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.isEmpty = isEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS((exports) => {
  var takeLast = function(count) {
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var buffer14 = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        buffer14.push(value4);
        count < buffer14.length && buffer14.shift();
      }, function() {
        var e_1, _a;
        try {
          for (var buffer_1 = __values(buffer14), buffer_1_1 = buffer_1.next();!buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
            var value4 = buffer_1_1.value;
            subscriber.next(value4);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
              _a.call(buffer_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      }, undefined, function() {
        buffer14 = null;
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeLast = undefined;
  var empty_1 = require_empty();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.takeLast = takeLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS((exports) => {
  var last = function(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError;
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.last = undefined;
  var EmptyError_1 = require_EmptyError();
  var filter_1 = require_filter();
  var takeLast_1 = require_takeLast();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var identity_1 = require_identity();
  exports.last = last;
});

// node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS((exports) => {
  var materialize = function() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        subscriber.next(Notification_1.Notification.createNext(value4));
      }, function() {
        subscriber.next(Notification_1.Notification.createComplete());
        subscriber.complete();
      }, function(err) {
        subscriber.next(Notification_1.Notification.createError(err));
        subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.materialize = undefined;
  var Notification_1 = require_Notification();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.materialize = materialize;
});

// node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS((exports) => {
  var max = function(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y2) {
      return comparer(x2, y2) > 0 ? x2 : y2;
    } : function(x2, y2) {
      return x2 > y2 ? x2 : y2;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.max = undefined;
  var reduce_1 = require_reduce();
  var isFunction_1 = require_isFunction();
  exports.max = max;
});

// node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flatMap = undefined;
  var mergeMap_1 = require_mergeMap();
  exports.flatMap = mergeMap_1.mergeMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS((exports) => {
  var mergeMapTo = function(innerObservable, resultSelector, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, resultSelector, concurrent);
    }
    if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return mergeMap_1.mergeMap(function() {
      return innerObservable;
    }, concurrent);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeMapTo = undefined;
  var mergeMap_1 = require_mergeMap();
  var isFunction_1 = require_isFunction();
  exports.mergeMapTo = mergeMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS((exports) => {
  var mergeScan = function(accumulator, seed, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    return lift_1.operate(function(source, subscriber) {
      var state = seed;
      return mergeInternals_1.mergeInternals(source, subscriber, function(value4, index) {
        return accumulator(state, value4, index);
      }, concurrent, function(value4) {
        state = value4;
      }, false, undefined, function() {
        return state = null;
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeScan = undefined;
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  exports.mergeScan = mergeScan;
});

// node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS((exports) => {
  var merge = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var concurrent = args_1.popNumber(args, Infinity);
    args = argsOrArgArray_1.argsOrArgArray(args);
    return lift_1.operate(function(source, subscriber) {
      mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var lift_1 = require_lift();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var mergeAll_1 = require_mergeAll();
  var args_1 = require_args();
  var from_1 = require_from();
  exports.merge = merge;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS((exports) => {
  var mergeWith = function() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return merge_1.merge.apply(undefined, __spreadArray([], __read(otherSources)));
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeWith = undefined;
  var merge_1 = require_merge2();
  exports.mergeWith = mergeWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS((exports) => {
  var min = function(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y2) {
      return comparer(x2, y2) < 0 ? x2 : y2;
    } : function(x2, y2) {
      return x2 < y2 ? x2 : y2;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.min = undefined;
  var reduce_1 = require_reduce();
  var isFunction_1 = require_isFunction();
  exports.min = min;
});

// node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS((exports) => {
  var multicast = function(subjectOrSubjectFactory, selector) {
    var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
      return subjectOrSubjectFactory;
    };
    if (isFunction_1.isFunction(selector)) {
      return connect_1.connect(selector, {
        connector: subjectFactory
      });
    }
    return function(source) {
      return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multicast = undefined;
  var ConnectableObservable_1 = require_ConnectableObservable();
  var isFunction_1 = require_isFunction();
  var connect_1 = require_connect();
  exports.multicast = multicast;
});

// node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS((exports) => {
  var onErrorResumeNextWith = function() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return function(source) {
      return onErrorResumeNext_1.onErrorResumeNext.apply(undefined, __spreadArray([source], __read(nextSources)));
    };
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.onErrorResumeNext = exports.onErrorResumeNextWith = undefined;
  var argsOrArgArray_1 = require_argsOrArgArray();
  var onErrorResumeNext_1 = require_onErrorResumeNext();
  exports.onErrorResumeNextWith = onErrorResumeNextWith;
  exports.onErrorResumeNext = onErrorResumeNextWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS((exports) => {
  var pairwise = function() {
    return lift_1.operate(function(source, subscriber) {
      var prev;
      var hasPrev = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var p = prev;
        prev = value4;
        hasPrev && subscriber.next([p, value4]);
        hasPrev = true;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pairwise = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.pairwise = pairwise;
});

// node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS((exports) => {
  var pluck = function() {
    var properties = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
      throw new Error("list of properties cannot be empty.");
    }
    return map_1.map(function(x2) {
      var currentProp = x2;
      for (var i = 0;i < length; i++) {
        var p = currentProp === null || currentProp === undefined ? undefined : currentProp[properties[i]];
        if (typeof p !== "undefined") {
          currentProp = p;
        } else {
          return;
        }
      }
      return currentProp;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pluck = undefined;
  var map_1 = require_map();
  exports.pluck = pluck;
});

// node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS((exports) => {
  var publish = function(selector) {
    return selector ? function(source) {
      return connect_1.connect(selector)(source);
    } : function(source) {
      return multicast_1.multicast(new Subject_1.Subject)(source);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publish = undefined;
  var Subject_1 = require_Subject();
  var multicast_1 = require_multicast();
  var connect_1 = require_connect();
  exports.publish = publish;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS((exports) => {
  var publishBehavior = function(initialValue) {
    return function(source) {
      var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishBehavior = undefined;
  var BehaviorSubject_1 = require_BehaviorSubject();
  var ConnectableObservable_1 = require_ConnectableObservable();
  exports.publishBehavior = publishBehavior;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS((exports) => {
  var publishLast = function() {
    return function(source) {
      var subject = new AsyncSubject_1.AsyncSubject;
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishLast = undefined;
  var AsyncSubject_1 = require_AsyncSubject();
  var ConnectableObservable_1 = require_ConnectableObservable();
  exports.publishLast = publishLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS((exports) => {
  var publishReplay = function(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
    if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
      timestampProvider = selectorOrScheduler;
    }
    var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;
    return function(source) {
      return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishReplay = undefined;
  var ReplaySubject_1 = require_ReplaySubject();
  var multicast_1 = require_multicast();
  var isFunction_1 = require_isFunction();
  exports.publishReplay = publishReplay;
});

// node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS((exports) => {
  var raceWith = function() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.raceWith = undefined;
  var race_1 = require_race();
  var lift_1 = require_lift();
  var identity_1 = require_identity();
  exports.raceWith = raceWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS((exports) => {
  var repeat = function(countOrConfig) {
    var _a;
    var count = Infinity;
    var delay;
    if (countOrConfig != null) {
      if (typeof countOrConfig === "object") {
        _a = countOrConfig.count, count = _a === undefined ? Infinity : _a, delay = countOrConfig.delay;
      } else {
        count = countOrConfig;
      }
    }
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var sourceSub;
      var resubscribe = function() {
        sourceSub === null || sourceSub === undefined || sourceSub.unsubscribe();
        sourceSub = null;
        if (delay != null) {
          var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
          var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            notifierSubscriber_1.unsubscribe();
            subscribeToSource();
          });
          notifier.subscribe(notifierSubscriber_1);
        } else {
          subscribeToSource();
        }
      };
      var subscribeToSource = function() {
        var syncUnsub = false;
        sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
          if (++soFar < count) {
            if (sourceSub) {
              resubscribe();
            } else {
              syncUnsub = true;
            }
          } else {
            subscriber.complete();
          }
        }));
        if (syncUnsub) {
          resubscribe();
        }
      };
      subscribeToSource();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.repeat = undefined;
  var empty_1 = require_empty();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var timer_1 = require_timer();
  exports.repeat = repeat;
});

// node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS((exports) => {
  var repeatWhen = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var completions$;
      var isNotifierComplete = false;
      var isMainComplete = false;
      var checkComplete = function() {
        return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
      };
      var getCompletionSubject = function() {
        if (!completions$) {
          completions$ = new Subject_1.Subject;
          innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            if (innerSub) {
              subscribeForRepeatWhen();
            } else {
              syncResub = true;
            }
          }, function() {
            isNotifierComplete = true;
            checkComplete();
          }));
        }
        return completions$;
      };
      var subscribeForRepeatWhen = function() {
        isMainComplete = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
          isMainComplete = true;
          !checkComplete() && getCompletionSubject().next();
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRepeatWhen();
        }
      };
      subscribeForRepeatWhen();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.repeatWhen = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.repeatWhen = repeatWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS((exports) => {
  var retry = function(configOrCount) {
    if (configOrCount === undefined) {
      configOrCount = Infinity;
    }
    var config;
    if (configOrCount && typeof configOrCount === "object") {
      config = configOrCount;
    } else {
      config = {
        count: configOrCount
      };
    }
    var _a = config.count, count = _a === undefined ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === undefined ? false : _b;
    return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var innerSub;
      var subscribeForRetry = function() {
        var syncUnsub = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
          if (resetOnSuccess) {
            soFar = 0;
          }
          subscriber.next(value4);
        }, undefined, function(err) {
          if (soFar++ < count) {
            var resub_1 = function() {
              if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                subscribeForRetry();
              } else {
                syncUnsub = true;
              }
            };
            if (delay != null) {
              var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
              var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                notifierSubscriber_1.unsubscribe();
                resub_1();
              }, function() {
                subscriber.complete();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              resub_1();
            }
          } else {
            subscriber.error(err);
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          subscribeForRetry();
        }
      };
      subscribeForRetry();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retry = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var identity_1 = require_identity();
  var timer_1 = require_timer();
  var innerFrom_1 = require_innerFrom();
  exports.retry = retry;
});

// node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS((exports) => {
  var retryWhen = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var errors$;
      var subscribeForRetryWhen = function() {
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function(err) {
          if (!errors$) {
            errors$ = new Subject_1.Subject;
            innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              return innerSub ? subscribeForRetryWhen() : syncResub = true;
            }));
          }
          if (errors$) {
            errors$.next(err);
          }
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRetryWhen();
        }
      };
      subscribeForRetryWhen();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryWhen = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.retryWhen = retryWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS((exports) => {
  var sample = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        hasValue = true;
        lastValue = value4;
      }));
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        if (hasValue) {
          hasValue = false;
          var value4 = lastValue;
          lastValue = null;
          subscriber.next(value4);
        }
      }, noop_1.noop));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sample = undefined;
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.sample = sample;
});

// node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS((exports) => {
  var sampleTime = function(period, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return sample_1.sample(interval_1.interval(period, scheduler));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sampleTime = undefined;
  var async_1 = require_async();
  var sample_1 = require_sample();
  var interval_1 = require_interval();
  exports.sampleTime = sampleTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS((exports) => {
  var scan = function(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scan = undefined;
  var lift_1 = require_lift();
  var scanInternals_1 = require_scanInternals();
  exports.scan = scan;
});

// node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS((exports) => {
  var sequenceEqual = function(compareTo, comparator) {
    if (comparator === undefined) {
      comparator = function(a, b2) {
        return a === b2;
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var aState = createState();
      var bState = createState();
      var emit = function(isEqual) {
        subscriber.next(isEqual);
        subscriber.complete();
      };
      var createSubscriber = function(selfState, otherState) {
        var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
          var { buffer: buffer14, complete } = otherState;
          if (buffer14.length === 0) {
            complete ? emit(false) : selfState.buffer.push(a);
          } else {
            !comparator(a, buffer14.shift()) && emit(false);
          }
        }, function() {
          selfState.complete = true;
          var { complete, buffer: buffer14 } = otherState;
          complete && emit(buffer14.length === 0);
          sequenceEqualSubscriber === null || sequenceEqualSubscriber === undefined || sequenceEqualSubscriber.unsubscribe();
        });
        return sequenceEqualSubscriber;
      };
      source.subscribe(createSubscriber(aState, bState));
      innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
    });
  };
  var createState = function() {
    return {
      buffer: [],
      complete: false
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sequenceEqual = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.sequenceEqual = sequenceEqual;
});

// node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS((exports) => {
  var share = function(options) {
    if (options === undefined) {
      options = {};
    }
    var _a = options.connector, connector = _a === undefined ? function() {
      return new Subject_1.Subject;
    } : _a, _b = options.resetOnError, resetOnError = _b === undefined ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === undefined ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === undefined ? true : _d;
    return function(wrapperSource) {
      var connection;
      var resetConnection;
      var subject;
      var refCount = 0;
      var hasCompleted = false;
      var hasErrored = false;
      var cancelReset = function() {
        resetConnection === null || resetConnection === undefined || resetConnection.unsubscribe();
        resetConnection = undefined;
      };
      var reset = function() {
        cancelReset();
        connection = subject = undefined;
        hasCompleted = hasErrored = false;
      };
      var resetAndUnsubscribe = function() {
        var conn = connection;
        reset();
        conn === null || conn === undefined || conn.unsubscribe();
      };
      return lift_1.operate(function(source, subscriber) {
        refCount++;
        if (!hasErrored && !hasCompleted) {
          cancelReset();
        }
        var dest = subject = subject !== null && subject !== undefined ? subject : connector();
        subscriber.add(function() {
          refCount--;
          if (refCount === 0 && !hasErrored && !hasCompleted) {
            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
          }
        });
        dest.subscribe(subscriber);
        if (!connection && refCount > 0) {
          connection = new Subscriber_1.SafeSubscriber({
            next: function(value4) {
              return dest.next(value4);
            },
            error: function(err) {
              hasErrored = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnError, err);
              dest.error(err);
            },
            complete: function() {
              hasCompleted = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnComplete);
              dest.complete();
            }
          });
          innerFrom_1.innerFrom(source).subscribe(connection);
        }
      })(wrapperSource);
    };
  };
  var handleReset = function(reset, on) {
    var args = [];
    for (var _i = 2;_i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    if (on === true) {
      reset();
      return;
    }
    if (on === false) {
      return;
    }
    var onSubscriber = new Subscriber_1.SafeSubscriber({
      next: function() {
        onSubscriber.unsubscribe();
        reset();
      }
    });
    return innerFrom_1.innerFrom(on.apply(undefined, __spreadArray([], __read(args)))).subscribe(onSubscriber);
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.share = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var Subscriber_1 = require_Subscriber();
  var lift_1 = require_lift();
  exports.share = share;
});

// node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS((exports) => {
  var shareReplay = function(configOrBufferSize, windowTime, scheduler) {
    var _a, _b, _c;
    var bufferSize;
    var refCount = false;
    if (configOrBufferSize && typeof configOrBufferSize === "object") {
      _a = configOrBufferSize.bufferSize, bufferSize = _a === undefined ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === undefined ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === undefined ? false : _c, scheduler = configOrBufferSize.scheduler;
    } else {
      bufferSize = configOrBufferSize !== null && configOrBufferSize !== undefined ? configOrBufferSize : Infinity;
    }
    return share_1.share({
      connector: function() {
        return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
      },
      resetOnError: true,
      resetOnComplete: false,
      resetOnRefCountZero: refCount
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shareReplay = undefined;
  var ReplaySubject_1 = require_ReplaySubject();
  var share_1 = require_share();
  exports.shareReplay = shareReplay;
});

// node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS((exports) => {
  var single = function(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var singleValue;
      var seenValue = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        seenValue = true;
        if (!predicate || predicate(value4, index++, source)) {
          hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
          hasValue = true;
          singleValue = value4;
        }
      }, function() {
        if (hasValue) {
          subscriber.next(singleValue);
          subscriber.complete();
        } else {
          subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError);
        }
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.single = undefined;
  var EmptyError_1 = require_EmptyError();
  var SequenceError_1 = require_SequenceError();
  var NotFoundError_1 = require_NotFoundError();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.single = single;
});

// node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS((exports) => {
  var skip = function(count) {
    return filter_1.filter(function(_2, index) {
      return count <= index;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skip = undefined;
  var filter_1 = require_filter();
  exports.skip = skip;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS((exports) => {
  var skipLast = function(skipCount) {
    return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var ring = new Array(skipCount);
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var valueIndex = seen++;
        if (valueIndex < skipCount) {
          ring[valueIndex] = value4;
        } else {
          var index = valueIndex % skipCount;
          var oldValue = ring[index];
          ring[index] = value4;
          subscriber.next(oldValue);
        }
      }));
      return function() {
        ring = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipLast = undefined;
  var identity_1 = require_identity();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.skipLast = skipLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS((exports) => {
  var skipUntil = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        skipSubscriber === null || skipSubscriber === undefined || skipSubscriber.unsubscribe();
        taking = true;
      }, noop_1.noop);
      innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return taking && subscriber.next(value4);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipUntil = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var noop_1 = require_noop();
  exports.skipUntil = skipUntil;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS((exports) => {
  var skipWhile = function(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return (taking || (taking = !predicate(value4, index++))) && subscriber.next(value4);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipWhile = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.skipWhile = skipWhile;
});

// node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS((exports) => {
  var startWith = function() {
    var values = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(values);
    return lift_1.operate(function(source, subscriber) {
      (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.startWith = undefined;
  var concat_1 = require_concat();
  var args_1 = require_args();
  var lift_1 = require_lift();
  exports.startWith = startWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS((exports) => {
  var switchMap = function(project, resultSelector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        innerSubscriber === null || innerSubscriber === undefined || innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom_1.innerFrom(project(value4, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value4, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchMap = undefined;
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.switchMap = switchMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS((exports) => {
  var switchAll = function() {
    return switchMap_1.switchMap(identity_1.identity);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchAll = undefined;
  var switchMap_1 = require_switchMap();
  var identity_1 = require_identity();
  exports.switchAll = switchAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS((exports) => {
  var switchMapTo = function(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
      return innerObservable;
    }, resultSelector) : switchMap_1.switchMap(function() {
      return innerObservable;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchMapTo = undefined;
  var switchMap_1 = require_switchMap();
  var isFunction_1 = require_isFunction();
  exports.switchMapTo = switchMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS((exports) => {
  var switchScan = function(accumulator, seed) {
    return lift_1.operate(function(source, subscriber) {
      var state = seed;
      switchMap_1.switchMap(function(value4, index) {
        return accumulator(state, value4, index);
      }, function(_2, innerValue) {
        return state = innerValue, innerValue;
      })(source).subscribe(subscriber);
      return function() {
        state = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchScan = undefined;
  var switchMap_1 = require_switchMap();
  var lift_1 = require_lift();
  exports.switchScan = switchScan;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS((exports) => {
  var takeUntil = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop_1.noop));
      !subscriber.closed && source.subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeUntil = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var noop_1 = require_noop();
  exports.takeUntil = takeUntil;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS((exports) => {
  var takeWhile = function(predicate, inclusive) {
    if (inclusive === undefined) {
      inclusive = false;
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var result = predicate(value4, index++);
        (result || inclusive) && subscriber.next(value4);
        !result && subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeWhile = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.takeWhile = takeWhile;
});

// node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS((exports) => {
  var tap = function(observerOrNext, error, complete) {
    var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
    return tapObserver ? lift_1.operate(function(source, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === undefined || _a.call(tapObserver);
      var isUnsub = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === undefined || _a2.call(tapObserver, value4);
        subscriber.next(value4);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === undefined || _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === undefined || _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === undefined || _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === undefined || _b.call(tapObserver);
      }));
    }) : identity_1.identity;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tap = undefined;
  var isFunction_1 = require_isFunction();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var identity_1 = require_identity();
  exports.tap = tap;
});

// node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS((exports) => {
  var throttle2 = function(durationSelector, config) {
    return lift_1.operate(function(source, subscriber) {
      var _a = config !== null && config !== undefined ? config : {}, _b = _a.leading, leading = _b === undefined ? true : _b, _c = _a.trailing, trailing = _c === undefined ? false : _c;
      var hasValue = false;
      var sendValue = null;
      var throttled = null;
      var isComplete = false;
      var endThrottling = function() {
        throttled === null || throttled === undefined || throttled.unsubscribe();
        throttled = null;
        if (trailing) {
          send();
          isComplete && subscriber.complete();
        }
      };
      var cleanupThrottling = function() {
        throttled = null;
        isComplete && subscriber.complete();
      };
      var startThrottle = function(value4) {
        return throttled = innerFrom_1.innerFrom(durationSelector(value4)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
      };
      var send = function() {
        if (hasValue) {
          hasValue = false;
          var value4 = sendValue;
          sendValue = null;
          subscriber.next(value4);
          !isComplete && startThrottle(value4);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        hasValue = true;
        sendValue = value4;
        !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value4));
      }, function() {
        isComplete = true;
        !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttle = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.throttle = throttle2;
});

// node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS((exports) => {
  var throttleTime = function(duration, scheduler, config) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    var duration$ = timer_1.timer(duration, scheduler);
    return throttle_1.throttle(function() {
      return duration$;
    }, config);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttleTime = undefined;
  var async_1 = require_async();
  var throttle_1 = require_throttle();
  var timer_1 = require_timer();
  exports.throttleTime = throttleTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS((exports) => {
  var timeInterval = function(scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var last = scheduler.now();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var now = scheduler.now();
        var interval = now - last;
        last = now;
        subscriber.next(new TimeInterval(value4, interval));
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TimeInterval = exports.timeInterval = undefined;
  var async_1 = require_async();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.timeInterval = timeInterval;
  var TimeInterval = function() {
    function TimeInterval2(value4, interval) {
      this.value = value4;
      this.interval = interval;
    }
    return TimeInterval2;
  }();
  exports.TimeInterval = TimeInterval;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS((exports) => {
  var timeoutWith = function(due, withObservable, scheduler) {
    var first;
    var each;
    var _with;
    scheduler = scheduler !== null && scheduler !== undefined ? scheduler : async_1.async;
    if (isDate_1.isValidDate(due)) {
      first = due;
    } else if (typeof due === "number") {
      each = due;
    }
    if (withObservable) {
      _with = function() {
        return withObservable;
      };
    } else {
      throw new TypeError("No observable provided to switch to");
    }
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return timeout_1.timeout({
      first,
      each,
      scheduler,
      with: _with
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutWith = undefined;
  var async_1 = require_async();
  var isDate_1 = require_isDate();
  var timeout_1 = require_timeout();
  exports.timeoutWith = timeoutWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var timestamp = function(timestampProvider) {
    if (timestampProvider === undefined) {
      timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
    }
    return map_1.map(function(value4) {
      return { value: value4, timestamp: timestampProvider.now() };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timestamp = undefined;
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var map_1 = require_map();
  exports.timestamp = timestamp;
});

// node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS((exports) => {
  var window2 = function(windowBoundaries) {
    return lift_1.operate(function(source, subscriber) {
      var windowSubject = new Subject_1.Subject;
      subscriber.next(windowSubject.asObservable());
      var errorHandler = function(err) {
        windowSubject.error(err);
        subscriber.error(err);
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return windowSubject === null || windowSubject === undefined ? undefined : windowSubject.next(value4);
      }, function() {
        windowSubject.complete();
        subscriber.complete();
      }, errorHandler));
      innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        windowSubject.complete();
        subscriber.next(windowSubject = new Subject_1.Subject);
      }, noop_1.noop, errorHandler));
      return function() {
        windowSubject === null || windowSubject === undefined || windowSubject.unsubscribe();
        windowSubject = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.window = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  exports.window = window2;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS((exports) => {
  var windowCount = function(windowSize, startWindowEvery) {
    if (startWindowEvery === undefined) {
      startWindowEvery = 0;
    }
    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
    return lift_1.operate(function(source, subscriber) {
      var windows = [new Subject_1.Subject];
      var starts = [];
      var count = 0;
      subscriber.next(windows[0].asObservable());
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var e_1, _a;
        try {
          for (var windows_1 = __values(windows), windows_1_1 = windows_1.next();!windows_1_1.done; windows_1_1 = windows_1.next()) {
            var window_1 = windows_1_1.value;
            window_1.next(value4);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
              _a.call(windows_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var c2 = count - windowSize + 1;
        if (c2 >= 0 && c2 % startEvery === 0) {
          windows.shift().complete();
        }
        if (++count % startEvery === 0) {
          var window_2 = new Subject_1.Subject;
          windows.push(window_2);
          subscriber.next(window_2.asObservable());
        }
      }, function() {
        while (windows.length > 0) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, function(err) {
        while (windows.length > 0) {
          windows.shift().error(err);
        }
        subscriber.error(err);
      }, function() {
        starts = null;
        windows = null;
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowCount = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.windowCount = windowCount;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS((exports) => {
  var windowTime = function(windowTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== undefined ? _a : async_1.asyncScheduler;
    var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== undefined ? _b : null;
    var maxWindowSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var windowRecords = [];
      var restartOnClose = false;
      var closeWindow = function(record) {
        var { window: window2, subs } = record;
        window2.complete();
        subs.unsubscribe();
        arrRemove_1.arrRemove(windowRecords, record);
        restartOnClose && startWindow();
      };
      var startWindow = function() {
        if (windowRecords) {
          var subs = new Subscription_1.Subscription;
          subscriber.add(subs);
          var window_1 = new Subject_1.Subject;
          var record_1 = {
            window: window_1,
            subs,
            seen: 0
          };
          windowRecords.push(record_1);
          subscriber.next(window_1.asObservable());
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return closeWindow(record_1);
          }, windowTimeSpan);
        }
      };
      if (windowCreationInterval !== null && windowCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
      } else {
        restartOnClose = true;
      }
      startWindow();
      var loop = function(cb) {
        return windowRecords.slice().forEach(cb);
      };
      var terminate = function(cb) {
        loop(function(_a2) {
          var window2 = _a2.window;
          return cb(window2);
        });
        cb(subscriber);
        subscriber.unsubscribe();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        loop(function(record) {
          record.window.next(value4);
          maxWindowSize <= ++record.seen && closeWindow(record);
        });
      }, function() {
        return terminate(function(consumer) {
          return consumer.complete();
        });
      }, function(err) {
        return terminate(function(consumer) {
          return consumer.error(err);
        });
      }));
      return function() {
        windowRecords = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowTime = undefined;
  var Subject_1 = require_Subject();
  var async_1 = require_async();
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  var args_1 = require_args();
  var executeSchedule_1 = require_executeSchedule();
  exports.windowTime = windowTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS((exports) => {
  var windowToggle = function(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var windows = [];
      var handleError = function(err) {
        while (0 < windows.length) {
          windows.shift().error(err);
        }
        subscriber.error(err);
      };
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var window2 = new Subject_1.Subject;
        windows.push(window2);
        var closingSubscription = new Subscription_1.Subscription;
        var closeWindow = function() {
          arrRemove_1.arrRemove(windows, window2);
          window2.complete();
          closingSubscription.unsubscribe();
        };
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
        } catch (err) {
          handleError(err);
          return;
        }
        subscriber.next(window2.asObservable());
        closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var e_1, _a;
        var windowsCopy = windows.slice();
        try {
          for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next();!windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
            var window_1 = windowsCopy_1_1.value;
            window_1.next(value4);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
              _a.call(windowsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (0 < windows.length) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, handleError, function() {
        while (0 < windows.length) {
          windows.shift().unsubscribe();
        }
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowToggle = undefined;
  var Subject_1 = require_Subject();
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var arrRemove_1 = require_arrRemove();
  exports.windowToggle = windowToggle;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS((exports) => {
  var windowWhen = function(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var window2;
      var closingSubscriber;
      var handleError = function(err) {
        window2.error(err);
        subscriber.error(err);
      };
      var openWindow = function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        window2 === null || window2 === undefined || window2.complete();
        window2 = new Subject_1.Subject;
        subscriber.next(window2.asObservable());
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector());
        } catch (err) {
          handleError(err);
          return;
        }
        closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
      };
      openWindow();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return window2.next(value4);
      }, function() {
        window2.complete();
        subscriber.complete();
      }, handleError, function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        window2 = null;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowWhen = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.windowWhen = windowWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS((exports) => {
  var withLatestFrom = function() {
    var inputs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      inputs[_i] = arguments[_i];
    }
    var project = args_1.popResultSelector(inputs);
    return lift_1.operate(function(source, subscriber) {
      var len = inputs.length;
      var otherValues = new Array(len);
      var hasValue = inputs.map(function() {
        return false;
      });
      var ready = false;
      var _loop_1 = function(i2) {
        innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
          otherValues[i2] = value4;
          if (!ready && !hasValue[i2]) {
            hasValue[i2] = true;
            (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
          }
        }, noop_1.noop));
      };
      for (var i = 0;i < len; i++) {
        _loop_1(i);
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        if (ready) {
          var values = __spreadArray([value4], __read(otherValues));
          subscriber.next(project ? project.apply(undefined, __spreadArray([], __read(values))) : values);
        }
      }));
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.withLatestFrom = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var identity_1 = require_identity();
  var noop_1 = require_noop();
  var args_1 = require_args();
  exports.withLatestFrom = withLatestFrom;
});

// node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS((exports) => {
  var zipAll = function(project) {
    return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zipAll = undefined;
  var zip_1 = require_zip();
  var joinAllInternals_1 = require_joinAllInternals();
  exports.zipAll = zipAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS((exports) => {
  var zip = function() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    return lift_1.operate(function(source, subscriber) {
      zip_1.zip.apply(undefined, __spreadArray([source], __read(sources))).subscribe(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zip = undefined;
  var zip_1 = require_zip();
  var lift_1 = require_lift();
  exports.zip = zip;
});

// node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS((exports) => {
  var zipWith = function() {
    var otherInputs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherInputs[_i] = arguments[_i];
    }
    return zip_1.zip.apply(undefined, __spreadArray([], __read(otherInputs)));
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j2 = to.length;i < il; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zipWith = undefined;
  var zip_1 = require_zip2();
  exports.zipWith = zipWith;
});

// node_modules/rxjs/dist/cjs/index.js
var require_cjs3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m[k2];
    } });
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = undefined;
  exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = undefined;
  exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = undefined;
  exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = undefined;
  var Observable_1 = require_Observable();
  Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
    return Observable_1.Observable;
  } });
  var ConnectableObservable_1 = require_ConnectableObservable();
  Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
    return ConnectableObservable_1.ConnectableObservable;
  } });
  var observable_1 = require_observable();
  Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
    return observable_1.observable;
  } });
  var animationFrames_1 = require_animationFrames();
  Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
    return animationFrames_1.animationFrames;
  } });
  var Subject_1 = require_Subject();
  Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
    return Subject_1.Subject;
  } });
  var BehaviorSubject_1 = require_BehaviorSubject();
  Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
    return BehaviorSubject_1.BehaviorSubject;
  } });
  var ReplaySubject_1 = require_ReplaySubject();
  Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
    return ReplaySubject_1.ReplaySubject;
  } });
  var AsyncSubject_1 = require_AsyncSubject();
  Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
    return AsyncSubject_1.AsyncSubject;
  } });
  var asap_1 = require_asap();
  Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
    return asap_1.asap;
  } });
  Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
    return asap_1.asapScheduler;
  } });
  var async_1 = require_async();
  Object.defineProperty(exports, "async", { enumerable: true, get: function() {
    return async_1.async;
  } });
  Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
    return async_1.asyncScheduler;
  } });
  var queue_1 = require_queue();
  Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
    return queue_1.queue;
  } });
  Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
    return queue_1.queueScheduler;
  } });
  var animationFrame_1 = require_animationFrame();
  Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
    return animationFrame_1.animationFrame;
  } });
  Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
    return animationFrame_1.animationFrameScheduler;
  } });
  var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
  Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualTimeScheduler;
  } });
  Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualAction;
  } });
  var Scheduler_1 = require_Scheduler();
  Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
    return Scheduler_1.Scheduler;
  } });
  var Subscription_1 = require_Subscription();
  Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
    return Subscription_1.Subscription;
  } });
  var Subscriber_1 = require_Subscriber();
  Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
    return Subscriber_1.Subscriber;
  } });
  var Notification_1 = require_Notification();
  Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
    return Notification_1.Notification;
  } });
  Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
    return Notification_1.NotificationKind;
  } });
  var pipe_1 = require_pipe();
  Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
    return pipe_1.pipe;
  } });
  var noop_1 = require_noop();
  Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
    return noop_1.noop;
  } });
  var identity_1 = require_identity();
  Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
    return identity_1.identity;
  } });
  var isObservable_1 = require_isObservable();
  Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
    return isObservable_1.isObservable;
  } });
  var lastValueFrom_1 = require_lastValueFrom();
  Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
    return lastValueFrom_1.lastValueFrom;
  } });
  var firstValueFrom_1 = require_firstValueFrom();
  Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
    return firstValueFrom_1.firstValueFrom;
  } });
  var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
  Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
    return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
  } });
  var EmptyError_1 = require_EmptyError();
  Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
    return EmptyError_1.EmptyError;
  } });
  var NotFoundError_1 = require_NotFoundError();
  Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
    return NotFoundError_1.NotFoundError;
  } });
  var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
  Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
    return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
  } });
  var SequenceError_1 = require_SequenceError();
  Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
    return SequenceError_1.SequenceError;
  } });
  var timeout_1 = require_timeout();
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return timeout_1.TimeoutError;
  } });
  var UnsubscriptionError_1 = require_UnsubscriptionError();
  Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
    return UnsubscriptionError_1.UnsubscriptionError;
  } });
  var bindCallback_1 = require_bindCallback();
  Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
    return bindCallback_1.bindCallback;
  } });
  var bindNodeCallback_1 = require_bindNodeCallback();
  Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
    return bindNodeCallback_1.bindNodeCallback;
  } });
  var combineLatest_1 = require_combineLatest();
  Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
    return combineLatest_1.combineLatest;
  } });
  var concat_1 = require_concat();
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return concat_1.concat;
  } });
  var connectable_1 = require_connectable();
  Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
    return connectable_1.connectable;
  } });
  var defer_1 = require_defer();
  Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
    return defer_1.defer;
  } });
  var empty_1 = require_empty();
  Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
    return empty_1.empty;
  } });
  var forkJoin_1 = require_forkJoin();
  Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
    return forkJoin_1.forkJoin;
  } });
  var from_1 = require_from();
  Object.defineProperty(exports, "from", { enumerable: true, get: function() {
    return from_1.from;
  } });
  var fromEvent_1 = require_fromEvent();
  Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
    return fromEvent_1.fromEvent;
  } });
  var fromEventPattern_1 = require_fromEventPattern();
  Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
    return fromEventPattern_1.fromEventPattern;
  } });
  var generate_1 = require_generate();
  Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
    return generate_1.generate;
  } });
  var iif_1 = require_iif();
  Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
    return iif_1.iif;
  } });
  var interval_1 = require_interval();
  Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
    return interval_1.interval;
  } });
  var merge_1 = require_merge();
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_1.merge;
  } });
  var never_1 = require_never();
  Object.defineProperty(exports, "never", { enumerable: true, get: function() {
    return never_1.never;
  } });
  var of_1 = require_of();
  Object.defineProperty(exports, "of", { enumerable: true, get: function() {
    return of_1.of;
  } });
  var onErrorResumeNext_1 = require_onErrorResumeNext();
  Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
    return onErrorResumeNext_1.onErrorResumeNext;
  } });
  var pairs_1 = require_pairs();
  Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
    return pairs_1.pairs;
  } });
  var partition_1 = require_partition();
  Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
    return partition_1.partition;
  } });
  var race_1 = require_race();
  Object.defineProperty(exports, "race", { enumerable: true, get: function() {
    return race_1.race;
  } });
  var range_1 = require_range();
  Object.defineProperty(exports, "range", { enumerable: true, get: function() {
    return range_1.range;
  } });
  var throwError_1 = require_throwError();
  Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
    return throwError_1.throwError;
  } });
  var timer_1 = require_timer();
  Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
    return timer_1.timer;
  } });
  var using_1 = require_using();
  Object.defineProperty(exports, "using", { enumerable: true, get: function() {
    return using_1.using;
  } });
  var zip_1 = require_zip();
  Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
    return zip_1.zip;
  } });
  var scheduled_1 = require_scheduled();
  Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
    return scheduled_1.scheduled;
  } });
  var empty_2 = require_empty();
  Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
    return empty_2.EMPTY;
  } });
  var never_2 = require_never();
  Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
    return never_2.NEVER;
  } });
  __exportStar(require_types2(), exports);
  var config_1 = require_config();
  Object.defineProperty(exports, "config", { enumerable: true, get: function() {
    return config_1.config;
  } });
  var audit_1 = require_audit();
  Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
    return audit_1.audit;
  } });
  var auditTime_1 = require_auditTime();
  Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
    return auditTime_1.auditTime;
  } });
  var buffer_1 = require_buffer2();
  Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
    return buffer_1.buffer;
  } });
  var bufferCount_1 = require_bufferCount();
  Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
    return bufferCount_1.bufferCount;
  } });
  var bufferTime_1 = require_bufferTime();
  Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
    return bufferTime_1.bufferTime;
  } });
  var bufferToggle_1 = require_bufferToggle();
  Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
    return bufferToggle_1.bufferToggle;
  } });
  var bufferWhen_1 = require_bufferWhen();
  Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
    return bufferWhen_1.bufferWhen;
  } });
  var catchError_1 = require_catchError();
  Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
    return catchError_1.catchError;
  } });
  var combineAll_1 = require_combineAll();
  Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
    return combineAll_1.combineAll;
  } });
  var combineLatestAll_1 = require_combineLatestAll();
  Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
    return combineLatestAll_1.combineLatestAll;
  } });
  var combineLatestWith_1 = require_combineLatestWith();
  Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
    return combineLatestWith_1.combineLatestWith;
  } });
  var concatAll_1 = require_concatAll();
  Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
    return concatAll_1.concatAll;
  } });
  var concatMap_1 = require_concatMap();
  Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
    return concatMap_1.concatMap;
  } });
  var concatMapTo_1 = require_concatMapTo();
  Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
    return concatMapTo_1.concatMapTo;
  } });
  var concatWith_1 = require_concatWith();
  Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
    return concatWith_1.concatWith;
  } });
  var connect_1 = require_connect();
  Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
    return connect_1.connect;
  } });
  var count_1 = require_count();
  Object.defineProperty(exports, "count", { enumerable: true, get: function() {
    return count_1.count;
  } });
  var debounce_1 = require_debounce();
  Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
    return debounce_1.debounce;
  } });
  var debounceTime_1 = require_debounceTime();
  Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
    return debounceTime_1.debounceTime;
  } });
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
    return defaultIfEmpty_1.defaultIfEmpty;
  } });
  var delay_1 = require_delay();
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_1.delay;
  } });
  var delayWhen_1 = require_delayWhen();
  Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
    return delayWhen_1.delayWhen;
  } });
  var dematerialize_1 = require_dematerialize();
  Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
    return dematerialize_1.dematerialize;
  } });
  var distinct_1 = require_distinct();
  Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
    return distinct_1.distinct;
  } });
  var distinctUntilChanged_1 = require_distinctUntilChanged();
  Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
    return distinctUntilChanged_1.distinctUntilChanged;
  } });
  var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
  Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
    return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
  } });
  var elementAt_1 = require_elementAt();
  Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
    return elementAt_1.elementAt;
  } });
  var endWith_1 = require_endWith();
  Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
    return endWith_1.endWith;
  } });
  var every_1 = require_every();
  Object.defineProperty(exports, "every", { enumerable: true, get: function() {
    return every_1.every;
  } });
  var exhaust_1 = require_exhaust();
  Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
    return exhaust_1.exhaust;
  } });
  var exhaustAll_1 = require_exhaustAll();
  Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
    return exhaustAll_1.exhaustAll;
  } });
  var exhaustMap_1 = require_exhaustMap();
  Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
    return exhaustMap_1.exhaustMap;
  } });
  var expand_1 = require_expand();
  Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
    return expand_1.expand;
  } });
  var filter_1 = require_filter();
  Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
    return filter_1.filter;
  } });
  var finalize_1 = require_finalize();
  Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
    return finalize_1.finalize;
  } });
  var find_1 = require_find();
  Object.defineProperty(exports, "find", { enumerable: true, get: function() {
    return find_1.find;
  } });
  var findIndex_1 = require_findIndex();
  Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
    return findIndex_1.findIndex;
  } });
  var first_1 = require_first();
  Object.defineProperty(exports, "first", { enumerable: true, get: function() {
    return first_1.first;
  } });
  var groupBy_1 = require_groupBy();
  Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
    return groupBy_1.groupBy;
  } });
  var ignoreElements_1 = require_ignoreElements();
  Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
    return ignoreElements_1.ignoreElements;
  } });
  var isEmpty_1 = require_isEmpty();
  Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
    return isEmpty_1.isEmpty;
  } });
  var last_1 = require_last();
  Object.defineProperty(exports, "last", { enumerable: true, get: function() {
    return last_1.last;
  } });
  var map_1 = require_map();
  Object.defineProperty(exports, "map", { enumerable: true, get: function() {
    return map_1.map;
  } });
  var mapTo_1 = require_mapTo();
  Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
    return mapTo_1.mapTo;
  } });
  var materialize_1 = require_materialize();
  Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
    return materialize_1.materialize;
  } });
  var max_1 = require_max();
  Object.defineProperty(exports, "max", { enumerable: true, get: function() {
    return max_1.max;
  } });
  var mergeAll_1 = require_mergeAll();
  Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
    return mergeAll_1.mergeAll;
  } });
  var flatMap_1 = require_flatMap();
  Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
    return flatMap_1.flatMap;
  } });
  var mergeMap_1 = require_mergeMap();
  Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
    return mergeMap_1.mergeMap;
  } });
  var mergeMapTo_1 = require_mergeMapTo();
  Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
    return mergeMapTo_1.mergeMapTo;
  } });
  var mergeScan_1 = require_mergeScan();
  Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
    return mergeScan_1.mergeScan;
  } });
  var mergeWith_1 = require_mergeWith();
  Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
    return mergeWith_1.mergeWith;
  } });
  var min_1 = require_min();
  Object.defineProperty(exports, "min", { enumerable: true, get: function() {
    return min_1.min;
  } });
  var multicast_1 = require_multicast();
  Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
    return multicast_1.multicast;
  } });
  var observeOn_1 = require_observeOn();
  Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
    return observeOn_1.observeOn;
  } });
  var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
  Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
    return onErrorResumeNextWith_1.onErrorResumeNextWith;
  } });
  var pairwise_1 = require_pairwise();
  Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
    return pairwise_1.pairwise;
  } });
  var pluck_1 = require_pluck();
  Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
    return pluck_1.pluck;
  } });
  var publish_1 = require_publish();
  Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
    return publish_1.publish;
  } });
  var publishBehavior_1 = require_publishBehavior();
  Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
    return publishBehavior_1.publishBehavior;
  } });
  var publishLast_1 = require_publishLast();
  Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
    return publishLast_1.publishLast;
  } });
  var publishReplay_1 = require_publishReplay();
  Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
    return publishReplay_1.publishReplay;
  } });
  var raceWith_1 = require_raceWith();
  Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
    return raceWith_1.raceWith;
  } });
  var reduce_1 = require_reduce();
  Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
    return reduce_1.reduce;
  } });
  var repeat_1 = require_repeat();
  Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
    return repeat_1.repeat;
  } });
  var repeatWhen_1 = require_repeatWhen();
  Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
    return repeatWhen_1.repeatWhen;
  } });
  var retry_1 = require_retry();
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var retryWhen_1 = require_retryWhen();
  Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
    return retryWhen_1.retryWhen;
  } });
  var refCount_1 = require_refCount();
  Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
    return refCount_1.refCount;
  } });
  var sample_1 = require_sample();
  Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
    return sample_1.sample;
  } });
  var sampleTime_1 = require_sampleTime();
  Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
    return sampleTime_1.sampleTime;
  } });
  var scan_1 = require_scan();
  Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
    return scan_1.scan;
  } });
  var sequenceEqual_1 = require_sequenceEqual();
  Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
    return sequenceEqual_1.sequenceEqual;
  } });
  var share_1 = require_share();
  Object.defineProperty(exports, "share", { enumerable: true, get: function() {
    return share_1.share;
  } });
  var shareReplay_1 = require_shareReplay();
  Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
    return shareReplay_1.shareReplay;
  } });
  var single_1 = require_single();
  Object.defineProperty(exports, "single", { enumerable: true, get: function() {
    return single_1.single;
  } });
  var skip_1 = require_skip();
  Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
    return skip_1.skip;
  } });
  var skipLast_1 = require_skipLast();
  Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
    return skipLast_1.skipLast;
  } });
  var skipUntil_1 = require_skipUntil();
  Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
    return skipUntil_1.skipUntil;
  } });
  var skipWhile_1 = require_skipWhile();
  Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
    return skipWhile_1.skipWhile;
  } });
  var startWith_1 = require_startWith();
  Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
    return startWith_1.startWith;
  } });
  var subscribeOn_1 = require_subscribeOn();
  Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
    return subscribeOn_1.subscribeOn;
  } });
  var switchAll_1 = require_switchAll();
  Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
    return switchAll_1.switchAll;
  } });
  var switchMap_1 = require_switchMap();
  Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
    return switchMap_1.switchMap;
  } });
  var switchMapTo_1 = require_switchMapTo();
  Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
    return switchMapTo_1.switchMapTo;
  } });
  var switchScan_1 = require_switchScan();
  Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
    return switchScan_1.switchScan;
  } });
  var take_1 = require_take();
  Object.defineProperty(exports, "take", { enumerable: true, get: function() {
    return take_1.take;
  } });
  var takeLast_1 = require_takeLast();
  Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
    return takeLast_1.takeLast;
  } });
  var takeUntil_1 = require_takeUntil();
  Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
    return takeUntil_1.takeUntil;
  } });
  var takeWhile_1 = require_takeWhile();
  Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
    return takeWhile_1.takeWhile;
  } });
  var tap_1 = require_tap();
  Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
    return tap_1.tap;
  } });
  var throttle_1 = require_throttle();
  Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
    return throttle_1.throttle;
  } });
  var throttleTime_1 = require_throttleTime();
  Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
    return throttleTime_1.throttleTime;
  } });
  var throwIfEmpty_1 = require_throwIfEmpty();
  Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
    return throwIfEmpty_1.throwIfEmpty;
  } });
  var timeInterval_1 = require_timeInterval();
  Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
    return timeInterval_1.timeInterval;
  } });
  var timeout_2 = require_timeout();
  Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
    return timeout_2.timeout;
  } });
  var timeoutWith_1 = require_timeoutWith();
  Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
    return timeoutWith_1.timeoutWith;
  } });
  var timestamp_1 = require_timestamp();
  Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
    return timestamp_1.timestamp;
  } });
  var toArray_1 = require_toArray();
  Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
    return toArray_1.toArray;
  } });
  var window_1 = require_window();
  Object.defineProperty(exports, "window", { enumerable: true, get: function() {
    return window_1.window;
  } });
  var windowCount_1 = require_windowCount();
  Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
    return windowCount_1.windowCount;
  } });
  var windowTime_1 = require_windowTime();
  Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
    return windowTime_1.windowTime;
  } });
  var windowToggle_1 = require_windowToggle();
  Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
    return windowToggle_1.windowToggle;
  } });
  var windowWhen_1 = require_windowWhen();
  Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
    return windowWhen_1.windowWhen;
  } });
  var withLatestFrom_1 = require_withLatestFrom();
  Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
    return withLatestFrom_1.withLatestFrom;
  } });
  var zipAll_1 = require_zipAll();
  Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
    return zipAll_1.zipAll;
  } });
  var zipWith_1 = require_zipWith();
  Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
    return zipWith_1.zipWith;
  } });
});

// node_modules/@dfinity/agent/lib/cjs/agent/api.js
var require_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplicaRejectCode = undefined;
  var ReplicaRejectCode2;
  (function(ReplicaRejectCode3) {
    ReplicaRejectCode3[ReplicaRejectCode3["SysFatal"] = 1] = "SysFatal";
    ReplicaRejectCode3[ReplicaRejectCode3["SysTransient"] = 2] = "SysTransient";
    ReplicaRejectCode3[ReplicaRejectCode3["DestinationInvalid"] = 3] = "DestinationInvalid";
    ReplicaRejectCode3[ReplicaRejectCode3["CanisterReject"] = 4] = "CanisterReject";
    ReplicaRejectCode3[ReplicaRejectCode3["CanisterError"] = 5] = "CanisterError";
  })(ReplicaRejectCode2 = exports.ReplicaRejectCode || (exports.ReplicaRejectCode = {}));
});

// node_modules/@dfinity/agent/lib/cjs/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AgentError = undefined;

  class AgentError2 extends Error {
    constructor(message) {
      super(message);
      this.message = message;
      Object.setPrototypeOf(this, AgentError2.prototype);
    }
  }
  exports.AgentError = AgentError2;
});

// node_modules/@dfinity/agent/lib/cjs/utils/buffer.js
var require_buffer3 = __commonJS((exports) => {
  var concat3 = function(...buffers) {
    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));
    let index = 0;
    for (const b2 of buffers) {
      result.set(new Uint8Array(b2), index);
      index += b2.byteLength;
    }
    return result.buffer;
  };
  var toHex2 = function(buffer14) {
    return [...new Uint8Array(buffer14)].map((x2) => x2.toString(16).padStart(2, "0")).join("");
  };
  var fromHex2 = function(hex) {
    if (!hexRe2.test(hex)) {
      throw new Error("Invalid hexadecimal string.");
    }
    const buffer14 = [...hex].reduce((acc, curr, i) => {
      acc[i / 2 | 0] = (acc[i / 2 | 0] || "") + curr;
      return acc;
    }, []).map((x2) => Number.parseInt(x2, 16));
    return new Uint8Array(buffer14).buffer;
  };
  var compare4 = function(b1, b2) {
    if (b1.byteLength !== b2.byteLength) {
      return b1.byteLength - b2.byteLength;
    }
    const u1 = new Uint8Array(b1);
    const u2 = new Uint8Array(b2);
    for (let i = 0;i < u1.length; i++) {
      if (u1[i] !== u2[i]) {
        return u1[i] - u2[i];
      }
    }
    return 0;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compare = exports.fromHex = exports.toHex = exports.concat = undefined;
  exports.concat = concat3;
  exports.toHex = toHex2;
  var hexRe2 = new RegExp(/^([0-9A-F]{2})*$/i);
  exports.fromHex = fromHex2;
  exports.compare = compare4;
});

// node_modules/@dfinity/agent/lib/cjs/request_id.js
var require_request_id = __commonJS((exports) => {
  var hash2 = function(data) {
    return js_sha256_1.sha256.create().update(new Uint8Array(data)).arrayBuffer();
  };
  var hashValue2 = function(value4) {
    if (value4 instanceof borc_1.default.Tagged) {
      return hashValue2(value4.value);
    } else if (typeof value4 === "string") {
      return hashString2(value4);
    } else if (typeof value4 === "number") {
      return hash2((0, candid_1.lebEncode)(value4));
    } else if (value4 instanceof ArrayBuffer || ArrayBuffer.isView(value4)) {
      return hash2(value4);
    } else if (Array.isArray(value4)) {
      const vals = value4.map(hashValue2);
      return hash2((0, buffer_1.concat)(...vals));
    } else if (value4 && typeof value4 === "object" && value4._isPrincipal) {
      return hash2(value4.toUint8Array());
    } else if (typeof value4 === "object" && value4 !== null && typeof value4.toHash === "function") {
      return hashValue2(value4.toHash());
    } else if (typeof value4 === "bigint") {
      return hash2((0, candid_1.lebEncode)(value4));
    }
    throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value4}`), {
      value: value4
    });
  };
  var requestIdOf2 = function(request2) {
    const hashed = Object.entries(request2).filter(([, value4]) => value4 !== undefined).map(([key, value4]) => {
      const hashedKey = hashString2(key);
      const hashedValue = hashValue2(value4);
      return [hashedKey, hashedValue];
    });
    const traversed = hashed;
    const sorted = traversed.sort(([k1], [k2]) => {
      return (0, buffer_1.compare)(k1, k2);
    });
    const concatenated = (0, buffer_1.concat)(...sorted.map((x2) => (0, buffer_1.concat)(...x2)));
    const requestId = hash2(concatenated);
    return requestId;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.requestIdOf = exports.hashValue = exports.hash = undefined;
  var candid_1 = require_cjs2();
  var borc_1 = __importDefault(require_src());
  var js_sha256_1 = require_sha256();
  var buffer_1 = require_buffer3();
  exports.hash = hash2;
  exports.hashValue = hashValue2;
  var hashString2 = (value4) => {
    const encoded = new TextEncoder().encode(value4);
    return hash2(encoded);
  };
  exports.requestIdOf = requestIdOf2;
});

// node_modules/@dfinity/agent/lib/cjs/auth.js
var require_auth = __commonJS((exports) => {
  var createIdentityDescriptor = function(identity2) {
    const identityIndicator = "getPublicKey" in identity2 ? { type: "PublicKeyIdentity", publicKey: (0, buffer_1.toHex)(identity2.getPublicKey().toDer()) } : { type: "AnonymousIdentity" };
    return identityIndicator;
  };
  var __rest2 = exports && exports.__rest || function(s2, e) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s2);i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
          t2[p[i]] = s2[p[i]];
      }
    return t2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createIdentityDescriptor = exports.AnonymousIdentity = exports.SignIdentity = undefined;
  var principal_1 = require_cjs();
  var request_id_1 = require_request_id();
  var buffer_1 = require_buffer3();
  var domainSeparator3 = new TextEncoder().encode(`
ic-request`);

  class SignIdentity2 {
    getPrincipal() {
      if (!this._principal) {
        this._principal = principal_1.Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));
      }
      return this._principal;
    }
    async transformRequest(request2) {
      const { body } = request2, fields = __rest2(request2, ["body"]);
      const requestId = await (0, request_id_1.requestIdOf)(body);
      return Object.assign(Object.assign({}, fields), { body: {
        content: body,
        sender_pubkey: this.getPublicKey().toDer(),
        sender_sig: await this.sign((0, buffer_1.concat)(domainSeparator3, requestId))
      } });
    }
  }
  exports.SignIdentity = SignIdentity2;

  class AnonymousIdentity2 {
    getPrincipal() {
      return principal_1.Principal.anonymous();
    }
    async transformRequest(request2) {
      return Object.assign(Object.assign({}, request2), { body: { content: request2.body } });
    }
  }
  exports.AnonymousIdentity = AnonymousIdentity2;
  exports.createIdentityDescriptor = createIdentityDescriptor;
});

// node_modules/@dfinity/agent/lib/cjs/cbor.js
var require_cbor = __commonJS((exports) => {
  var encode2 = function(value4) {
    return serializer2.serialize(value4);
  };
  var decodePositiveBigInt2 = function(buf) {
    const len = buf.byteLength;
    let res = BigInt(0);
    for (let i = 0;i < len; i++) {
      res = res * BigInt(256) + BigInt(buf[i]);
    }
    return res;
  };
  var decode3 = function(input) {
    const buffer14 = new Uint8Array(input);
    const decoder = new Uint8ArrayDecoder2({
      size: buffer14.byteLength,
      tags: {
        2: (val) => decodePositiveBigInt2(val),
        3: (val) => -decodePositiveBigInt2(val),
        [CborTag2.Semantic]: (value4) => value4
      }
    });
    return decoder.decodeFirst(buffer14);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decode = exports.encode = exports.CborTag = undefined;
  var borc_1 = __importDefault(require_src());
  var cbor4 = __importStar(require_src2());
  var simple_cbor_1 = require_src2();
  var buffer_1 = require_buffer3();

  class PrincipalEncoder2 {
    get name() {
      return "Principal";
    }
    get priority() {
      return 0;
    }
    match(value4) {
      return value4 && value4._isPrincipal === true;
    }
    encode(v) {
      return cbor4.value.bytes(v.toUint8Array());
    }
  }

  class BufferEncoder2 {
    get name() {
      return "Buffer";
    }
    get priority() {
      return 1;
    }
    match(value4) {
      return value4 instanceof ArrayBuffer || ArrayBuffer.isView(value4);
    }
    encode(v) {
      return cbor4.value.bytes(new Uint8Array(v));
    }
  }

  class BigIntEncoder2 {
    get name() {
      return "BigInt";
    }
    get priority() {
      return 1;
    }
    match(value4) {
      return typeof value4 === `bigint`;
    }
    encode(v) {
      if (v > BigInt(0)) {
        return cbor4.value.tagged(2, cbor4.value.bytes((0, buffer_1.fromHex)(v.toString(16))));
      } else {
        return cbor4.value.tagged(3, cbor4.value.bytes((0, buffer_1.fromHex)((BigInt("-1") * v).toString(16))));
      }
    }
  }
  var serializer2 = simple_cbor_1.SelfDescribeCborSerializer.withDefaultEncoders(true);
  serializer2.addEncoder(new PrincipalEncoder2);
  serializer2.addEncoder(new BufferEncoder2);
  serializer2.addEncoder(new BigIntEncoder2);
  var CborTag2;
  (function(CborTag3) {
    CborTag3[CborTag3["Uint64LittleEndian"] = 71] = "Uint64LittleEndian";
    CborTag3[CborTag3["Semantic"] = 55799] = "Semantic";
  })(CborTag2 = exports.CborTag || (exports.CborTag = {}));
  exports.encode = encode2;

  class Uint8ArrayDecoder2 extends borc_1.default.Decoder {
    createByteString(raw) {
      return (0, buffer_1.concat)(...raw);
    }
    createByteStringFromHeap(start, end) {
      if (start === end) {
        return new ArrayBuffer(0);
      }
      return new Uint8Array(this._heap.slice(start, end));
    }
  }
  exports.decode = decode3;
});

// node_modules/@dfinity/agent/lib/cjs/agent/http/types.js
var require_types3 = __commonJS((exports) => {
  var makeNonce2 = function() {
    const buffer14 = new ArrayBuffer(16);
    const view = new DataView(buffer14);
    const now = BigInt(+Date.now());
    const randHi = Math.floor(Math.random() * 4294967295);
    const randLo = Math.floor(Math.random() * 4294967295);
    if (typeof view.setBigUint64 === "function") {
      view.setBigUint64(0, now);
    } else {
      const TWO_TO_THE_32 = BigInt(1) << BigInt(32);
      view.setUint32(0, Number(now >> BigInt(32)));
      view.setUint32(4, Number(now % TWO_TO_THE_32));
    }
    view.setUint32(8, randHi);
    view.setUint32(12, randLo);
    return buffer14;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeNonce = exports.SubmitRequestType = undefined;
  var SubmitRequestType2;
  (function(SubmitRequestType3) {
    SubmitRequestType3["Call"] = "call";
  })(SubmitRequestType2 = exports.SubmitRequestType || (exports.SubmitRequestType = {}));
  exports.makeNonce = makeNonce2;
});

// node_modules/@dfinity/agent/lib/cjs/agent/http/transforms.js
var require_transforms = __commonJS((exports) => {
  var makeNonceTransform2 = function(nonceFn = types_1.makeNonce) {
    return async (request2) => {
      const nonce = nonceFn();
      const headers = request2.request.headers;
      request2.request.headers = headers;
      if (request2.endpoint === "call") {
        request2.body.nonce = nonceFn();
      }
    };
  };
  var makeExpiryTransform = function(delayInMilliseconds) {
    return async (request2) => {
      request2.body.ingress_expiry = new Expiry2(delayInMilliseconds);
    };
  };
  var httpHeadersTransform2 = function(headers) {
    const headerFields = [];
    headers.forEach((value4, key) => {
      headerFields.push([key, value4]);
    });
    return headerFields;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.httpHeadersTransform = exports.makeExpiryTransform = exports.makeNonceTransform = exports.Expiry = undefined;
  var candid_1 = require_cjs2();
  var cbor4 = __importStar(require_src2());
  var types_1 = require_types3();
  var NANOSECONDS_PER_MILLISECONDS2 = BigInt(1e6);
  var REPLICA_PERMITTED_DRIFT_MILLISECONDS2 = BigInt(60 * 1000);

  class Expiry2 {
    constructor(deltaInMSec) {
      this._value = (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS2) * NANOSECONDS_PER_MILLISECONDS2;
    }
    toCBOR() {
      return cbor4.value.u64(this._value.toString(16), 16);
    }
    toHash() {
      return (0, candid_1.lebEncode)(this._value);
    }
  }
  exports.Expiry = Expiry2;
  exports.makeNonceTransform = makeNonceTransform2;
  exports.makeExpiryTransform = makeExpiryTransform;
  exports.httpHeadersTransform = httpHeadersTransform2;
});

// node_modules/@dfinity/agent/lib/cjs/agent/http/errors.js
var require_errors2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AgentHTTPResponseError = undefined;

  class AgentHTTPResponseError2 extends Error {
    constructor(message, response) {
      super(message);
      this.response = response;
      this.name = this.constructor.name;
      Object.setPrototypeOf(this, new.target.prototype);
    }
  }
  exports.AgentHTTPResponseError = AgentHTTPResponseError2;
});

// node_modules/@dfinity/agent/lib/cjs/vendor/bls/wasm.js
var require_wasm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wasmBytesBase64 = undefined;
  exports.wasmBytesBase64 = `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akE4ENABGiACQbgDakEBNgIAIAJBwANqQTgQ0AEaIAJB+ANqQQE2AgAgAkGABGpBOBDQARogAkEBNgK4BCACQcAEakE4ENABGiACQfgEakEBNgIAIAJBgAVqQTgQ0AEaIAJBuAVqQQE2AgAgAkHABWpBOBDQARogAkH4BWpBATYCACACQYAGakE4ENABGiACQQE2ArgGIAJBwAZqQTgQ0AEaIAJB+AZqQQE2AgAgAkGAB2pBOBDQARogAkG4B2pBATYCACACQcAHakE4ENABGiACQfgHakEBNgIAIAIgARAYAkAgASgCgAZBBEYNACAAKAKABkEERg0AIAJBgARqIgMgAEGAAmoQlgEgAyABQYACahAYDAYLIAJBwAxqIgdBOBDQARogAkEBNgL4DCACQYANakE4ENABGiACQbgNakEBNgIAIAJBgAhqIgRBOBDQARogAkEBNgK4CCACQcAIakE4ENABGiACQfgIakEBNgIAIAJBgApqIgMgAEGAA2oiBRBeIAQgAxCZASADIAFBgANqIgYQXiAEIAMQESAHELYBIAEoAoAGQQRHDQMMBAsgACABEAMMBgsgAkHADGoiAyABQYAFahBeIAJBgAxqIgQgA0HAABDRARogAkGABmogBBCnAQsgAkGABmoQZCACQYAIaiIDIAIQlgEgAxArIAJBgAJqIgQgAxCXASAGIAQQlgEgAkGABGoiByADEJYBIAMgABCWASADIAUQlwEgAxCwASACQYAKaiIEIAEQlgEgBCABQYAEahCXASAEELABIAMgBBAYIAcgAxCXASADIAUQlgECQCABKAKABkECRwRAIAJBwAxqIgMgAUGABWoQXiACQYAIaiADEKYBDAELIAJBwAxqIgMgAUGABWoQXiACQYAMaiIBIANBwAAQ0QEaIAJBgAhqIAEQpwELIAJBgAhqIgEQZCACQYAKaiIDIAEQlgEgAxArIAUgAkGABGoQlgEgBSADEJcBIAJBgAZqIgQgAxCXASABEGQgBiABEJcBIAQQsAEgBBBkIAAgAhCWASAAIAQQlwEMAwsgAkGACmoiAyAFEF4gAkHADGoiBCADEJkBIAMgAUGAAmoQXiAEIAMQEQsgACgCgAZBBEcEQCACQYAKaiIDIABBgAJqEF4gAkHADGoiBCADEJkBIAMgBhBeIAQgAxARCyACQYAEaiIDIAJB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AEHcu8AAKAIAQX4gA0EDdndxNgIACyAAIAEQoAEgAEH0vsAAKAIARw0BQey+wAAgATYCAAsPCyABQYACTwRAIAAgARAWDwsgAUEDdiICQQN0QeS7wABqIQECf0Hcu8AAKAIAIgNBASACdCICcQRAIAEoAggMAQtB3LvAACACIANyNgIAIAELIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIC+UDAQN/IwBB0CJrIgMkACADQcAWaiIEQcitwAAQSSADQcgcaiIFQYCuwAAQSSADQQhqIAQgBRBLIANBiAFqQTgQ0AEaIANBwAFqQTgQ0AEaIANB+AFqED0CQCACEIYBBEAgABBVDAELIANB+ARqIgQQPSAEIAEQfSAEEEcgA0H4B2oiARBnIAEgAhB4IAEQRiADQcgcaiICIAEQkAEgA0G4CWogAhCQASACIANBuAhqEJABIANB+AlqIAIQkAEgA0G4CmoiARA9IANBuA1qEFUgASAEEH0gA0HAE2oiARA9IAEgBBB9IAEQogEgA0HAAWogA0GIAWoQUEECayECA0AgAkEBakEBTQRAIANBuA1qIgEQngEgACABQYgGENEBGgUgA0G4DWoQGiADQcAWaiADQbgKaiADQbgJaiADQfgJahALAkACQAJAIANBwAFqIAIQUyADQYgBaiACEFNrQQFqDgMBAgACCyADQcgcaiIBIANBuApqIANB+ARqIANBuAlqIANB+AlqEAogA0HAFmogARADDAELIANByBxqIgEgA0G4CmogA0HAE2ogA0G4CWogA0H4CWoQCiADQcAWaiABEAMLIAJBAWshAiADQbgNaiADQcAWahABDAELCwsgA0HQImokAAvBAwEVfwNAIANBwAFGBEACQCAAQShqIQsgAEEUaigCACIMIQggAEEQaigCACINIQIgAEEMaigCACIOIQEgACgCCCIPIQMgAEEYaigCACIQIQogAEEcaigCACIRIQQgAEEgaigCACISIQcgAEEkaigCACITIQYDQCAHIQkgBCEHIAohBCAFQYACRg0BIAEgAnEhFCABIAJzIRUgBSALaigCACAFQcCiwABqKAIAIAkgBEF/c3EgBCAHcXIgBmogBEEadyAEQRV3cyAEQQd3c2pqaiIGIAhqIQogBUEEaiEFIAIhCCABIQIgAyIBQR53IAFBE3dzIAFBCndzIBQgASAVcXNqIAZqIQMgCSEGDAALAAsFIAAgA2oiAkHoAGogAkEoaigCACACQcwAaigCACACQeAAaigCACIBQQ93IAFBDXdzIAFBCnZzamogAkEsaigCACIBQRl3IAFBDndzIAFBA3ZzajYCACADQQRqIQMMAQsLIAAgBiATajYCJCAAIAkgEmo2AiAgACAHIBFqNgIcIAAgBCAQajYCGCAAIAggDGo2AhQgACACIA1qNgIQIAAgASAOajYCDCAAIAMgD2o2AggL5AEBAn8jAEGAA2siAyQAIAMQPSAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbyAAIAFBgANqIAJBAXNBAWtBH3YQbyAAIAFBgAZqIAJBAnNBAWtBH3YQbyAAIAFBgAlqIAJBA3NBAWtBH3YQbyAAIAFBgAxqIAJBBHNBAWtBH3YQbyAAIAFBgA9qIAJBBXNBAWtBH3YQbyAAIAFBgBJqIAJBBnNBAWtBH3YQbyAAIAFBgBVqIAJBB3NBAWtBH3YQbyADIAAQfSADEKIBIAAgAyAEQQFxEG8gA0GAA2okAAvlAwEIfyMAQZAGayICJAAgAEFAayEIAkAgAUH4AGooAgAgASgCOGqsIABB+ABqKAIAIgcgACgCOCIEaqx+Qv///w9XDQAgBEEBSgR/IAAQHiAAKAJ4BSAHC0EBTA0AIAgQHgsgAkHYpMAAEEkgAkE4aiIHQfAAENABGiACIQNBACECA0AgAkE4RgRAAkAgB0E4aiEEQQAhAgNAIAJBOEYNASACIARqIAIgA2opAwA3AwAgAkEIaiECDAALAAsFIAIgB2pCADcDACACQQhqIQIMAQsLIANBqAFqIgYgABBdIANB4AFqIgUgARBdIANBmAJqIgIgACABEAUgA0GIA2oiBCAIIAFBQGsiARAFIAYgCBBgIAYQQiAFIAEQYCAFEEIgA0H4A2oiCSAGIAUQBUEAIQEgA0HoBGoiBkHwABDQASEFA0AgAUHwAEcEQCABIAVqIAEgAmopAwA3AwAgAUEIaiEBDAELCyAGIAQQYkEAIQEDQCABQfAARwRAIAEgBGoiBSABIAdqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAiAEEGIgAhBIIAkgBhBjIAkQSCADQdgFaiIBIAIQayAAIAEQaiAAQQM2AjggASAJEGsgCCABEGogAEECNgJ4IANBkAZqJAALowIBCH8jAEGABmsiAiQAIAIgAEGAAWoiBxBeIAJBgAFqIgQgBxBeIAQQLSACQYACaiIFIAIQXiAFIABBgAJqIgMQESACQYADaiIBIAMQXiABEC0gAyAEEJkBIAMgBBCaASADEKkBIAMQuAEgAxC4ASADEKkBIAFBDBCrASABEHwgARCpASACQYAEaiIIIAEQXiAIIAMQESACQYAFaiIGIAQQXiAGIAEQmgEgBhCpASADIAUQESAFIAEQmQEgBSABEJoBIAEgBRCaASABEKkBIAQgARB7IAQQqQEgBiAEEBEgBiAIEJoBIAUgABCZASAFIAIQESAAIAQQmQEgABCpASAAIAUQESAAELgBIAAQqQEgByAGEJkBIAcQqQEgAkGABmokAAu8AgEGfyMAQYAIayIBJAAgASAAEIwBIAFBgAJqIgMgAEGABGoiBRCMASABQYAEaiIEIABBgAJqIgYQjAEgAUGABmoiAkE4ENABGiABQQE2ArgGIAFBwAZqQTgQ0AEaIAFB+AZqQQE2AgAgAUGAB2pBOBDQARogAUG4B2pBATYCACABQcAHakE4ENABGiABQfgHakEBNgIAIAAQISACIAAQlgEgAiAAEJcBIAAgAhCXASAAELABIAEQyQEgARCzASAAIAEQlwEgAxAhIAMQZCACIAMQlgEgAiADEJcBIAMgAhCXASADELABIAQQISACIAQQlgEgAiAEEJcBIAQgAhCXASAEELABIAYQsgEgBhCzASAFEMkBIAUQswEgBiADEJcBIAUgBBCXASAAQQU2AoAGIAAQnAEgAUGACGokAAv/AQEHfyMAQcACayIBJAAgASAAQUBrIgYQkAEgARBMIAFBQGsiAyAGEJABIAMgAEGAAWoiAhBKIAFBgAFqIgQgAhCQASAEEEwgAiABEK4BIAIgARB3IAIQQiACEIIBIAIQggEgAhBCIARBDBA0IAFBwAFqIgcgBBCQASAHIAIQSiABQYACaiIFIAEQkAEgBSAEEHcgBRBCIAIgAxBKIAMgBBCuASADIAQQdyAEIAMQdyABIAQQfiABEEIgBSABEEogBSAHEHcgAyAAEK4BIAMgBhBKIAAgARCuASAAEEIgACADEEogABCCASAAEEIgBiAFEK4BIAYQQiABQcACaiQAC84CAgd/An4CQAJAAkBBDSABQTpuIgJrIgRBDU0EQEEMIAJrIgNBDk8NASAAIAAgA0EDdGopAwBBOiABIAJBOmxrIgNrrSIKhyAAIARBA3RqKQMAIAOtIgmGhDcDaCAEQQ1rIQUgAEHgAGohBCACQQFqIQZBACACQQN0ayEHQQshAwNAAkAgA0ECaiAGTQRAIAFBrAZPDQEgACACQQN0aiAAKQMAIAmGQv//////////A4M3AwADQCACRQ0HIABCADcDACACQQFrIQIgAEEIaiEADAALAAsgAyAFakEOTw0EIAQgBCAHaiIIQQhrKQMAIAqHIAgpAwAgCYZC//////////8Dg4Q3AwAgA0EBayEDIARBCGshBAwBCwsgAkEOQYCywAAQOwALIARBDkHQscAAEDsACyADQQ5B4LHAABA7AAtBf0EOQfCxwAAQOwALC6cCAQR/IABCADcCECAAAn9BACABQYACSQ0AGkEfIAFB////B0sNABogAUEGIAFBCHZnIgNrdkEBcSADQQF0a0E+agsiBDYCHCAEQQJ0Qey9wABqIQMgACECAkACQAJAAkBB4LvAACgCACIAQQEgBHQiBXEEQCADKAIAIQMgBBCfASEAIAMQywEgAUcNASADIQAMAgtB4LvAACAAIAVyNgIAIAMgAjYCAAwDCyABIAB0IQQDQCADIARBHXZBBHFqQRBqIgUoAgAiAEUNAiAEQQF0IQQgACIDEMsBIAFHDQALCyAAKAIIIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCCACQQA2AhgPCyAFIAI2AgALIAIgAzYCGCACIAI2AgggAiACNgIMC7YCAQV/IAAoAhghBAJAAkAgACAAKAIMRgRAIABBFEEQIABBFGoiASgCACIDG2ooAgAiAg0BQQAhAQwCCyAAKAIIIgIgACgCDCIBNgIMIAEgAjYCCAwBCyABIABBEGogAxshAwNAIAMhBSACIgFBFGoiAygCACICRQRAIAFBEGohAyABKAIQIQILIAINAAsgBUEANgIACwJAIARFDQACQCAAIAAoAhxBAnRB7L3AAGoiAigCAEcEQCAEQRBBFCAEKAIQIABGG2ogATYCACABDQEMAgsgAiABNgIAIAENAEHgu8AAQeC7wAAoAgBBfiAAKAIcd3E2AgAPCyABIAQ2AhggACgCECICBEAgASACNgIQIAIgATYCGAsgAEEUaigCACIARQ0AIAFBFGogADYCACAAIAE2AhgLC+UBAQZ/IwBBgARrIgIkACACIAAQXiACQYABaiIFIABBgAFqIgYQXiACQYACaiIDQTgQ0AEaIAJBATYCuAIgAkHAAmpBOBDQARogAkH4AmpBATYCACACQYADaiIEIAYQXiACIAEQESAFIAFBgAFqIgcQESADIAcQmQEgAyABEJoBIAQgABCaASADEKkBIAQQqQEgBCADEBEgAyACEJkBIAMQNiAEIAMQmgEgBBCpASADIAUQmQEgAxA2IAYgBBCZASAGIAMQmgEgBRB8IAAgBRCZASAAIAIQmgEgABCwASACQYAEaiQAC28BDH9BjL/AACgCACICRQRAQZy/wABB/x82AgBBAA8LQYS/wAAhBgNAIAIiASgCCCECIAEoAgQhAyABKAIAIQQgAUEMaigCABogASEGIAVBAWohBSACDQALQZy/wAAgBUH/HyAFQf8fSxs2AgBBAAuAAgEGfyMAQYAIayIBJAAgACgCgAZBAUcEQCABIAAQjAEgAUGAAmoiAiAAQYACaiIEEIwBIAFBgARqIgUgAEGABGoiAxCMASABQYAGaiIGIAAQjAEgARAhIAIgAxAYIAIQswEgAhCwASAFECEgBiAEEBggBhCzASADIAAQlwEgAyAEEJcBIAMQsAEgAxAhIAAgARCWASABIAIQlwEgARCwASABIAUQlwEgASAGEJcBIAEQsAEgARArIAIQZCAFEGQgACACEJcBIAQgBRCWASAEIAYQlwEgAyABEJcBIABBBEEFIAAoAoAGQX5xQQJGGzYCgAYgABCdAQsgAUGACGokAAuZAgEBfyMAQYANayIDJAAgAyABEGkgAxCdASADQYgGaiIBIAIQXSABEEIgA0HABmoiAiABEF0gAkEDECkaIAIQQiADQfgGaiADEGkCQCACEFdFBEAgA0HABmoQKkECayECA0AgAkEBakEBTQRAIANB+AZqIgEQnAEMAwUgA0H4BmoQEwJAAkACQCADQcAGaiACEFMgA0GIBmogAhBTa0EBag4DAQIAAgsgA0H4BmogAxAHDAELIAMQngEgA0H4BmogAxAHIAMQngELIAJBAWshAgwBCwALAAsgA0H4BmoiARC3ASABQYABahC2ASABQYACahCxASABQYAEahCxASABQQE2AoAGCyAAIAFBiAYQ0QEaIANBgA1qJAALhgICBH8BfiMAQTBrIgIkACABQQRqIQQgASgCBEUEQCABKAIAIQMgAkEQaiIFQQA2AgAgAkIBNwMIIAIgAkEIajYCFCACQShqIANBEGopAgA3AwAgAkEgaiADQQhqKQIANwMAIAIgAykCADcDGCACQRRqIAJBGGoQDBogBEEIaiAFKAIANgIAIAQgAikDCDcCAAsgAkEgaiIDIARBCGooAgA2AgAgAUEMakEANgIAIAQpAgAhBiABQgE3AgQgAiAGNwMYQQxBBBC5ASIBRQRAQQxBBBDPAQALIAEgAikDGDcCACABQQhqIAMoAgA2AgAgAEGEt8AANgIEIAAgATYCACACQTBqJAAL5AEBAn8jAEHAAWsiAyQAIAMQZyAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbiAAIAFBwAFqIAJBAXNBAWtBH3YQbiAAIAFBgANqIAJBAnNBAWtBH3YQbiAAIAFBwARqIAJBA3NBAWtBH3YQbiAAIAFBgAZqIAJBBHNBAWtBH3YQbiAAIAFBwAdqIAJBBXNBAWtBH3YQbiAAIAFBgAlqIAJBBnNBAWtBH3YQbiAAIAFBwApqIAJBB3NBAWtBH3YQbiADIAAQeCADEKQBIAAgAyAEQQFxEG4gA0HAAWokAAvDAwIGfwN+IwBB8ABrIgEkACABQcCywAAQSSABQThqIAEQXSAAEEICQAJAAkAgAQJ/IAAoAjgiAkEQTARAIAJBAWsQNQwBCyABKQMwIghCAXwiByAIVA0BIAApAzAiCEKAgICAgICAgIB/USAHQn9RcQ0CIAFBOGoiAiAIIAd/pxApIQcgASABKQNoIAdCOoZ8NwNoIAAgAhBhIAAQQkECCyIEECgDQCAERQ0DQQAhAyABIAEpAwgiCEI5hkKAgICAgICAgAKDIAEpAwBCAYeEIgc3AwAgACkDACAHfSEHIABBCGohBSAAIAFBOGoiAkEBA38gAiADaiAHQv//////////A4M3AwAgB0I6hyEHIANBKEYEfyABIAEpAzBCAYciCDcDMCACIAApAzAgCH0gB3wiBzcDMCAHQj+IpwUgASADaiIGQQhqIAhCAYcgBkEQaikDACIIQjmGQoCAgICAgICAAoOEIgk3AwAgAyAFaikDACAHfCAJfSEHIANBCGohAwwBCwtrEDAgBEEBayEEDAALAAtB4LPAAEEZQcSzwAAQWQALQYC0wABBH0HEs8AAEFkACyAAQQE2AjggAUHwAGokAAvuAQECfyMAQbABayIDJAAgA0EwENABIQMCQAJAA0AgAkEwRgRAIANBMGogAxBwIAFBMGohAUEAIQIDQCACQTBGDQMgAkEwRg0EIAIgA2ogASACai0AADoAACACQQFqIQIMAAsACyACQeAARwRAIAIgA2ogASACai0AADoAACACQQFqIQIMAQsLQeAAQeAAQYCmwAAQOwALIANB8ABqIgEgAxBwIABBOBDQASIAQQE2AjggAEFAa0E4ENABIABB+ABqQQE2AgAgACABEK4BIANBMGoQrgEgA0GwAWokAA8LIAJBMGpB4ABBkKbAABA7AAuPAgEDfyMAQSBrIgUkAEEBIQZB2LvAAEHYu8AAKAIAIgdBAWo2AgACQEGgv8AALQAABEBBpL/AACgCAEEBaiEGDAELQaC/wABBAToAAAtBpL/AACAGNgIAAkACQCAHQQBIIAZBAktyDQAgBSAEOgAYIAUgAzYCFCAFIAI2AhBBzLvAACgCACICQQBIDQBBzLvAACACQQFqIgI2AgBBzLvAAEHUu8AAKAIAIgMEf0HQu8AAKAIAIAUgACABKAIQEQAAIAUgBSkDADcDCCAFQQhqIAMoAhQRAABBzLvAACgCAAUgAgtBAWs2AgAgBkEBSw0AIAQNAQsACyMAQRBrIgIkACACIAE2AgwgAiAANgIIAAucAQEEfyMAQYADayICJAAgAiAAEF4gAkGAAWoiASAAQYABaiIEEF4gAkGAAmoiAyAAEF4gAyAEEBEgAiAEEJoBIAEQfCABIAAQmgEgAhCpASABEKkBIAAgAhCZASAAIAEQESABIAMQmQEgARB8IAEgAxCaASABEKkBIAEQNiAAIAEQmgEgAxC4ASAEIAMQmQEgABCwASACQYADaiQAC7kBAQJ/IwBBIGsiAyQAAkAgASABIAJqIgFLDQAgAEEEaigCACICQQF0IgQgASABIARJGyIBQQggAUEISxshAQJAIAIEQCADQRhqQQE2AgAgAyACNgIUIAMgACgCADYCEAwBCyADQQA2AhALIAMgASADQRBqECYgAygCAARAIANBCGooAgAiAEUNASADKAIEIAAQzwEACyADKAIEIQIgAEEEaiABNgIAIAAgAjYCACADQSBqJAAPCxBlAAusAQECfyMAQYADayIDJAAgA0EIaiABEJABAkAgAgRAIANBCGogAhCuAQwBCyADQQhqEDoLIANByABqIgJB8LTAABBJIANBgAFqIAIQjgEgA0HAAWoiAiADQQhqIgQQkAEgAhBMIAIgARBKIAAgARCQASAAIAQQSiADQYACaiACEJABIAAQViEBIANBwAJqIgIgABCQASACEEMgAhBCIAAgAiABEHIgA0GAA2okAAueAQEFfyMAQYABayICJAAgAkE4ENABIgJBATYCOCACQUBrIgNBOBDQARogAkEBNgJ4IAIgABCuASACIAFBgAFqIgUQSiADIAEQrgEgAyAAQYABaiIGEEoCQCACIAMQWEUNACACIABBQGsQrgEgAiAFEEogAkFAayIAIAFBQGsQrgEgACAGEEogAiAAEFhFDQBBASEECyACQYABaiQAIAQLpwEBA38jAEEwayICJAAgAUEEaiEDIAEoAgRFBEAgASgCACEBIAJBEGoiBEEANgIAIAJCATcDCCACIAJBCGo2AhQgAkEoaiABQRBqKQIANwMAIAJBIGogAUEIaikCADcDACACIAEpAgA3AxggAkEUaiACQRhqEAwaIANBCGogBCgCADYCACADIAIpAwg3AgALIABBhLfAADYCBCAAIAM2AgAgAkEwaiQAC5UBAQJ/AkACQAJAAkACfwJAAkACf0EBIgMgAUEASA0AGiACKAIAIgRFDQEgAigCBCICDQQgAQ0CQQEMAwshA0EAIQEMBgsgAQ0AQQEMAQsgAUEBELkBCyICRQ0BDAILIAQgARCsASICDQELIAAgATYCBEEBIQEMAQsgACACNgIEQQAhAwsgACADNgIAIABBCGogATYCAAvvMwISfwV+IwBBMGsiDiQAIA5BEGogACABEFsgDiAOKAIUIgA2AhwgDiAOKAIQIgg2AhggDkEIaiACIAMQWyAOIA4oAgwiATYCJCAOIA4oAggiAzYCICAOIAQgBRBbIA4gDigCBCIFNgIsIA4gDigCACINNgIoIAAhBCMAQZAVayICJAAjAEGwBmsiCiQAIApBEGpBOBDQARogCkHQAGpBOBDQASEVIApBiAFqQQE2AgAgCkEBNgJIIApBkAFqIgBB2KTAABBJIAAQKiEPIApByAFqIhNBgAIQ0AEaIApB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ABBJAkACQAJAAkADQAJAIAxBMEYEQCAAIAAtAABBH3E6AAAgAEHoAGogABC+ASAEDQFBAEEAQZiBwAAQOwALIAQgDEYNAiAAIAxqIAggDGotAAA6AAAgDEEBaiEMDAELC0EAIQwgCCwAACIJQQBIDQIgCEEwaiEDIARBMCAEQTBLG0EwayEIA0AgDEEwRgRAIABBoAFqIgQgABC+ASMAQYABayIDJAAgARBnIAEgAEHoAGoQwAEgAUFAayIIIAQQwAEgAUGAAWoQygEgARBCIAMgARBPIANBQGsiBCAIEJABIAQQTCAEIAMQWEUEQCABEJIBCyADQYABaiQADAULIAggDEYNAiAAIAxqIAMgDGotAAA6AAAgDEEBaiEMDAALAAsgBCAEQYiBwAAQOwALIAxBMGogBEGogcAAEDsACyMAQcABayIDJAAgAEGgAWoiBBBnIANBOBDQASIDQQE2AjggBCAAQegAahDAASAEEEIgBEGAAWoQygEgA0FAayIIIAQQTwJAAkACQCAIIAMQWkEBRgRAIANBgAFqIgggA0FAayADECMgCBBWDQEMAgsgBBCSAQwCCyADQYABaiIIEEMgCBBCCyAEQUBrIANBgAFqEK4BCyADQcABaiQAIAlBIHEiA0EAIABB4AFqEE0iBEEBRxtBASADIARBAUdyGwRAIABBoAFqEKQBCyABIABBoAFqQcABENEBGgsgAEHgAmokAAJ/QQAhAyMAQcAFayIAJAACQCABEIYBDQAgAEEIaiIIQZCtwAAQSSAAQYAEaiIEQbiuwAAQSSAAQUBrIgkgBBCOASAAQYABaiIEEGcgBCABEHggBCAJEEogAEHAAmoiBCABIAgQvQEgASAEECQNACAAQYAEaiIEIABBwAJqIgEgAEEIahC9ASABIARBwAEQ0QEaIAEQpAEgAEGAAWogARAkRQ0AQQEhAwsgAEHABWokAEF/IANFDQAaIAJBwAFqEKQBIAJBgANqIQhBACEAIwBB4ARrIgEkACABQeAAENABIQECQCAFBEADQCAAQeAARgRAIAEgAS0AAEEfcToAACABQeAAaiABEB9BACEAAkAgDSwAACILQQBOBEAgDUHgAGohAyAFQeAAIAVB4ABLG0HgAGshBANAIABB4ABGBEAgAUHgAWoiACABEB8gCCABQeAAaiAAED8MAwsgACAERwRA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AWoQmQEgACAEEBEgAEGAAWoiASAFQYABahCZASABIAgQESAAIAEQeg0BC0EADAELQQELIQEgAEGAAmokACANQcAHaiQAQX8gAUUNABojAEHgA2siACQAIABBgAFqIgFBwKjAABBJIABBuAFqIgNB+KjAABBJIAAgASADEEsgAEHwAmoiAUGwqcAAEEkgAEGoA2oiA0HoqcAAEEkgAEHwAWoiBCABIAMQSyACQYAGaiIBIAAgBBA/IABB4ANqJAAgAkGACWohByACQYADaiEIIwBBkDRrIgAkACAAQYAoaiIDQcitwAAQSSAAQYguaiIEQYCuwAAQSSAAIAMgBBBLIABBgAFqQTgQ0AEaIABBuAFqQTgQ0AEaIABB8AFqED0CQCACQcABaiIEEIYBRQRAIAIQhgEEQCAHIAEgBBAODAILIABB8ARqIgMQPSADIAEQfSADEEcgAEHwB2oiBRBnIAUgBBB4IAUQRiAAQbAJaiIEED0gBCAIEH0gBBBHIABBsAxqIggQZyAIIAIQeCAIEEYgAEGILmoiASAFEJABIABB8A1qIAEQkAEgASAAQbAIahCQASAAQbAOaiABEJABIAEgCBCQASAAQfAOaiABEJABIAEgAEHwDGoQkAEgAEGwD2ogARCQASAAQfAPaiIBED0gAEHwEmoiBRA9IABB8BVqEFUgASADEH0gBSAEEH0gAEH4G2oiARA9IAEgAxB9IAEQogEgAEH4HmoiARA9IAEgBBB9IAEQogEgAEG4AWogAEGAAWoQUEECayEBA0AgAUEBakEBTQRAIABB8BVqIgEQngEgByABQYgGENEBGgwDBSAAQfAVaiIEEBogAEH4IWoiAyAAQfAPaiAAQfANaiAAQbAOahALIABBgChqIgUgAEHwEmogAEHwDmogAEGwD2oQCyADIAUQAyAEIAMQAQJAAkACQCAAQbgBaiABEFMgAEGAAWogARBTa0EBag4DAQIAAgsgAEGILmoiAyAAQfAPaiAAQfAEaiAAQfANaiAAQbAOahAKIABB+CFqIgQgA0GIBhDRARogAyAAQfASaiAAQbAJaiAAQfAOaiAAQbAPahAKIAQgAxADIABB8BVqIAQQAQwBCyAAQYguaiIDIABB8A9qIABB+BtqIABB8A1qIABBsA5qEAogAEH4IWoiBCADQYgGENEBGiADIABB8BJqIABB+B5qIABB8A5qIABBsA9qEAogBCADEAMgAEHwFWogBBABCyABQQFrIQEMAQsACwALIAcgCCACEA4LIABBkDRqJAAjAEHgH2siCCQAIAhB0BNqIgFByK3AABBJIAhB2BlqIg1BgK7AABBJIAggASANEEsgCEGAAWoiC0GQrcAAEEkgAkGID2oiACAHEGkgCEG4AWoiBSAAEGkjAEGACGsiAyQAIAMgBRCMASADQYACaiIJIAVBgAJqIg8QjAEgA0GABGoiCiAFEIwBIANBgAZqIgRBOBDQARogA0EBNgK4BiADQcAGakE4ENABGiADQfgGakEBNgIAIANBgAdqQTgQ0AEaIANBuAdqQQE2AgAgA0HAB2pBOBDQARogA0H4B2pBATYCACAFEJ0BIAMQISAJIAVBgARqIgwQGCAJEGQgAyAJEHkgAxCwASAJIAwQlgEgCRAhIAkQZCAKIA8QGCAJIAoQeSAJELABIAogDxCWASAKECEgBCAFEJYBIAQgDBAYIAogBBB5IAoQsAEgBCAPEJYBIAQgChAYIAQQZCAFIAMQGCAEIAUQlwEgDCAJEBggDBBkIAQgDBCXASAEELABIwBBgAJrIgYkACAGIAQQXiAGQYABaiIQIARBgAFqIhIQXiAGEC0gEBAtIBAQfCAQEKkBIAYgEBB7IAYQPiAEIAYQESAGEDYgBhCpASASIAYQESAGQYACaiQAIAUgAxCWASAFIAQQGCAPIAkQlgEgDyAEEBggDCAKEJYBIAwgBBAYIAVBBTYCgAYgA0GACGokACAAEJ4BIAAgBRAHIAUgABBtIAAgCBAyIAAgCBAyIAAgBRAHIAhBwAdqIgQgABBpIAQQEyAEIAAQByANIAAgCxAbIAhByA1qIgMgDRBpIAMQngEgASAAEGkgARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gASAIEDIgACADEG0gACABEAcgDSAAIAsQGyADIA0QbSANIAMgCxAbIAMgDRBtIAEgABBtIAEgCBAyIAEgCBAyIAMgARAHIAEgABBtIAEQngEgACADEG0gACABEAcgACAEEAcgABCcASAIQeAfaiQAIAcgAEGIBhDRARpBACEAIwBBgAJrIgEkACABEGwCQCAHIAEQegR/IAdBgAFqIAFBgAFqEHoFQQALRQ0AIAdBgAJqEIcBRQ0AIAdBgARqEIcBIQALIAFBgAJqJABBACAADQAaQX8LIAJBkBVqJAAgDkEoahC0ASAOQSBqELQBIA5BGGoQtAEgDkEwaiQAC58BAgJ/BX4gAEEwaiICKQMAIAFBP3GtIgSGIQUgACkDKCIGQTogAWtBP3GtIgiHIQdBBiEBA38gAiAFIAeENwMAIAFBAU0EfyAAIAApAwAgBIZC//////////8DgzcDACAAKQMwQiSHpwUgAUEBayEBIAJBEGsiA0EIaiECIAYgBIZC//////////8DgyEHIAMpAwAiBiAIhyEFDAELCxoLiAECA34DfyMAQRBrIgUkAAN+IAZBOEYEfiAFQRBqJAAgAwUgBSAAIAZqIgcpAwAiAiACQj+HIAGsIgIgAkI/hxAvIAcgBSkDACIEIAN8IgJC//////////8DgzcDACACIARUrSAFQQhqKQMAIANCP4d8fEIGhiACQjqIhCEDIAZBCGohBgwBCwsLigECA38BfiMAQUBqIgIkACACQQhqIgEgABBdIAEQQiACQThqIQFBBiEDQdwCIQACQAJAA0AgA0EATgRAIAEpAwAiBEIAUg0CIAFBCGshASAAQTprIQAgA0EBayEDDAELC0EAIQAMAQsDQCAEUA0BIABBAWohACAEQgJ/IQQMAAsACyACQUBrJAAgAAuHAQEDfyMAQYACayIBJAAgABCwASABIAAQXiABQYABaiICQTgQ0AEaIAFBATYCuAEgAUHAAWpBOBDQARogAUH4AWpBATYCACABIABBgAFqIgMQmgEgARA2IAIgARCZASACIAMQmgEgAyABEJkBIAMgABCaASAAIAIQmQEgABCwASABQYACaiQAC30CBH4BfyABQT9xrSECQTogAWtBP3GtIQRBACEBIAApAwAiBSEDA38gAUEwRgR/IAAgACkDMCAChzcDMCAFQn8gAoZCf4WDpwUgACABaiIGIAMgAocgBkEIaikDACIDIASGQv//////////A4OENwMAIAFBCGohAQwBCwsaC2kBBH8jAEHAAWsiASQAIAEgABCQASABQUBrIgIgABCQASABQYABaiIDIABBQGsiBBCQASABIAQQdyACIAAQdyACEEIgBCACEEogAxBDIAAgAxB3IAEQQiAAEEIgACABEEogAUHAAWokAAuCAQIBfwF+IABB8AAQ0AEhAANAIAJBOEYEQAJAIAAgASkDMCIDQjqHNwM4IAAgA0L//////////wODNwMwIABBQGshAEEAIQIDQCACQTBGDQEgACACakIANwMAIAJBCGohAgwACwALBSAAIAJqIAEgAmopAwA3AwAgAkEIaiECDAELCwtuAQZ+IAAgA0L/////D4MiBSABQv////8PgyIGfiIHIAUgAUIgiCIIfiIJIAYgA0IgiCIGfnwiBUIghnwiCjcDACAAIAcgClatIAYgCH4gBSAJVK1CIIYgBUIgiIR8fCABIAR+IAIgA358fDcDCAtqAgF/BX4gASkDCCAAKQMAhSIGQgGGQgGHIQdBACACa6whCAN+IANBOEYEfiAFBSAAIANqIgIgAikDACIEIAaFIAEgA2opAwAgBIUgCIOFIgQgB4U3AwAgBCAFhSEFIANBCGohAwwBCwsaC18CAX8EfkIBIQNBMCECA38gAkF4RgR/IARCAYYgA3ynQQFrBSABIAJqKQMAIgUgACACaikDACIGfUI6hyADgyAEhCEEIAJBCGshAiAFIAaFQgF9QjqHIAODIQMMAQsLC2kBBH8jAEGAAmsiAiQAIAIgARBeIAJBgAFqIgMgARBeIAIQLSADIAIQESAAIAMQmAEgAEGAAmoiBCADEJgBIABBgARqIgUgAxCYASAEIAEQpgEgBSACEKYBIABBBTYCgAYgAkGAAmokAAtiAQJ/IwBBQGoiAiQAIAAQQiACIAAQkAECQCABBEAgACABEK4BDAELIAAQOgtBACEBA0AgA0UEQCAAEExBASABQQFqIAFBAUYiAxshAQwBCwsgACACEEogABAeIAJBQGskAAtnAQJ/IwBBQGoiAyQAAkAgASABQR91IgJqIAJzIgIgACgCOGxBgICAEE4EQCADIAIQOSAAIAMQSgwBCyAAIAIQKRogACAAKAI4IAJsNgI4CyABQQBIBEAgABBDIAAQQgsgA0FAayQAC2cAIABBAXYgAHIiAEECdiAAciIAQQR2IAByIgBBCHYgAHIiAEEQdiAAciIAIABBAXZB1arVqgVxayIAQQJ2QbPmzJkDcSAAQbPmzJkDcWoiAEEEdiAAakGPnrz4AHFBgYKECGxBGHYLYQEDfyMAQYABayIBJAAgASAAEJABIAFBQGsiAkE4ENABGiABQQE2AnggASAAQUBrIgMQdyABEEMgAiABEK4BIAIgAxB3IAMgARCuASADIAAQdyAAIAIQrgEgAUGAAWokAAtVAgJ/AX4jAEHwAGsiASQAIAFBwLLAABBJIAApAwAhAyABQThqIgIgABBdIABBARAsIAIgARBgIAIQQiACQQEQLCAAIAIgA0ICgacQMCABQfAAaiQAC5gBAQZ/IwBBwAFrIgMkACAAIAEQXiAAEC0gA0GIAWoiBkHop8AAEEkjAEFAaiIEJAAgA0EIaiICQTgQ0AEiBUEBNgI4IAVBQGtBOBDQASAFQfgAakEBNgIAIAQgBhCOASAFIAQQrgEQwQEgBEFAayQAIAIQqQEgAhB8IAIQqQEgACABEBEgACACEJoBIAAQtQEgA0HAAWokAAtZAQJ/IwBBQGoiAyQAIABBOBDQASIAQQE2AjgCQCABQQBOBEAgACABEJMBDAELIANBCGoiAkHAssAAEEkgAiABEJMBIAIQQiAAIAIQagsgABBUIANBQGskAAu9CAEKfyMAQYABayIHJAAgB0EIaiIDQcCywAAQSSADQQEQlAECQAJAA0AgAUEwRgRAIANBMGogAykDMEIBhzcDACADQThqIQEDQCACRQ0EIAFCADcDACACQQFrIQIgAUEIaiEBDAALAAsgAUE4Rg0BIAFBOEcEQCABIANqIAEgA2oiBEEIaikDAEI5hkL//////////wODIAQpAwBCAYeENwMAIAVBAWohBSABQQhqIQEMAQsLQQdBB0GEm8AAEDsACyAFQQdB9JrAABA7AAsgA0EBEJQBIANBARAsIAdBQGshBUEAIQIjAEGgCmsiASQAIAFBOBDQASIBQUBrQTgQ0AEhBiABQYABakE4ENABGiABQcABakE4ENABGiABQYACakE4ENABGiABQcACakE4ENABGiABQYADakE4ENABGiABQcADakE4ENABGiABQYAEakE4ENABGiABQcAEakE4ENABGiABQYAFakE4ENABGiABQcAFakE4ENABGiABQYAGakE4ENABGiABQcAGakE4ENABGiABQYAHakE4ENABGiABQcAHakE4ENABGiABQfgHakEBNgIAIAFBuAdqQQE2AgAgAUH4BmpBATYCACABQbgGakEBNgIAIAFB+AVqQQE2AgAgAUG4BWpBATYCACABQfgEakEBNgIAIAFBuARqQQE2AgAgAUH4A2pBATYCACABQbgDakEBNgIAIAFB+AJqQQE2AgAgAUG4AmpBATYCACABQfgBakEBNgIAIAFBuAFqQQE2AgAgAUH4AGpBATYCACABQQE2AjggAUGBCGpB5wAQ0AEaIAFB6AhqIgQgABCQASAEEEIgAUGoCWoiBCADEF0gBBBCIAQQKkEDaiIIQQJ2IgNBAWohCQJAA0AgAiAJRgRAIAEQygEgBiABQegIahCuASABQeAJakE4ENABGiABQQE2ApgKQYB5IQIMAgsgAUGoCWoiBCAEQQQQjwEiChCUASAEEEIgAkHnAEcEQCABQYEIaiACaiAKOgAAIAFBqAlqQQQQLCACQQFqIQIMAQsLQecAQecAQaC0wAAQOwALA0AgAgRAIAFB4AlqIgQgASACaiIGQcAHahCuASAGQYAIaiIGIAQQrgEgBiABQegIahBKIAJBQGshAgwBCwsCQAJAAkACQCAIQZwDSQRAIAFBgQhqIANqLAAAIgJBEE8NASAFIAEgAkEGdGoQkAEgA0EBayICQeYASyEEA0AgAkF/Rg0DIAUQTCAFEEwgBRBMIAUQTCAEDQQgAUGBCGogAmotAAAiA0EQSQRAIAUgASADQQZ0ahBKIAJBAWshAgwBCwsgA0EYdEEYdUEQQeC0wAAQOwALIANB5wBBsLTAABA7AAsgAkEQQcC0wAAQOwALIAUQHiABQaAKaiQADAELIAJB5wBB0LTAABA7AAsgACAFEK4BIAdBgAFqJAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQE2AgAgA0ICNwIMIANB2LjAADYCCCADQQE2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEGYAC2UBAn8gACAAKAIAIgJBCGoiAzYCACAAIAJBA3ZBPHFqQShqIgIgAUH/AXEgAigCAEEIdHI2AgACQAJAIANFBEAgAEEANgIAIAAgACgCBEEBajYCBAwBCyADQf8DcQ0BCyAAEA8LC1wAIABBOBDQASIAQQE2AjggAEFAa0E4ENABGiAAQfgAakEBNgIAIABBgAFqEFEgAEGAAmpBOBDQARogAEG4AmpBATYCACAAQcACakE4ENABGiAAQfgCakEBNgIAC1sBA38jAEGAAWsiASQAIAAQqQEgASAAEJABIAFBQGsiAiAAQUBrIgMQkAEgARBMIAIQTCABIAIQdyABQQAQMyAAIAEQSiABEEMgARBCIAMgARBKIAFBgAFqJAALYQEBfyMAQYACayIDJAAgABA9IAAgARCZASAAQYABaiIBIAIQmQEgAEGAAmoQtwEgABCpASADIAAQOCADQYABaiICIAEQXiACEC0gAiADEHpFBEAgABCbAQsgA0GAAmokAAtUAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqIAJBCGoQDCACQSBqJAALZwAjAEEwayIBJABBpLvAAC0AAARAIAFBHGpBATYCACABQgI3AgwgAUGQtsAANgIIIAFBATYCJCABIAA2AiwgASABQSBqNgIYIAEgAUEsajYCICABQQhqQbi2wAAQZgALIAFBMGokAAtiAgF+An8gACkDACEBA34gACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkEoRgR+IAAgACkDMCABfCIBNwMwIAFCJIcFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLGgt8AQV/IwBBQGoiAyQAIANBCGoiAkHAssAAEEkgAiAAKAI4QQFrEDUiBBAoA0AgAUE4RwRAIAAgAWoiBSABIAJqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAEEBIARBAWp0IgI2AjggAkH///8PSgRAIAAQHgsgA0FAayQAC3sBAn8gAEEoaiECA0AgAUGAAkYEQCAAQufMp9DW0Ouzu383AgggAEIANwIAIABBIGpCq7OP/JGjs/DbADcCACAAQRhqQv+kuYjFkdqCm383AgAgAEEQakLy5rvjo6f9p6V/NwIABSABIAJqQQA2AgAgAUEEaiEBDAELCwtUACAAQTgQ0AEiAEEBNgI4IABBQGtBOBDQARogAEH4AGpBATYCACAAQYABakE4ENABGiAAQbgBakEBNgIAIABBwAFqQTgQ0AEaIABB+AFqQQE2AgALWAECfyMAQUBqIgEkAAJAIAAQhgENACABQQEQOSAAQYABaiICIAEQWA0AIAJBABAzIAAgAhBKIAAQHiAAQUBrIgAgAhBKIAAQHiACIAEQrgELIAFBQGskAAtZAQJ/IwBBgAFrIgEkAAJAIAAQigENACABEFEgAEGAAmoiAiABEHoNACACED4gACACEBEgABC1ASAAQYABaiIAIAIQESAAELUBIAIgARCZAQsgAUGAAWokAAtbAgF+An8gACkDACEBA0AgACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkHgAEYEQCAAIAApA2ggAXw3A2gFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLC08BAX8gAEE4ENABGgJAA0AgAkEHRwRAIAJBB0YNAiAAIAEpAwA3AwAgAEEIaiEAIAFBCGohASACQQFqIQIMAQsLDwtBB0EHQeSawAAQOwALVAECfyMAQbABayICJAAgATQCOCAANAI4fkL///8PVQRAIAAQHgsgAkEIaiIDIAAgARAFIAJB+ABqIgEgAxBrIAAgARBqIABBAjYCOCACQbABaiQAC1EBAn8jAEFAaiIDJAAgAEE4ENABIgBBATYCOCAAQUBrQTgQ0AEgAEH4AGpBATYCACADIAEQjgEgACADEK4BIAMgAhCOASADEK4BIANBQGskAAvwDAIRfwh+IwBBsAFrIg8kACAANAI4IhIgEn5C////D1YEQCAAEB4LIwBB0AFrIgEkACAPQQhqIgZBCGpB0AAQ0AEaIAFBwAFqIAApAwAiFyAXQj+HIhYgFyAWEC8gBiABKQPAASISQv//////////A4M3AwAgAUHIAWopAwAiFUIGhiASQjqIhCETIBVCOoghGCAAQQhqIgwhDSAAIQlBASEKQQEhBwJAA0AgCkEERgRAIABBGGohCiAAQRBqIQkgAEEoaiEMIAApAzAhF0EHIQUgAUHIAGohCwNAIAVBC0kEQCABQUBrIAVBA3QiCCAAakEwaykDACISIBJCP4cgFyAXQj+HIhYQLyAFQQFqIg1BAXYhByALKQMAIRUgASkDQCESIAkhAiAMIQQgBUEFayIOIQMDQCADIAdJBEAgASACKQMAIhQgFEI/hyAEKQMAIhQgFEI/hxAvIAEpAwAiFCASfCISIBRUrSABQQhqKQMAIBV8fCEVIAJBCGohAiAEQQhrIQQgA0EBaiEDDAELCyAGIAhqIBJCAYYiFCATfCITQv//////////A4M3AwAgAUEwaiAAIA5BA3RqKQMAIhkgGUI/hyAXIBYQLyATIBRU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aikDADcDACACQQhqIQIMAQsLC4QJAg1/Cn4jAEFAaiILJAAgC0EIaiIJQcCywAAQSSMAQZACayICJAAgAEEwENABIQogAkHoAGpB8AAQ0AEaIAJB4AFqQTAQ0AEaIAoQcSACIAEiDCkDACIQQv3/8//P///5AX5C//////////8DgyISNwPYASACQdgAaiASQgAgCSkDACIXIBdCP4ciGBAvIBAgAikDWCIPfCITIA9UrSACQeAAaikDACAQQj+HfHwiEEI6hyABKQMIIg9CP4d8IA8gEEIGhiATQjqIhCITfCIQIBNUrXwhD0EBIQBCACETAkACQANAAkAgAEEHRgRAQQYhB0EAIQhBByEADAELIABBAXYiAUEBaiEGIAggAWshAyABQQN0IgFBCGohBCAHIAFrIQUgAkHIAGogCSAAQQN0Ig1qKQMAIhUgFUI/hyIWIBJCABAvIAJB0ABqKQMAIBAgECATfCIRVq0gDyAUfHx8IBEgAikDSHwiDyARVK18IRAgAEEBaiEBA0AgACAGTQRAIAJB2AFqIA1qIA9C/f/z/8////kBfkL//////////wODIhE3AwAgAkE4aiARQgAgFyAYEC8gAkEoaiARQgAgFSAWEC8gAkHoAGogAEEEdGoiACACQTBqKQMAIhE3AwggACACKQMoIhU3AwAgDyACKQM4IhZ8Ig8gFlStIAJBQGspAwAgEHx8IhBCOocgDCABQQN0aikDACIWQj+HfCAWIBBCBoYgD0I6iIQiD3wiECAPVK18IQ8gEyAVfCITIBVUrSARIBR8fCEUIAdBCGohByAIQQFqIQggASEADAMLIANBB08NAyACQRhqIAQgCWopAwAgBSAJaikDAH0iESARQj+HIAJB2AFqIg4gBWopAwAgBCAOaikDAH0iESARQj+HEC8gAikDGCIRIA98Ig8gEVStIAJBIGopAwAgEHx8IRAgBkEBaiEGIARBCGohBCAFQQhrIQUgA0EBayEDDAALAAsLA0ACQAJAIABBDUcEQCAHIABBAXYiBmshAyAIIAZBA3QiAWshBCABQQhqIQUgDyAUfCAQIBN8Ig8gEFStfCEQIABBAWohAQNAIAZBBUsNAyADQQdPDQIgAkEIaiAFIAlqKQMAIAQgCWpBMGopAwB9IhIgEkI/hyACIARqQYgCaikDACACQdgBaiAFaikDAH0iEiASQj+HEC8gAikDCCISIA98Ig8gElStIAJBEGopAwAgEHx8IRAgBkEBaiEGIARBCGshBCADQQFrIQMgBUEIaiEFDAALAAsgCiAQQv//////////A4M3AzAgAkGQAmokAAwECyADQQdBpJzAABA7AAsgAEEDdCAKakE4ayAPQv//////////A4M3AwAgEEI6hyAMIAFBA3RqKQMAIhJCP4d8IBIgEEIGhiAPQjqIhCIPfCIQIA9UrXwhDyAUIABBBHQgAmpBCGoiAEEIaikDAH0gEyAAKQMAIhJUrX0hFCAIQQhqIQggB0EBaiEHIBMgEn0hEyABIQAMAAsACyADQQdBlJzAABA7AAsgC0FAayQACy4BAX8jAEGAAWsiASQAIAAQRSABEFEgACABEJkBIABBgAFqELYBIAFBgAFqJAALMwAgACABEJYBIABBgAJqIAFBgAJqEJYBIABBgARqIAFBgARqEJYBIAAgASgCgAY2AoAGCygAIAAgASACEHIgAEFAayABQUBrIAIQciAAQYABaiABQYABaiACEHILLQAgACABIAIQjQEgAEGAAWogAUGAAWogAhCNASAAQYACaiABQYACaiACEI0BCycBAn8jAEFAaiICJAAgAkEIaiIDIAEQvgEgACADEI4BIAJBQGskAAsiAQF/A0AgAUE4RwRAIAAgAWpCADcDACABQQhqIQEMAQsLCyUAIAAgASACEDAgAEEAIAJrIAAoAjgiACABKAI4c3EgAHM2AjgLJwAgACAAKAIEQQFxIAFyQQJyNgIEIAAgAWoiACAAKAIEQQFyNgIECyMAA0AgAgRAIAAgAS0AABA8IAJBAWshAiABQQFqIQEMAQsLCywAIAAQiwEgACABEJYBIABBgAJqIAIQlgEgAEGABGogAxCWASAAQQU2AoAGCyMBAX8jAEFAaiIBJAAgASAAEJABIAEQHiABEFcgAUFAayQACykAIAAgARBgIAAgACgCOCABKAI4aiIBNgI4IAFB////D0oEQCAAEB4LCyUAIAAgARCuASAAQUBrIAFBQGsQrgEgAEGAAWogAUGAAWoQrgELKAEBfyMAQYACayICJAAgAiABEIwBIAIQKyAAIAIQlwEgAkGAAmokAAscAQF/IAAgARBYBH8gAEFAayABQUBrEFgFQQALCycBAX8jAEGAAWsiAiQAIAIg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DCELDQALCyAMpyICQeMASwRAIABBAmsiACAGQQlqaiAMpyICIAJB//8DcUHkAG4iAkHkAGxrQf//A3FBAXRB6LjAAGovAAA7AAALAkAgAkEKTwRAIABBAmsiACAGQQlqaiACQQF0Qei4wABqLwAAOwAADAELIABBAWsiACAGQQlqaiACQTBqOgAACwJ/IAZBCWogAGohCEErQYCAxAAgASgCACIDQQFxIgIbIQQgAkEnIABrIglqIQJBlLjAAEEAIANBBHEbIQUCQAJAIAEoAghFBEBBASEAIAEgBCAFEFINAQwCCwJAAkACQAJAIAIgAUEMaigCACIDSQRAIAEtAABBCHENBEEAIQAgAyACayICIQNBASABLQAgIgcgB0EDRhtBA3FBAWsOAgECAwtBASEAIAEgBCAFEFINBAwFC0EAIQMgAiEADAELIAJBAXYhACACQQFqQQF2IQMLIABBAWohACABQRxqKAIAIQcgASgCBCECIAEoAhghCgJAA0AgAEEBayIARQ0BIAogAiAHKAIQEQQARQ0AC0EBDAQLQQEhACACQYCAxABGDQEgASAEIAUQUg0BIAEoAhggCCAJIAEoAhwoAgwRBQANASABKAIcIQQgASgCGCEBQQAhAAJ/A0AgAyAAIANGDQEaIABBAWohACABIAIgBCgCEBEEAEUNAAsgAEEBawsgA0khAAwBCyABKAIEIQcgAUEwNgIEIAEtACAhCkEBIQAgAUEBOgAgIAEgBCAFEFINAEEAIQAgAyACayICIQMCQAJAAkBBASABLQAgIgQgBEEDRhtBA3FBAWsOAgABAgtBACEDIAIhAAwBCyACQQF2IQAgAkEBakEBdiEDCyAAQQFqIQAgAUEcaigCACECIAEoAgQhBCABKAIYIQUCQANAIABBAWsiAEUNASAFIAQgAigCEBEEAEUNAAtBAQwDC0EBIQAgBEGAgMQARg0AIAEoAhggCCAJIAEoAhwoAgwRBQANACABKAIcIQAgASgCGCEFQQAhAgJAA0AgAiADRg0BIAJBAWohAiAFIAQgACgCEBEEAEUNAAtBASEAIAJBAWsgA0kNAQsgASAKOgAgIAEgBzYCBEEADAILIAAMAQsgASgCGCAIIAkgAUEcaigCACgCDBEFAAsgBkEwaiQACwsAIAAQNiAAELABCysCAX8BfkIBIQIDQCAAIAFq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AAANAEHgs8AAC8EHYXR0ZW1wdCB0byBkaXZpZGUgYnkgemVybwAAAAAAAABhdHRlbXB0IHRvIGRpdmlkZSB3aXRoIG92ZXJmbG93ALAZEAASAAAADAIAAA0AAACwGRAAEgAAABgCAAAmAAAAsBkQABIAAAAYAgAAIwAAALAZEAASAAAAHgIAABcAAACwGRAAEgAAAB4CAAAUAAAAqqr//////gHu//9UrP//AupBYg9rDyoBw5z9ShTOEwJLd2TXrEtDAu3pxpKm+V8Cox4RoAEAAAADAAAABAAAAAQAAAAEAAAABQAAAAYAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAoAAOsaEAAVAAAAABsQAA4AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnMgGxAAGAAAAEkBAAAJAAAAbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5yc0gbEAAcAAAARgIAAB8AAABIGxAAHAAAAEcCAAAeAAAABwAAAAwAAAAEAAAACAAAAAMAAAAIAAAABAAAAAkAAAAKAAAAEAAAAAQAAAALAAAADAAAAAMAAAAIAAAABAAAAA0AAAAOAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAA6BsQABEAAADMGxAAHAAAAAUCAAAFAAAAEAAAAAAAAAABAAAAEQAAAGluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAAkHBAAIAAAAEQcEAASAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5yc3JhbmdlIGVuZCBpbmRleCAAAABxHRAAEAAAADAdEAAiAAAAUh0QAB8AAABJAAAABQB7CXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS42MS4wIChmZTViMTNkNjggMjAyMi0wNS0xOCkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4SMC4yLjgxICgwNjJhYTVmNzAp`;
});

// node_modules/@dfinity/agent/lib/cjs/vendor/bls/bls.js
var require_bls = __commonJS((exports) => {
  var bls_init2 = function() {
    let ret2 = wasm3.bls_init();
    return ret2;
  };
  var getUint8Memory02 = function() {
    if (cachegetUint8Memory02 === null || cachegetUint8Memory02.buffer !== wasm3.memory.buffer) {
      cachegetUint8Memory02 = new Uint8Array(wasm3.memory.buffer);
    }
    return cachegetUint8Memory02;
  };
  var passArray8ToWasm02 = function(arg, malloc) {
    const ptr = malloc(arg.length * 1);
    getUint8Memory02().set(arg, ptr / 1);
    return [ptr, arg.length];
  };
  var bls_verify2 = function(sig, m, w) {
    const [ptr0, len0] = passArray8ToWasm02(sig, wasm3.__wbindgen_malloc);
    const [ptr1, len1] = passArray8ToWasm02(m, wasm3.__wbindgen_malloc);
    const [ptr2, len2] = passArray8ToWasm02(w, wasm3.__wbindgen_malloc);
    const ret2 = wasm3.bls_verify(ptr0, len0, ptr1, len1, ptr2, len2);
    return ret2;
  };
  async function load2(module2, imports) {
    if (typeof Response === "function" && module2 instanceof Response) {
      const bytes = await module2.arrayBuffer();
      return await WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = await WebAssembly.instantiate(module2, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module: module2 };
      } else {
        return instance;
      }
    }
  }
  async function init2() {
    const imports = {};
    const { instance, module: module2 } = await load2(wasmBytes2, imports);
    wasm3 = instance.exports;
    init2.__wbindgen_wasm_module = module2;
    return wasm3;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bls_verify = exports.bls_init = undefined;
  var base64Arraybuffer2 = __importStar(require_base64_arraybuffer());
  var wasm_1 = require_wasm();
  var wasm3;
  var wasmBytes2 = base64Arraybuffer2.decode(wasm_1.wasmBytesBase64);
  exports.bls_init = bls_init2;
  var cachegetUint8Memory02 = null;
  exports.bls_verify = bls_verify2;
  exports.default = init2;
});

// node_modules/@dfinity/agent/lib/cjs/utils/bls.js
var require_bls2 = __commonJS((exports) => {
  async function blsVerify2(pk, sig, msg) {
    if (!exports.verify) {
      await (0, bls_1.default)();
      if ((0, bls_1.bls_init)() !== 0) {
        throw new Error("Cannot initialize BLS");
      }
      exports.verify = (pk1, sig1, msg1) => {
        return (0, bls_1.bls_verify)(sig1, msg1, pk1) === 0;
      };
    }
    return (0, exports.verify)(pk, sig, msg);
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.blsVerify = exports.verify = undefined;
  var bls_1 = __importStar(require_bls());
  exports.blsVerify = blsVerify2;
});

// node_modules/@dfinity/agent/lib/cjs/certificate.js
var require_certificate = __commonJS((exports) => {
  var hashTreeToString = function(tree) {
    const indent = (s2) => s2.split("\n").map((x2) => "  " + x2).join("\n");
    function labelToString(label) {
      const decoder = new TextDecoder(undefined, { fatal: true });
      try {
        return JSON.stringify(decoder.decode(label));
      } catch (e) {
        return `data(...${label.byteLength} bytes)`;
      }
    }
    switch (tree[0]) {
      case 0:
        return "()";
      case 1: {
        const left = hashTreeToString(tree[1]);
        const right = hashTreeToString(tree[2]);
        return `sub(\n left:\n${indent(left)}\n---\n right:\n${indent(right)}\n)`;
      }
      case 2: {
        const label = labelToString(tree[1]);
        const sub = hashTreeToString(tree[2]);
        return `label(\n label:\n${indent(label)}\n sub:\n${indent(sub)}\n)`;
      }
      case 3: {
        return `leaf(...${tree[1].byteLength} bytes)`;
      }
      case 4: {
        return `pruned(${(0, buffer_1.toHex)(new Uint8Array(tree[1]))}`;
      }
      default: {
        return `unknown(${JSON.stringify(tree[0])})`;
      }
    }
  };
  var isBufferEqual2 = function(a, b2) {
    if (a.byteLength !== b2.byteLength) {
      return false;
    }
    const a8 = new Uint8Array(a);
    const b8 = new Uint8Array(b2);
    for (let i = 0;i < a8.length; i++) {
      if (a8[i] !== b8[i]) {
        return false;
      }
    }
    return true;
  };
  var extractDER2 = function(buf) {
    const expectedLength = DER_PREFIX2.byteLength + KEY_LENGTH2;
    if (buf.byteLength !== expectedLength) {
      throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);
    }
    const prefix = buf.slice(0, DER_PREFIX2.byteLength);
    if (!isBufferEqual2(prefix, DER_PREFIX2)) {
      throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX2}, but get ${prefix}`);
    }
    return buf.slice(DER_PREFIX2.byteLength);
  };
  async function reconstruct2(t2) {
    switch (t2[0]) {
      case 0:
        return (0, request_id_1.hash)(domain_sep2("ic-hashtree-empty"));
      case 4:
        return t2[1];
      case 3:
        return (0, request_id_1.hash)((0, buffer_1.concat)(domain_sep2("ic-hashtree-leaf"), t2[1]));
      case 2:
        return (0, request_id_1.hash)((0, buffer_1.concat)(domain_sep2("ic-hashtree-labeled"), t2[1], await reconstruct2(t2[2])));
      case 1:
        return (0, request_id_1.hash)((0, buffer_1.concat)(domain_sep2("ic-hashtree-fork"), await reconstruct2(t2[1]), await reconstruct2(t2[2])));
      default:
        throw new Error("unreachable");
    }
  }
  var domain_sep2 = function(s2) {
    const len = new Uint8Array([s2.length]);
    const str = new TextEncoder().encode(s2);
    return (0, buffer_1.concat)(len, str);
  };
  var lookup_path2 = function(path, tree) {
    if (path.length === 0) {
      switch (tree[0]) {
        case 3: {
          return new Uint8Array(tree[1]).buffer;
        }
        default: {
          return;
        }
      }
    }
    const label = typeof path[0] === "string" ? new TextEncoder().encode(path[0]) : path[0];
    const t2 = find_label2(label, flatten_forks2(tree));
    if (t2) {
      return lookup_path2(path.slice(1), t2);
    }
  };
  var flatten_forks2 = function(t2) {
    switch (t2[0]) {
      case 0:
        return [];
      case 1:
        return flatten_forks2(t2[1]).concat(flatten_forks2(t2[2]));
      default:
        return [t2];
    }
  };
  var find_label2 = function(l, trees) {
    if (trees.length === 0) {
      return;
    }
    for (const t2 of trees) {
      if (t2[0] === 2) {
        const p = t2[1];
        if (isBufferEqual2(l, p)) {
          return t2[2];
        }
      }
    }
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lookup_path = exports.reconstruct = exports.Certificate = exports.hashTreeToString = exports.CertificateVerificationError = undefined;
  var cbor4 = __importStar(require_cbor());
  var errors_1 = require_errors();
  var request_id_1 = require_request_id();
  var buffer_1 = require_buffer3();
  var principal_1 = require_cjs();
  var bls3 = __importStar(require_bls2());

  class CertificateVerificationError2 extends errors_1.AgentError {
    constructor(reason) {
      super(`Invalid certificate: ${reason}`);
    }
  }
  exports.CertificateVerificationError = CertificateVerificationError2;
  exports.hashTreeToString = hashTreeToString;

  class Certificate2 {
    constructor(certificate4, _rootKey, _canisterId, _blsVerify) {
      this._rootKey = _rootKey;
      this._canisterId = _canisterId;
      this._blsVerify = _blsVerify;
      this.cert = cbor4.decode(new Uint8Array(certificate4));
    }
    static async create(options) {
      let blsVerify2 = options.blsVerify;
      if (!blsVerify2) {
        blsVerify2 = bls3.blsVerify;
      }
      const cert = new Certificate2(options.certificate, options.rootKey, options.canisterId, blsVerify2);
      await cert.verify();
      return cert;
    }
    lookup(path) {
      return lookup_path2(path, this.cert.tree);
    }
    async verify() {
      const rootHash = await reconstruct2(this.cert.tree);
      const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);
      const sig = this.cert.signature;
      const key = extractDER2(derKey);
      const msg = (0, buffer_1.concat)(domain_sep2("ic-state-root"), rootHash);
      let sigVer = false;
      try {
        sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));
      } catch (err) {
        sigVer = false;
      }
      if (!sigVer) {
        throw new CertificateVerificationError2("Signature verification failed");
      }
    }
    async _checkDelegationAndGetKey(d) {
      if (!d) {
        return this._rootKey;
      }
      const cert = await Certificate2.create({
        certificate: d.certificate,
        rootKey: this._rootKey,
        canisterId: this._canisterId
      });
      const rangeLookup = cert.lookup(["subnet", d.subnet_id, "canister_ranges"]);
      if (!rangeLookup) {
        throw new CertificateVerificationError2(`Could not find canister ranges for subnet 0x${(0, buffer_1.toHex)(d.subnet_id)}`);
      }
      const ranges_arr = cbor4.decode(rangeLookup);
      const ranges = ranges_arr.map((v) => [
        principal_1.Principal.fromUint8Array(v[0]),
        principal_1.Principal.fromUint8Array(v[1])
      ]);
      const canisterInRange = ranges.some((r) => r[0].ltEq(this._canisterId) && r[1].gtEq(this._canisterId));
      if (!canisterInRange) {
        throw new CertificateVerificationError2(`Canister ${this._canisterId} not in range of delegations for subnet 0x${(0, buffer_1.toHex)(d.subnet_id)}`);
      }
      const publicKeyLookup = cert.lookup(["subnet", d.subnet_id, "public_key"]);
      if (!publicKeyLookup) {
        throw new Error(`Could not find subnet key for subnet 0x${(0, buffer_1.toHex)(d.subnet_id)}`);
      }
      return publicKeyLookup;
    }
  }
  exports.Certificate = Certificate2;
  var DER_PREFIX2 = (0, buffer_1.fromHex)("308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100");
  var KEY_LENGTH2 = 96;
  exports.reconstruct = reconstruct2;
  exports.lookup_path = lookup_path2;
});

// node_modules/@dfinity/agent/lib/cjs/canisterStatus/index.js
var require_canisterStatus = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodePath = exports.request = undefined;
  var candid_1 = require_cjs2();
  var principal_1 = require_cjs();
  var errors_1 = require_errors();
  var certificate_1 = require_certificate();
  var buffer_1 = require_buffer3();
  var Cbor = __importStar(require_cbor());
  var request2 = async (options) => {
    const { canisterId, agent: agent14, paths } = options;
    const uniquePaths = [...new Set(paths)];
    const encodedPaths = uniquePaths.map((path) => {
      return (0, exports.encodePath)(path, canisterId);
    });
    const status = new Map;
    const promises = uniquePaths.map((path, index) => {
      return (async () => {
        var _a;
        try {
          const response = await agent14.readState(canisterId, {
            paths: [encodedPaths[index]]
          });
          const cert = await certificate_1.Certificate.create({
            certificate: response.certificate,
            rootKey: agent14.rootKey,
            canisterId
          });
          const data = cert.lookup((0, exports.encodePath)(uniquePaths[index], canisterId));
          if (!data) {
            console.warn(`Expected to find result for path ${path}, but instead found nothing.`);
            if (typeof path === "string") {
              status.set(path, null);
            } else {
              status.set(path.key, null);
            }
          } else {
            switch (path) {
              case "time": {
                status.set(path, decodeTime2(data));
                break;
              }
              case "controllers": {
                status.set(path, decodeControllers2(data));
                break;
              }
              case "module_hash": {
                status.set(path, decodeHex2(data));
                break;
              }
              case "candid": {
                status.set(path, new TextDecoder().decode(data));
                break;
              }
              default: {
                if (typeof path !== "string" && ("key" in path) && ("path" in path)) {
                  switch (path.decodeStrategy) {
                    case "raw":
                      status.set(path.key, data);
                      break;
                    case "leb128": {
                      status.set(path.key, decodeLeb1282(data));
                      break;
                    }
                    case "cbor": {
                      status.set(path.key, decodeCbor2(data));
                      break;
                    }
                    case "hex": {
                      status.set(path.key, decodeHex2(data));
                      break;
                    }
                    case "utf-8": {
                      status.set(path.key, decodeUtf82(data));
                    }
                  }
                }
              }
            }
          }
        } catch (error) {
          if ((_a = error === null || error === undefined ? undefined : error.message) === null || _a === undefined ? undefined : _a.includes("Invalid certificate")) {
            throw new errors_1.AgentError(error.message);
          }
          if (typeof path !== "string" && ("key" in path) && ("path" in path)) {
            status.set(path.key, null);
          } else {
            status.set(path, null);
          }
          console.group();
          console.warn(`Expected to find result for path ${path}, but instead found nothing.`);
          console.warn(error);
          console.groupEnd();
        }
      })();
    });
    await Promise.all(promises);
    return status;
  };
  exports.request = request2;
  var encodePath2 = (path, canisterId) => {
    const encoder = new TextEncoder;
    const encode2 = (arg) => {
      return new DataView(encoder.encode(arg).buffer).buffer;
    };
    const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;
    switch (path) {
      case "time":
        return [encode2("time")];
      case "controllers":
        return [encode2("canister"), canisterBuffer, encode2("controllers")];
      case "module_hash":
        return [encode2("canister"), canisterBuffer, encode2("module_hash")];
      case "subnet":
        return [encode2("subnet")];
      case "candid":
        return [encode2("canister"), canisterBuffer, encode2("metadata"), encode2("candid:service")];
      default: {
        if (("key" in path) && ("path" in path)) {
          if (typeof path["path"] === "string" || path["path"] instanceof ArrayBuffer) {
            const metaPath = path.path;
            const encoded = typeof metaPath === "string" ? encode2(metaPath) : metaPath;
            return [encode2("canister"), canisterBuffer, encode2("metadata"), encoded];
          } else {
            return path["path"];
          }
        }
      }
    }
    throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`);
  };
  exports.encodePath = encodePath2;
  var decodeHex2 = (buf) => {
    return (0, buffer_1.toHex)(buf);
  };
  var decodeLeb1282 = (buf) => {
    return (0, candid_1.lebDecode)(new candid_1.PipeArrayBuffer(buf));
  };
  var decodeCbor2 = (buf) => {
    return Cbor.decode(buf);
  };
  var decodeUtf82 = (buf) => {
    return new TextDecoder().decode(buf);
  };
  var decodeTime2 = (buf) => {
    const decoded = decodeLeb1282(buf);
    return new Date(Number(decoded / BigInt(1e6)));
  };
  var decodeControllers2 = (buf) => {
    const [tag, ...controllersRaw] = decodeCbor2(buf);
    return controllersRaw.map((buf2) => {
      return principal_1.Principal.fromUint8Array(new Uint8Array(buf2));
    });
  };
});

// node_modules/@dfinity/agent/lib/cjs/agent/http/index.js
var require_http = __commonJS((exports) => {
  var getDefaultFetch2 = function() {
    let defaultFetch;
    if (typeof window !== "undefined") {
      if (window.fetch) {
        defaultFetch = window.fetch.bind(window);
      } else {
        throw new HttpDefaultFetchError2("Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.");
      }
    } else if (typeof global !== "undefined") {
      if (global.fetch) {
        defaultFetch = global.fetch.bind(global);
      } else {
        throw new HttpDefaultFetchError2("Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.");
      }
    } else if (typeof self !== "undefined") {
      if (self.fetch) {
        defaultFetch = self.fetch.bind(self);
      }
    }
    if (defaultFetch) {
      return defaultFetch;
    }
    throw new HttpDefaultFetchError2("Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.");
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpAgent = exports.IdentityInvalidError = exports.RequestStatusResponseStatus = exports.makeNonce = undefined;
  var principal_1 = require_cjs();
  var errors_1 = require_errors();
  var auth_1 = require_auth();
  var cbor4 = __importStar(require_cbor());
  var request_id_1 = require_request_id();
  var buffer_1 = require_buffer3();
  var transforms_1 = require_transforms();
  var types_1 = require_types3();
  var errors_2 = require_errors2();
  __exportStar(require_transforms(), exports);
  var types_2 = require_types3();
  Object.defineProperty(exports, "makeNonce", { enumerable: true, get: function() {
    return types_2.makeNonce;
  } });
  var RequestStatusResponseStatus2;
  (function(RequestStatusResponseStatus3) {
    RequestStatusResponseStatus3["Received"] = "received";
    RequestStatusResponseStatus3["Processing"] = "processing";
    RequestStatusResponseStatus3["Replied"] = "replied";
    RequestStatusResponseStatus3["Rejected"] = "rejected";
    RequestStatusResponseStatus3["Unknown"] = "unknown";
    RequestStatusResponseStatus3["Done"] = "done";
  })(RequestStatusResponseStatus2 = exports.RequestStatusResponseStatus || (exports.RequestStatusResponseStatus = {}));
  var DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS2 = 5 * 60 * 1000;
  var IC_ROOT_KEY2 = "308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d9685f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484b01291091c5f87b98883463f98091a0baaae";
  var IC0_DOMAIN2 = "ic0.app";
  var IC0_SUB_DOMAIN2 = ".ic0.app";
  var ICP0_DOMAIN2 = "icp0.io";
  var ICP0_SUB_DOMAIN2 = ".icp0.io";
  var ICP_API_DOMAIN2 = "icp-api.io";
  var ICP_API_SUB_DOMAIN2 = ".icp-api.io";

  class HttpDefaultFetchError2 extends errors_1.AgentError {
    constructor(message) {
      super(message);
      this.message = message;
    }
  }

  class IdentityInvalidError2 extends errors_1.AgentError {
    constructor(message) {
      super(message);
      this.message = message;
    }
  }
  exports.IdentityInvalidError = IdentityInvalidError2;

  class HttpAgent2 {
    constructor(options = {}) {
      this.rootKey = (0, buffer_1.fromHex)(IC_ROOT_KEY2);
      this._pipeline = [];
      this._timeDiffMsecs = 0;
      this._rootKeyFetched = false;
      this._isAgent = true;
      if (options.source) {
        if (!(options.source instanceof HttpAgent2)) {
          throw new Error("An Agent's source can only be another HttpAgent");
        }
        this._pipeline = [...options.source._pipeline];
        this._identity = options.source._identity;
        this._fetch = options.source._fetch;
        this._host = options.source._host;
        this._credentials = options.source._credentials;
      } else {
        this._fetch = options.fetch || getDefaultFetch2() || fetch.bind(global);
        this._fetchOptions = options.fetchOptions;
        this._callOptions = options.callOptions;
      }
      if (options.host !== undefined) {
        if (!options.host.match(/^[a-z]+:/) && typeof window !== "undefined") {
          this._host = new URL(window.location.protocol + "//" + options.host);
        } else {
          this._host = new URL(options.host);
        }
      } else if (options.source !== undefined) {
        this._host = options.source._host;
      } else {
        const location = typeof window !== "undefined" ? window.location : undefined;
        if (!location) {
          throw new Error("Must specify a host to connect to.");
        }
        this._host = new URL(location + "");
      }
      this._retryTimes = options.retryTimes !== undefined && options.retryTimes >= 0 ? options.retryTimes : 3;
      if (this._host.hostname.endsWith(IC0_SUB_DOMAIN2)) {
        this._host.hostname = IC0_DOMAIN2;
      } else if (this._host.hostname.endsWith(ICP0_SUB_DOMAIN2)) {
        this._host.hostname = ICP0_DOMAIN2;
      } else if (this._host.hostname.endsWith(ICP_API_SUB_DOMAIN2)) {
        this._host.hostname = ICP_API_DOMAIN2;
      }
      if (options.credentials) {
        const { name, password } = options.credentials;
        this._credentials = `${name}${password ? ":" + password : ""}`;
      }
      this._identity = Promise.resolve(options.identity || new auth_1.AnonymousIdentity);
      if (!options.disableNonce) {
        this.addTransform((0, transforms_1.makeNonceTransform)(types_1.makeNonce));
      }
    }
    isLocal() {
      const hostname = this._host.hostname;
      return hostname === "127.0.0.1" || hostname.endsWith("localhost");
    }
    addTransform(fn, priority = fn.priority || 0) {
      const i = this._pipeline.findIndex((x2) => (x2.priority || 0) < priority);
      this._pipeline.splice(i >= 0 ? i : this._pipeline.length, 0, Object.assign(fn, { priority }));
    }
    async getPrincipal() {
      if (!this._identity) {
        throw new IdentityInvalidError2("This identity has expired due this application's security policy. Please refresh your authentication.");
      }
      return (await this._identity).getPrincipal();
    }
    async call(canisterId, options, identity2) {
      const id = await (identity2 !== undefined ? await identity2 : await this._identity);
      if (!id) {
        throw new IdentityInvalidError2("This identity has expired due this application's security policy. Please refresh your authentication.");
      }
      const canister = principal_1.Principal.from(canisterId);
      const ecid = options.effectiveCanisterId ? principal_1.Principal.from(options.effectiveCanisterId) : canister;
      const sender = id.getPrincipal() || principal_1.Principal.anonymous();
      let ingress_expiry = new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS2);
      if (Math.abs(this._timeDiffMsecs) > 1000 * 30) {
        ingress_expiry = new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS2 + this._timeDiffMsecs);
      }
      const submit = {
        request_type: types_1.SubmitRequestType.Call,
        canister_id: canister,
        method_name: options.methodName,
        arg: options.arg,
        sender,
        ingress_expiry
      };
      let transformedRequest = await this._transform({
        request: {
          body: null,
          method: "POST",
          headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
        },
        endpoint: "call",
        body: submit
      });
      transformedRequest = await id.transformRequest(transformedRequest);
      const body = cbor4.encode(transformedRequest.body);
      const request2 = this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign(Object.assign({}, this._callOptions), transformedRequest.request), { body })));
      const [response, requestId] = await Promise.all([request2, (0, request_id_1.requestIdOf)(submit)]);
      const responseBuffer = await response.arrayBuffer();
      const responseBody = response.status === 200 && responseBuffer.byteLength > 0 ? cbor4.decode(responseBuffer) : null;
      return {
        requestId,
        response: {
          ok: response.ok,
          status: response.status,
          statusText: response.statusText,
          body: responseBody,
          headers: (0, transforms_1.httpHeadersTransform)(response.headers)
        }
      };
    }
    async _requestAndRetry(request2, tries = 0) {
      const response = await request2();
      if (response.ok) {
        return response;
      }
      const responseText = await response.clone().text();
      const errorMessage = `Server returned an error:\n` + `  Code: ${response.status} (${response.statusText})\n` + `  Body: ${responseText}\n`;
      if (this._retryTimes > tries) {
        console.warn(errorMessage + `  Retrying request.`);
        return await this._requestAndRetry(request2, tries + 1);
      }
      throw new errors_2.AgentHTTPResponseError(errorMessage, {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
        headers: (0, transforms_1.httpHeadersTransform)(response.headers)
      });
    }
    async query(canisterId, fields, identity2) {
      const id = await (identity2 !== undefined ? await identity2 : await this._identity);
      if (!id) {
        throw new IdentityInvalidError2("This identity has expired due this application's security policy. Please refresh your authentication.");
      }
      const canister = typeof canisterId === "string" ? principal_1.Principal.fromText(canisterId) : canisterId;
      const sender = (id === null || id === undefined ? undefined : id.getPrincipal()) || principal_1.Principal.anonymous();
      const request2 = {
        request_type: "query",
        canister_id: canister,
        method_name: fields.methodName,
        arg: fields.arg,
        sender,
        ingress_expiry: new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS2)
      };
      let transformedRequest = await this._transform({
        request: {
          method: "POST",
          headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
        },
        endpoint: "read",
        body: request2
      });
      transformedRequest = await (id === null || id === undefined ? undefined : id.transformRequest(transformedRequest));
      const body = cbor4.encode(transformedRequest.body);
      const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
      const queryResponse = cbor4.decode(await response.arrayBuffer());
      return Object.assign(Object.assign({}, queryResponse), { httpDetails: {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
        headers: (0, transforms_1.httpHeadersTransform)(response.headers)
      } });
    }
    async createReadStateRequest(fields, identity2) {
      const id = await (identity2 !== undefined ? await identity2 : await this._identity);
      if (!id) {
        throw new IdentityInvalidError2("This identity has expired due this application's security policy. Please refresh your authentication.");
      }
      const sender = (id === null || id === undefined ? undefined : id.getPrincipal()) || principal_1.Principal.anonymous();
      const transformedRequest = await this._transform({
        request: {
          method: "POST",
          headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
        },
        endpoint: "read_state",
        body: {
          request_type: "read_state",
          paths: fields.paths,
          sender,
          ingress_expiry: new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS2)
        }
      });
      return id === null || id === undefined ? undefined : id.transformRequest(transformedRequest);
    }
    async readState(canisterId, fields, identity2, request2) {
      const canister = typeof canisterId === "string" ? principal_1.Principal.fromText(canisterId) : canisterId;
      const transformedRequest = request2 !== null && request2 !== undefined ? request2 : await this.createReadStateRequest(fields, identity2);
      const body = cbor4.encode(transformedRequest.body);
      const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
      if (!response.ok) {
        throw new Error(`Server returned an error:\n` + `  Code: ${response.status} (${response.statusText})\n` + `  Body: ${await response.text()}\n`);
      }
      return cbor4.decode(await response.arrayBuffer());
    }
    async syncTime(canisterId) {
      const CanisterStatus = await Promise.resolve().then(() => __importStar(require_canisterStatus()));
      const callTime = Date.now();
      try {
        if (!canisterId) {
          console.log("Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai");
        }
        const status = await CanisterStatus.request({
          canisterId: canisterId !== null && canisterId !== undefined ? canisterId : principal_1.Principal.from("ryjl3-tyaaa-aaaaa-aaaba-cai"),
          agent: this,
          paths: ["time"]
        });
        const replicaTime = status.get("time");
        if (replicaTime) {
          this._timeDiffMsecs = Number(replicaTime) - Number(callTime);
        }
      } catch (error) {
        console.error("Caught exception while attempting to sync time:", error);
      }
    }
    async status() {
      const headers = this._credentials ? {
        Authorization: "Basic " + btoa(this._credentials)
      } : {};
      const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/status`, this._host), Object.assign({ headers }, this._fetchOptions)));
      return cbor4.decode(await response.arrayBuffer());
    }
    async fetchRootKey() {
      if (!this._rootKeyFetched) {
        this.rootKey = (await this.status()).root_key;
        this._rootKeyFetched = true;
      }
      return this.rootKey;
    }
    invalidateIdentity() {
      this._identity = null;
    }
    replaceIdentity(identity2) {
      this._identity = Promise.resolve(identity2);
    }
    _transform(request2) {
      let p = Promise.resolve(request2);
      for (const fn of this._pipeline) {
        p = p.then((r) => fn(r).then((r2) => r2 || r));
      }
      return p;
    }
  }
  exports.HttpAgent = HttpAgent2;
});

// node_modules/@dfinity/agent/lib/cjs/agent/proxy.js
var require_proxy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyAgent = exports.ProxyStubAgent = exports.ProxyMessageKind = undefined;
  var principal_1 = require_cjs();
  var ProxyMessageKind2;
  (function(ProxyMessageKind3) {
    ProxyMessageKind3["Error"] = "err";
    ProxyMessageKind3["GetPrincipal"] = "gp";
    ProxyMessageKind3["GetPrincipalResponse"] = "gpr";
    ProxyMessageKind3["Query"] = "q";
    ProxyMessageKind3["QueryResponse"] = "qr";
    ProxyMessageKind3["Call"] = "c";
    ProxyMessageKind3["CallResponse"] = "cr";
    ProxyMessageKind3["ReadState"] = "rs";
    ProxyMessageKind3["ReadStateResponse"] = "rsr";
    ProxyMessageKind3["Status"] = "s";
    ProxyMessageKind3["StatusResponse"] = "sr";
  })(ProxyMessageKind2 = exports.ProxyMessageKind || (exports.ProxyMessageKind = {}));

  class ProxyStubAgent {
    constructor(_frontend, _agent) {
      this._frontend = _frontend;
      this._agent = _agent;
    }
    onmessage(msg) {
      switch (msg.type) {
        case ProxyMessageKind2.GetPrincipal:
          this._agent.getPrincipal().then((response) => {
            this._frontend({
              id: msg.id,
              type: ProxyMessageKind2.GetPrincipalResponse,
              response: response.toText()
            });
          });
          break;
        case ProxyMessageKind2.Query:
          this._agent.query(...msg.args).then((response) => {
            this._frontend({
              id: msg.id,
              type: ProxyMessageKind2.QueryResponse,
              response
            });
          });
          break;
        case ProxyMessageKind2.Call:
          this._agent.call(...msg.args).then((response) => {
            this._frontend({
              id: msg.id,
              type: ProxyMessageKind2.CallResponse,
              response
            });
          });
          break;
        case ProxyMessageKind2.ReadState:
          this._agent.readState(...msg.args).then((response) => {
            this._frontend({
              id: msg.id,
              type: ProxyMessageKind2.ReadStateResponse,
              response
            });
          });
          break;
        case ProxyMessageKind2.Status:
          this._agent.status().then((response) => {
            this._frontend({
              id: msg.id,
              type: ProxyMessageKind2.StatusResponse,
              response
            });
          });
          break;
        default:
          throw new Error(`Invalid message received: ${JSON.stringify(msg)}`);
      }
    }
  }
  exports.ProxyStubAgent = ProxyStubAgent;

  class ProxyAgent {
    constructor(_backend) {
      this._backend = _backend;
      this._nextId = 0;
      this._pendingCalls = new Map;
      this.rootKey = null;
    }
    onmessage(msg) {
      const id = msg.id;
      const maybePromise = this._pendingCalls.get(id);
      if (!maybePromise) {
        throw new Error("A proxy get the same message twice...");
      }
      this._pendingCalls.delete(id);
      const [resolve, reject] = maybePromise;
      switch (msg.type) {
        case ProxyMessageKind2.Error:
          return reject(msg.error);
        case ProxyMessageKind2.GetPrincipalResponse:
        case ProxyMessageKind2.CallResponse:
        case ProxyMessageKind2.QueryResponse:
        case ProxyMessageKind2.ReadStateResponse:
        case ProxyMessageKind2.StatusResponse:
          return resolve(msg.response);
        default:
          throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`);
      }
    }
    async getPrincipal() {
      return this._sendAndWait({
        id: this._nextId++,
        type: ProxyMessageKind2.GetPrincipal
      }).then((principal13) => {
        if (typeof principal13 !== "string") {
          throw new Error("Invalid principal received.");
        }
        return principal_1.Principal.fromText(principal13);
      });
    }
    readState(canisterId, fields) {
      return this._sendAndWait({
        id: this._nextId++,
        type: ProxyMessageKind2.ReadState,
        args: [canisterId.toString(), fields]
      });
    }
    call(canisterId, fields) {
      return this._sendAndWait({
        id: this._nextId++,
        type: ProxyMessageKind2.Call,
        args: [canisterId.toString(), fields]
      });
    }
    status() {
      return this._sendAndWait({
        id: this._nextId++,
        type: ProxyMessageKind2.Status
      });
    }
    query(canisterId, fields) {
      return this._sendAndWait({
        id: this._nextId++,
        type: ProxyMessageKind2.Query,
        args: [canisterId.toString(), fields]
      });
    }
    async _sendAndWait(msg) {
      return new Promise((resolve, reject) => {
        this._pendingCalls.set(msg.id, [resolve, reject]);
        this._backend(msg);
      });
    }
    async fetchRootKey() {
      const rootKey = (await this.status()).root_key;
      this.rootKey = rootKey;
      return rootKey;
    }
  }
  exports.ProxyAgent = ProxyAgent;
});

// node_modules/@dfinity/agent/lib/cjs/agent/index.js
var require_agent = __commonJS((exports) => {
  var getDefaultAgent2 = function() {
    const agent14 = typeof window === "undefined" ? typeof global === "undefined" ? typeof self === "undefined" ? undefined : self.ic.agent : global.ic.agent : window.ic.agent;
    if (!agent14) {
      throw new Error("No Agent could be found.");
    }
    return agent14;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getDefaultAgent = undefined;
  __exportStar(require_api(), exports);
  __exportStar(require_http(), exports);
  __exportStar(require_proxy(), exports);
  exports.getDefaultAgent = getDefaultAgent2;
});

// node_modules/@dfinity/agent/lib/cjs/polling/strategy.js
var require_strategy = __commonJS((exports) => {
  var defaultStrategy2 = function() {
    return chain2(conditionalDelay2(once2(), 1000), backoff2(1000, 1.2), timeout2(FIVE_MINUTES_IN_MSEC2));
  };
  var once2 = function() {
    let first = true;
    return async () => {
      if (first) {
        first = false;
        return true;
      }
      return false;
    };
  };
  var conditionalDelay2 = function(condition, timeInMsec) {
    return async (canisterId, requestId, status) => {
      if (await condition(canisterId, requestId, status)) {
        return new Promise((resolve) => setTimeout(resolve, timeInMsec));
      }
    };
  };
  var maxAttempts2 = function(count) {
    let attempts = count;
    return async (canisterId, requestId, status) => {
      if (--attempts <= 0) {
        throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\n` + `  Request ID: ${(0, buffer_1.toHex)(requestId)}\n` + `  Request status: ${status}\n`);
      }
    };
  };
  var throttle2 = function(throttleInMsec) {
    return () => new Promise((resolve) => setTimeout(resolve, throttleInMsec));
  };
  var timeout2 = function(timeInMsec) {
    const end = Date.now() + timeInMsec;
    return async (canisterId, requestId, status) => {
      if (Date.now() > end) {
        throw new Error(`Request timed out after ${timeInMsec} msec:\n` + `  Request ID: ${(0, buffer_1.toHex)(requestId)}\n` + `  Request status: ${status}\n`);
      }
    };
  };
  var backoff2 = function(startingThrottleInMsec, backoffFactor) {
    let currentThrottling = startingThrottleInMsec;
    return () => new Promise((resolve) => setTimeout(() => {
      currentThrottling *= backoffFactor;
      resolve();
    }, currentThrottling));
  };
  var chain2 = function(...strategies) {
    return async (canisterId, requestId, status) => {
      for (const a of strategies) {
        await a(canisterId, requestId, status);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chain = exports.backoff = exports.timeout = exports.throttle = exports.maxAttempts = exports.conditionalDelay = exports.once = exports.defaultStrategy = undefined;
  var buffer_1 = require_buffer3();
  var FIVE_MINUTES_IN_MSEC2 = 5 * 60 * 1000;
  exports.defaultStrategy = defaultStrategy2;
  exports.once = once2;
  exports.conditionalDelay = conditionalDelay2;
  exports.maxAttempts = maxAttempts2;
  exports.throttle = throttle2;
  exports.timeout = timeout2;
  exports.backoff = backoff2;
  exports.chain = chain2;
});

// node_modules/@dfinity/agent/lib/cjs/polling/index.js
var require_polling = __commonJS((exports) => {
  async function pollForResponse2(agent14, canisterId, requestId, strategy, request2, blsVerify2) {
    var _a;
    const path = [new TextEncoder().encode("request_status"), requestId];
    const currentRequest = request2 !== null && request2 !== undefined ? request2 : await ((_a = agent14.createReadStateRequest) === null || _a === undefined ? undefined : _a.call(agent14, { paths: [path] }));
    const state = await agent14.readState(canisterId, { paths: [path] }, undefined, currentRequest);
    if (agent14.rootKey == null)
      throw new Error("Agent root key not initialized before polling");
    const cert = await certificate_1.Certificate.create({
      certificate: state.certificate,
      rootKey: agent14.rootKey,
      canisterId,
      blsVerify: blsVerify2
    });
    const maybeBuf = cert.lookup([...path, new TextEncoder().encode("status")]);
    let status;
    if (typeof maybeBuf === "undefined") {
      status = agent_1.RequestStatusResponseStatus.Unknown;
    } else {
      status = new TextDecoder().decode(maybeBuf);
    }
    switch (status) {
      case agent_1.RequestStatusResponseStatus.Replied: {
        return cert.lookup([...path, "reply"]);
      }
      case agent_1.RequestStatusResponseStatus.Received:
      case agent_1.RequestStatusResponseStatus.Unknown:
      case agent_1.RequestStatusResponseStatus.Processing:
        await strategy(canisterId, requestId, status);
        return pollForResponse2(agent14, canisterId, requestId, strategy, currentRequest);
      case agent_1.RequestStatusResponseStatus.Rejected: {
        const rejectCode = new Uint8Array(cert.lookup([...path, "reject_code"]))[0];
        const rejectMessage = new TextDecoder().decode(cert.lookup([...path, "reject_message"]));
        throw new Error(`Call was rejected:\n` + `  Request ID: ${(0, buffer_1.toHex)(requestId)}\n` + `  Reject code: ${rejectCode}\n` + `  Reject text: ${rejectMessage}\n`);
      }
      case agent_1.RequestStatusResponseStatus.Done:
        throw new Error(`Call was marked as done but we never saw the reply:\n` + `  Request ID: ${(0, buffer_1.toHex)(requestId)}\n`);
    }
    throw new Error("unreachable");
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pollForResponse = exports.defaultStrategy = exports.strategy = undefined;
  var agent_1 = require_agent();
  var certificate_1 = require_certificate();
  var buffer_1 = require_buffer3();
  exports.strategy = __importStar(require_strategy());
  var strategy_1 = require_strategy();
  Object.defineProperty(exports, "defaultStrategy", { enumerable: true, get: function() {
    return strategy_1.defaultStrategy;
  } });
  exports.pollForResponse = pollForResponse2;
});

// node_modules/prom-client/lib/util.js
var require_util = __commonJS((exports) => {
  var hashObject = function(labels) {
    let keys = Object.keys(labels);
    if (keys.length === 0) {
      return "";
    }
    if (keys.length > 1) {
      keys = keys.sort();
    }
    let hash2 = "";
    let i = 0;
    const size = keys.length;
    for (;i < size - 1; i++) {
      hash2 += `${keys[i]}:${labels[keys[i]]},`;
    }
    hash2 += `${keys[i]}:${labels[keys[i]]}`;
    return hash2;
  };
  exports.getValueAsString = function getValueString(value4) {
    if (Number.isNaN(value4)) {
      return "Nan";
    } else if (!Number.isFinite(value4)) {
      if (value4 < 0) {
        return "-Inf";
      } else {
        return "+Inf";
      }
    } else {
      return `${value4}`;
    }
  };
  exports.removeLabels = function removeLabels(hashMap, labels) {
    const hash2 = hashObject(labels);
    delete hashMap[hash2];
  };
  exports.setValue = function setValue(hashMap, value4, labels) {
    const hash2 = hashObject(labels);
    hashMap[hash2] = {
      value: typeof value4 === "number" ? value4 : 0,
      labels: labels || {}
    };
    return hashMap;
  };
  exports.setValueDelta = function setValueDelta(hashMap, deltaValue, labels, hash2 = "") {
    const value4 = typeof deltaValue === "number" ? deltaValue : 0;
    if (hashMap[hash2]) {
      hashMap[hash2].value += value4;
    } else {
      hashMap[hash2] = { value: value4, labels };
    }
    return hashMap;
  };
  exports.getLabels = function(labelNames, args) {
    if (typeof args[0] === "object") {
      return args[0];
    }
    if (labelNames.length !== args.length) {
      throw new Error("Invalid number of arguments");
    }
    const acc = {};
    for (let i = 0;i < labelNames.length; i++) {
      acc[labelNames[i]] = args[i];
    }
    return acc;
  };
  exports.hashObject = hashObject;
  exports.isObject = function isObject(obj) {
    return obj === Object(obj);
  };
  exports.nowTimestamp = function nowTimestamp() {
    return Date.now() / 1000;
  };

  class Grouper extends Map {
    add(key, value4) {
      if (this.has(key)) {
        this.get(key).push(value4);
      } else {
        this.set(key, [value4]);
      }
    }
  }
  exports.Grouper = Grouper;
});

// node_modules/prom-client/lib/registry.js
var require_registry = __commonJS((exports, module) => {
  var formatLabels = function(labels, exclude) {
    const { hasOwnProperty } = Object.prototype;
    const formatted = [];
    for (const [name, value4] of Object.entries(labels)) {
      if (!exclude || !hasOwnProperty.call(exclude, name)) {
        formatted.push(`${name}="${escapeLabelValue(value4)}"`);
      }
    }
    return formatted;
  };
  var flattenSharedLabels = function(labels) {
    const cached = sharedLabelCache.get(labels);
    if (cached) {
      return cached;
    }
    const formattedLabels = formatLabels(labels);
    const flattened = formattedLabels.join(",");
    sharedLabelCache.set(labels, flattened);
    return flattened;
  };
  var escapeLabelValue = function(str) {
    if (typeof str !== "string") {
      return str;
    }
    return escapeString(str).replace(/"/g, '\\"');
  };
  var escapeString = function(str) {
    return str.replace(/\\/g, "\\\\").replace(/\n/g, "\\n");
  };
  var standardizeCounterName = function(name) {
    return name.replace(/_total$/, "");
  };
  var { getValueAsString } = require_util();

  class Registry {
    static get PROMETHEUS_CONTENT_TYPE() {
      return "text/plain; version=0.0.4; charset=utf-8";
    }
    static get OPENMETRICS_CONTENT_TYPE() {
      return "application/openmetrics-text; version=1.0.0; charset=utf-8";
    }
    constructor(regContentType = Registry.PROMETHEUS_CONTENT_TYPE) {
      this._metrics = {};
      this._collectors = [];
      this._defaultLabels = {};
      if (regContentType !== Registry.PROMETHEUS_CONTENT_TYPE && regContentType !== Registry.OPENMETRICS_CONTENT_TYPE) {
        throw new TypeError(`Content type ${regContentType} is unsupported`);
      }
      this._contentType = regContentType;
    }
    getMetricsAsArray() {
      return Object.values(this._metrics);
    }
    async getMetricsAsString(metrics) {
      const metric = typeof metrics.getForPromString === "function" ? await metrics.getForPromString() : await metrics.get();
      const name = escapeString(metric.name);
      const help = `# HELP ${name} ${escapeString(metric.help)}`;
      const type = `# TYPE ${name} ${metric.type}`;
      const values = [help, type];
      const defaultLabels = Object.keys(this._defaultLabels).length > 0 ? this._defaultLabels : null;
      const isOpenMetrics = this.contentType === Registry.OPENMETRICS_CONTENT_TYPE;
      for (const val of metric.values || []) {
        let { metricName = name, labels = {} } = val;
        const { sharedLabels = {} } = val;
        if (isOpenMetrics && metric.type === "counter") {
          metricName = `${metricName}_total`;
        }
        if (defaultLabels) {
          labels = { ...labels, ...defaultLabels, ...labels };
        }
        const formattedLabels = formatLabels(labels, sharedLabels);
        const flattenedShared = flattenSharedLabels(sharedLabels);
        const labelParts = [...formattedLabels, flattenedShared].filter(Boolean);
        const labelsString = labelParts.length ? `{${labelParts.join(",")}}` : "";
        let fullMetricLine = `${metricName}${labelsString} ${getValueAsString(val.value)}`;
        const { exemplar } = val;
        if (exemplar && isOpenMetrics) {
          const formattedExemplars = formatLabels(exemplar.labelSet);
          fullMetricLine += ` # {${formattedExemplars.join(",")}} ${getValueAsString(exemplar.value)} ${exemplar.timestamp}`;
        }
        values.push(fullMetricLine);
      }
      return values.join("\n");
    }
    async metrics() {
      const isOpenMetrics = this.contentType === Registry.OPENMETRICS_CONTENT_TYPE;
      const promises = this.getMetricsAsArray().map((metric) => {
        if (isOpenMetrics && metric.type === "counter") {
          metric.name = standardizeCounterName(metric.name);
        }
        return this.getMetricsAsString(metric);
      });
      const resolves = await Promise.all(promises);
      return isOpenMetrics ? `${resolves.join("\n")}\n# EOF\n` : `${resolves.join("\n\n")}\n`;
    }
    registerMetric(metric) {
      if (this._metrics[metric.name] && this._metrics[metric.name] !== metric) {
        throw new Error(`A metric with the name ${metric.name} has already been registered.`);
      }
      this._metrics[metric.name] = metric;
    }
    clear() {
      this._metrics = {};
      this._defaultLabels = {};
    }
    async getMetricsAsJSON() {
      const metrics = [];
      const defaultLabelNames = Object.keys(this._defaultLabels);
      const promises = [];
      for (const metric of this.getMetricsAsArray()) {
        promises.push(metric.get());
      }
      const resolves = await Promise.all(promises);
      for (const item of resolves) {
        if (item.values && defaultLabelNames.length > 0) {
          for (const val of item.values) {
            val.labels = Object.assign({}, val.labels);
            for (const labelName of defaultLabelNames) {
              val.labels[labelName] = val.labels[labelName] || this._defaultLabels[labelName];
            }
          }
        }
        metrics.push(item);
      }
      return metrics;
    }
    removeSingleMetric(name) {
      delete this._metrics[name];
    }
    getSingleMetricAsString(name) {
      return this.getMetricsAsString(this._metrics[name]);
    }
    getSingleMetric(name) {
      return this._metrics[name];
    }
    setDefaultLabels(labels) {
      this._defaultLabels = labels;
    }
    resetMetrics() {
      for (const metric in this._metrics) {
        this._metrics[metric].reset();
      }
    }
    get contentType() {
      return this._contentType;
    }
    setContentType(metricsContentType) {
      if (metricsContentType === Registry.OPENMETRICS_CONTENT_TYPE || metricsContentType === Registry.PROMETHEUS_CONTENT_TYPE) {
        this._contentType = metricsContentType;
      } else {
        throw new Error(`Content type ${metricsContentType} is unsupported`);
      }
    }
    static merge(registers) {
      const regType = registers[0].contentType;
      for (const reg of registers) {
        if (reg.contentType !== regType) {
          throw new Error("Registers can only be merged if they have the same content type");
        }
      }
      const mergedRegistry = new Registry(regType);
      const metricsToMerge = registers.reduce((acc, reg) => acc.concat(reg.getMetricsAsArray()), []);
      metricsToMerge.forEach(mergedRegistry.registerMetric, mergedRegistry);
      return mergedRegistry;
    }
  }
  var sharedLabelCache = new WeakMap;
  module.exports = Registry;
  module.exports.globalRegistry = new Registry;
});

// node_modules/prom-client/lib/validation.js
var require_validation = __commonJS((exports) => {
  var util = import.meta.require("util");
  var metricRegexp = /^[a-zA-Z_:][a-zA-Z0-9_:]*$/;
  var labelRegexp = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
  exports.validateMetricName = function(name) {
    return metricRegexp.test(name);
  };
  exports.validateLabelName = function(names = []) {
    return names.every((name) => labelRegexp.test(name));
  };
  exports.validateLabel = function validateLabel(savedLabels, labels) {
    for (const label in labels) {
      if (!savedLabels.includes(label)) {
        throw new Error(`Added label "${label}" is not included in initial labelset: ${util.inspect(savedLabels)}`);
      }
    }
  };
});

// node_modules/prom-client/lib/metric.js
var require_metric = __commonJS((exports, module) => {
  var Registry = require_registry();
  var { isObject } = require_util();
  var { validateMetricName, validateLabelName } = require_validation();

  class Metric {
    constructor(config, defaults = {}) {
      if (!isObject(config)) {
        throw new TypeError("constructor expected a config object");
      }
      Object.assign(this, {
        labelNames: [],
        registers: [Registry.globalRegistry],
        aggregator: "sum",
        enableExemplars: false
      }, defaults, config);
      if (!this.registers) {
        this.registers = [Registry.globalRegistry];
      }
      if (!this.help) {
        throw new Error("Missing mandatory help parameter");
      }
      if (!this.name) {
        throw new Error("Missing mandatory name parameter");
      }
      if (!validateMetricName(this.name)) {
        throw new Error("Invalid metric name");
      }
      if (!validateLabelName(this.labelNames)) {
        throw new Error("Invalid label name");
      }
      if (this.collect && typeof this.collect !== "function") {
        throw new Error('Optional "collect" parameter must be a function');
      }
      this.reset();
      for (const register of this.registers) {
        if (this.enableExemplars && register.contentType === Registry.PROMETHEUS_CONTENT_TYPE) {
          throw new TypeError("Exemplars are supported only on OpenMetrics registries");
        }
        register.registerMetric(this);
      }
    }
    reset() {
    }
  }
  module.exports = { Metric };
});

// node_modules/prom-client/lib/exemplar.js
var require_exemplar = __commonJS((exports, module) => {
  class Exemplar {
    constructor(labelSet = {}, value4 = null) {
      this.labelSet = labelSet;
      this.value = value4;
    }
    validateExemplarLabelSet(labelSet) {
      let res = "";
      for (const [labelName, labelValue] of Object.entries(labelSet)) {
        res += `${labelName}${labelValue}`;
      }
      if (res.length > 128) {
        throw new RangeError("Label set size must be smaller than 128 UTF-8 chars");
      }
    }
  }
  module.exports = Exemplar;
});

// node_modules/prom-client/lib/counter.js
var require_counter = __commonJS((exports, module) => {
  var setValue = function(hashMap, value4, labels = {}, hash2 = "") {
    if (hashMap[hash2]) {
      hashMap[hash2].value += value4;
    } else {
      hashMap[hash2] = { value: value4, labels };
    }
    return hashMap;
  };
  var util = import.meta.require("util");
  var {
    hashObject,
    isObject,
    getLabels,
    removeLabels,
    nowTimestamp
  } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();
  var Exemplar = require_exemplar();

  class Counter extends Metric {
    constructor(config) {
      super(config);
      this.type = "counter";
      this.defaultLabels = {};
      this.defaultValue = 1;
      this.defaultExemplarLabelSet = {};
      if (config.enableExemplars) {
        this.enableExemplars = true;
        this.inc = this.incWithExemplar;
      } else {
        this.inc = this.incWithoutExemplar;
      }
    }
    incWithoutExemplar(labels, value4) {
      let hash2 = "";
      if (isObject(labels)) {
        hash2 = hashObject(labels);
        validateLabel(this.labelNames, labels);
      } else {
        value4 = labels;
        labels = {};
      }
      if (value4 && !Number.isFinite(value4)) {
        throw new TypeError(`Value is not a valid number: ${util.format(value4)}`);
      }
      if (value4 < 0) {
        throw new Error("It is not possible to decrease a counter");
      }
      if (value4 === null || value4 === undefined)
        value4 = 1;
      setValue(this.hashMap, value4, labels, hash2);
      return { labelHash: hash2 };
    }
    incWithExemplar({
      labels = this.defaultLabels,
      value: value4 = this.defaultValue,
      exemplarLabels = this.defaultExemplarLabelSet
    } = {}) {
      const res = this.incWithoutExemplar(labels, value4);
      this.updateExemplar(exemplarLabels, value4, res.labelHash);
    }
    updateExemplar(exemplarLabels, value4, hash2) {
      if (!isObject(this.hashMap[hash2].exemplar)) {
        this.hashMap[hash2].exemplar = new Exemplar;
      }
      this.hashMap[hash2].exemplar.validateExemplarLabelSet(exemplarLabels);
      this.hashMap[hash2].exemplar.labelSet = exemplarLabels;
      this.hashMap[hash2].exemplar.value = value4 ? value4 : 1;
      this.hashMap[hash2].exemplar.timestamp = nowTimestamp();
    }
    reset() {
      this.hashMap = {};
      if (this.labelNames.length === 0) {
        setValue(this.hashMap, 0);
      }
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      return {
        help: this.help,
        name: this.name,
        type: this.type,
        values: Object.values(this.hashMap),
        aggregator: this.aggregator
      };
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args) || {};
      return {
        inc: this.inc.bind(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args) || {};
      validateLabel(this.labelNames, labels);
      return removeLabels.call(this, this.hashMap, labels);
    }
  }
  module.exports = Counter;
});

// node_modules/prom-client/lib/gauge.js
var require_gauge = __commonJS((exports, module) => {
  var set = function(gauge, labels, value4) {
    if (typeof value4 !== "number") {
      throw new TypeError(`Value is not a valid number: ${util.format(value4)}`);
    }
    validateLabel(gauge.labelNames, labels);
    setValue(gauge.hashMap, value4, labels);
  };
  var setDelta = function(gauge, labels, delta) {
    if (typeof delta !== "number") {
      throw new TypeError(`Delta is not a valid number: ${util.format(delta)}`);
    }
    validateLabel(gauge.labelNames, labels);
    const hash2 = hashObject(labels);
    setValueDelta(gauge.hashMap, delta, labels, hash2);
  };
  var getLabelArg = function(labels) {
    return isObject(labels) ? labels : {};
  };
  var getValueArg = function(labels, value4) {
    return isObject(labels) ? value4 : labels;
  };
  var util = import.meta.require("util");
  var {
    setValue,
    setValueDelta,
    getLabels,
    hashObject,
    isObject,
    removeLabels
  } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();

  class Gauge extends Metric {
    constructor(config) {
      super(config);
      this.type = "gauge";
    }
    set(labels, value4) {
      value4 = getValueArg(labels, value4);
      labels = getLabelArg(labels);
      set(this, labels, value4);
    }
    reset() {
      this.hashMap = {};
      if (this.labelNames.length === 0) {
        setValue(this.hashMap, 0, {});
      }
    }
    inc(labels, value4) {
      value4 = getValueArg(labels, value4);
      labels = getLabelArg(labels);
      if (value4 === undefined)
        value4 = 1;
      setDelta(this, labels, value4);
    }
    dec(labels, value4) {
      value4 = getValueArg(labels, value4);
      labels = getLabelArg(labels);
      if (value4 === undefined)
        value4 = 1;
      setDelta(this, labels, -value4);
    }
    setToCurrentTime(labels) {
      const now = Date.now() / 1000;
      if (labels === undefined) {
        this.set(now);
      } else {
        this.set(labels, now);
      }
    }
    startTimer(labels) {
      const start = process.hrtime();
      return (endLabels) => {
        const delta = process.hrtime(start);
        const value4 = delta[0] + delta[1] / 1e9;
        this.set(Object.assign({}, labels, endLabels), value4);
        return value4;
      };
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      return {
        help: this.help,
        name: this.name,
        type: this.type,
        values: Object.values(this.hashMap),
        aggregator: this.aggregator
      };
    }
    _getValue(labels) {
      const hash2 = hashObject(labels || {});
      return this.hashMap[hash2] ? this.hashMap[hash2].value : 0;
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      return {
        inc: this.inc.bind(this, labels),
        dec: this.dec.bind(this, labels),
        set: this.set.bind(this, labels),
        setToCurrentTime: this.setToCurrentTime.bind(this, labels),
        startTimer: this.startTimer.bind(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      removeLabels.call(this, this.hashMap, labels);
    }
  }
  module.exports = Gauge;
});

// node_modules/prom-client/lib/histogram.js
var require_histogram = __commonJS((exports, module) => {
  var startTimer = function(startLabels) {
    return () => {
      const start = process.hrtime();
      return (endLabels) => {
        const delta = process.hrtime(start);
        const value4 = delta[0] + delta[1] / 1e9;
        this.observe(Object.assign({}, startLabels, endLabels), value4);
        return value4;
      };
    };
  };
  var setValuePair = function(labels, value4, metricName, exemplar, sharedLabels = {}) {
    return {
      labels,
      sharedLabels,
      value: value4,
      metricName,
      exemplar
    };
  };
  var findBound = function(upperBounds, value4) {
    for (let i = 0;i < upperBounds.length; i++) {
      const bound = upperBounds[i];
      if (value4 <= bound) {
        return bound;
      }
    }
    return -1;
  };
  var observe = function(labels) {
    return (value4) => {
      const labelValuePair = convertLabelsAndValues(labels, value4);
      validateLabel(this.labelNames, labelValuePair.labels);
      if (!Number.isFinite(labelValuePair.value)) {
        throw new TypeError(`Value is not a valid number: ${util.format(labelValuePair.value)}`);
      }
      const hash2 = hashObject(labelValuePair.labels);
      let valueFromMap = this.hashMap[hash2];
      if (!valueFromMap) {
        valueFromMap = createBaseValues(labelValuePair.labels, this.bucketValues, this.bucketExemplars);
      }
      const b2 = findBound(this.upperBounds, labelValuePair.value);
      valueFromMap.sum += labelValuePair.value;
      valueFromMap.count += 1;
      if (Object.prototype.hasOwnProperty.call(valueFromMap.bucketValues, b2)) {
        valueFromMap.bucketValues[b2] += 1;
      }
      this.hashMap[hash2] = valueFromMap;
    };
  };
  var createBaseValues = function(labels, bucketValues, bucketExemplars) {
    return {
      labels,
      bucketValues: { ...bucketValues },
      bucketExemplars: { ...bucketExemplars },
      sum: 0,
      count: 0
    };
  };
  var convertLabelsAndValues = function(labels, value4) {
    return isObject(labels) ? {
      labels,
      value: value4
    } : {
      value: labels,
      labels: {}
    };
  };
  var extractBucketValuesForExport = function(histogram) {
    const name = `${histogram.name}_bucket`;
    return (bucketData) => {
      let acc = 0;
      const buckets = histogram.upperBounds.map((upperBound) => {
        acc += bucketData.bucketValues[upperBound];
        return setValuePair({ le: upperBound }, acc, name, bucketData.bucketExemplars[upperBound], bucketData.labels);
      });
      return { buckets, data: bucketData };
    };
  };
  var addSumAndCountForExport = function(histogram) {
    return (acc, d) => {
      acc.push(...d.buckets);
      const infLabel = { le: "+Inf" };
      acc.push(setValuePair(infLabel, d.data.count, `${histogram.name}_bucket`, d.data.bucketExemplars["-1"], d.data.labels), setValuePair({}, d.data.sum, `${histogram.name}_sum`, undefined, d.data.labels), setValuePair({}, d.data.count, `${histogram.name}_count`, undefined, d.data.labels));
      return acc;
    };
  };
  var splayLabels = function(bucket) {
    const { sharedLabels, labels, ...newBucket } = bucket;
    for (const label of Object.keys(sharedLabels)) {
      labels[label] = sharedLabels[label];
    }
    newBucket.labels = labels;
    return newBucket;
  };
  var util = import.meta.require("util");
  var {
    getLabels,
    hashObject,
    isObject,
    removeLabels,
    nowTimestamp
  } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();
  var Exemplar = require_exemplar();

  class Histogram extends Metric {
    constructor(config) {
      super(config, {
        buckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]
      });
      this.type = "histogram";
      this.defaultLabels = {};
      this.defaultExemplarLabelSet = {};
      if (config.enableExemplars) {
        this.observe = this.observeWithExemplar;
      } else {
        this.observe = this.observeWithoutExemplar;
      }
      for (const label of this.labelNames) {
        if (label === "le") {
          throw new Error("le is a reserved label keyword");
        }
      }
      this.upperBounds = this.buckets;
      this.bucketValues = this.upperBounds.reduce((acc, upperBound) => {
        acc[upperBound] = 0;
        return acc;
      }, {});
      this.bucketExemplars = this.upperBounds.reduce((acc, upperBound) => {
        acc[upperBound] = null;
        return acc;
      }, {});
      Object.freeze(this.bucketValues);
      Object.freeze(this.bucketExemplars);
      Object.freeze(this.upperBounds);
      if (this.labelNames.length === 0) {
        this.hashMap = {
          [hashObject({})]: createBaseValues({}, this.bucketValues, this.bucketExemplars)
        };
      }
    }
    observeWithoutExemplar(labels, value4) {
      observe.call(this, labels === 0 ? 0 : labels || {})(value4);
    }
    observeWithExemplar({
      labels = this.defaultLabels,
      value: value4,
      exemplarLabels = this.defaultExemplarLabelSet
    } = {}) {
      observe.call(this, labels === 0 ? 0 : labels || {})(value4);
      this.updateExemplar(labels, value4, exemplarLabels);
    }
    updateExemplar(labels, value4, exemplarLabels) {
      const hash2 = hashObject(labels);
      const bound = findBound(this.upperBounds, value4);
      const { bucketExemplars } = this.hashMap[hash2];
      let exemplar = bucketExemplars[bound];
      if (!isObject(exemplar)) {
        exemplar = new Exemplar;
        bucketExemplars[bound] = exemplar;
      }
      exemplar.validateExemplarLabelSet(exemplarLabels);
      exemplar.labelSet = exemplarLabels;
      exemplar.value = value4;
      exemplar.timestamp = nowTimestamp();
    }
    async get() {
      const data = await this.getForPromString();
      data.values = data.values.map(splayLabels);
      return data;
    }
    async getForPromString() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      const data = Object.values(this.hashMap);
      const values = data.map(extractBucketValuesForExport(this)).reduce(addSumAndCountForExport(this), []);
      return {
        name: this.name,
        help: this.help,
        type: this.type,
        values,
        aggregator: this.aggregator
      };
    }
    reset() {
      this.hashMap = {};
    }
    zero(labels) {
      const hash2 = hashObject(labels);
      this.hashMap[hash2] = createBaseValues(labels, this.bucketValues, this.bucketExemplars);
    }
    startTimer(labels) {
      return startTimer.call(this, labels)();
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      return {
        observe: observe.call(this, labels),
        startTimer: startTimer.call(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      removeLabels.call(this, this.hashMap, labels);
    }
  }
  module.exports = Histogram;
});

// node_modules/bintrees/lib/treebase.js
var require_treebase = __commonJS((exports, module) => {
  var TreeBase = function() {
  };
  var Iterator = function(tree) {
    this._tree = tree;
    this._ancestors = [];
    this._cursor = null;
  };
  TreeBase.prototype.clear = function() {
    this._root = null;
    this.size = 0;
  };
  TreeBase.prototype.find = function(data) {
    var res = this._root;
    while (res !== null) {
      var c2 = this._comparator(data, res.data);
      if (c2 === 0) {
        return res.data;
      } else {
        res = res.get_child(c2 > 0);
      }
    }
    return null;
  };
  TreeBase.prototype.findIter = function(data) {
    var res = this._root;
    var iter = this.iterator();
    while (res !== null) {
      var c2 = this._comparator(data, res.data);
      if (c2 === 0) {
        iter._cursor = res;
        return iter;
      } else {
        iter._ancestors.push(res);
        res = res.get_child(c2 > 0);
      }
    }
    return null;
  };
  TreeBase.prototype.lowerBound = function(item) {
    var cur = this._root;
    var iter = this.iterator();
    var cmp = this._comparator;
    while (cur !== null) {
      var c2 = cmp(item, cur.data);
      if (c2 === 0) {
        iter._cursor = cur;
        return iter;
      }
      iter._ancestors.push(cur);
      cur = cur.get_child(c2 > 0);
    }
    for (var i = iter._ancestors.length - 1;i >= 0; --i) {
      cur = iter._ancestors[i];
      if (cmp(item, cur.data) < 0) {
        iter._cursor = cur;
        iter._ancestors.length = i;
        return iter;
      }
    }
    iter._ancestors.length = 0;
    return iter;
  };
  TreeBase.prototype.upperBound = function(item) {
    var iter = this.lowerBound(item);
    var cmp = this._comparator;
    while (iter.data() !== null && cmp(iter.data(), item) === 0) {
      iter.next();
    }
    return iter;
  };
  TreeBase.prototype.min = function() {
    var res = this._root;
    if (res === null) {
      return null;
    }
    while (res.left !== null) {
      res = res.left;
    }
    return res.data;
  };
  TreeBase.prototype.max = function() {
    var res = this._root;
    if (res === null) {
      return null;
    }
    while (res.right !== null) {
      res = res.right;
    }
    return res.data;
  };
  TreeBase.prototype.iterator = function() {
    return new Iterator(this);
  };
  TreeBase.prototype.each = function(cb) {
    var it2 = this.iterator(), data;
    while ((data = it2.next()) !== null) {
      if (cb(data) === false) {
        return;
      }
    }
  };
  TreeBase.prototype.reach = function(cb) {
    var it2 = this.iterator(), data;
    while ((data = it2.prev()) !== null) {
      if (cb(data) === false) {
        return;
      }
    }
  };
  Iterator.prototype.data = function() {
    return this._cursor !== null ? this._cursor.data : null;
  };
  Iterator.prototype.next = function() {
    if (this._cursor === null) {
      var root = this._tree._root;
      if (root !== null) {
        this._minNode(root);
      }
    } else {
      if (this._cursor.right === null) {
        var save;
        do {
          save = this._cursor;
          if (this._ancestors.length) {
            this._cursor = this._ancestors.pop();
          } else {
            this._cursor = null;
            break;
          }
        } while (this._cursor.right === save);
      } else {
        this._ancestors.push(this._cursor);
        this._minNode(this._cursor.right);
      }
    }
    return this._cursor !== null ? this._cursor.data : null;
  };
  Iterator.prototype.prev = function() {
    if (this._cursor === null) {
      var root = this._tree._root;
      if (root !== null) {
        this._maxNode(root);
      }
    } else {
      if (this._cursor.left === null) {
        var save;
        do {
          save = this._cursor;
          if (this._ancestors.length) {
            this._cursor = this._ancestors.pop();
          } else {
            this._cursor = null;
            break;
          }
        } while (this._cursor.left === save);
      } else {
        this._ancestors.push(this._cursor);
        this._maxNode(this._cursor.left);
      }
    }
    return this._cursor !== null ? this._cursor.data : null;
  };
  Iterator.prototype._minNode = function(start) {
    while (start.left !== null) {
      this._ancestors.push(start);
      start = start.left;
    }
    this._cursor = start;
  };
  Iterator.prototype._maxNode = function(start) {
    while (start.right !== null) {
      this._ancestors.push(start);
      start = start.right;
    }
    this._cursor = start;
  };
  module.exports = TreeBase;
});

// node_modules/bintrees/lib/rbtree.js
var require_rbtree = __commonJS((exports, module) => {
  var Node = function(data) {
    this.data = data;
    this.left = null;
    this.right = null;
    this.red = true;
  };
  var RBTree = function(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
  };
  var is_red = function(node) {
    return node !== null && node.red;
  };
  var single_rotate = function(root, dir) {
    var save = root.get_child(!dir);
    root.set_child(!dir, save.get_child(dir));
    save.set_child(dir, root);
    root.red = true;
    save.red = false;
    return save;
  };
  var double_rotate = function(root, dir) {
    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));
    return single_rotate(root, dir);
  };
  var TreeBase = require_treebase();
  Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
  };
  Node.prototype.set_child = function(dir, val) {
    if (dir) {
      this.right = val;
    } else {
      this.left = val;
    }
  };
  RBTree.prototype = new TreeBase;
  RBTree.prototype.insert = function(data) {
    var ret2 = false;
    if (this._root === null) {
      this._root = new Node(data);
      ret2 = true;
      this.size++;
    } else {
      var head = new Node(undefined);
      var dir = 0;
      var last = 0;
      var gp = null;
      var ggp = head;
      var p = null;
      var node = this._root;
      ggp.right = this._root;
      while (true) {
        if (node === null) {
          node = new Node(data);
          p.set_child(dir, node);
          ret2 = true;
          this.size++;
        } else if (is_red(node.left) && is_red(node.right)) {
          node.red = true;
          node.left.red = false;
          node.right.red = false;
        }
        if (is_red(node) && is_red(p)) {
          var dir2 = ggp.right === gp;
          if (node === p.get_child(last)) {
            ggp.set_child(dir2, single_rotate(gp, !last));
          } else {
            ggp.set_child(dir2, double_rotate(gp, !last));
          }
        }
        var cmp = this._comparator(node.data, data);
        if (cmp === 0) {
          break;
        }
        last = dir;
        dir = cmp < 0;
        if (gp !== null) {
          ggp = gp;
        }
        gp = p;
        p = node;
        node = node.get_child(dir);
      }
      this._root = head.right;
    }
    this._root.red = false;
    return ret2;
  };
  RBTree.prototype.remove = function(data) {
    if (this._root === null) {
      return false;
    }
    var head = new Node(undefined);
    var node = head;
    node.right = this._root;
    var p = null;
    var gp = null;
    var found = null;
    var dir = 1;
    while (node.get_child(dir) !== null) {
      var last = dir;
      gp = p;
      p = node;
      node = node.get_child(dir);
      var cmp = this._comparator(data, node.data);
      dir = cmp > 0;
      if (cmp === 0) {
        found = node;
      }
      if (!is_red(node) && !is_red(node.get_child(dir))) {
        if (is_red(node.get_child(!dir))) {
          var sr = single_rotate(node, dir);
          p.set_child(last, sr);
          p = sr;
        } else if (!is_red(node.get_child(!dir))) {
          var sibling = p.get_child(!last);
          if (sibling !== null) {
            if (!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {
              p.red = false;
              sibling.red = true;
              node.red = true;
            } else {
              var dir2 = gp.right === p;
              if (is_red(sibling.get_child(last))) {
                gp.set_child(dir2, double_rotate(p, last));
              } else if (is_red(sibling.get_child(!last))) {
                gp.set_child(dir2, single_rotate(p, last));
              }
              var gpc = gp.get_child(dir2);
              gpc.red = true;
              node.red = true;
              gpc.left.red = false;
              gpc.right.red = false;
            }
          }
        }
      }
    }
    if (found !== null) {
      found.data = node.data;
      p.set_child(p.right === node, node.get_child(node.left === null));
      this.size--;
    }
    this._root = head.right;
    if (this._root !== null) {
      this._root.red = false;
    }
    return found !== null;
  };
  module.exports = RBTree;
});

// node_modules/bintrees/lib/bintree.js
var require_bintree = __commonJS((exports, module) => {
  var Node = function(data) {
    this.data = data;
    this.left = null;
    this.right = null;
  };
  var BinTree = function(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
  };
  var TreeBase = require_treebase();
  Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
  };
  Node.prototype.set_child = function(dir, val) {
    if (dir) {
      this.right = val;
    } else {
      this.left = val;
    }
  };
  BinTree.prototype = new TreeBase;
  BinTree.prototype.insert = function(data) {
    if (this._root === null) {
      this._root = new Node(data);
      this.size++;
      return true;
    }
    var dir = 0;
    var p = null;
    var node = this._root;
    while (true) {
      if (node === null) {
        node = new Node(data);
        p.set_child(dir, node);
        ret = true;
        this.size++;
        return true;
      }
      if (this._comparator(node.data, data) === 0) {
        return false;
      }
      dir = this._comparator(node.data, data) < 0;
      p = node;
      node = node.get_child(dir);
    }
  };
  BinTree.prototype.remove = function(data) {
    if (this._root === null) {
      return false;
    }
    var head = new Node(undefined);
    var node = head;
    node.right = this._root;
    var p = null;
    var found = null;
    var dir = 1;
    while (node.get_child(dir) !== null) {
      p = node;
      node = node.get_child(dir);
      var cmp = this._comparator(data, node.data);
      dir = cmp > 0;
      if (cmp === 0) {
        found = node;
      }
    }
    if (found !== null) {
      found.data = node.data;
      p.set_child(p.right === node, node.get_child(node.left === null));
      this._root = head.right;
      this.size--;
      return true;
    } else {
      return false;
    }
  };
  module.exports = BinTree;
});

// node_modules/bintrees/index.js
var require_bintrees = __commonJS((exports, module) => {
  module.exports = {
    RBTree: require_rbtree(),
    BinTree: require_bintree()
  };
});

// node_modules/tdigest/tdigest.js
var require_tdigest = __commonJS((exports, module) => {
  var TDigest = function(delta, K2, CX) {
    this.discrete = delta === false;
    this.delta = delta || 0.01;
    this.K = K2 === undefined ? 25 : K2;
    this.CX = CX === undefined ? 1.1 : CX;
    this.centroids = new RBTree(compare_centroid_means);
    this.nreset = 0;
    this.reset();
  };
  var compare_centroid_means = function(a, b2) {
    return a.mean > b2.mean ? 1 : a.mean < b2.mean ? -1 : 0;
  };
  var compare_centroid_mean_cumns = function(a, b2) {
    return a.mean_cumn - b2.mean_cumn;
  };
  var pop_random = function(choices) {
    var idx = Math.floor(Math.random() * choices.length);
    return choices.splice(idx, 1)[0];
  };
  var Digest = function(config) {
    this.config = config || {};
    this.mode = this.config.mode || "auto";
    TDigest.call(this, this.mode === "cont" ? config.delta : false);
    this.digest_ratio = this.config.ratio || 0.9;
    this.digest_thresh = this.config.thresh || 1000;
    this.n_unique = 0;
  };
  var RBTree = require_bintrees().RBTree;
  TDigest.prototype.reset = function() {
    this.centroids.clear();
    this.n = 0;
    this.nreset += 1;
    this.last_cumulate = 0;
  };
  TDigest.prototype.size = function() {
    return this.centroids.size;
  };
  TDigest.prototype.toArray = function(everything) {
    var result = [];
    if (everything) {
      this._cumulate(true);
      this.centroids.each(function(c2) {
        result.push(c2);
      });
    } else {
      this.centroids.each(function(c2) {
        result.push({ mean: c2.mean, n: c2.n });
      });
    }
    return result;
  };
  TDigest.prototype.summary = function() {
    var approx = this.discrete ? "exact " : "approximating ";
    var s2 = [
      approx + this.n + " samples using " + this.size() + " centroids",
      "min = " + this.percentile(0),
      "Q1  = " + this.percentile(0.25),
      "Q2  = " + this.percentile(0.5),
      "Q3  = " + this.percentile(0.75),
      "max = " + this.percentile(1)
    ];
    return s2.join("\n");
  };
  TDigest.prototype.push = function(x2, n) {
    n = n || 1;
    x2 = Array.isArray(x2) ? x2 : [x2];
    for (var i = 0;i < x2.length; i++) {
      this._digest(x2[i], n);
    }
  };
  TDigest.prototype.push_centroid = function(c2) {
    c2 = Array.isArray(c2) ? c2 : [c2];
    for (var i = 0;i < c2.length; i++) {
      this._digest(c2[i].mean, c2[i].n);
    }
  };
  TDigest.prototype._cumulate = function(exact) {
    if (this.n === this.last_cumulate || !exact && this.CX && this.CX > this.n / this.last_cumulate) {
      return;
    }
    var cumn = 0;
    this.centroids.each(function(c2) {
      c2.mean_cumn = cumn + c2.n / 2;
      cumn = c2.cumn = cumn + c2.n;
    });
    this.n = this.last_cumulate = cumn;
  };
  TDigest.prototype.find_nearest = function(x2) {
    if (this.size() === 0) {
      return null;
    }
    var iter = this.centroids.lowerBound({ mean: x2 });
    var c2 = iter.data() === null ? iter.prev() : iter.data();
    if (c2.mean === x2 || this.discrete) {
      return c2;
    }
    var prev = iter.prev();
    if (prev && Math.abs(prev.mean - x2) < Math.abs(c2.mean - x2)) {
      return prev;
    } else {
      return c2;
    }
  };
  TDigest.prototype._new_centroid = function(x2, n, cumn) {
    var c2 = { mean: x2, n, cumn };
    this.centroids.insert(c2);
    this.n += n;
    return c2;
  };
  TDigest.prototype._addweight = function(nearest, x2, n) {
    if (x2 !== nearest.mean) {
      nearest.mean += n * (x2 - nearest.mean) / (nearest.n + n);
    }
    nearest.cumn += n;
    nearest.mean_cumn += n / 2;
    nearest.n += n;
    this.n += n;
  };
  TDigest.prototype._digest = function(x2, n) {
    var min = this.centroids.min();
    var max = this.centroids.max();
    var nearest = this.find_nearest(x2);
    if (nearest && nearest.mean === x2) {
      this._addweight(nearest, x2, n);
    } else if (nearest === min) {
      this._new_centroid(x2, n, 0);
    } else if (nearest === max) {
      this._new_centroid(x2, n, this.n);
    } else if (this.discrete) {
      this._new_centroid(x2, n, nearest.cumn);
    } else {
      var p = nearest.mean_cumn / this.n;
      var max_n = Math.floor(4 * this.n * this.delta * p * (1 - p));
      if (max_n - nearest.n >= n) {
        this._addweight(nearest, x2, n);
      } else {
        this._new_centroid(x2, n, nearest.cumn);
      }
    }
    this._cumulate(false);
    if (!this.discrete && this.K && this.size() > this.K / this.delta) {
      this.compress();
    }
  };
  TDigest.prototype.bound_mean = function(x2) {
    var iter = this.centroids.upperBound({ mean: x2 });
    var lower = iter.prev();
    var upper = lower.mean === x2 ? lower : iter.next();
    return [lower, upper];
  };
  TDigest.prototype.p_rank = function(x_or_xlist) {
    var xs = Array.isArray(x_or_xlist) ? x_or_xlist : [x_or_xlist];
    var ps = xs.map(this._p_rank, this);
    return Array.isArray(x_or_xlist) ? ps : ps[0];
  };
  TDigest.prototype._p_rank = function(x2) {
    if (this.size() === 0) {
      return;
    } else if (x2 < this.centroids.min().mean) {
      return 0;
    } else if (x2 > this.centroids.max().mean) {
      return 1;
    }
    this._cumulate(true);
    var bound = this.bound_mean(x2);
    var lower = bound[0], upper = bound[1];
    if (this.discrete) {
      return lower.cumn / this.n;
    } else {
      var cumn = lower.mean_cumn;
      if (lower !== upper) {
        cumn += (x2 - lower.mean) * (upper.mean_cumn - lower.mean_cumn) / (upper.mean - lower.mean);
      }
      return cumn / this.n;
    }
  };
  TDigest.prototype.bound_mean_cumn = function(cumn) {
    this.centroids._comparator = compare_centroid_mean_cumns;
    var iter = this.centroids.upperBound({ mean_cumn: cumn });
    this.centroids._comparator = compare_centroid_means;
    var lower = iter.prev();
    var upper = lower && lower.mean_cumn === cumn ? lower : iter.next();
    return [lower, upper];
  };
  TDigest.prototype.percentile = function(p_or_plist) {
    var ps = Array.isArray(p_or_plist) ? p_or_plist : [p_or_plist];
    var qs = ps.map(this._percentile, this);
    return Array.isArray(p_or_plist) ? qs : qs[0];
  };
  TDigest.prototype._percentile = function(p) {
    if (this.size() === 0) {
      return;
    }
    this._cumulate(true);
    var h2 = this.n * p;
    var bound = this.bound_mean_cumn(h2);
    var lower = bound[0], upper = bound[1];
    if (upper === lower || lower === null || upper === null) {
      return (lower || upper).mean;
    } else if (!this.discrete) {
      return lower.mean + (h2 - lower.mean_cumn) * (upper.mean - lower.mean) / (upper.mean_cumn - lower.mean_cumn);
    } else if (h2 <= lower.cumn) {
      return lower.mean;
    } else {
      return upper.mean;
    }
  };
  TDigest.prototype.compress = function() {
    if (this.compressing) {
      return;
    }
    var points = this.toArray();
    this.reset();
    this.compressing = true;
    while (points.length > 0) {
      this.push_centroid(pop_random(points));
    }
    this._cumulate(true);
    this.compressing = false;
  };
  Digest.prototype = Object.create(TDigest.prototype);
  Digest.prototype.constructor = Digest;
  Digest.prototype.push = function(x_or_xlist) {
    TDigest.prototype.push.call(this, x_or_xlist);
    this.check_continuous();
  };
  Digest.prototype._new_centroid = function(x2, n, cumn) {
    this.n_unique += 1;
    TDigest.prototype._new_centroid.call(this, x2, n, cumn);
  };
  Digest.prototype._addweight = function(nearest, x2, n) {
    if (nearest.n === 1) {
      this.n_unique -= 1;
    }
    TDigest.prototype._addweight.call(this, nearest, x2, n);
  };
  Digest.prototype.check_continuous = function() {
    if (this.mode !== "auto" || this.size() < this.digest_thresh) {
      return false;
    }
    if (this.n_unique / this.size() > this.digest_ratio) {
      this.mode = "cont";
      this.discrete = false;
      this.delta = this.config.delta || 0.01;
      this.compress();
      return true;
    }
    return false;
  };
  module.exports = {
    TDigest,
    Digest
  };
});

// node_modules/prom-client/lib/timeWindowQuantiles.js
var require_timeWindowQuantiles = __commonJS((exports, module) => {
  var rotate = function() {
    let timeSinceLastRotateMillis = Date.now() - this.lastRotateTimestampMillis;
    while (timeSinceLastRotateMillis > this.durationBetweenRotatesMillis && this.shouldRotate) {
      this.ringBuffer[this.currentBuffer] = new TDigest;
      if (++this.currentBuffer >= this.ringBuffer.length) {
        this.currentBuffer = 0;
      }
      timeSinceLastRotateMillis -= this.durationBetweenRotatesMillis;
      this.lastRotateTimestampMillis += this.durationBetweenRotatesMillis;
    }
    return this.ringBuffer[this.currentBuffer];
  };
  var { TDigest } = require_tdigest();

  class TimeWindowQuantiles {
    constructor(maxAgeSeconds, ageBuckets) {
      this.maxAgeSeconds = maxAgeSeconds || 0;
      this.ageBuckets = ageBuckets || 0;
      this.shouldRotate = maxAgeSeconds && ageBuckets;
      this.ringBuffer = Array(ageBuckets).fill(new TDigest);
      this.currentBuffer = 0;
      this.lastRotateTimestampMillis = Date.now();
      this.durationBetweenRotatesMillis = maxAgeSeconds * 1000 / ageBuckets || Infinity;
    }
    size() {
      const bucket = rotate.call(this);
      return bucket.size();
    }
    percentile(quantile) {
      const bucket = rotate.call(this);
      return bucket.percentile(quantile);
    }
    push(value4) {
      rotate.call(this);
      this.ringBuffer.forEach((bucket) => {
        bucket.push(value4);
      });
    }
    reset() {
      this.ringBuffer.forEach((bucket) => {
        bucket.reset();
      });
    }
    compress() {
      this.ringBuffer.forEach((bucket) => {
        bucket.compress();
      });
    }
  }
  module.exports = TimeWindowQuantiles;
});

// node_modules/prom-client/lib/summary.js
var require_summary = __commonJS((exports, module) => {
  var extractSummariesForExport = function(summaryOfLabels, percentiles) {
    summaryOfLabels.td.compress();
    return percentiles.map((percentile) => {
      const percentileValue = summaryOfLabels.td.percentile(percentile);
      return {
        labels: Object.assign({ quantile: percentile }, summaryOfLabels.labels),
        value: percentileValue ? percentileValue : 0
      };
    });
  };
  var getCountForExport = function(value4, summary) {
    return {
      metricName: `${summary.name}_count`,
      labels: value4.labels,
      value: value4.count
    };
  };
  var getSumForExport = function(value4, summary) {
    return {
      metricName: `${summary.name}_sum`,
      labels: value4.labels,
      value: value4.sum
    };
  };
  var startTimer = function(startLabels) {
    return () => {
      const start = process.hrtime();
      return (endLabels) => {
        const delta = process.hrtime(start);
        const value4 = delta[0] + delta[1] / 1e9;
        this.observe(Object.assign({}, startLabels, endLabels), value4);
        return value4;
      };
    };
  };
  var observe = function(labels) {
    return (value4) => {
      const labelValuePair = convertLabelsAndValues(labels, value4);
      validateLabel(this.labelNames, labels);
      if (!Number.isFinite(labelValuePair.value)) {
        throw new TypeError(`Value is not a valid number: ${util.format(labelValuePair.value)}`);
      }
      const hash2 = hashObject(labelValuePair.labels);
      let summaryOfLabel = this.hashMap[hash2];
      if (!summaryOfLabel) {
        summaryOfLabel = {
          labels: labelValuePair.labels,
          td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),
          count: 0,
          sum: 0
        };
      }
      summaryOfLabel.td.push(labelValuePair.value);
      summaryOfLabel.count++;
      if (summaryOfLabel.count % this.compressCount === 0) {
        summaryOfLabel.td.compress();
      }
      summaryOfLabel.sum += labelValuePair.value;
      this.hashMap[hash2] = summaryOfLabel;
    };
  };
  var convertLabelsAndValues = function(labels, value4) {
    if (value4 === undefined) {
      return {
        value: labels,
        labels: {}
      };
    }
    return {
      labels,
      value: value4
    };
  };
  var util = import.meta.require("util");
  var { getLabels, hashObject, removeLabels } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();
  var timeWindowQuantiles = require_timeWindowQuantiles();
  var DEFAULT_COMPRESS_COUNT = 1000;

  class Summary extends Metric {
    constructor(config) {
      super(config, {
        percentiles: [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999],
        compressCount: DEFAULT_COMPRESS_COUNT,
        hashMap: {}
      });
      this.type = "summary";
      for (const label of this.labelNames) {
        if (label === "quantile")
          throw new Error("quantile is a reserved label keyword");
      }
      if (this.labelNames.length === 0) {
        this.hashMap = {
          [hashObject({})]: {
            labels: {},
            td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),
            count: 0,
            sum: 0
          }
        };
      }
    }
    observe(labels, value4) {
      observe.call(this, labels === 0 ? 0 : labels || {})(value4);
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      const hashKeys = Object.keys(this.hashMap);
      const values = [];
      hashKeys.forEach((hashKey) => {
        const s2 = this.hashMap[hashKey];
        if (s2) {
          if (this.pruneAgedBuckets && s2.td.size() === 0) {
            delete this.hashMap[hashKey];
          } else {
            extractSummariesForExport(s2, this.percentiles).forEach((v) => {
              values.push(v);
            });
            values.push(getSumForExport(s2, this));
            values.push(getCountForExport(s2, this));
          }
        }
      });
      return {
        name: this.name,
        help: this.help,
        type: this.type,
        values,
        aggregator: this.aggregator
      };
    }
    reset() {
      const data = Object.values(this.hashMap);
      data.forEach((s2) => {
        s2.td.reset();
        s2.count = 0;
        s2.sum = 0;
      });
    }
    startTimer(labels) {
      return startTimer.call(this, labels)();
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      return {
        observe: observe.call(this, labels),
        startTimer: startTimer.call(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      removeLabels.call(this, this.hashMap, labels);
    }
  }
  module.exports = Summary;
});

// node_modules/prom-client/lib/pushgateway.js
var require_pushgateway = __commonJS((exports, module) => {
  async function useGateway(method, job, groupings) {
    const gatewayUrlParsed = url.parse(this.gatewayUrl);
    const gatewayUrlPath = gatewayUrlParsed.pathname && gatewayUrlParsed.pathname !== "/" ? gatewayUrlParsed.pathname : "";
    const path = `${gatewayUrlPath}/metrics/job/${encodeURIComponent(job)}${generateGroupings(groupings)}`;
    const target = url.resolve(this.gatewayUrl, path);
    const requestParams = url.parse(target);
    const httpModule = isHttps(requestParams.href) ? https : http3;
    const options = Object.assign(requestParams, this.requestOptions, {
      method
    });
    return new Promise((resolve, reject) => {
      if (method === "DELETE" && options.headers) {
        delete options.headers["Content-Encoding"];
      }
      const req = httpModule.request(options, (resp) => {
        let body = "";
        resp.setEncoding("utf8");
        resp.on("data", (chunk) => {
          body += chunk;
        });
        resp.on("end", () => {
          if (resp.statusCode >= 400) {
            reject(new Error(`push failed with status ${resp.statusCode}, ${body}`));
          } else {
            resolve({ resp, body });
          }
        });
      });
      req.on("error", (err) => {
        reject(err);
      });
      req.on("timeout", () => {
        req.destroy(new Error("Pushgateway request timed out"));
      });
      if (method !== "DELETE") {
        this.registry.metrics().then((metrics) => {
          if (options.headers && options.headers["Content-Encoding"] === "gzip") {
            metrics = gzipSync(metrics);
          }
          req.write(metrics);
          req.end();
        }).catch((err) => {
          reject(err);
        });
      } else {
        req.end();
      }
    });
  }
  var generateGroupings = function(groupings) {
    if (!groupings) {
      return "";
    }
    return Object.keys(groupings).map((key) => `/${encodeURIComponent(key)}/${encodeURIComponent(groupings[key])}`).join("");
  };
  var isHttps = function(href) {
    return href.search(/^https/) !== -1;
  };
  var url = import.meta.require("url");
  var http3 = import.meta.require("http");
  var https = import.meta.require("https");
  var { gzipSync } = import.meta.require("zlib");
  var { globalRegistry } = require_registry();

  class Pushgateway {
    constructor(gatewayUrl, options, registry) {
      if (!registry) {
        registry = globalRegistry;
      }
      this.registry = registry;
      this.gatewayUrl = gatewayUrl;
      this.requestOptions = Object.assign({}, options);
    }
    pushAdd(params) {
      if (!params || !params.jobName) {
        throw new Error("Missing jobName parameter");
      }
      return useGateway.call(this, "POST", params.jobName, params.groupings);
    }
    push(params) {
      if (!params || !params.jobName) {
        throw new Error("Missing jobName parameter");
      }
      return useGateway.call(this, "PUT", params.jobName, params.groupings);
    }
    delete(params) {
      if (!params || !params.jobName) {
        throw new Error("Missing jobName parameter");
      }
      return useGateway.call(this, "DELETE", params.jobName, params.groupings);
    }
  }
  module.exports = Pushgateway;
});

// node_modules/prom-client/lib/bucketGenerators.js
var require_bucketGenerators = __commonJS((exports) => {
  exports.linearBuckets = (start, width, count) => {
    if (count < 1) {
      throw new Error("Linear buckets needs a positive count");
    }
    const buckets = new Array(count);
    for (let i = 0;i < count; i++) {
      buckets[i] = start + i * width;
    }
    return buckets;
  };
  exports.exponentialBuckets = (start, factor, count) => {
    if (start <= 0) {
      throw new Error("Exponential buckets needs a positive start");
    }
    if (count < 1) {
      throw new Error("Exponential buckets needs a positive count");
    }
    if (factor <= 1) {
      throw new Error("Exponential buckets needs a factor greater than 1");
    }
    const buckets = new Array(count);
    for (let i = 0;i < count; i++) {
      buckets[i] = start;
      start *= factor;
    }
    return buckets;
  };
});

// node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m[k2];
    } });
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_globalThis(), exports);
});

// node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m[k2];
    } });
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_node(), exports);
});

// node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "1.6.0";
});

// node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS((exports) => {
  var _makeCompatibilityCheck = function(ownVersion) {
    const acceptedVersions = new Set([ownVersion]);
    const rejectedVersions = new Set;
    const myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
      return () => false;
    }
    const ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
      return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
      };
    }
    function _reject(v) {
      rejectedVersions.add(v);
      return false;
    }
    function _accept(v) {
      acceptedVersions.add(v);
      return true;
    }
    return function isCompatible(globalVersion) {
      if (acceptedVersions.has(globalVersion)) {
        return true;
      }
      if (rejectedVersions.has(globalVersion)) {
        return false;
      }
      const globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) {
        return _reject(globalVersion);
      }
      const globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      if (globalVersionParsed.prerelease != null) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major !== globalVersionParsed.major) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major === 0) {
        if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }
      if (ownVersionParsed.minor <= globalVersionParsed.minor) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCompatible = exports._makeCompatibilityCheck = undefined;
  var version_1 = require_version();
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  exports._makeCompatibilityCheck = _makeCompatibilityCheck;
  exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
});

// node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS((exports) => {
  var registerGlobal = function(type, instance, diag, allowOverride = false) {
    var _a;
    const api2 = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== undefined ? _a : {
      version: version_1.VERSION
    };
    if (!allowOverride && api2[type]) {
      const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
      diag.error(err.stack || err.message);
      return false;
    }
    if (api2.version !== version_1.VERSION) {
      const err = new Error(`@opentelemetry/api: Registration of version v${api2.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
      diag.error(err.stack || err.message);
      return false;
    }
    api2[type] = instance;
    diag.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`);
    return true;
  };
  var getGlobal = function(type) {
    var _a, _b;
    const globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === undefined ? undefined : _a.version;
    if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
      return;
    }
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === undefined ? undefined : _b[type];
  };
  var unregisterGlobal = function(type, diag) {
    diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
    const api2 = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api2) {
      delete api2[type];
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = undefined;
  var platform_1 = require_platform();
  var version_1 = require_version();
  var semver_1 = require_semver();
  var major = version_1.VERSION.split(".")[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
  var _global = platform_1._globalThis;
  exports.registerGlobal = registerGlobal;
  exports.getGlobal = getGlobal;
  exports.unregisterGlobal = unregisterGlobal;
});

// node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS((exports) => {
  var logProxy = function(funcName, namespace, args) {
    const logger = (0, global_utils_1.getGlobal)("diag");
    if (!logger) {
      return;
    }
    args.unshift(namespace);
    return logger[funcName](...args);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagComponentLogger = undefined;
  var global_utils_1 = require_global_utils();

  class DiagComponentLogger {
    constructor(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    debug(...args) {
      return logProxy("debug", this._namespace, args);
    }
    error(...args) {
      return logProxy("error", this._namespace, args);
    }
    info(...args) {
      return logProxy("info", this._namespace, args);
    }
    warn(...args) {
      return logProxy("warn", this._namespace, args);
    }
    verbose(...args) {
      return logProxy("verbose", this._namespace, args);
    }
  }
  exports.DiagComponentLogger = DiagComponentLogger;
});

// node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagLogLevel = undefined;
  var DiagLogLevel;
  (function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
  })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
});

// node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS((exports) => {
  var createLogLevelDiagLogger = function(maxLevel, logger) {
    if (maxLevel < types_1.DiagLogLevel.NONE) {
      maxLevel = types_1.DiagLogLevel.NONE;
    } else if (maxLevel > types_1.DiagLogLevel.ALL) {
      maxLevel = types_1.DiagLogLevel.ALL;
    }
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
      const theFunc = logger[funcName];
      if (typeof theFunc === "function" && maxLevel >= theLevel) {
        return theFunc.bind(logger);
      }
      return function() {
      };
    }
    return {
      error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
      warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
      info: _filterFunc("info", types_1.DiagLogLevel.INFO),
      debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLogLevelDiagLogger = undefined;
  var types_1 = require_types4();
  exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
});

// node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagAPI = undefined;
  var ComponentLogger_1 = require_ComponentLogger();
  var logLevelLogger_1 = require_logLevelLogger();
  var types_1 = require_types4();
  var global_utils_1 = require_global_utils();
  var API_NAME = "diag";

  class DiagAPI {
    constructor() {
      function _logProxy(funcName) {
        return function(...args) {
          const logger = (0, global_utils_1.getGlobal)("diag");
          if (!logger)
            return;
          return logger[funcName](...args);
        };
      }
      const self2 = this;
      const setLogger = (logger, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
        var _a, _b, _c;
        if (logger === self2) {
          const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a = err.stack) !== null && _a !== undefined ? _a : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        const oldLogger = (0, global_utils_1.getGlobal)("diag");
        const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== undefined ? _b : types_1.DiagLogLevel.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          const stack = (_c = new Error().stack) !== null && _c !== undefined ? _c : "<failed to generate stacktrace>";
          oldLogger.warn(`Current logger will be overwritten from ${stack}`);
          newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
        }
        return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
      };
      self2.setLogger = setLogger;
      self2.disable = () => {
        (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
      };
      self2.createComponentLogger = (options) => {
        return new ComponentLogger_1.DiagComponentLogger(options);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    static instance() {
      if (!this._instance) {
        this._instance = new DiagAPI;
      }
      return this._instance;
    }
  }
  exports.DiagAPI = DiagAPI;
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaggageImpl = undefined;

  class BaggageImpl {
    constructor(entries) {
      this._entries = entries ? new Map(entries) : new Map;
    }
    getEntry(key) {
      const entry = this._entries.get(key);
      if (!entry) {
        return;
      }
      return Object.assign({}, entry);
    }
    getAllEntries() {
      return Array.from(this._entries.entries()).map(([k2, v]) => [k2, v]);
    }
    setEntry(key, entry) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    }
    removeEntry(key) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    }
    removeEntries(...keys) {
      const newBaggage = new BaggageImpl(this._entries);
      for (const key of keys) {
        newBaggage._entries.delete(key);
      }
      return newBaggage;
    }
    clear() {
      return new BaggageImpl;
    }
  }
  exports.BaggageImpl = BaggageImpl;
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataSymbol = undefined;
  exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
});

// node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils2 = __commonJS((exports) => {
  var createBaggage = function(entries = {}) {
    return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
  };
  var baggageEntryMetadataFromString = function(str) {
    if (typeof str !== "string") {
      diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
      str = "";
    }
    return {
      __TYPE__: symbol_1.baggageEntryMetadataSymbol,
      toString() {
        return str;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataFromString = exports.createBaggage = undefined;
  var diag_1 = require_diag();
  var baggage_impl_1 = require_baggage_impl();
  var symbol_1 = require_symbol();
  var diag = diag_1.DiagAPI.instance();
  exports.createBaggage = createBaggage;
  exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
});

// node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS((exports) => {
  var createContextKey = function(description) {
    return Symbol.for(description);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ROOT_CONTEXT = exports.createContextKey = undefined;
  exports.createContextKey = createContextKey;

  class BaseContext {
    constructor(parentContext) {
      const self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : new Map;
      self2.getValue = (key) => self2._currentContext.get(key);
      self2.setValue = (key, value4) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.set(key, value4);
        return context;
      };
      self2.deleteValue = (key) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
  }
  exports.ROOT_CONTEXT = new BaseContext;
});

// node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagConsoleLogger = undefined;
  var consoleMap = [
    { n: "error", c: "error" },
    { n: "warn", c: "warn" },
    { n: "info", c: "info" },
    { n: "debug", c: "debug" },
    { n: "verbose", c: "trace" }
  ];

  class DiagConsoleLogger {
    constructor() {
      function _consoleFunc(funcName) {
        return function(...args) {
          if (console) {
            let theFunc = console[funcName];
            if (typeof theFunc !== "function") {
              theFunc = console.log;
            }
            if (typeof theFunc === "function") {
              return theFunc.apply(console, args);
            }
          }
        };
      }
      for (let i = 0;i < consoleMap.length; i++) {
        this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
    }
  }
  exports.DiagConsoleLogger = DiagConsoleLogger;
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS((exports) => {
  var createNoopMeter = function() {
    return exports.NOOP_METER;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = undefined;

  class NoopMeter {
    constructor() {
    }
    createHistogram(_name, _options) {
      return exports.NOOP_HISTOGRAM_METRIC;
    }
    createCounter(_name, _options) {
      return exports.NOOP_COUNTER_METRIC;
    }
    createUpDownCounter(_name, _options) {
      return exports.NOOP_UP_DOWN_COUNTER_METRIC;
    }
    createObservableGauge(_name, _options) {
      return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
    }
    createObservableCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
    }
    createObservableUpDownCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    }
    addBatchObservableCallback(_callback, _observables) {
    }
    removeBatchObservableCallback(_callback) {
    }
  }
  exports.NoopMeter = NoopMeter;

  class NoopMetric {
  }
  exports.NoopMetric = NoopMetric;

  class NoopCounterMetric extends NoopMetric {
    add(_value, _attributes) {
    }
  }
  exports.NoopCounterMetric = NoopCounterMetric;

  class NoopUpDownCounterMetric extends NoopMetric {
    add(_value, _attributes) {
    }
  }
  exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;

  class NoopHistogramMetric extends NoopMetric {
    record(_value, _attributes) {
    }
  }
  exports.NoopHistogramMetric = NoopHistogramMetric;

  class NoopObservableMetric {
    addCallback(_callback) {
    }
    removeCallback(_callback) {
    }
  }
  exports.NoopObservableMetric = NoopObservableMetric;

  class NoopObservableCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableCounterMetric = NoopObservableCounterMetric;

  class NoopObservableGaugeMetric extends NoopObservableMetric {
  }
  exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;

  class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
  exports.NOOP_METER = new NoopMeter;
  exports.NOOP_COUNTER_METRIC = new NoopCounterMetric;
  exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
  exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
  exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
  exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
  exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
  exports.createNoopMeter = createNoopMeter;
});

// node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueType = undefined;
  var ValueType;
  (function(ValueType2) {
    ValueType2[ValueType2["INT"] = 0] = "INT";
    ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
  })(ValueType = exports.ValueType || (exports.ValueType = {}));
});

// node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultTextMapSetter = exports.defaultTextMapGetter = undefined;
  exports.defaultTextMapGetter = {
    get(carrier, key) {
      if (carrier == null) {
        return;
      }
      return carrier[key];
    },
    keys(carrier) {
      if (carrier == null) {
        return [];
      }
      return Object.keys(carrier);
    }
  };
  exports.defaultTextMapSetter = {
    set(carrier, key, value4) {
      if (carrier == null) {
        return;
      }
      carrier[key] = value4;
    }
  };
});

// node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopContextManager = undefined;
  var context_1 = require_context();

  class NoopContextManager {
    active() {
      return context_1.ROOT_CONTEXT;
    }
    with(_context, fn, thisArg, ...args) {
      return fn.call(thisArg, ...args);
    }
    bind(_context, target) {
      return target;
    }
    enable() {
      return this;
    }
    disable() {
      return this;
    }
  }
  exports.NoopContextManager = NoopContextManager;
});

// node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContextAPI = undefined;
  var NoopContextManager_1 = require_NoopContextManager();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "context";
  var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager;

  class ContextAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new ContextAPI;
      }
      return this._instance;
    }
    setGlobalContextManager(contextManager) {
      return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
    }
    active() {
      return this._getContextManager().active();
    }
    with(context, fn, thisArg, ...args) {
      return this._getContextManager().with(context, fn, thisArg, ...args);
    }
    bind(context, target) {
      return this._getContextManager().bind(context, target);
    }
    _getContextManager() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
    }
    disable() {
      this._getContextManager().disable();
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.ContextAPI = ContextAPI;
});

// node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceFlags = undefined;
  var TraceFlags;
  (function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = undefined;
  var trace_flags_1 = require_trace_flags();
  exports.INVALID_SPANID = "0000000000000000";
  exports.INVALID_TRACEID = "00000000000000000000000000000000";
  exports.INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACEID,
    spanId: exports.INVALID_SPANID,
    traceFlags: trace_flags_1.TraceFlags.NONE
  };
});

// node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NonRecordingSpan = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();

  class NonRecordingSpan {
    constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
      this._spanContext = _spanContext;
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(_key, _value) {
      return this;
    }
    setAttributes(_attributes) {
      return this;
    }
    addEvent(_name, _attributes) {
      return this;
    }
    setStatus(_status) {
      return this;
    }
    updateName(_name) {
      return this;
    }
    end(_endTime) {
    }
    isRecording() {
      return false;
    }
    recordException(_exception, _time) {
    }
  }
  exports.NonRecordingSpan = NonRecordingSpan;
});

// node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS((exports) => {
  var getSpan = function(context) {
    return context.getValue(SPAN_KEY) || undefined;
  };
  var getActiveSpan = function() {
    return getSpan(context_2.ContextAPI.getInstance().active());
  };
  var setSpan = function(context, span) {
    return context.setValue(SPAN_KEY, span);
  };
  var deleteSpan = function(context) {
    return context.deleteValue(SPAN_KEY);
  };
  var setSpanContext = function(context, spanContext) {
    return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
  };
  var getSpanContext = function(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === undefined ? undefined : _a.spanContext();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = undefined;
  var context_1 = require_context();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var context_2 = require_context2();
  var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
  exports.getSpan = getSpan;
  exports.getActiveSpan = getActiveSpan;
  exports.setSpan = setSpan;
  exports.deleteSpan = deleteSpan;
  exports.setSpanContext = setSpanContext;
  exports.getSpanContext = getSpanContext;
});

// node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS((exports) => {
  var isValidTraceId = function(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
  };
  var isValidSpanId = function(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
  };
  var isSpanContextValid = function(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  };
  var wrapSpanContext = function(spanContext) {
    return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  exports.isValidTraceId = isValidTraceId;
  exports.isValidSpanId = isValidSpanId;
  exports.isSpanContextValid = isSpanContextValid;
  exports.wrapSpanContext = wrapSpanContext;
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS((exports) => {
  var isSpanContext = function(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracer = undefined;
  var context_1 = require_context2();
  var context_utils_1 = require_context_utils();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var spancontext_utils_1 = require_spancontext_utils();
  var contextApi = context_1.ContextAPI.getInstance();

  class NoopTracer {
    startSpan(name, options, context = contextApi.active()) {
      const root = Boolean(options === null || options === undefined ? undefined : options.root);
      if (root) {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
      const parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
      if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
        return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
    }
    startActiveSpan(name, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
      const span = this.startSpan(name, opts, parentContext);
      const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, undefined, span);
    }
  }
  exports.NoopTracer = NoopTracer;
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracer = undefined;
  var NoopTracer_1 = require_NoopTracer();
  var NOOP_TRACER = new NoopTracer_1.NoopTracer;

  class ProxyTracer {
    constructor(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    startSpan(name, options, context) {
      return this._getTracer().startSpan(name, options, context);
    }
    startActiveSpan(_name, _options, _context, _fn) {
      const tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    }
    _getTracer() {
      if (this._delegate) {
        return this._delegate;
      }
      const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    }
  }
  exports.ProxyTracer = ProxyTracer;
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracerProvider = undefined;
  var NoopTracer_1 = require_NoopTracer();

  class NoopTracerProvider {
    getTracer(_name, _version, _options) {
      return new NoopTracer_1.NoopTracer;
    }
  }
  exports.NoopTracerProvider = NoopTracerProvider;
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracerProvider = undefined;
  var ProxyTracer_1 = require_ProxyTracer();
  var NoopTracerProvider_1 = require_NoopTracerProvider();
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider;

  class ProxyTracerProvider {
    getTracer(name, version, options) {
      var _a;
      return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== undefined ? _a : new ProxyTracer_1.ProxyTracer(this, name, version, options);
    }
    getDelegate() {
      var _a;
      return (_a = this._delegate) !== null && _a !== undefined ? _a : NOOP_TRACER_PROVIDER;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    getDelegateTracer(name, version, options) {
      var _a;
      return (_a = this._delegate) === null || _a === undefined ? undefined : _a.getTracer(name, version, options);
    }
  }
  exports.ProxyTracerProvider = ProxyTracerProvider;
});

// node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanKind = undefined;
  var SpanKind;
  (function(SpanKind2) {
    SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
    SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
    SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
    SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
    SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
  })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanStatusCode = undefined;
  var SpanStatusCode;
  (function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS((exports) => {
  var validateKey = function(key) {
    return VALID_KEY_REGEX.test(key);
  };
  var validateValue = function(value4) {
    return VALID_VALUE_BASE_REGEX.test(value4) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value4);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})\$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  exports.validateKey = validateKey;
  exports.validateValue = validateValue;
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceStateImpl = undefined;
  var tracestate_validators_1 = require_tracestate_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceStateImpl {
    constructor(rawTraceState) {
      this._internalState = new Map;
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value4) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value4);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          const key = listMember.slice(0, i);
          const value4 = listMember.slice(i + 1, part.length);
          if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value4)) {
            agg.set(key, value4);
          } else {
          }
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceStateImpl;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceStateImpl = TraceStateImpl;
});

// node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils3 = __commonJS((exports) => {
  var createTraceState = function(rawTraceState) {
    return new tracestate_impl_1.TraceStateImpl(rawTraceState);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTraceState = undefined;
  var tracestate_impl_1 = require_tracestate_impl();
  exports.createTraceState = createTraceState;
});

// node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.context = undefined;
  var context_1 = require_context2();
  exports.context = context_1.ContextAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.diag = undefined;
  var diag_1 = require_diag();
  exports.diag = diag_1.DiagAPI.instance();
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = undefined;
  var NoopMeter_1 = require_NoopMeter();

  class NoopMeterProvider {
    getMeter(_name, _version, _options) {
      return NoopMeter_1.NOOP_METER;
    }
  }
  exports.NoopMeterProvider = NoopMeterProvider;
  exports.NOOP_METER_PROVIDER = new NoopMeterProvider;
});

// node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricsAPI = undefined;
  var NoopMeterProvider_1 = require_NoopMeterProvider();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "metrics";

  class MetricsAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new MetricsAPI;
      }
      return this._instance;
    }
    setGlobalMeterProvider(provider) {
      return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
    }
    getMeterProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
    }
    getMeter(name, version, options) {
      return this.getMeterProvider().getMeter(name, version, options);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.MetricsAPI = MetricsAPI;
});

// node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metrics = undefined;
  var metrics_1 = require_metrics();
  exports.metrics = metrics_1.MetricsAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTextMapPropagator = undefined;

  class NoopTextMapPropagator {
    inject(_context, _carrier) {
    }
    extract(context, _carrier) {
      return context;
    }
    fields() {
      return [];
    }
  }
  exports.NoopTextMapPropagator = NoopTextMapPropagator;
});

// node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS((exports) => {
  var getBaggage = function(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
  };
  var getActiveBaggage = function() {
    return getBaggage(context_1.ContextAPI.getInstance().active());
  };
  var setBaggage = function(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
  };
  var deleteBaggage = function(context) {
    return context.deleteValue(BAGGAGE_KEY);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = undefined;
  var context_1 = require_context2();
  var context_2 = require_context();
  var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
  exports.getBaggage = getBaggage;
  exports.getActiveBaggage = getActiveBaggage;
  exports.setBaggage = setBaggage;
  exports.deleteBaggage = deleteBaggage;
});

// node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PropagationAPI = undefined;
  var global_utils_1 = require_global_utils();
  var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
  var TextMapPropagator_1 = require_TextMapPropagator();
  var context_helpers_1 = require_context_helpers();
  var utils_1 = require_utils2();
  var diag_1 = require_diag();
  var API_NAME = "propagation";
  var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator;

  class PropagationAPI {
    constructor() {
      this.createBaggage = utils_1.createBaggage;
      this.getBaggage = context_helpers_1.getBaggage;
      this.getActiveBaggage = context_helpers_1.getActiveBaggage;
      this.setBaggage = context_helpers_1.setBaggage;
      this.deleteBaggage = context_helpers_1.deleteBaggage;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new PropagationAPI;
      }
      return this._instance;
    }
    setGlobalPropagator(propagator) {
      return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
    }
    inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
      return this._getGlobalPropagator().inject(context, carrier, setter);
    }
    extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
      return this._getGlobalPropagator().extract(context, carrier, getter);
    }
    fields() {
      return this._getGlobalPropagator().fields();
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
    _getGlobalPropagator() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    }
  }
  exports.PropagationAPI = PropagationAPI;
});

// node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.propagation = undefined;
  var propagation_1 = require_propagation();
  exports.propagation = propagation_1.PropagationAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceAPI = undefined;
  var global_utils_1 = require_global_utils();
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  var spancontext_utils_1 = require_spancontext_utils();
  var context_utils_1 = require_context_utils();
  var diag_1 = require_diag();
  var API_NAME = "trace";

  class TraceAPI {
    constructor() {
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
      this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
      this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
      this.deleteSpan = context_utils_1.deleteSpan;
      this.getSpan = context_utils_1.getSpan;
      this.getActiveSpan = context_utils_1.getActiveSpan;
      this.getSpanContext = context_utils_1.getSpanContext;
      this.setSpan = context_utils_1.setSpan;
      this.setSpanContext = context_utils_1.setSpanContext;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new TraceAPI;
      }
      return this._instance;
    }
    setGlobalTracerProvider(provider) {
      const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    }
    getTracerProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
    }
    getTracer(name, version) {
      return this.getTracerProvider().getTracer(name, version);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
    }
  }
  exports.TraceAPI = TraceAPI;
});

// node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = undefined;
  var trace_1 = require_trace();
  exports.trace = trace_1.TraceAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/index.js
var require_src3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = undefined;
  var utils_1 = require_utils2();
  Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
    return utils_1.baggageEntryMetadataFromString;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "createContextKey", { enumerable: true, get: function() {
    return context_1.createContextKey;
  } });
  Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: function() {
    return context_1.ROOT_CONTEXT;
  } });
  var consoleLogger_1 = require_consoleLogger();
  Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: function() {
    return consoleLogger_1.DiagConsoleLogger;
  } });
  var types_1 = require_types4();
  Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: function() {
    return types_1.DiagLogLevel;
  } });
  var NoopMeter_1 = require_NoopMeter();
  Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: function() {
    return NoopMeter_1.createNoopMeter;
  } });
  var Metric_1 = require_Metric();
  Object.defineProperty(exports, "ValueType", { enumerable: true, get: function() {
    return Metric_1.ValueType;
  } });
  var TextMapPropagator_1 = require_TextMapPropagator();
  Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapGetter;
  } });
  Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapSetter;
  } });
  var ProxyTracer_1 = require_ProxyTracer();
  Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: function() {
    return ProxyTracer_1.ProxyTracer;
  } });
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: function() {
    return ProxyTracerProvider_1.ProxyTracerProvider;
  } });
  var SamplingResult_1 = require_SamplingResult();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return SamplingResult_1.SamplingDecision;
  } });
  var span_kind_1 = require_span_kind();
  Object.defineProperty(exports, "SpanKind", { enumerable: true, get: function() {
    return span_kind_1.SpanKind;
  } });
  var status_1 = require_status();
  Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: function() {
    return status_1.SpanStatusCode;
  } });
  var trace_flags_1 = require_trace_flags();
  Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: function() {
    return trace_flags_1.TraceFlags;
  } });
  var utils_2 = require_utils3();
  Object.defineProperty(exports, "createTraceState", { enumerable: true, get: function() {
    return utils_2.createTraceState;
  } });
  var spancontext_utils_1 = require_spancontext_utils();
  Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: function() {
    return spancontext_utils_1.isSpanContextValid;
  } });
  Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidTraceId;
  } });
  Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidSpanId;
  } });
  var invalid_span_constants_1 = require_invalid_span_constants();
  Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPANID;
  } });
  Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_TRACEID;
  } });
  Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
  } });
  var context_api_1 = require_context_api();
  Object.defineProperty(exports, "context", { enumerable: true, get: function() {
    return context_api_1.context;
  } });
  var diag_api_1 = require_diag_api();
  Object.defineProperty(exports, "diag", { enumerable: true, get: function() {
    return diag_api_1.diag;
  } });
  var metrics_api_1 = require_metrics_api();
  Object.defineProperty(exports, "metrics", { enumerable: true, get: function() {
    return metrics_api_1.metrics;
  } });
  var propagation_api_1 = require_propagation_api();
  Object.defineProperty(exports, "propagation", { enumerable: true, get: function() {
    return propagation_api_1.propagation;
  } });
  var trace_api_1 = require_trace_api();
  Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
    return trace_api_1.trace;
  } });
  exports.default = {
    context: context_api_1.context,
    diag: diag_api_1.diag,
    metrics: metrics_api_1.metrics,
    propagation: propagation_api_1.propagation,
    trace: trace_api_1.trace
  };
});

// node_modules/prom-client/lib/metrics/processCpuTotal.js
var require_processCpuTotal = __commonJS((exports, module) => {
  var OtelApi = require_src3();
  var Counter = require_counter();
  var PROCESS_CPU_USER_SECONDS = "process_cpu_user_seconds_total";
  var PROCESS_CPU_SYSTEM_SECONDS = "process_cpu_system_seconds_total";
  var PROCESS_CPU_SECONDS = "process_cpu_seconds_total";
  module.exports = (registry, config = {}) => {
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const exemplars = config.enableExemplars ? config.enableExemplars : false;
    const labelNames = Object.keys(labels);
    let lastCpuUsage = process.cpuUsage();
    const cpuUserUsageCounter = new Counter({
      name: namePrefix + PROCESS_CPU_USER_SECONDS,
      help: "Total user CPU time spent in seconds.",
      enableExemplars: exemplars,
      registers,
      labelNames,
      collect() {
        const cpuUsage = process.cpuUsage();
        const userUsageMicros = cpuUsage.user - lastCpuUsage.user;
        const systemUsageMicros = cpuUsage.system - lastCpuUsage.system;
        lastCpuUsage = cpuUsage;
        if (this.enableExemplars) {
          let exemplarLabels = {};
          const currentSpan = OtelApi.trace.getSpan(OtelApi.context.active());
          if (currentSpan) {
            exemplarLabels = {
              traceId: currentSpan.spanContext().traceId,
              spanId: currentSpan.spanContext().spanId
            };
          }
          cpuUserUsageCounter.inc({
            labels,
            value: userUsageMicros / 1e6,
            exemplarLabels
          });
          cpuSystemUsageCounter.inc({
            labels,
            value: systemUsageMicros / 1e6,
            exemplarLabels
          });
          cpuUsageCounter.inc({
            labels,
            value: (userUsageMicros + systemUsageMicros) / 1e6,
            exemplarLabels
          });
        } else {
          cpuUserUsageCounter.inc(labels, userUsageMicros / 1e6);
          cpuSystemUsageCounter.inc(labels, systemUsageMicros / 1e6);
          cpuUsageCounter.inc(labels, (userUsageMicros + systemUsageMicros) / 1e6);
        }
      }
    });
    const cpuSystemUsageCounter = new Counter({
      name: namePrefix + PROCESS_CPU_SYSTEM_SECONDS,
      help: "Total system CPU time spent in seconds.",
      enableExemplars: exemplars,
      registers,
      labelNames
    });
    const cpuUsageCounter = new Counter({
      name: namePrefix + PROCESS_CPU_SECONDS,
      help: "Total user and system CPU time spent in seconds.",
      enableExemplars: exemplars,
      registers,
      labelNames
    });
  };
  module.exports.metricNames = [
    PROCESS_CPU_USER_SECONDS,
    PROCESS_CPU_SYSTEM_SECONDS,
    PROCESS_CPU_SECONDS
  ];
});

// node_modules/prom-client/lib/metrics/processStartTime.js
var require_processStartTime = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var startInSeconds = Math.round(Date.now() / 1000 - process.uptime());
  var PROCESS_START_TIME = "process_start_time_seconds";
  module.exports = (registry, config = {}) => {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_START_TIME,
      help: "Start time of the process since unix epoch in seconds.",
      registers: registry ? [registry] : undefined,
      labelNames,
      aggregator: "omit",
      collect() {
        this.set(labels, startInSeconds);
      }
    });
  };
  module.exports.metricNames = [PROCESS_START_TIME];
});

// node_modules/prom-client/lib/metrics/osMemoryHeapLinux.js
var require_osMemoryHeapLinux = __commonJS((exports, module) => {
  var structureOutput = function(input) {
    const returnValue = {};
    input.split("\n").filter((s2) => values.some((value4) => s2.indexOf(value4) === 0)).forEach((string) => {
      const split = string.split(":");
      let value4 = split[1].trim();
      value4 = value4.substr(0, value4.length - 3);
      value4 = Number(value4) * 1024;
      returnValue[split[0]] = value4;
    });
    return returnValue;
  };
  var Gauge = require_gauge();
  var fs = import.meta.require("fs");
  var values = ["VmSize", "VmRSS", "VmData"];
  var PROCESS_RESIDENT_MEMORY = "process_resident_memory_bytes";
  var PROCESS_VIRTUAL_MEMORY = "process_virtual_memory_bytes";
  var PROCESS_HEAP = "process_heap_bytes";
  module.exports = (registry, config = {}) => {
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const residentMemGauge = new Gauge({
      name: namePrefix + PROCESS_RESIDENT_MEMORY,
      help: "Resident memory size in bytes.",
      registers,
      labelNames,
      collect() {
        try {
          const stat = fs.readFileSync("/proc/self/status", "utf8");
          const structuredOutput = structureOutput(stat);
          residentMemGauge.set(labels, structuredOutput.VmRSS);
          virtualMemGauge.set(labels, structuredOutput.VmSize);
          heapSizeMemGauge.set(labels, structuredOutput.VmData);
        } catch {
        }
      }
    });
    const virtualMemGauge = new Gauge({
      name: namePrefix + PROCESS_VIRTUAL_MEMORY,
      help: "Virtual memory size in bytes.",
      registers,
      labelNames
    });
    const heapSizeMemGauge = new Gauge({
      name: namePrefix + PROCESS_HEAP,
      help: "Process heap size in bytes.",
      registers,
      labelNames
    });
  };
  module.exports.metricNames = [
    PROCESS_RESIDENT_MEMORY,
    PROCESS_VIRTUAL_MEMORY,
    PROCESS_HEAP
  ];
});

// node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js
var require_safeMemoryUsage = __commonJS((exports, module) => {
  var safeMemoryUsage = function() {
    try {
      return process.memoryUsage();
    } catch {
      return;
    }
  };
  module.exports = safeMemoryUsage;
});

// node_modules/prom-client/lib/metrics/osMemoryHeap.js
var require_osMemoryHeap = __commonJS((exports, module) => {
  var notLinuxVariant = function(registry, config = {}) {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_RESIDENT_MEMORY,
      help: "Resident memory size in bytes.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        const memUsage = safeMemoryUsage();
        if (memUsage) {
          this.set(labels, memUsage.rss);
        }
      }
    });
  };
  var Gauge = require_gauge();
  var linuxVariant = require_osMemoryHeapLinux();
  var safeMemoryUsage = require_safeMemoryUsage();
  var PROCESS_RESIDENT_MEMORY = "process_resident_memory_bytes";
  module.exports = (registry, config) => process.platform === "linux" ? linuxVariant(registry, config) : notLinuxVariant(registry, config);
  module.exports.metricNames = process.platform === "linux" ? linuxVariant.metricNames : [PROCESS_RESIDENT_MEMORY];
});

// node_modules/prom-client/lib/metrics/processOpenFileDescriptors.js
var require_processOpenFileDescriptors = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var fs = import.meta.require("fs");
  var process2 = import.meta.require("process");
  var PROCESS_OPEN_FDS = "process_open_fds";
  module.exports = (registry, config = {}) => {
    if (process2.platform !== "linux") {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_OPEN_FDS,
      help: "Number of open file descriptors.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        try {
          const fds = fs.readdirSync("/proc/self/fd");
          this.set(labels, fds.length - 1);
        } catch {
        }
      }
    });
  };
  module.exports.metricNames = [PROCESS_OPEN_FDS];
});

// node_modules/prom-client/lib/metrics/processMaxFileDescriptors.js
var require_processMaxFileDescriptors = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var fs = import.meta.require("fs");
  var PROCESS_MAX_FDS = "process_max_fds";
  var maxFds;
  module.exports = (registry, config = {}) => {
    if (maxFds === undefined) {
      try {
        const limits = fs.readFileSync("/proc/self/limits", "utf8");
        const lines = limits.split("\n");
        for (const line of lines) {
          if (line.startsWith("Max open files")) {
            const parts = line.split(/  +/);
            maxFds = Number(parts[1]);
            break;
          }
        }
      } catch {
        return;
      }
    }
    if (maxFds === undefined)
      return;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_MAX_FDS,
      help: "Maximum number of open file descriptors.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        if (maxFds !== undefined)
          this.set(labels, maxFds);
      }
    });
  };
  module.exports.metricNames = [PROCESS_MAX_FDS];
});

// node_modules/prom-client/lib/metrics/eventLoopLag.js
var require_eventLoopLag = __commonJS((exports, module) => {
  var reportEventloopLag = function(start, gauge, labels) {
    const delta = process.hrtime(start);
    const nanosec = delta[0] * 1e9 + delta[1];
    const seconds = nanosec / 1e9;
    gauge.set(labels, seconds);
  };
  var Gauge = require_gauge();
  var perf_hooks;
  try {
    perf_hooks = import.meta.require("perf_hooks");
  } catch {
  }
  var NODEJS_EVENTLOOP_LAG = "nodejs_eventloop_lag_seconds";
  var NODEJS_EVENTLOOP_LAG_MIN = "nodejs_eventloop_lag_min_seconds";
  var NODEJS_EVENTLOOP_LAG_MAX = "nodejs_eventloop_lag_max_seconds";
  var NODEJS_EVENTLOOP_LAG_MEAN = "nodejs_eventloop_lag_mean_seconds";
  var NODEJS_EVENTLOOP_LAG_STDDEV = "nodejs_eventloop_lag_stddev_seconds";
  var NODEJS_EVENTLOOP_LAG_P50 = "nodejs_eventloop_lag_p50_seconds";
  var NODEJS_EVENTLOOP_LAG_P90 = "nodejs_eventloop_lag_p90_seconds";
  var NODEJS_EVENTLOOP_LAG_P99 = "nodejs_eventloop_lag_p99_seconds";
  module.exports = (registry, config = {}) => {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const registers = registry ? [registry] : undefined;
    let collect;
    if (!perf_hooks || !perf_hooks.monitorEventLoopDelay) {
      collect = () => {
        const start = process.hrtime();
        setImmediate(reportEventloopLag, start, lag, labels);
      };
    } else {
      const histogram = perf_hooks.monitorEventLoopDelay({
        resolution: config.eventLoopMonitoringPrecision
      });
      histogram.enable();
      collect = () => {
        const start = process.hrtime();
        setImmediate(reportEventloopLag, start, lag, labels);
        lagMin.set(labels, histogram.min / 1e9);
        lagMax.set(labels, histogram.max / 1e9);
        lagMean.set(labels, histogram.mean / 1e9);
        lagStddev.set(labels, histogram.stddev / 1e9);
        lagP50.set(labels, histogram.percentile(50) / 1e9);
        lagP90.set(labels, histogram.percentile(90) / 1e9);
        lagP99.set(labels, histogram.percentile(99) / 1e9);
        histogram.reset();
      };
    }
    const lag = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG,
      help: "Lag of event loop in seconds.",
      registers,
      labelNames,
      aggregator: "average",
      collect
    });
    const lagMin = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_MIN,
      help: "The minimum recorded event loop delay.",
      registers,
      labelNames,
      aggregator: "min"
    });
    const lagMax = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_MAX,
      help: "The maximum recorded event loop delay.",
      registers,
      labelNames,
      aggregator: "max"
    });
    const lagMean = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_MEAN,
      help: "The mean of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagStddev = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_STDDEV,
      help: "The standard deviation of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagP50 = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_P50,
      help: "The 50th percentile of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagP90 = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_P90,
      help: "The 90th percentile of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagP99 = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_P99,
      help: "The 99th percentile of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
  };
  module.exports.metricNames = [
    NODEJS_EVENTLOOP_LAG,
    NODEJS_EVENTLOOP_LAG_MIN,
    NODEJS_EVENTLOOP_LAG_MAX,
    NODEJS_EVENTLOOP_LAG_MEAN,
    NODEJS_EVENTLOOP_LAG_STDDEV,
    NODEJS_EVENTLOOP_LAG_P50,
    NODEJS_EVENTLOOP_LAG_P90,
    NODEJS_EVENTLOOP_LAG_P99
  ];
});

// node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js
var require_processMetricsHelpers = __commonJS((exports, module) => {
  var aggregateByObjectName = function(list) {
    const data = {};
    for (let i = 0;i < list.length; i++) {
      const listElement = list[i];
      if (!listElement || typeof listElement.constructor === "undefined") {
        continue;
      }
      if (Object.hasOwnProperty.call(data, listElement.constructor.name)) {
        data[listElement.constructor.name] += 1;
      } else {
        data[listElement.constructor.name] = 1;
      }
    }
    return data;
  };
  var updateMetrics = function(gauge, data, labels) {
    gauge.reset();
    for (const key in data) {
      gauge.set(Object.assign({ type: key }, labels || {}), data[key]);
    }
  };
  module.exports = {
    aggregateByObjectName,
    updateMetrics
  };
});

// node_modules/prom-client/lib/metrics/processHandles.js
var require_processHandles = __commonJS((exports, module) => {
  var { aggregateByObjectName } = require_processMetricsHelpers();
  var { updateMetrics } = require_processMetricsHelpers();
  var Gauge = require_gauge();
  var NODEJS_ACTIVE_HANDLES = "nodejs_active_handles";
  var NODEJS_ACTIVE_HANDLES_TOTAL = "nodejs_active_handles_total";
  module.exports = (registry, config = {}) => {
    if (typeof process._getActiveHandles !== "function") {
      return;
    }
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_HANDLES,
      help: "Number of active libuv handles grouped by handle type. Every handle type is C++ class name.",
      labelNames: ["type", ...labelNames],
      registers,
      collect() {
        const handles = process._getActiveHandles();
        updateMetrics(this, aggregateByObjectName(handles), labels);
      }
    });
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_HANDLES_TOTAL,
      help: "Total number of active handles.",
      registers,
      labelNames,
      collect() {
        const handles = process._getActiveHandles();
        this.set(labels, handles.length);
      }
    });
  };
  module.exports.metricNames = [
    NODEJS_ACTIVE_HANDLES,
    NODEJS_ACTIVE_HANDLES_TOTAL
  ];
});

// node_modules/prom-client/lib/metrics/processRequests.js
var require_processRequests = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var { aggregateByObjectName } = require_processMetricsHelpers();
  var { updateMetrics } = require_processMetricsHelpers();
  var NODEJS_ACTIVE_REQUESTS = "nodejs_active_requests";
  var NODEJS_ACTIVE_REQUESTS_TOTAL = "nodejs_active_requests_total";
  module.exports = (registry, config = {}) => {
    if (typeof process._getActiveRequests !== "function") {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_REQUESTS,
      help: "Number of active libuv requests grouped by request type. Every request type is C++ class name.",
      labelNames: ["type", ...labelNames],
      registers: registry ? [registry] : undefined,
      collect() {
        const requests = process._getActiveRequests();
        updateMetrics(this, aggregateByObjectName(requests), labels);
      }
    });
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_REQUESTS_TOTAL,
      help: "Total number of active requests.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        const requests = process._getActiveRequests();
        this.set(labels, requests.length);
      }
    });
  };
  module.exports.metricNames = [
    NODEJS_ACTIVE_REQUESTS,
    NODEJS_ACTIVE_REQUESTS_TOTAL
  ];
});

// node_modules/prom-client/lib/metrics/processResources.js
var require_processResources = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var { updateMetrics } = require_processMetricsHelpers();
  var NODEJS_ACTIVE_RESOURCES = "nodejs_active_resources";
  var NODEJS_ACTIVE_RESOURCES_TOTAL = "nodejs_active_resources_total";
  module.exports = (registry, config = {}) => {
    if (typeof process.getActiveResourcesInfo !== "function") {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_RESOURCES,
      help: "Number of active resources that are currently keeping the event loop alive, grouped by async resource type.",
      labelNames: ["type", ...labelNames],
      registers: registry ? [registry] : undefined,
      collect() {
        const resources = process.getActiveResourcesInfo();
        const data = {};
        for (let i = 0;i < resources.length; i++) {
          const resource = resources[i];
          if (Object.hasOwn(data, resource)) {
            data[resource] += 1;
          } else {
            data[resource] = 1;
          }
        }
        updateMetrics(this, data, labels);
      }
    });
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_RESOURCES_TOTAL,
      help: "Total number of active resources.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        const resources = process.getActiveResourcesInfo();
        this.set(labels, resources.length);
      }
    });
  };
  module.exports.metricNames = [
    NODEJS_ACTIVE_RESOURCES,
    NODEJS_ACTIVE_RESOURCES_TOTAL
  ];
});

// node_modules/prom-client/lib/metrics/heapSizeAndUsed.js
var require_heapSizeAndUsed = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var safeMemoryUsage = require_safeMemoryUsage();
  var NODEJS_HEAP_SIZE_TOTAL = "nodejs_heap_size_total_bytes";
  var NODEJS_HEAP_SIZE_USED = "nodejs_heap_size_used_bytes";
  var NODEJS_EXTERNAL_MEMORY = "nodejs_external_memory_bytes";
  module.exports = (registry, config = {}) => {
    if (typeof process.memoryUsage !== "function") {
      return;
    }
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const collect = () => {
      const memUsage = safeMemoryUsage();
      if (memUsage) {
        heapSizeTotal.set(labels, memUsage.heapTotal);
        heapSizeUsed.set(labels, memUsage.heapUsed);
        if (memUsage.external !== undefined) {
          externalMemUsed.set(labels, memUsage.external);
        }
      }
    };
    const heapSizeTotal = new Gauge({
      name: namePrefix + NODEJS_HEAP_SIZE_TOTAL,
      help: "Process heap size from Node.js in bytes.",
      registers,
      labelNames,
      collect
    });
    const heapSizeUsed = new Gauge({
      name: namePrefix + NODEJS_HEAP_SIZE_USED,
      help: "Process heap size used from Node.js in bytes.",
      registers,
      labelNames
    });
    const externalMemUsed = new Gauge({
      name: namePrefix + NODEJS_EXTERNAL_MEMORY,
      help: "Node.js external memory size in bytes.",
      registers,
      labelNames
    });
  };
  module.exports.metricNames = [
    NODEJS_HEAP_SIZE_TOTAL,
    NODEJS_HEAP_SIZE_USED,
    NODEJS_EXTERNAL_MEMORY
  ];
});

// node_modules/prom-client/lib/metrics/heapSpacesSizeAndUsed.js
var require_heapSpacesSizeAndUsed = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var v8 = import.meta.require("v8");
  var METRICS = ["total", "used", "available"];
  var NODEJS_HEAP_SIZE = {};
  METRICS.forEach((metricType) => {
    NODEJS_HEAP_SIZE[metricType] = `nodejs_heap_space_size_${metricType}_bytes`;
  });
  module.exports = (registry, config = {}) => {
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = ["space", ...Object.keys(labels)];
    const gauges = {};
    METRICS.forEach((metricType) => {
      gauges[metricType] = new Gauge({
        name: namePrefix + NODEJS_HEAP_SIZE[metricType],
        help: `Process heap space size ${metricType} from Node.js in bytes.`,
        labelNames,
        registers
      });
    });
    gauges.total.collect = () => {
      for (const space of v8.getHeapSpaceStatistics()) {
        const spaceName = space.space_name.substr(0, space.space_name.indexOf("_space"));
        gauges.total.set({ space: spaceName, ...labels }, space.space_size);
        gauges.used.set({ space: spaceName, ...labels }, space.space_used_size);
        gauges.available.set({ space: spaceName, ...labels }, space.space_available_size);
      }
    };
  };
  module.exports.metricNames = Object.values(NODEJS_HEAP_SIZE);
});

// node_modules/prom-client/lib/metrics/version.js
var require_version2 = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var version = process.version;
  var versionSegments = version.slice(1).split(".").map(Number);
  var NODE_VERSION_INFO = "nodejs_version_info";
  module.exports = (registry, config = {}) => {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODE_VERSION_INFO,
      help: "Node.js version info.",
      labelNames: ["version", "major", "minor", "patch", ...labelNames],
      registers: registry ? [registry] : undefined,
      aggregator: "first",
      collect() {
        this.labels(version, versionSegments[0], versionSegments[1], versionSegments[2], ...Object.values(labels)).set(1);
      }
    });
  };
  module.exports.metricNames = [NODE_VERSION_INFO];
});

// node_modules/prom-client/lib/metrics/gc.js
var require_gc = __commonJS((exports, module) => {
  var Histogram = require_histogram();
  var perf_hooks;
  try {
    perf_hooks = import.meta.require("perf_hooks");
  } catch {
  }
  var NODEJS_GC_DURATION_SECONDS = "nodejs_gc_duration_seconds";
  var DEFAULT_GC_DURATION_BUCKETS = [0.001, 0.01, 0.1, 1, 2, 5];
  var kinds = [];
  if (perf_hooks && perf_hooks.constants) {
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MAJOR] = "major";
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MINOR] = "minor";
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_INCREMENTAL] = "incremental";
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_WEAKCB] = "weakcb";
  }
  module.exports = (registry, config = {}) => {
    if (!perf_hooks) {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const buckets = config.gcDurationBuckets ? config.gcDurationBuckets : DEFAULT_GC_DURATION_BUCKETS;
    const gcHistogram = new Histogram({
      name: namePrefix + NODEJS_GC_DURATION_SECONDS,
      help: "Garbage collection duration by kind, one of major, minor, incremental or weakcb.",
      labelNames: ["kind", ...labelNames],
      enableExemplars: false,
      buckets,
      registers: registry ? [registry] : undefined
    });
    const obs = new perf_hooks.PerformanceObserver((list) => {
      const entry = list.getEntries()[0];
      const kind = entry.detail ? kinds[entry.detail.kind] : kinds[entry.kind];
      gcHistogram.observe(Object.assign({ kind }, labels), entry.duration / 1000);
    });
    obs.observe({ entryTypes: ["gc"] });
  };
  module.exports.metricNames = [NODEJS_GC_DURATION_SECONDS];
});

// node_modules/prom-client/lib/defaultMetrics.js
var require_defaultMetrics = __commonJS((exports, module) => {
  var { isObject } = require_util();
  var processCpuTotal = require_processCpuTotal();
  var processStartTime = require_processStartTime();
  var osMemoryHeap = require_osMemoryHeap();
  var processOpenFileDescriptors = require_processOpenFileDescriptors();
  var processMaxFileDescriptors = require_processMaxFileDescriptors();
  var eventLoopLag = require_eventLoopLag();
  var processHandles = require_processHandles();
  var processRequests = require_processRequests();
  var processResources = require_processResources();
  var heapSizeAndUsed = require_heapSizeAndUsed();
  var heapSpacesSizeAndUsed = require_heapSpacesSizeAndUsed();
  var version = require_version2();
  var gc = require_gc();
  var metrics = {
    processCpuTotal,
    processStartTime,
    osMemoryHeap,
    processOpenFileDescriptors,
    processMaxFileDescriptors,
    eventLoopLag,
    ...typeof process.getActiveResourcesInfo === "function" ? { processResources } : {},
    processHandles,
    processRequests,
    heapSizeAndUsed,
    heapSpacesSizeAndUsed,
    version,
    gc
  };
  var metricsList = Object.keys(metrics);
  module.exports = function collectDefaultMetrics(config) {
    if (config !== null && config !== undefined && !isObject(config)) {
      throw new TypeError("config must be null, undefined, or an object");
    }
    config = { eventLoopMonitoringPrecision: 10, ...config };
    for (const metric of Object.values(metrics)) {
      metric(config.register, config);
    }
  };
  module.exports.metricsList = metricsList;
});

// node_modules/prom-client/lib/metricAggregators.js
var require_metricAggregators = __commonJS((exports) => {
  var AggregatorFactory = function(aggregatorFn) {
    return (metrics) => {
      if (metrics.length === 0)
        return;
      const result = {
        help: metrics[0].help,
        name: metrics[0].name,
        type: metrics[0].type,
        values: [],
        aggregator: metrics[0].aggregator
      };
      const byLabels = new Grouper;
      metrics.forEach((metric) => {
        metric.values.forEach((value4) => {
          const key = hashObject(value4.labels);
          byLabels.add(`${value4.metricName}_${key}`, value4);
        });
      });
      byLabels.forEach((values) => {
        if (values.length === 0)
          return;
        const valObj = {
          value: aggregatorFn(values),
          labels: values[0].labels
        };
        if (values[0].metricName) {
          valObj.metricName = values[0].metricName;
        }
        result.values.push(valObj);
      });
      return result;
    };
  };
  var { Grouper, hashObject } = require_util();
  exports.AggregatorFactory = AggregatorFactory;
  exports.aggregators = {
    sum: AggregatorFactory((v) => v.reduce((p, c2) => p + c2.value, 0)),
    first: AggregatorFactory((v) => v[0].value),
    omit: () => {
    },
    average: AggregatorFactory((v) => v.reduce((p, c2) => p + c2.value, 0) / v.length),
    min: AggregatorFactory((v) => v.reduce((p, c2) => Math.min(p, c2.value), Infinity)),
    max: AggregatorFactory((v) => v.reduce((p, c2) => Math.max(p, c2.value), (-Infinity)))
  };
});

// node_modules/prom-client/lib/cluster.js
var require_cluster = __commonJS((exports, module) => {
  var addListeners = function() {
    if (listenersAdded)
      return;
    listenersAdded = true;
    if (cluster().isMaster) {
      cluster().on("message", (worker, message) => {
        if (message.type === GET_METRICS_RES) {
          const request2 = requests.get(message.requestId);
          if (message.error) {
            request2.done(new Error(message.error));
            return;
          }
          message.metrics.forEach((registry) => request2.responses.push(registry));
          request2.pending--;
          if (request2.pending === 0) {
            requests.delete(message.requestId);
            clearTimeout(request2.errorTimeout);
            const registry = AggregatorRegistry.aggregate(request2.responses);
            const promString = registry.metrics();
            request2.done(null, promString);
          }
        }
      });
    }
    if (cluster().isWorker) {
      process.on("message", (message) => {
        if (message.type === GET_METRICS_REQ) {
          Promise.all(registries.map((r) => r.getMetricsAsJSON())).then((metrics) => {
            process.send({
              type: GET_METRICS_RES,
              requestId: message.requestId,
              metrics
            });
          }).catch((error) => {
            process.send({
              type: GET_METRICS_RES,
              requestId: message.requestId,
              error: error.message
            });
          });
        }
      });
    }
  };
  var Registry = require_registry();
  var { Grouper } = require_util();
  var { aggregators } = require_metricAggregators();
  var cluster = () => {
    const data = import.meta.require("cluster");
    cluster = () => data;
    return data;
  };
  var GET_METRICS_REQ = "prom-client:getMetricsReq";
  var GET_METRICS_RES = "prom-client:getMetricsRes";
  var registries = [Registry.globalRegistry];
  var requestCtr = 0;
  var listenersAdded = false;
  var requests = new Map;

  class AggregatorRegistry extends Registry {
    constructor(regContentType = Registry.PROMETHEUS_CONTENT_TYPE) {
      super(regContentType);
      addListeners();
    }
    clusterMetrics() {
      const requestId = requestCtr++;
      return new Promise((resolve, reject) => {
        let settled = false;
        function done(err, result) {
          if (settled)
            return;
          settled = true;
          if (err)
            reject(err);
          else
            resolve(result);
        }
        const request2 = {
          responses: [],
          pending: 0,
          done,
          errorTimeout: setTimeout(() => {
            const err = new Error("Operation timed out.");
            request2.done(err);
          }, 5000)
        };
        requests.set(requestId, request2);
        const message = {
          type: GET_METRICS_REQ,
          requestId
        };
        for (const id in cluster().workers) {
          if (cluster().workers[id].isConnected()) {
            cluster().workers[id].send(message);
            request2.pending++;
          }
        }
        if (request2.pending === 0) {
          clearTimeout(request2.errorTimeout);
          process.nextTick(() => done(null, ""));
        }
      });
    }
    get contentType() {
      return super.contentType;
    }
    static aggregate(metricsArr, registryType = Registry.PROMETHEUS_CONTENT_TYPE) {
      const aggregatedRegistry = new Registry;
      const metricsByName = new Grouper;
      aggregatedRegistry.setContentType(registryType);
      metricsArr.forEach((metrics) => {
        metrics.forEach((metric) => {
          metricsByName.add(metric.name, metric);
        });
      });
      metricsByName.forEach((metrics) => {
        const aggregatorName = metrics[0].aggregator;
        const aggregatorFn = aggregators[aggregatorName];
        if (typeof aggregatorFn !== "function") {
          throw new Error(`'${aggregatorName}' is not a defined aggregator.`);
        }
        const aggregatedMetric = aggregatorFn(metrics);
        if (aggregatedMetric) {
          const aggregatedMetricWrapper = Object.assign({
            get: () => aggregatedMetric
          }, aggregatedMetric);
          aggregatedRegistry.registerMetric(aggregatedMetricWrapper);
        }
      });
      return aggregatedRegistry;
    }
    static setRegistries(regs) {
      if (!Array.isArray(regs))
        regs = [regs];
      regs.forEach((reg) => {
        if (!(reg instanceof Registry)) {
          throw new TypeError(`Expected Registry, got ${typeof reg}`);
        }
      });
      registries = regs;
    }
  }
  module.exports = AggregatorRegistry;
});

// node_modules/prom-client/index.js
var require_prom_client = __commonJS((exports) => {
  exports.register = require_registry().globalRegistry;
  exports.Registry = require_registry();
  exports.contentType = require_registry().globalRegistry.contentType;
  exports.prometheusContentType = require_registry().PROMETHEUS_CONTENT_TYPE;
  exports.openMetricsContentType = require_registry().OPENMETRICS_CONTENT_TYPE;
  exports.validateMetricName = require_validation().validateMetricName;
  exports.Counter = require_counter();
  exports.Gauge = require_gauge();
  exports.Histogram = require_histogram();
  exports.Summary = require_summary();
  exports.Pushgateway = require_pushgateway();
  exports.linearBuckets = require_bucketGenerators().linearBuckets;
  exports.exponentialBuckets = require_bucketGenerators().exponentialBuckets;
  exports.collectDefaultMetrics = require_defaultMetrics();
  exports.aggregators = require_metricAggregators().aggregators;
  exports.AggregatorRegistry = require_cluster();
});

// node_modules/@research-ag/hpl-client/dist/esm/chunk-WFBVPRMZ.js
var s = (e) => {
  e instanceof Array && e.length == 1 && (e = e[0]);
  let r = Object.keys(e)[0];
  return [r, e[r]];
};
var t = (e, r) => typeof r == "bigint" ? `${r.toString()}n` : r;
var y = class extends Error {
  errorKey;
  errorPayload;
  constructor(r) {
    let [o, n] = s(r), i = "#" + o;
    n !== null && (i += ": " + JSON.stringify(n, t)), super(i), this.errorKey = o, this.errorPayload = n;
  }
  isTrapped() {
    return this.errorKey == "CanisterError";
  }
  isErrorRejectThrown() {
    return this.errorKey == "CanisterReject";
  }
  toString() {
    return `#${this.errorKey}(${JSON.stringify(this.errorPayload, t)})`;
  }
};

// node_modules/@research-ag/hpl-client/dist/esm/chunk-56QVBPN4.js
var principal8 = __toESM(require_cjs(), 1);
var principal9 = __toESM(require_cjs(), 1);
var principal10 = __toESM(require_cjs(), 1);
var candid5 = __toESM(require_cjs2(), 1);

// node_modules/buffer/index.js
var typedArraySupport = function() {
  try {
    var arr = new Uint8Array(1);
    var proto = { foo: function() {
      return 42;
    } };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
};
var createBuffer = function(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer2.prototype);
  return buf;
};
var Buffer2 = function(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
};
var from = function(value, encodingOrOffset, length) {
  if (typeof value === "string") {
    return fromString(value, encodingOrOffset);
  }
  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value);
  }
  if (value == null) {
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof value === "number") {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }
  var valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value) {
    return Buffer2.from(valueOf, encodingOrOffset, length);
  }
  var b = fromObject(value);
  if (b)
    return b;
  if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
    return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
  }
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
};
var assertSize = function(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
};
var alloc = function(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
};
var allocUnsafe = function(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
};
var fromString = function(string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError("Unknown encoding: " + encoding);
  }
  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
};
var fromArrayLike = function(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var i = 0;i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
};
var fromArrayView = function(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }
  return fromArrayLike(arrayView);
};
var fromArrayBuffer = function(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }
  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }
  Object.setPrototypeOf(buf, Buffer2.prototype);
  return buf;
};
var fromObject = function(obj) {
  if (Buffer2.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);
    if (buf.length === 0) {
      return buf;
    }
    obj.copy(buf, 0, 0, len);
    return buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }
    return fromArrayLike(obj);
  }
  if (obj.type === "Buffer" && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
};
var checked = function(length) {
  if (length >= K_MAX_LENGTH) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
  }
  return length | 0;
};
var byteLength = function(string, encoding) {
  if (Buffer2.isBuffer(string)) {
    return string.length;
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
  }
  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0)
    return 0;
  var loweredCase = false;
  for (;; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length;
        }
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
var slowToString = function(encoding, start, end) {
  var loweredCase = false;
  if (start === undefined || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
};
var swap = function(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
};
var bidirectionalIndexOf = function(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (numberIsNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (Buffer2.isBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
};
var arrayIndexOf = function(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset;i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset;i >= 0; i--) {
      var found = true;
      for (var j = 0;j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
};
var hexWrite = function(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0;i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
};
var utf8Write = function(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
};
var asciiWrite = function(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
};
var base64Write = function(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
};
var ucs2Write = function(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
};
var base64Slice = function(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
};
var utf8Slice = function(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
};
var decodeCodePointsArray = function(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
};
var asciiSlice = function(buf, start, end) {
  var ret2 = "";
  end = Math.min(buf.length, end);
  for (var i = start;i < end; ++i) {
    ret2 += String.fromCharCode(buf[i] & 127);
  }
  return ret2;
};
var latin1Slice = function(buf, start, end) {
  var ret2 = "";
  end = Math.min(buf.length, end);
  for (var i = start;i < end; ++i) {
    ret2 += String.fromCharCode(buf[i]);
  }
  return ret2;
};
var hexSlice = function(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start;i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }
  return out;
};
var utf16leSlice = function(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0;i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
};
var checkOffset = function(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
};
var checkInt = function(buf, value, offset, ext, max, min) {
  if (!Buffer2.isBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
};
var checkIEEE754 = function(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
};
var writeFloat = function(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
};
var writeDouble = function(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
};
var base64clean = function(str) {
  str = str.split("=")[0];
  str = str.trim().replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
};
var utf8ToBytes = function(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0;i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
};
var asciiToBytes = function(str) {
  var byteArray = [];
  for (var i = 0;i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
};
var utf16leToBytes = function(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0;i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
};
var base64ToBytes = function(str) {
  return base64.toByteArray(base64clean(str));
};
var blitBuffer = function(src, dst, offset, length) {
  for (var i = 0;i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
};
var isInstance = function(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
};
var numberIsNaN = function(obj) {
  return obj !== obj;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var base64 = require_base64_js();
var ieee754 = require_ieee754();
var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
var $Buffer = Buffer2;
var $INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 2147483647;
Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
  console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
}
Object.defineProperty(Buffer2.prototype, "parent", {
  enumerable: true,
  get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.buffer;
  }
});
Object.defineProperty(Buffer2.prototype, "offset", {
  enumerable: true,
  get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.byteOffset;
  }
});
Buffer2.poolSize = 8192;
Buffer2.from = function(value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer2, Uint8Array);
Buffer2.alloc = function(size, fill, encoding) {
  return alloc(size, fill, encoding);
};
Buffer2.allocUnsafe = function(size) {
  return allocUnsafe(size);
};
Buffer2.allocUnsafeSlow = function(size) {
  return allocUnsafe(size);
};
Buffer2.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer2.prototype;
};
Buffer2.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array))
    a = Buffer2.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array))
    b = Buffer2.from(b, b.offset, b.byteLength);
  if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b)
    return 0;
  var x = a.length;
  var y2 = b.length;
  for (var i = 0, len = Math.min(x, y2);i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y2 = b[i];
      break;
    }
  }
  if (x < y2)
    return -1;
  if (y2 < x)
    return 1;
  return 0;
};
Buffer2.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer2.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer2.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0;i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer2.allocUnsafe(length);
  var pos = 0;
  for (i = 0;i < list.length; ++i) {
    var buf = list[i];
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        Buffer2.from(buf).copy(buffer, pos);
      } else {
        Uint8Array.prototype.set.call(buffer, buf, pos);
      }
    } else if (!Buffer2.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    } else {
      buf.copy(buffer, pos);
    }
    pos += buf.length;
  }
  return buffer;
};
Buffer2.byteLength = byteLength;
Buffer2.prototype._isBuffer = true;
Buffer2.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0;i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer2.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0;i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer2.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0;i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer2.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
Buffer2.prototype.equals = function equals(b) {
  if (!Buffer2.isBuffer(b))
    throw new TypeError("Argument must be a Buffer");
  if (this === b)
    return true;
  return Buffer2.compare(this, b) === 0;
};
Buffer2.prototype.inspect = function inspect() {
  var str = "";
  var max = $INSPECT_MAX_BYTES;
  str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
  if (this.length > max)
    str += " ... ";
  return "<Buffer " + str + ">";
};
if (customInspectSymbol) {
  Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
}
Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer2.from(target, target.offset, target.byteLength);
  }
  if (!Buffer2.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x = thisEnd - thisStart;
  var y2 = end - start;
  var len = Math.min(x, y2);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0;i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y2 = targetCopy[i];
      break;
    }
  }
  if (x < y2)
    return -1;
  if (y2 < x)
    return 1;
  return 0;
};
Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer2.prototype.write = function write(string, offset, length, encoding) {
  if (offset === undefined) {
    encoding = "utf8";
    length = this.length;
    offset = 0;
  } else if (length === undefined && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined)
        encoding = "utf8";
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (;; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset, length);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset, length);
      case "ascii":
      case "latin1":
      case "binary":
        return asciiWrite(this, string, offset, length);
      case "base64":
        return base64Write(this, string, offset, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer2.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
var MAX_ARGUMENTS_LENGTH = 4096;
Buffer2.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer2.prototype);
  return newBuf;
};
Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
  offset = offset >>> 0;
  byteLength2 = byteLength2 >>> 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength2 && (mul *= 256)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
  offset = offset >>> 0;
  byteLength2 = byteLength2 >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength2, this.length);
  }
  var val = this[offset + --byteLength2];
  var mul = 1;
  while (byteLength2 > 0 && (mul *= 256)) {
    val += this[offset + --byteLength2] * mul;
  }
  return val;
};
Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
  offset = offset >>> 0;
  byteLength2 = byteLength2 >>> 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength2 && (mul *= 256)) {
    val += this[offset + i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
  offset = offset >>> 0;
  byteLength2 = byteLength2 >>> 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var i = byteLength2;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 256)) {
    val += this[offset + --i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  if (!(this[offset] & 128))
    return this[offset];
  return (255 - this[offset] + 1) * -1;
};
Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};
Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};
Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};
Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};
Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength2 = byteLength2 >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 255;
  while (++i < byteLength2 && (mul *= 256)) {
    this[offset + i] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength2 = byteLength2 >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var i = byteLength2 - 1;
  var mul = 1;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul *= 256)) {
    this[offset + i] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 255, 0);
  this[offset] = value & 255;
  return offset + 1;
};
Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  this[offset] = value & 255;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 255;
  return offset + 2;
};
Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 255;
  return offset + 4;
};
Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 255;
  return offset + 4;
};
Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 255;
  while (++i < byteLength2 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i = byteLength2 - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 127, -128);
  if (value < 0)
    value = 255 + value + 1;
  this[offset] = value & 255;
  return offset + 1;
};
Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  this[offset] = value & 255;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 255;
  return offset + 2;
};
Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  this[offset] = value & 255;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};
Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  if (value < 0)
    value = 4294967295 + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 255;
  return offset + 4;
};
Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};
Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer2.isBuffer(target))
    throw new TypeError("argument should be a Buffer");
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("Index out of range");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }
  return len;
};
Buffer2.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (encoding !== undefined && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (encoding === "utf8" && code < 128 || encoding === "latin1") {
        val = code;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  } else if (typeof val === "boolean") {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start;i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
    var len = bytes.length;
    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }
    for (i = 0;i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
var hexSliceLookupTable = function() {
  var alphabet = "0123456789abcdef";
  var table = new Array(256);
  for (var i = 0;i < 16; ++i) {
    var i16 = i * 16;
    for (var j = 0;j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }
  return table;
}();

// node_modules/@dfinity/agent/lib/esm/agent/api.js
var ReplicaRejectCode;
(function(ReplicaRejectCode2) {
  ReplicaRejectCode2[ReplicaRejectCode2["SysFatal"] = 1] = "SysFatal";
  ReplicaRejectCode2[ReplicaRejectCode2["SysTransient"] = 2] = "SysTransient";
  ReplicaRejectCode2[ReplicaRejectCode2["DestinationInvalid"] = 3] = "DestinationInvalid";
  ReplicaRejectCode2[ReplicaRejectCode2["CanisterReject"] = 4] = "CanisterReject";
  ReplicaRejectCode2[ReplicaRejectCode2["CanisterError"] = 5] = "CanisterError";
})(ReplicaRejectCode || (ReplicaRejectCode = {}));
// node_modules/@dfinity/agent/lib/esm/agent/http/index.js
var principal4 = __toESM(require_cjs(), 1);
init_errors();

// node_modules/@dfinity/agent/lib/esm/auth.js
var principal = __toESM(require_cjs(), 1);
init_request_id();
init_buffer();
var __rest = function(s2, e) {
  var t2 = {};
  for (var p in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
      t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s2);i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
        t2[p[i]] = s2[p[i]];
    }
  return t2;
};
var domainSeparator = new TextEncoder().encode(`
ic-request`);

class SignIdentity {
  getPrincipal() {
    if (!this._principal) {
      this._principal = principal.Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));
    }
    return this._principal;
  }
  async transformRequest(request) {
    const { body } = request, fields = __rest(request, ["body"]);
    const requestId = await requestIdOf(body);
    return Object.assign(Object.assign({}, fields), { body: {
      content: body,
      sender_pubkey: this.getPublicKey().toDer(),
      sender_sig: await this.sign(concat2(domainSeparator, requestId))
    } });
  }
}

class AnonymousIdentity {
  getPrincipal() {
    return principal.Principal.anonymous();
  }
  async transformRequest(request) {
    return Object.assign(Object.assign({}, request), { body: { content: request.body } });
  }
}

// node_modules/@dfinity/agent/lib/esm/agent/http/index.js
init_cbor();
init_request_id();
init_buffer();

// node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js
var candid2 = __toESM(require_cjs2(), 1);
var cbor2 = __toESM(require_src2(), 1);

// node_modules/@dfinity/agent/lib/esm/agent/http/types.js
function makeNonce() {
  const buffer4 = new ArrayBuffer(16);
  const view = new DataView(buffer4);
  const now = BigInt(+Date.now());
  const randHi = Math.floor(Math.random() * 4294967295);
  const randLo = Math.floor(Math.random() * 4294967295);
  if (typeof view.setBigUint64 === "function") {
    view.setBigUint64(0, now);
  } else {
    const TWO_TO_THE_32 = BigInt(1) << BigInt(32);
    view.setUint32(0, Number(now >> BigInt(32)));
    view.setUint32(4, Number(now % TWO_TO_THE_32));
  }
  view.setUint32(8, randHi);
  view.setUint32(12, randLo);
  return buffer4;
}
var SubmitRequestType;
(function(SubmitRequestType2) {
  SubmitRequestType2["Call"] = "call";
})(SubmitRequestType || (SubmitRequestType = {}));

// node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js
function makeNonceTransform(nonceFn = makeNonce) {
  return async (request) => {
    const nonce = nonceFn();
    const headers = request.request.headers;
    request.request.headers = headers;
    if (request.endpoint === "call") {
      request.body.nonce = nonceFn();
    }
  };
}
function httpHeadersTransform(headers) {
  const headerFields = [];
  headers.forEach((value3, key) => {
    headerFields.push([key, value3]);
  });
  return headerFields;
}
var NANOSECONDS_PER_MILLISECONDS = BigInt(1e6);
var REPLICA_PERMITTED_DRIFT_MILLISECONDS = BigInt(60 * 1000);

class Expiry {
  constructor(deltaInMSec) {
    this._value = (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS) * NANOSECONDS_PER_MILLISECONDS;
  }
  toCBOR() {
    return cbor2.value.u64(this._value.toString(16), 16);
  }
  toHash() {
    return candid2.lebEncode(this._value);
  }
}

// node_modules/@dfinity/agent/lib/esm/agent/http/errors.js
class AgentHTTPResponseError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
    this.name = this.constructor.name;
    Object.setPrototypeOf(this, new.target.prototype);
  }
}

// node_modules/@dfinity/agent/lib/esm/agent/http/index.js
var getDefaultFetch = function() {
  let defaultFetch;
  if (typeof window !== "undefined") {
    if (window.fetch) {
      defaultFetch = window.fetch.bind(window);
    } else {
      throw new HttpDefaultFetchError("Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.");
    }
  } else if (typeof global !== "undefined") {
    if (global.fetch) {
      defaultFetch = global.fetch.bind(global);
    } else {
      throw new HttpDefaultFetchError("Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.");
    }
  } else if (typeof self !== "undefined") {
    if (self.fetch) {
      defaultFetch = self.fetch.bind(self);
    }
  }
  if (defaultFetch) {
    return defaultFetch;
  }
  throw new HttpDefaultFetchError("Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.");
};
var RequestStatusResponseStatus;
(function(RequestStatusResponseStatus2) {
  RequestStatusResponseStatus2["Received"] = "received";
  RequestStatusResponseStatus2["Processing"] = "processing";
  RequestStatusResponseStatus2["Replied"] = "replied";
  RequestStatusResponseStatus2["Rejected"] = "rejected";
  RequestStatusResponseStatus2["Unknown"] = "unknown";
  RequestStatusResponseStatus2["Done"] = "done";
})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));
var DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;
var IC_ROOT_KEY = "308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d9685f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484b01291091c5f87b98883463f98091a0baaae";
var IC0_DOMAIN = "ic0.app";
var IC0_SUB_DOMAIN = ".ic0.app";
var ICP0_DOMAIN = "icp0.io";
var ICP0_SUB_DOMAIN = ".icp0.io";
var ICP_API_DOMAIN = "icp-api.io";
var ICP_API_SUB_DOMAIN = ".icp-api.io";

class HttpDefaultFetchError extends AgentError {
  constructor(message) {
    super(message);
    this.message = message;
  }
}

class IdentityInvalidError extends AgentError {
  constructor(message) {
    super(message);
    this.message = message;
  }
}

class HttpAgent {
  constructor(options = {}) {
    this.rootKey = fromHex(IC_ROOT_KEY);
    this._pipeline = [];
    this._timeDiffMsecs = 0;
    this._rootKeyFetched = false;
    this._isAgent = true;
    if (options.source) {
      if (!(options.source instanceof HttpAgent)) {
        throw new Error("An Agent's source can only be another HttpAgent");
      }
      this._pipeline = [...options.source._pipeline];
      this._identity = options.source._identity;
      this._fetch = options.source._fetch;
      this._host = options.source._host;
      this._credentials = options.source._credentials;
    } else {
      this._fetch = options.fetch || getDefaultFetch() || fetch.bind(global);
      this._fetchOptions = options.fetchOptions;
      this._callOptions = options.callOptions;
    }
    if (options.host !== undefined) {
      if (!options.host.match(/^[a-z]+:/) && typeof window !== "undefined") {
        this._host = new URL(window.location.protocol + "//" + options.host);
      } else {
        this._host = new URL(options.host);
      }
    } else if (options.source !== undefined) {
      this._host = options.source._host;
    } else {
      const location = typeof window !== "undefined" ? window.location : undefined;
      if (!location) {
        throw new Error("Must specify a host to connect to.");
      }
      this._host = new URL(location + "");
    }
    this._retryTimes = options.retryTimes !== undefined && options.retryTimes >= 0 ? options.retryTimes : 3;
    if (this._host.hostname.endsWith(IC0_SUB_DOMAIN)) {
      this._host.hostname = IC0_DOMAIN;
    } else if (this._host.hostname.endsWith(ICP0_SUB_DOMAIN)) {
      this._host.hostname = ICP0_DOMAIN;
    } else if (this._host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {
      this._host.hostname = ICP_API_DOMAIN;
    }
    if (options.credentials) {
      const { name, password } = options.credentials;
      this._credentials = `${name}${password ? ":" + password : ""}`;
    }
    this._identity = Promise.resolve(options.identity || new AnonymousIdentity);
    if (!options.disableNonce) {
      this.addTransform(makeNonceTransform(makeNonce));
    }
  }
  isLocal() {
    const hostname = this._host.hostname;
    return hostname === "127.0.0.1" || hostname.endsWith("localhost");
  }
  addTransform(fn, priority = fn.priority || 0) {
    const i = this._pipeline.findIndex((x) => (x.priority || 0) < priority);
    this._pipeline.splice(i >= 0 ? i : this._pipeline.length, 0, Object.assign(fn, { priority }));
  }
  async getPrincipal() {
    if (!this._identity) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    return (await this._identity).getPrincipal();
  }
  async call(canisterId, options, identity) {
    const id = await (identity !== undefined ? await identity : await this._identity);
    if (!id) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    const canister = principal4.Principal.from(canisterId);
    const ecid = options.effectiveCanisterId ? principal4.Principal.from(options.effectiveCanisterId) : canister;
    const sender = id.getPrincipal() || principal4.Principal.anonymous();
    let ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);
    if (Math.abs(this._timeDiffMsecs) > 1000 * 30) {
      ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this._timeDiffMsecs);
    }
    const submit = {
      request_type: SubmitRequestType.Call,
      canister_id: canister,
      method_name: options.methodName,
      arg: options.arg,
      sender,
      ingress_expiry
    };
    let transformedRequest = await this._transform({
      request: {
        body: null,
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "call",
      body: submit
    });
    transformedRequest = await id.transformRequest(transformedRequest);
    const body = encode(transformedRequest.body);
    const request2 = this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign(Object.assign({}, this._callOptions), transformedRequest.request), { body })));
    const [response, requestId] = await Promise.all([request2, requestIdOf(submit)]);
    const responseBuffer = await response.arrayBuffer();
    const responseBody = response.status === 200 && responseBuffer.byteLength > 0 ? decode(responseBuffer) : null;
    return {
      requestId,
      response: {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
        body: responseBody,
        headers: httpHeadersTransform(response.headers)
      }
    };
  }
  async _requestAndRetry(request2, tries = 0) {
    const response = await request2();
    if (response.ok) {
      return response;
    }
    const responseText = await response.clone().text();
    const errorMessage = `Server returned an error:\n` + `  Code: ${response.status} (${response.statusText})\n` + `  Body: ${responseText}\n`;
    if (this._retryTimes > tries) {
      console.warn(errorMessage + `  Retrying request.`);
      return await this._requestAndRetry(request2, tries + 1);
    }
    throw new AgentHTTPResponseError(errorMessage, {
      ok: response.ok,
      status: response.status,
      statusText: response.statusText,
      headers: httpHeadersTransform(response.headers)
    });
  }
  async query(canisterId, fields, identity) {
    const id = await (identity !== undefined ? await identity : await this._identity);
    if (!id) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    const canister = typeof canisterId === "string" ? principal4.Principal.fromText(canisterId) : canisterId;
    const sender = (id === null || id === undefined ? undefined : id.getPrincipal()) || principal4.Principal.anonymous();
    const request2 = {
      request_type: "query",
      canister_id: canister,
      method_name: fields.methodName,
      arg: fields.arg,
      sender,
      ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)
    };
    let transformedRequest = await this._transform({
      request: {
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "read",
      body: request2
    });
    transformedRequest = await (id === null || id === undefined ? undefined : id.transformRequest(transformedRequest));
    const body = encode(transformedRequest.body);
    const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
    const queryResponse = decode(await response.arrayBuffer());
    return Object.assign(Object.assign({}, queryResponse), { httpDetails: {
      ok: response.ok,
      status: response.status,
      statusText: response.statusText,
      headers: httpHeadersTransform(response.headers)
    } });
  }
  async createReadStateRequest(fields, identity) {
    const id = await (identity !== undefined ? await identity : await this._identity);
    if (!id) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    const sender = (id === null || id === undefined ? undefined : id.getPrincipal()) || principal4.Principal.anonymous();
    const transformedRequest = await this._transform({
      request: {
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "read_state",
      body: {
        request_type: "read_state",
        paths: fields.paths,
        sender,
        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)
      }
    });
    return id === null || id === undefined ? undefined : id.transformRequest(transformedRequest);
  }
  async readState(canisterId, fields, identity, request2) {
    const canister = typeof canisterId === "string" ? principal4.Principal.fromText(canisterId) : canisterId;
    const transformedRequest = request2 !== null && request2 !== undefined ? request2 : await this.createReadStateRequest(fields, identity);
    const body = encode(transformedRequest.body);
    const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
    if (!response.ok) {
      throw new Error(`Server returned an error:\n` + `  Code: ${response.status} (${response.statusText})\n` + `  Body: ${await response.text()}\n`);
    }
    return decode(await response.arrayBuffer());
  }
  async syncTime(canisterId) {
    const CanisterStatus = await Promise.resolve().then(() => (init_canisterStatus(), exports_canisterStatus));
    const callTime = Date.now();
    try {
      if (!canisterId) {
        console.log("Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai");
      }
      const status = await CanisterStatus.request({
        canisterId: canisterId !== null && canisterId !== undefined ? canisterId : principal4.Principal.from("ryjl3-tyaaa-aaaaa-aaaba-cai"),
        agent: this,
        paths: ["time"]
      });
      const replicaTime = status.get("time");
      if (replicaTime) {
        this._timeDiffMsecs = Number(replicaTime) - Number(callTime);
      }
    } catch (error) {
      console.error("Caught exception while attempting to sync time:", error);
    }
  }
  async status() {
    const headers = this._credentials ? {
      Authorization: "Basic " + btoa(this._credentials)
    } : {};
    const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/status`, this._host), Object.assign({ headers }, this._fetchOptions)));
    return decode(await response.arrayBuffer());
  }
  async fetchRootKey() {
    if (!this._rootKeyFetched) {
      this.rootKey = (await this.status()).root_key;
      this._rootKeyFetched = true;
    }
    return this.rootKey;
  }
  invalidateIdentity() {
    this._identity = null;
  }
  replaceIdentity(identity) {
    this._identity = Promise.resolve(identity);
  }
  _transform(request2) {
    let p = Promise.resolve(request2);
    for (const fn of this._pipeline) {
      p = p.then((r) => fn(r).then((r2) => r2 || r));
    }
    return p;
  }
}
// node_modules/@dfinity/agent/lib/esm/agent/proxy.js
var principal5 = __toESM(require_cjs(), 1);
var ProxyMessageKind;
(function(ProxyMessageKind2) {
  ProxyMessageKind2["Error"] = "err";
  ProxyMessageKind2["GetPrincipal"] = "gp";
  ProxyMessageKind2["GetPrincipalResponse"] = "gpr";
  ProxyMessageKind2["Query"] = "q";
  ProxyMessageKind2["QueryResponse"] = "qr";
  ProxyMessageKind2["Call"] = "c";
  ProxyMessageKind2["CallResponse"] = "cr";
  ProxyMessageKind2["ReadState"] = "rs";
  ProxyMessageKind2["ReadStateResponse"] = "rsr";
  ProxyMessageKind2["Status"] = "s";
  ProxyMessageKind2["StatusResponse"] = "sr";
})(ProxyMessageKind || (ProxyMessageKind = {}));

// node_modules/@dfinity/agent/lib/esm/agent/index.js
function getDefaultAgent() {
  const agent = typeof window === "undefined" ? typeof global === "undefined" ? typeof self === "undefined" ? undefined : self.ic.agent : global.ic.agent : window.ic.agent;
  if (!agent) {
    throw new Error("No Agent could be found.");
  }
  return agent;
}

// node_modules/@dfinity/agent/lib/esm/actor.js
init_errors();
var candid4 = __toESM(require_cjs2(), 1);

// node_modules/@dfinity/agent/lib/esm/polling/index.js
var exports_polling = {};
__export(exports_polling, {
  strategy: () => {
    {
      return exports_strategy;
    }
  },
  pollForResponse: () => {
    {
      return pollForResponse;
    }
  },
  defaultStrategy: () => {
    {
      return defaultStrategy;
    }
  }
});
init_certificate();
init_buffer();

// node_modules/@dfinity/agent/lib/esm/polling/strategy.js
var exports_strategy = {};
__export(exports_strategy, {
  timeout: () => {
    {
      return timeout;
    }
  },
  throttle: () => {
    {
      return throttle;
    }
  },
  once: () => {
    {
      return once;
    }
  },
  maxAttempts: () => {
    {
      return maxAttempts;
    }
  },
  defaultStrategy: () => {
    {
      return defaultStrategy;
    }
  },
  conditionalDelay: () => {
    {
      return conditionalDelay;
    }
  },
  chain: () => {
    {
      return chain;
    }
  },
  backoff: () => {
    {
      return backoff;
    }
  }
});
init_buffer();
function defaultStrategy() {
  return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));
}
function once() {
  let first = true;
  return async () => {
    if (first) {
      first = false;
      return true;
    }
    return false;
  };
}
function conditionalDelay(condition, timeInMsec) {
  return async (canisterId, requestId, status) => {
    if (await condition(canisterId, requestId, status)) {
      return new Promise((resolve) => setTimeout(resolve, timeInMsec));
    }
  };
}
function maxAttempts(count) {
  let attempts = count;
  return async (canisterId, requestId, status) => {
    if (--attempts <= 0) {
      throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\n` + `  Request ID: ${toHex(requestId)}\n` + `  Request status: ${status}\n`);
    }
  };
}
function throttle(throttleInMsec) {
  return () => new Promise((resolve) => setTimeout(resolve, throttleInMsec));
}
function timeout(timeInMsec) {
  const end = Date.now() + timeInMsec;
  return async (canisterId, requestId, status) => {
    if (Date.now() > end) {
      throw new Error(`Request timed out after ${timeInMsec} msec:\n` + `  Request ID: ${toHex(requestId)}\n` + `  Request status: ${status}\n`);
    }
  };
}
function backoff(startingThrottleInMsec, backoffFactor) {
  let currentThrottling = startingThrottleInMsec;
  return () => new Promise((resolve) => setTimeout(() => {
    currentThrottling *= backoffFactor;
    resolve();
  }, currentThrottling));
}
function chain(...strategies) {
  return async (canisterId, requestId, status) => {
    for (const a of strategies) {
      await a(canisterId, requestId, status);
    }
  };
}
var FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;

// node_modules/@dfinity/agent/lib/esm/polling/index.js
async function pollForResponse(agent2, canisterId, requestId, strategy, request2, blsVerify2) {
  var _a;
  const path = [new TextEncoder().encode("request_status"), requestId];
  const currentRequest = request2 !== null && request2 !== undefined ? request2 : await ((_a = agent2.createReadStateRequest) === null || _a === undefined ? undefined : _a.call(agent2, { paths: [path] }));
  const state = await agent2.readState(canisterId, { paths: [path] }, undefined, currentRequest);
  if (agent2.rootKey == null)
    throw new Error("Agent root key not initialized before polling");
  const cert = await Certificate.create({
    certificate: state.certificate,
    rootKey: agent2.rootKey,
    canisterId,
    blsVerify: blsVerify2
  });
  const maybeBuf = cert.lookup([...path, new TextEncoder().encode("status")]);
  let status;
  if (typeof maybeBuf === "undefined") {
    status = RequestStatusResponseStatus.Unknown;
  } else {
    status = new TextDecoder().decode(maybeBuf);
  }
  switch (status) {
    case RequestStatusResponseStatus.Replied: {
      return cert.lookup([...path, "reply"]);
    }
    case RequestStatusResponseStatus.Received:
    case RequestStatusResponseStatus.Unknown:
    case RequestStatusResponseStatus.Processing:
      await strategy(canisterId, requestId, status);
      return pollForResponse(agent2, canisterId, requestId, strategy, currentRequest);
    case RequestStatusResponseStatus.Rejected: {
      const rejectCode = new Uint8Array(cert.lookup([...path, "reject_code"]))[0];
      const rejectMessage = new TextDecoder().decode(cert.lookup([...path, "reject_message"]));
      throw new Error(`Call was rejected:\n` + `  Request ID: ${toHex(requestId)}\n` + `  Reject code: ${rejectCode}\n` + `  Reject text: ${rejectMessage}\n`);
    }
    case RequestStatusResponseStatus.Done:
      throw new Error(`Call was marked as done but we never saw the reply:\n` + `  Request ID: ${toHex(requestId)}\n`);
  }
  throw new Error("unreachable");
}

// node_modules/@dfinity/agent/lib/esm/actor.js
var principal6 = __toESM(require_cjs(), 1);
init_buffer();

// node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js
var management_idl_default = ({ IDL }) => {
  const canister_id = IDL.Principal;
  const definite_canister_settings = IDL.Record({
    controllers: IDL.Vec(IDL.Principal),
    freezing_threshold: IDL.Nat,
    memory_allocation: IDL.Nat,
    compute_allocation: IDL.Nat
  });
  const canister_settings = IDL.Record({
    controllers: IDL.Opt(IDL.Vec(IDL.Principal)),
    freezing_threshold: IDL.Opt(IDL.Nat),
    memory_allocation: IDL.Opt(IDL.Nat),
    compute_allocation: IDL.Opt(IDL.Nat)
  });
  const wasm_module = IDL.Vec(IDL.Nat8);
  return IDL.Service({
    canister_status: IDL.Func([IDL.Record({ canister_id })], [
      IDL.Record({
        status: IDL.Variant({
          stopped: IDL.Null,
          stopping: IDL.Null,
          running: IDL.Null
        }),
        memory_size: IDL.Nat,
        cycles: IDL.Nat,
        settings: definite_canister_settings,
        module_hash: IDL.Opt(IDL.Vec(IDL.Nat8))
      })
    ], []),
    create_canister: IDL.Func([IDL.Record({ settings: IDL.Opt(canister_settings) })], [IDL.Record({ canister_id })], []),
    delete_canister: IDL.Func([IDL.Record({ canister_id })], [], []),
    deposit_cycles: IDL.Func([IDL.Record({ canister_id })], [], []),
    install_code: IDL.Func([
      IDL.Record({
        arg: IDL.Vec(IDL.Nat8),
        wasm_module,
        mode: IDL.Variant({
          reinstall: IDL.Null,
          upgrade: IDL.Null,
          install: IDL.Null
        }),
        canister_id
      })
    ], [], []),
    provisional_create_canister_with_cycles: IDL.Func([
      IDL.Record({
        settings: IDL.Opt(canister_settings),
        amount: IDL.Opt(IDL.Nat)
      })
    ], [IDL.Record({ canister_id })], []),
    provisional_top_up_canister: IDL.Func([IDL.Record({ canister_id, amount: IDL.Nat })], [], []),
    raw_rand: IDL.Func([], [IDL.Vec(IDL.Nat8)], []),
    start_canister: IDL.Func([IDL.Record({ canister_id })], [], []),
    stop_canister: IDL.Func([IDL.Record({ canister_id })], [], []),
    uninstall_code: IDL.Func([IDL.Record({ canister_id })], [], []),
    update_settings: IDL.Func([
      IDL.Record({
        canister_id: IDL.Principal,
        settings: canister_settings
      })
    ], [], [])
  });
};

// node_modules/@dfinity/agent/lib/esm/actor.js
var decodeReturnValue = function(types3, msg) {
  const returnValues = candid4.IDL.decode(types3, $Buffer.from(msg));
  switch (returnValues.length) {
    case 0:
      return;
    case 1:
      return returnValues[0];
    default:
      return returnValues;
  }
};
var _createActorMethod = function(actor, methodName, func, blsVerify2) {
  let caller;
  if (func.annotations.includes("query") || func.annotations.includes("composite_query")) {
    caller = async (options, ...args) => {
      var _a, _b;
      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === undefined ? undefined : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
      const agent3 = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();
      const cid = principal6.Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);
      const arg = candid4.IDL.encode(func.argTypes, args);
      const result = await agent3.query(cid, { methodName, arg });
      switch (result.status) {
        case "rejected":
          throw new QueryCallRejectedError(cid, methodName, result);
        case "replied":
          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS) ? {
            httpDetails: result.httpDetails,
            result: decodeReturnValue(func.retTypes, result.reply.arg)
          } : decodeReturnValue(func.retTypes, result.reply.arg);
      }
    };
  } else {
    caller = async (options, ...args) => {
      var _a, _b;
      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === undefined ? undefined : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
      const agent3 = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();
      const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);
      const cid = principal6.Principal.from(canisterId);
      const ecid = effectiveCanisterId !== undefined ? principal6.Principal.from(effectiveCanisterId) : cid;
      const arg = candid4.IDL.encode(func.argTypes, args);
      const { requestId, response } = await agent3.call(cid, {
        methodName,
        arg,
        effectiveCanisterId: ecid
      });
      if (!response.ok || response.body) {
        throw new UpdateCallRejectedError(cid, methodName, requestId, response);
      }
      const pollStrategy = pollingStrategyFactory();
      const responseBytes = await pollForResponse(agent3, ecid, requestId, pollStrategy, blsVerify2);
      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);
      if (responseBytes !== undefined) {
        return shouldIncludeHttpDetails ? {
          httpDetails: response,
          result: decodeReturnValue(func.retTypes, responseBytes)
        } : decodeReturnValue(func.retTypes, responseBytes);
      } else if (func.retTypes.length === 0) {
        return shouldIncludeHttpDetails ? {
          httpDetails: response,
          result: undefined
        } : undefined;
      } else {
        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(",")}].`);
      }
    };
  }
  const handler = (...args) => caller({}, ...args);
  handler.withOptions = (options) => (...args) => caller(options, ...args);
  return handler;
};
function getManagementCanister(config) {
  function transform(_methodName, args, _callConfig) {
    const first = args[0];
    let effectiveCanisterId = principal6.Principal.fromHex("");
    if (first && typeof first === "object" && first.canister_id) {
      effectiveCanisterId = principal6.Principal.from(first.canister_id);
    }
    return { effectiveCanisterId };
  }
  return Actor.createActor(management_idl_default, Object.assign(Object.assign(Object.assign({}, config), { canisterId: principal6.Principal.fromHex("") }), {
    callTransform: transform,
    queryTransform: transform
  }));
}

class ActorCallError extends AgentError {
  constructor(canisterId, methodName, type, props) {
    super([
      `Call failed:`,
      `  Canister: ${canisterId.toText()}`,
      `  Method: ${methodName} (${type})`,
      ...Object.getOwnPropertyNames(props).map((n) => `  "${n}": ${JSON.stringify(props[n])}`)
    ].join("\n"));
    this.canisterId = canisterId;
    this.methodName = methodName;
    this.type = type;
    this.props = props;
  }
}

class QueryCallRejectedError extends ActorCallError {
  constructor(canisterId, methodName, result) {
    var _a;
    super(canisterId, methodName, "query", {
      Status: result.status,
      Code: (_a = ReplicaRejectCode[result.reject_code]) !== null && _a !== undefined ? _a : `Unknown Code "${result.reject_code}"`,
      Message: result.reject_message
    });
    this.result = result;
  }
}

class UpdateCallRejectedError extends ActorCallError {
  constructor(canisterId, methodName, requestId, response) {
    super(canisterId, methodName, "update", Object.assign({ "Request ID": toHex(requestId) }, response.body ? Object.assign(Object.assign({}, response.body.error_code ? {
      "Error code": response.body.error_code
    } : {}), { "Reject code": String(response.body.reject_code), "Reject message": response.body.reject_message }) : {
      "HTTP status code": response.status.toString(),
      "HTTP status text": response.statusText
    }));
    this.requestId = requestId;
    this.response = response;
  }
}
var CanisterInstallMode;
(function(CanisterInstallMode2) {
  CanisterInstallMode2["Install"] = "install";
  CanisterInstallMode2["Reinstall"] = "reinstall";
  CanisterInstallMode2["Upgrade"] = "upgrade";
})(CanisterInstallMode || (CanisterInstallMode = {}));
var metadataSymbol = Symbol.for("ic-agent-metadata");

class Actor {
  constructor(metadata) {
    this[metadataSymbol] = Object.freeze(metadata);
  }
  static agentOf(actor) {
    return actor[metadataSymbol].config.agent;
  }
  static interfaceOf(actor) {
    return actor[metadataSymbol].service;
  }
  static canisterIdOf(actor) {
    return principal6.Principal.from(actor[metadataSymbol].config.canisterId);
  }
  static async install(fields, config) {
    const mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode;
    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];
    const wasmModule = [...new Uint8Array(fields.module)];
    const canisterId = typeof config.canisterId === "string" ? principal6.Principal.fromText(config.canisterId) : config.canisterId;
    await getManagementCanister(config).install_code({
      mode: { [mode]: null },
      arg,
      wasm_module: wasmModule,
      canister_id: canisterId
    });
  }
  static async createCanister(config) {
    const { canister_id: canisterId } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({ amount: [], settings: [] });
    return canisterId;
  }
  static async createAndInstallCanister(interfaceFactory, fields, config) {
    const canisterId = await this.createCanister(config);
    await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));
    return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));
  }
  static createActorClass(interfaceFactory, options) {
    const service = interfaceFactory({ IDL: candid4.IDL });

    class CanisterActor extends Actor {
      constructor(config) {
        const canisterId = typeof config.canisterId === "string" ? principal6.Principal.fromText(config.canisterId) : config.canisterId;
        super({
          config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId }),
          service
        });
        for (const [methodName, func] of service._fields) {
          if (options === null || options === undefined ? undefined : options.httpDetails) {
            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);
          }
          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);
        }
      }
    }
    return CanisterActor;
  }
  static createActor(interfaceFactory, configuration) {
    return new (this.createActorClass(interfaceFactory))(configuration);
  }
  static createActorWithHttpDetails(interfaceFactory, configuration) {
    return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(configuration);
  }
}
var DEFAULT_ACTOR_CONFIG = {
  pollingStrategyFactory: exports_strategy.defaultStrategy
};
var ACTOR_METHOD_WITH_HTTP_DETAILS = "http-details";

// node_modules/@dfinity/agent/lib/esm/index.js
init_certificate();

// node_modules/@dfinity/agent/lib/esm/fetch_candid.js
var principal7 = __toESM(require_cjs(), 1);
init_canisterStatus();

// node_modules/@dfinity/agent/lib/esm/index.js
init_request_id();
init_bls2();
init_buffer();
init_canisterStatus();
init_cbor();

// node_modules/@research-ag/hpl-client/dist/esm/chunk-56QVBPN4.js
async function lt(t2, r) {
  let e = new HttpAgent({ host: t2 == "ic" ? "https://ic0.app" : "http://127.0.0.1:4943", ...r });
  return t2 === "local" && await e.fetchRootKey(), e;
}
var principal11 = __toESM(require_cjs(), 1);
var Qt = function(t2) {
  let r = 500, e = null, o = t2.message.split(`
`).map((i) => i.trim().toLowerCase()).find((i) => i.startsWith("code:") || i.startsWith("http status code:")), n = t2.message.split(`
`).map((i) => i.trim()).find((i) => i.startsWith('"Code": "'));
  if (o) {
    let i = o.split(":");
    if (i && i.length > 1) {
      let a = i[1].trim(), s2 = a.split(" ");
      s2 && s2.length > 1 && (a = s2[0].trim()), r = parseInt(a, 10), isNaN(r) && (r = 500);
    }
  }
  return n && (e = n.split('"')[3]), [r, e];
};
var Lt = function(t2) {
  let r = [];
  return t2.forEach((e, o) => {
    r.push([o, e]);
  }), r;
};
var At = function(t2, r) {
  let e = candid5.IDL.decode(t2, Buffer.from(r));
  switch (e.length) {
    case 0:
      return;
    case 1:
      return e[0];
    default:
      return e;
  }
};
var A = function(t2, r) {
  if (typeof r != "function" && r !== null)
    throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
  D(t2, r);
  function e() {
    this.constructor = t2;
  }
  t2.prototype = r === null ? Object.create(r) : (e.prototype = r.prototype, new e);
};
var N = function(t2) {
  var r = typeof Symbol == "function" && Symbol.iterator, e = r && t2[r], o = 0;
  if (e)
    return e.call(t2);
  if (t2 && typeof t2.length == "number")
    return { next: function() {
      return t2 && o >= t2.length && (t2 = undefined), { value: t2 && t2[o++], done: !t2 };
    } };
  throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var T = function(t2, r) {
  var e = typeof Symbol == "function" && t2[Symbol.iterator];
  if (!e)
    return t2;
  var o = e.call(t2), n, i = [], a;
  try {
    for (;(r === undefined || r-- > 0) && !(n = o.next()).done; )
      i.push(n.value);
  } catch (s2) {
    a = { error: s2 };
  } finally {
    try {
      n && !n.done && (e = o.return) && e.call(o);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return i;
};
var P = function(t2, r, e) {
  if (e || arguments.length === 2)
    for (var o = 0, n = r.length, i;o < n; o++)
      (i || !(o in r)) && (i || (i = Array.prototype.slice.call(r, 0, o)), i[o] = r[o]);
  return t2.concat(i || Array.prototype.slice.call(r));
};
var h = function(t2) {
  return typeof t2 == "function";
};
var G = function(t2) {
  var r = function(o) {
    Error.call(o), o.stack = new Error().stack;
  }, e = t2(r);
  return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e;
};
var F = function(t2, r) {
  if (t2) {
    var e = t2.indexOf(r);
    0 <= e && t2.splice(e, 1);
  }
};
var z = function(t2) {
  return t2 instanceof _ || t2 && ("closed" in t2) && h(t2.remove) && h(t2.add) && h(t2.unsubscribe);
};
var Pt = function(t2) {
  h(t2) ? t2() : t2.unsubscribe();
};
var _t = function(t2) {
  R.setTimeout(function() {
    var r = g.onUnhandledError;
    if (r)
      r(t2);
    else
      throw t2;
  });
};
var et = function() {
};
var Et = function(t2) {
  return rt("E", undefined, t2);
};
var Ot = function(t2) {
  return rt("N", t2, undefined);
};
var rt = function(t2, r, e) {
  return { kind: t2, value: r, error: e };
};
var E = function(t2) {
  if (g.useDeprecatedSynchronousErrorHandling) {
    var r = !S;
    if (r && (S = { errorThrown: false, error: null }), t2(), r) {
      var e = S, o = e.errorThrown, n = e.error;
      if (S = null, o)
        throw n;
    }
  } else
    t2();
};
var Vt = function(t2) {
  g.useDeprecatedSynchronousErrorHandling && S && (S.errorThrown = true, S.error = t2);
};
var ot = function(t2, r) {
  return oe.call(t2, r);
};
var Y = function(t2) {
  g.useDeprecatedSynchronousErrorHandling ? Vt(t2) : _t(t2);
};
var ie = function(t2) {
  throw t2;
};
var nt = function(t2, r) {
  var e = g.onStoppedNotification;
  e && R.setTimeout(function() {
    return e(t2, r);
  });
};
var Ft = function(t2) {
  return t2;
};
var qt = function(t2) {
  return t2.length === 0 ? Ft : t2.length === 1 ? t2[0] : function(e) {
    return t2.reduce(function(o, n) {
      return n(o);
    }, e);
  };
};
var Ct = function(t2) {
  var r;
  return (r = t2 ?? g.Promise) !== null && r !== undefined ? r : Promise;
};
var se = function(t2) {
  return t2 && h(t2.next) && h(t2.error) && h(t2.complete);
};
var ce = function(t2) {
  return t2 && t2 instanceof q || se(t2) && z(t2);
};
var ue = function(t2) {
  return h(t2?.lift);
};
var K = function(t2) {
  return function(r) {
    if (ue(r))
      return r.lift(function(e) {
        try {
          return t2(e, this);
        } catch (o) {
          this.error(o);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
};
var kt = function(t2, r, e, o, n) {
  return new pe(t2, r, e, o, n);
};
var at = function(t2) {
  return K(function(r, e) {
    try {
      r.subscribe(e);
    } finally {
      e.add(t2);
    }
  });
};
var st = function(t2, r) {
  return r === undefined && (r = false), K(function(e, o) {
    var n = 0;
    e.subscribe(kt(o, function(i) {
      var a = t2(i, n++);
      (a || r) && o.next(i), !a && o.complete();
    }));
  });
};
var pt = ({ IDL: t2 }) => {
  let r = t2.Tuple(t2.Nat, t2.Opt(t2.Nat)), e = t2.Variant({ id: t2.Nat, cat: t2.Vec(t2.Variant({ id: t2.Nat, idRange: r })), idRange: r }), o = t2.Nat, n = t2.Nat, i = t2.Variant({ ft: n }), a = t2.Nat, s2 = t2.Variant({ ft: t2.Nat }), c = t2.Nat64, u = t2.Tuple(t2.Principal, t2.Nat), p = t2.Variant({ id: u, cat: t2.Vec(t2.Variant({ id: u })) }), f = t2.Nat, l = t2.Tuple(t2.Nat, t2.Nat), m = t2.Variant({ DeletedVirtualAccount: t2.Null, InvalidArguments: t2.Text, InsufficientFunds: t2.Null }), y2 = t2.Variant({ ftTransfer: m }), d = t2.Variant({ ftTransfer: t2.Record({ fee: t2.Nat, amount: t2.Nat }) }), $ = t2.Variant({ failure: y2, success: d }), w = t2.Variant({ dropped: t2.Record({}), awaited: t2.Record({}), processed: t2.Tuple(t2.Opt($)) });
  return t2.Service({ accountInfo: t2.Func([e], [t2.Vec(t2.Tuple(o, i))], ["query"]), aggregatorPrincipal: t2.Func([t2.Nat], [t2.Variant({ ok: t2.Principal, err: t2.Variant({ NotFound: t2.Null }) })], ["query"]), aggregators: t2.Func([], [t2.Vec(t2.Tuple(t2.Principal, t2.Nat))], ["query"]), createFungibleToken: t2.Func([t2.Nat8, t2.Text], [t2.Variant({ ok: n, err: t2.Variant({ NoSpace: t2.Null, FeeError: t2.Null }) })], []), deleteVirtualAccount: t2.Func([a], [t2.Variant({ ok: t2.Variant({ ft: t2.Nat }), err: t2.Variant({ DeletedVirtualAccount: t2.Null, InvalidArguments: t2.Text }) })], []), ftInfo: t2.Func([e], [t2.Vec(t2.Tuple(n, t2.Record({ controller: t2.Principal, decimals: t2.Nat8, description: t2.Text })))], ["query"]), nAccounts: t2.Func([], [t2.Nat], ["query"]), nFtAssets: t2.Func([], [t2.Nat], ["query"]), nStreams: t2.Func([], [t2.Nat], ["query"]), nVirtualAccounts: t2.Func([], [t2.Nat], ["query"]), openAccounts: t2.Func([t2.Nat, i], [t2.Variant({ ok: t2.Record({ first: o }), err: t2.Variant({ InvalidArguments: t2.Text, NoSpaceForPrincipal: t2.Null, NoSpaceForSubaccount: t2.Null }) })], []), openVirtualAccount: t2.Func([i, t2.Principal, s2, o, c], [t2.Variant({ ok: t2.Record({ id: a }), err: t2.Variant({ InvalidArguments: t2.Text, NoSpaceForAccount: t2.Null }) })], []), state: t2.Func([t2.Record({ ftSupplies: t2.Opt(e), virtualAccounts: t2.Opt(e), accounts: t2.Opt(e), remoteAccounts: t2.Opt(p) })], [t2.Record({ ftSupplies: t2.Vec(t2.Tuple(n, f)), virtualAccounts: t2.Vec(t2.Tuple(a, t2.Opt(t2.Tuple(s2, o, c)))), accounts: t2.Vec(t2.Tuple(o, s2)), remoteAccounts: t2.Vec(t2.Tuple(u, t2.Opt(t2.Tuple(s2, c)))) })], ["query"]), streamStatus: t2.Func([e], [t2.Vec(t2.Tuple(t2.Nat, t2.Record({ closed: t2.Bool, source: t2.Variant({ internal: t2.Null, aggregator: t2.Principal }), length: t2.Nat, lastActive: c })))], ["query"]), txStatus: t2.Func([t2.Vec(l)], [t2.Vec(w)], ["query"]), updateVirtualAccount: t2.Func([a, t2.Record({ backingAccount: t2.Opt(o), state: t2.Opt(t2.Variant({ ft_dec: t2.Nat, ft_inc: t2.Nat, ft_set: t2.Nat })), expiration: t2.Opt(c) })], [t2.Variant({ ok: t2.Variant({ ft: t2.Tuple(t2.Nat, t2.Int) }), err: t2.Variant({ DeletedVirtualAccount: t2.Null, InvalidArguments: t2.Text, InsufficientFunds: t2.Null }) })], []), virtualAccountInfo: t2.Func([e], [t2.Vec(t2.Tuple(a, t2.Opt(t2.Tuple(i, t2.Principal))))], ["query"]) });
};
var ft = async (t2, r, e) => {
  let o = await lt(e, { retryTimes: 5 });
  return Actor.createActor(r, { agent: o, canisterId: t2 });
};
var X = async (t2, ...r) => {
  try {
    return await t2(...r);
  } catch (e) {
    if (e.props?.Code) {
      let o = e.props.Message, n = null;
      throw e.props.Code == "CanisterError" && (n = /trapped explicitly:\s(.+)/gi.exec(o)), new y({ [e.props.Code]: n ? n[1] : o });
    } else if (e.message.startsWith("Call was rejected:")) {
      let o = /Reject\scode:\s(\d+)/gi.exec(e.message);
      if (o) {
        let n = ReplicaRejectCode[+o[1]], i = null;
        throw n == "CanisterError" && (i = /trapped explicitly:\s(.+)/gi.exec(e.message)), i || (i = /Reject text:\s(.+)/gi.exec(e.message)), new y({ [n]: i ? i[1] : e.message });
      }
    }
    throw e;
  }
};
var V = (t2) => new Promise((r) => setTimeout(r, t2));
var It = 100;
var Kt = 5;
var mt = async (t2, r, ...e) => {
  try {
    return await t2(...e);
  } catch (o) {
    let [n, i] = Qt(o);
    if (![401, 403].includes(n) && (!i || !["CanisterReject", "CanisterError"].includes(i)) && r < Kt) {
      let a = It * Math.pow(2, r);
      return await V(a), mt(t2, r + 1, ...e);
    } else
      throw o;
  }
};
var dt = async (t2, ...r) => mt(t2, 0, ...r);
var yt = async (t2) => b(await t2);
var b = (t2) => t2.length > 0 ? t2[0] : null;
var C = async (t2) => {
  let r = await t2;
  if (r.err)
    throw new y(r.err);
  return r.ok;
};
var bt = 5 * 60 * 1000;
var k = class extends HttpAgent {
  async prepareRequest(r, e, o) {
    let n = await (o !== undefined ? await o : await this._identity);
    if (!n)
      throw new Error("This identity has expired due this application's security policy. Please refresh your authentication.");
    let i = principal11.Principal.from(r), a = e.effectiveCanisterId ? principal11.Principal.from(e.effectiveCanisterId) : i, s2 = n.getPrincipal() || principal11.Principal.anonymous(), c = new Expiry(bt);
    Math.abs(this._timeDiffMsecs) > 1000 * 30 && (c = new Expiry(bt + this._timeDiffMsecs));
    let u = { request_type: SubmitRequestType.Call, canister_id: i, method_name: e.methodName, arg: e.arg, sender: s2, ingress_expiry: c }, p = await this._transform({ request: { body: null, method: "POST", headers: { "Content-Type": "application/cbor", ...this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {} } }, endpoint: "call", body: u });
    p = await n.transformRequest(p);
    let f = exports_cbor.encode(p.body), l = await requestIdOf(u);
    return { requestId: l, call: async () => {
      let m = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${a.toText()}/call`, this._host), { ...this._callOptions, ...p.request, body: f })), y2 = await m.arrayBuffer(), d = m.status === 200 && y2.byteLength > 0 ? exports_cbor.decode(y2) : null;
      return { requestId: l, response: { ok: m.ok, status: m.status, statusText: m.statusText, body: d, headers: Lt(m.headers) } };
    } };
  }
};
var x = class {
  constructor(r, e, o) {
    this.idl = r;
    this._canisterPrincipal = e;
    this.network = o;
    this._canisterPromise = ft(e, r, o).then((n) => (this._service = n, n));
  }
  get canisterPrincipal() {
    return this._canisterPrincipal instanceof principal10.Principal ? this._canisterPrincipal : principal10.Principal.fromText(this._canisterPrincipal);
  }
  _service = null;
  _canisterPromise;
  get service() {
    return this._service ? Promise.resolve(this._service) : this._canisterPromise;
  }
  get agent() {
    return this.service.then((r) => Actor.agentOf(r));
  }
  wrapCall(r, e, ...o) {
    return e.length ? e.pop()((...n) => this.wrapCall(r, e, ...o), ...o) : r(...o);
  }
  query(r, ...e) {
    return this.wrapCall(r, [dt, X], ...e);
  }
  optQuery(r, ...e) {
    return yt(this.query(r, ...e));
  }
  update(r, ...e) {
    return this.wrapCall(r, [X], ...e);
  }
  resUpdate(r, ...e) {
    return C(this.query(r, ...e));
  }
  async getFunction(r) {
    let e = await this.service, [o, n] = e[Symbol.for("ic-agent-metadata")].service._fields.find((i) => i[0] === r) || [];
    return n;
  }
  async parseResponse(r, e, o) {
    let n = await this.getFunction(r);
    if (!n)
      throw new Error(`Function "${r} not found!`);
    let i = n.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);
    if (e !== undefined)
      return i ? { httpDetails: o, result: At(n.retTypes, e) } : At(n.retTypes, e);
    if (n.retTypes.length === 0)
      return i ? { httpDetails: o, result: undefined } : undefined;
    throw new Error(`Call was returned undefined, but type [${n.retTypes.join(",")}].`);
  }
  async prepareUpdateRequest(r, ...e) {
    let o = await this.getFunction(r);
    if (!o)
      throw new Error(`Function "${r} not found!`);
    let i = (await this.service)[Symbol.for("ic-agent-metadata")].config, { canisterId: a, effectiveCanisterId: s2, pollingStrategyFactory: c, blsVerify: u } = i, p = principal10.Principal.from(a), f = s2 !== undefined ? principal10.Principal.from(s2) : p, l = candid5.IDL.encode(o.argTypes, e), m = await this.agent, y2 = new k({ host: this.network == "ic" ? "https://ic0.app" : "http://127.0.0.1:4943", identity: (m || {})._identity || new AnonymousIdentity });
    this.network === "local" && await y2.fetchRootKey();
    let { requestId: d, call: $ } = await y2.prepareRequest(p, { methodName: r, arg: l, effectiveCanisterId: f });
    return { requestId: d, call: async () => {
      let { response: w } = await $();
      if (!w.ok || w.body)
        throw new UpdateCallRejectedError(p, r, d, w);
      let ut = (c || exports_polling.defaultStrategy)(), Gt = await exports_polling.pollForResponse(y2, f, d, ut, null, u);
      return this.parseResponse(r, Gt, w);
    } };
  }
};
var L = (t2) => ({ type: "ft", balance: t2.ft });
var U = (t2) => ({ type: "ft", assetId: t2.ft });
var M = (t2) => ({ ftSupplies: t2.ftSupplies, virtualAccounts: t2.virtualAccounts.map(([r, e]) => [r, b(e) && { state: L(b(e)[0]), backingSubaccountId: b(e)[1], expiration: b(e)[2] }]), accounts: t2.accounts.map(([r, e]) => [r, L(e)]), remoteAccounts: t2.remoteAccounts.map(([r, e]) => [r, b(e) && { state: L(b(e)[0]), expiration: b(e)[1] }]) });
var B = class extends x {
  constructor(e, o) {
    super(pt, e, o);
    this._canisterPrincipal = e;
  }
  async accountInfo(e) {
    return (await this.query((await this.service).accountInfo, e)).map(([o, n]) => [o, U(n)]);
  }
  async nAccounts() {
    return this.query((await this.service).nAccounts);
  }
  async nVirtualAccounts() {
    return this.query((await this.service).nVirtualAccounts);
  }
  async virtualAccountInfo(e) {
    return (await this.query((await this.service).virtualAccountInfo, e)).map(([n, i]) => [n, i[0] ? { type: "ft", assetId: i[0][0].ft, accessPrincipal: i[0][1] } : null]);
  }
  async createFungibleToken(e, o) {
    return this.resUpdate((await this.service).createFungibleToken, e, o);
  }
  async openAccounts(e, o) {
    return this.resUpdate((await this.service).openAccounts, BigInt(o), e);
  }
  async openVirtualAccount(e, o, n, i, a) {
    return this.resUpdate((await this.service).openVirtualAccount, { [e.type]: e.assetId }, o instanceof principal9.Principal ? o : principal9.Principal.fromText(o), { [n.type]: n.balance }, i, BigInt(a || 0) * BigInt(1e6));
  }
  async updateVirtualAccount(e, o) {
    let n = await this.resUpdate((await this.service).updateVirtualAccount, e, { backingAccount: o.backingAccount || o.backingAccount === BigInt(0) ? [o.backingAccount] : [], state: o.state ? [o.state] : [], expiration: o.expiration || o.expiration === 0 ? [BigInt(o.expiration) * BigInt(1e6)] : [] });
    return { type: "ft", balance: n.ft[0], delta: n.ft[1] };
  }
  async deleteVirtualAccount(e) {
    return { type: "ft", balance: (await this.resUpdate((await this.service).deleteVirtualAccount, e)).ft };
  }
  async txStatus(e) {
    return (await this.query((await this.service).txStatus, e)).map((n) => {
      let [i, a] = s(n);
      return i === "awaited" ? { status: i, aggregator: a[0] } : i === "processed" ? { status: i, result: a[0] || null } : { status: i };
    });
  }
  async singleTxStatus(e) {
    return (await this.txStatus([e]))[0];
  }
  async nFtAssets() {
    return this.query((await this.service).nFtAssets);
  }
  async ftInfo(e) {
    return this.query((await this.service).ftInfo, e);
  }
  async aggregators() {
    return (await this.query((await this.service).aggregators)).map(([o, n]) => ({ principal: o, priority: Number(n) }));
  }
  async aggregatorPrincipal(e) {
    return C(this.query((await this.service).aggregatorPrincipal, e));
  }
  async nStreams() {
    return this.query((await this.service).nStreams);
  }
  async streamStatus(e) {
    return (await this.query((await this.service).streamStatus, e)).map(([n, i]) => {
      let [a, s2] = s(i.source), c = { type: a };
      return a === "aggregator" && (c.principal = s2), [n, { ...i, source: c }];
    });
  }
  async state(e) {
    return M(await this.query((await this.service).state, { ftSupplies: e.ftSupplies ? [e.ftSupplies] : [], virtualAccounts: e.virtualAccounts ? [e.virtualAccounts] : [], accounts: e.accounts ? [e.accounts] : [], remoteAccounts: e.remoteAccounts ? [e.remoteAccounts] : [] }));
  }
};
var wt = ({ IDL: t2 }) => {
  let r = t2.Tuple(t2.Nat, t2.Opt(t2.Nat)), e = t2.Variant({ id: t2.Nat, cat: t2.Vec(t2.Variant({ id: t2.Nat, idRange: r })), idRange: r }), o = t2.Nat, n = t2.Nat, i = t2.Variant({ ft: n }), a = t2.Tuple(t2.Principal, t2.Nat), s2 = t2.Variant({ id: a, cat: t2.Vec(t2.Variant({ id: a })) }), c = t2.Nat, u = t2.Nat, p = t2.Variant({ ft: t2.Nat }), f = t2.Nat64;
  return t2.Service({ adminAccountInfo: t2.Func([e], [t2.Vec(t2.Tuple(o, i))], ["query"]), adminState: t2.Func([t2.Record({ ftSupplies: t2.Opt(e), virtualAccounts: t2.Opt(e), accounts: t2.Opt(e), remoteAccounts: t2.Opt(s2) })], [t2.Record({ ftSupplies: t2.Vec(t2.Tuple(n, c)), virtualAccounts: t2.Vec(t2.Tuple(u, t2.Opt(t2.Tuple(p, o, f)))), accounts: t2.Vec(t2.Tuple(o, p)), remoteAccounts: t2.Vec(t2.Tuple(a, t2.Opt(t2.Tuple(p, f)))) })], ["query"]), nAdminAccounts: t2.Func([], [t2.Nat], ["query"]) });
};
var W = class extends x {
  constructor(e, o) {
    super(wt, e, o);
    this._canisterPrincipal = e;
  }
  async accountInfo(e) {
    return (await this.query((await this.service).adminAccountInfo, e)).map(([o, n]) => [o, U(n)]);
  }
  async nAccounts() {
    return this.query((await this.service).nAdminAccounts);
  }
  async state(e) {
    return M(await this.query((await this.service).adminState, { ftSupplies: e.ftSupplies ? [e.ftSupplies] : [], virtualAccounts: e.virtualAccounts ? [e.virtualAccounts] : [], accounts: e.accounts ? [e.accounts] : [], remoteAccounts: e.remoteAccounts ? [e.remoteAccounts] : [] }));
  }
};
var Tt = ({ IDL: t2 }) => {
  let r = t2.Record({ id: t2.Nat, sent: t2.Nat, length: t2.Nat, received: t2.Nat }), e = t2.Variant({ sub: t2.Nat, vir: t2.Tuple(t2.Principal, t2.Nat), mint: t2.Null }), o = t2.Nat, n = t2.Record({ to: e, asset: o, from: e, memo: t2.Vec(t2.Vec(t2.Nat8)), amount: t2.Variant({ max: t2.Null, amount: t2.Nat }) }), i = t2.Variant({ ftTransfer: n }), a = t2.Tuple(t2.Nat, t2.Nat), s2 = t2.Nat64, c = t2.Variant({ pending: t2.Record({}), other: t2.Tuple(s2, t2.Variant({ settled: t2.Null, settledIfIssuedHere: t2.Null })), queued: t2.Tuple(t2.Nat) });
  return t2.Service({ streamStatus: t2.Func([], [t2.Vec(r)], ["query"]), submitAndExecute: t2.Func([t2.Vec(i)], [t2.Vec(a)], []), txStatus: t2.Func([t2.Vec(a)], [t2.Vec(c)], ["query"]) });
};
var H = class extends x {
  constructor(e, o) {
    super(Tt, e, o);
    this._canisterPrincipal = e;
  }
  async submitAndExecute(e) {
    return this.update((await this.service).submitAndExecute, e);
  }
  async singleSubmitAndExecute(e) {
    return (await this.update((await this.service).submitAndExecute, [e]))[0];
  }
  async txStatus(e) {
    return (await this.query((await this.service).txStatus, e)).map((n) => {
      let [i, a] = s(n);
      return i === "queued" ? { status: i, queueNumber: a[0] } : i === "other" ? { status: i, lastLedgerTimestamp: a[0] } : { status: i };
    });
  }
  async singleTxStatus(e) {
    return (await this.txStatus([e]))[0];
  }
  async streamStatus() {
    return (await this.service).streamStatus();
  }
};
var D = function(t2, r) {
  return D = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var n in o)
      Object.prototype.hasOwnProperty.call(o, n) && (e[n] = o[n]);
  }, D(t2, r);
};
var J = G(function(t2) {
  return function(e) {
    t2(this), this.message = e ? e.length + ` errors occurred during unsubscription:
` + e.map(function(o, n) {
      return n + 1 + ") " + o.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = e;
  };
});
var _ = function() {
  function t2(r) {
    this.initialTeardown = r, this.closed = false, this._parentage = null, this._finalizers = null;
  }
  return t2.prototype.unsubscribe = function() {
    var r, e, o, n, i;
    if (!this.closed) {
      this.closed = true;
      var a = this._parentage;
      if (a)
        if (this._parentage = null, Array.isArray(a))
          try {
            for (var s2 = N(a), c = s2.next();!c.done; c = s2.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (d) {
            r = { error: d };
          } finally {
            try {
              c && !c.done && (e = s2.return) && e.call(s2);
            } finally {
              if (r)
                throw r.error;
            }
          }
        else
          a.remove(this);
      var p = this.initialTeardown;
      if (h(p))
        try {
          p();
        } catch (d) {
          i = d instanceof J ? d.errors : [d];
        }
      var f = this._finalizers;
      if (f) {
        this._finalizers = null;
        try {
          for (var l = N(f), m = l.next();!m.done; m = l.next()) {
            var y2 = m.value;
            try {
              Pt(y2);
            } catch (d) {
              i = i ?? [], d instanceof J ? i = P(P([], T(i)), T(d.errors)) : i.push(d);
            }
          }
        } catch (d) {
          o = { error: d };
        } finally {
          try {
            m && !m.done && (n = l.return) && n.call(l);
          } finally {
            if (o)
              throw o.error;
          }
        }
      }
      if (i)
        throw new J(i);
    }
  }, t2.prototype.add = function(r) {
    var e;
    if (r && r !== this)
      if (this.closed)
        Pt(r);
      else {
        if (r instanceof t2) {
          if (r.closed || r._hasParent(this))
            return;
          r._addParent(this);
        }
        (this._finalizers = (e = this._finalizers) !== null && e !== undefined ? e : []).push(r);
      }
  }, t2.prototype._hasParent = function(r) {
    var e = this._parentage;
    return e === r || Array.isArray(e) && e.includes(r);
  }, t2.prototype._addParent = function(r) {
    var e = this._parentage;
    this._parentage = Array.isArray(e) ? (e.push(r), e) : e ? [e, r] : r;
  }, t2.prototype._removeParent = function(r) {
    var e = this._parentage;
    e === r ? this._parentage = null : Array.isArray(e) && F(e, r);
  }, t2.prototype.remove = function(r) {
    var e = this._finalizers;
    e && F(e, r), r instanceof t2 && r._removeParent(this);
  }, t2.EMPTY = function() {
    var r = new t2;
    return r.closed = true, r;
  }(), t2;
}();
var tt = _.EMPTY;
var g = { onUnhandledError: null, onStoppedNotification: null, Promise: undefined, useDeprecatedSynchronousErrorHandling: false, useDeprecatedNextContext: false };
var R = { setTimeout: function(t2, r) {
  for (var e = [], o = 2;o < arguments.length; o++)
    e[o - 2] = arguments[o];
  var n = R.delegate;
  return n?.setTimeout ? n.setTimeout.apply(n, P([t2, r], T(e))) : setTimeout.apply(undefined, P([t2, r], T(e)));
}, clearTimeout: function(t2) {
  var r = R.delegate;
  return (r?.clearTimeout || clearTimeout)(t2);
}, delegate: undefined };
var Rt = function() {
  return rt("C", undefined, undefined);
}();
var S = null;
var q = function(t2) {
  A(r, t2);
  function r(e) {
    var o = t2.call(this) || this;
    return o.isStopped = false, e ? (o.destination = e, z(e) && e.add(o)) : o.destination = ae, o;
  }
  return r.create = function(e, o, n) {
    return new I(e, o, n);
  }, r.prototype.next = function(e) {
    this.isStopped ? nt(Ot(e), this) : this._next(e);
  }, r.prototype.error = function(e) {
    this.isStopped ? nt(Et(e), this) : (this.isStopped = true, this._error(e));
  }, r.prototype.complete = function() {
    this.isStopped ? nt(Rt, this) : (this.isStopped = true, this._complete());
  }, r.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = true, t2.prototype.unsubscribe.call(this), this.destination = null);
  }, r.prototype._next = function(e) {
    this.destination.next(e);
  }, r.prototype._error = function(e) {
    try {
      this.destination.error(e);
    } finally {
      this.unsubscribe();
    }
  }, r.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, r;
}(_);
var oe = Function.prototype.bind;
var ne = function() {
  function t2(r) {
    this.partialObserver = r;
  }
  return t2.prototype.next = function(r) {
    var e = this.partialObserver;
    if (e.next)
      try {
        e.next(r);
      } catch (o) {
        Y(o);
      }
  }, t2.prototype.error = function(r) {
    var e = this.partialObserver;
    if (e.error)
      try {
        e.error(r);
      } catch (o) {
        Y(o);
      }
    else
      Y(r);
  }, t2.prototype.complete = function() {
    var r = this.partialObserver;
    if (r.complete)
      try {
        r.complete();
      } catch (e) {
        Y(e);
      }
  }, t2;
}();
var I = function(t2) {
  A(r, t2);
  function r(e, o, n) {
    var i = t2.call(this) || this, a;
    if (h(e) || !e)
      a = { next: e ?? undefined, error: o ?? undefined, complete: n ?? undefined };
    else {
      var s2;
      i && g.useDeprecatedNextContext ? (s2 = Object.create(e), s2.unsubscribe = function() {
        return i.unsubscribe();
      }, a = { next: e.next && ot(e.next, s2), error: e.error && ot(e.error, s2), complete: e.complete && ot(e.complete, s2) }) : a = e;
    }
    return i.destination = new ne(a), i;
  }
  return r;
}(q);
var ae = { closed: true, next: et, error: ie, complete: et };
var Nt = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
var it = function() {
  function t2(r) {
    r && (this._subscribe = r);
  }
  return t2.prototype.lift = function(r) {
    var e = new t2;
    return e.source = this, e.operator = r, e;
  }, t2.prototype.subscribe = function(r, e, o) {
    var n = this, i = ce(r) ? r : new I(r, e, o);
    return E(function() {
      var a = n, s2 = a.operator, c = a.source;
      i.add(s2 ? s2.call(i, c) : c ? n._subscribe(i) : n._trySubscribe(i));
    }), i;
  }, t2.prototype._trySubscribe = function(r) {
    try {
      return this._subscribe(r);
    } catch (e) {
      r.error(e);
    }
  }, t2.prototype.forEach = function(r, e) {
    var o = this;
    return e = Ct(e), new e(function(n, i) {
      var a = new I({ next: function(s2) {
        try {
          r(s2);
        } catch (c) {
          i(c), a.unsubscribe();
        }
      }, error: i, complete: n });
      o.subscribe(a);
    });
  }, t2.prototype._subscribe = function(r) {
    var e;
    return (e = this.source) === null || e === undefined ? undefined : e.subscribe(r);
  }, t2.prototype[Nt] = function() {
    return this;
  }, t2.prototype.pipe = function() {
    for (var r = [], e = 0;e < arguments.length; e++)
      r[e] = arguments[e];
    return qt(r)(this);
  }, t2.prototype.toPromise = function(r) {
    var e = this;
    return r = Ct(r), new r(function(o, n) {
      var i;
      e.subscribe(function(a) {
        return i = a;
      }, function(a) {
        return n(a);
      }, function() {
        return o(i);
      });
    });
  }, t2.create = function(r) {
    return new t2(r);
  }, t2;
}();
var pe = function(t2) {
  A(r, t2);
  function r(e, o, n, i, a, s2) {
    var c = t2.call(this, e) || this;
    return c.onFinalize = a, c.shouldUnsubscribe = s2, c._next = o ? function(u) {
      try {
        o(u);
      } catch (p) {
        e.error(p);
      }
    } : t2.prototype._next, c._error = i ? function(u) {
      try {
        i(u);
      } catch (p) {
        e.error(p);
      } finally {
        this.unsubscribe();
      }
    } : t2.prototype._error, c._complete = n ? function() {
      try {
        n();
      } catch (u) {
        e.error(u);
      } finally {
        this.unsubscribe();
      }
    } : t2.prototype._complete, c;
  }
  return r.prototype.unsubscribe = function() {
    var e;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var o = this.closed;
      t2.prototype.unsubscribe.call(this), !o && ((e = this.onFinalize) === null || e === undefined || e.call(this));
    }
  }, r;
}(q);
var jt = G(function(t2) {
  return function() {
    t2(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
});
var Q = function(t2) {
  A(r, t2);
  function r() {
    var e = t2.call(this) || this;
    return e.closed = false, e.currentObservers = null, e.observers = [], e.isStopped = false, e.hasError = false, e.thrownError = null, e;
  }
  return r.prototype.lift = function(e) {
    var o = new Ut(this, this);
    return o.operator = e, o;
  }, r.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new jt;
  }, r.prototype.next = function(e) {
    var o = this;
    E(function() {
      var n, i;
      if (o._throwIfClosed(), !o.isStopped) {
        o.currentObservers || (o.currentObservers = Array.from(o.observers));
        try {
          for (var a = N(o.currentObservers), s2 = a.next();!s2.done; s2 = a.next()) {
            var c = s2.value;
            c.next(e);
          }
        } catch (u) {
          n = { error: u };
        } finally {
          try {
            s2 && !s2.done && (i = a.return) && i.call(a);
          } finally {
            if (n)
              throw n.error;
          }
        }
      }
    });
  }, r.prototype.error = function(e) {
    var o = this;
    E(function() {
      if (o._throwIfClosed(), !o.isStopped) {
        o.hasError = o.isStopped = true, o.thrownError = e;
        for (var n = o.observers;n.length; )
          n.shift().error(e);
      }
    });
  }, r.prototype.complete = function() {
    var e = this;
    E(function() {
      if (e._throwIfClosed(), !e.isStopped) {
        e.isStopped = true;
        for (var o = e.observers;o.length; )
          o.shift().complete();
      }
    });
  }, r.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true, this.observers = this.currentObservers = null;
  }, Object.defineProperty(r.prototype, "observed", { get: function() {
    var e;
    return ((e = this.observers) === null || e === undefined ? undefined : e.length) > 0;
  }, enumerable: false, configurable: true }), r.prototype._trySubscribe = function(e) {
    return this._throwIfClosed(), t2.prototype._trySubscribe.call(this, e);
  }, r.prototype._subscribe = function(e) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e);
  }, r.prototype._innerSubscribe = function(e) {
    var o = this, n = this, i = n.hasError, a = n.isStopped, s2 = n.observers;
    return i || a ? tt : (this.currentObservers = null, s2.push(e), new _(function() {
      o.currentObservers = null, F(s2, e);
    }));
  }, r.prototype._checkFinalizedStatuses = function(e) {
    var o = this, n = o.hasError, i = o.thrownError, a = o.isStopped;
    n ? e.error(i) : a && e.complete();
  }, r.prototype.asObservable = function() {
    var e = new it;
    return e.source = this, e;
  }, r.create = function(e, o) {
    return new Ut(e, o);
  }, r;
}(it);
var Ut = function(t2) {
  A(r, t2);
  function r(e, o) {
    var n = t2.call(this) || this;
    return n.destination = e, n.source = o, n;
  }
  return r.prototype.next = function(e) {
    var o, n;
    (n = (o = this.destination) === null || o === undefined ? undefined : o.next) === null || n === undefined || n.call(o, e);
  }, r.prototype.error = function(e) {
    var o, n;
    (n = (o = this.destination) === null || o === undefined ? undefined : o.error) === null || n === undefined || n.call(o, e);
  }, r.prototype.complete = function() {
    var e, o;
    (o = (e = this.destination) === null || e === undefined ? undefined : e.complete) === null || o === undefined || o.call(e);
  }, r.prototype._subscribe = function(e) {
    var o, n;
    return (n = (o = this.source) === null || o === undefined ? undefined : o.subscribe(e)) !== null && n !== undefined ? n : tt;
  }, r;
}(Q);
var Wt = (t2) => {
  switch (t2.type) {
    case "mint":
      return { mint: null };
    case "sub":
      return { sub: t2.id };
    case "vir":
      return { vir: [t2.owner instanceof principal8.Principal ? t2.owner : principal8.Principal.fromText(t2.owner), t2.id] };
  }
};
var Ht = class {
  constructor(r, e) {
    this.ledgerPrincipal = r;
    this.network = e;
    this.ledger = new B(this.ledgerPrincipal, e), this.admin = new W(this.ledgerPrincipal, e);
  }
  ledger;
  admin;
  _externalIdentity = null;
  get externalIdentity() {
    return this._externalIdentity;
  }
  async setIdentity(r) {
    this._externalIdentity = r, r = r || new AnonymousIdentity, Actor.agentOf(await this.ledger.service).replaceIdentity(r), Actor.agentOf(await this.admin.service).replaceIdentity(r);
  }
  async getAggregators() {
    return Promise.all((await this.ledger.aggregators()).filter(({ priority: r }) => r > 0).map(({ principal: r }) => this.createAggregatorDelegate(r)));
  }
  async pickAggregator() {
    let r = await this.ledger.aggregators(), e = r.reduce((a, s2) => a + s2.priority, 0);
    if (e == 0)
      return null;
    let o = Math.random() * e, n = 0, i = null;
    for (let a = 0;a < r.length; a++)
      if (n += r[a].priority, o <= n) {
        i = r[a].principal;
        break;
      }
    return this.createAggregatorDelegate(i);
  }
  async createAggregatorDelegate(r) {
    let e = new H(r, this.network), o = this.externalIdentity || new AnonymousIdentity;
    return Actor.agentOf(await e.service).replaceIdentity(o), e;
  }
  simpleTransfer(r, e, o, n, i, a = []) {
    return r.singleSubmitAndExecute(this._txInputFromRawArgs(e, o, n, i, a));
  }
  async prepareSimpleTransfer(r, e, o, n, i, a = []) {
    let { requestId: s2, call: c } = await r.prepareUpdateRequest("submitAndExecute", [this._txInputFromRawArgs(e, o, n, i, a)]);
    return { requestId: s2, commit: async () => (await c())[0] };
  }
  pollTx(r, e) {
    let o = new Q, n = false, i;
    return o.pipe(st(() => !n)).subscribe((a) => {
      i = a;
    }), setTimeout(async () => {
      try {
        let a = "aggregator", s2 = 0, c = async () => {
          let f = await r.singleTxStatus(e), l = null;
          return f.status == "queued" ? (l = { status: "queued", txId: e, statusPayload: f.queueNumber }, a = "aggregator") : f.status == "pending" ? (l = { status: "forwarding", txId: e, statusPayload: { info: 'Aggregator responded with state "pending"' } }, a = "both") : (l = { status: "forwarded", txId: e }, a = "final"), l;
        }, u = async (f) => {
          let l = await this.ledger.singleTxStatus(e);
          if (l.status === "dropped")
            throw new Error('Ledger responded with "dropped" state');
          if (l.status === "processed")
            return o.next({ status: "processed", txId: e, statusPayload: l.result }), true;
          if (l.status === "awaited") {
            if (f)
              throw new Error('Ledger responded with "awaited" state, when aggregator already forwarded transaction');
            o.next({ status: i.status, txId: e, statusPayload: { info: 'Ledger responded with state "awaited"' } });
          }
          return false;
        }, p = 0;
        t:
          for (;; ) {
            switch (a) {
              case "aggregator":
                await V(250);
                try {
                  o.next(await c());
                } catch (y2) {
                  if (p < 10 && y2 instanceof y && y2.errorKey == "CanisterReject" && y2.errorPayload == "Not yet issued")
                    p++;
                  else
                    throw y2;
                }
                break;
              case "both":
                await V(250);
                let f = [u(false)];
                s2 % 3 == 0 && f.push(c());
                let [l, m] = await Promise.all(f);
                if (l)
                  break t;
                m && o.next(m);
                break;
              case "final":
                await u(true);
                break t;
            }
            s2++;
          }
      } catch (a) {
        o.error(a);
      }
      o.complete();
    }, 0), o.pipe(at(() => n = true));
  }
  _txInputFromRawArgs(r, e, o, n, i = []) {
    return { ftTransfer: { from: Wt(r), to: Wt(e), asset: o, amount: n === "max" ? { max: null } : { amount: typeof n == "bigint" ? n : BigInt(n) }, memo: i } };
  }
};

// node_modules/@dfinity/identity/lib/esm/identity/ed25519.js
var tweetnacl = __toESM(require_nacl_fast(), 1);

// node_modules/@dfinity/identity/lib/esm/buffer.js
function fromHexString(hexString) {
  var _a;
  return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== undefined ? _a : []).map((byte) => parseInt(byte, 16))).buffer;
}
function toHexString(bytes) {
  return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// node_modules/@dfinity/identity/lib/esm/identity/der.js
function wrapDER(payload, oid) {
  const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);
  const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;
  let offset = 0;
  const buf = new Uint8Array(1 + encodeLenBytes(len) + len);
  buf[offset++] = 48;
  offset += encodeLen(buf, offset, len);
  buf.set(oid, offset);
  offset += oid.byteLength;
  buf[offset++] = 3;
  offset += encodeLen(buf, offset, payload.byteLength + 1);
  buf[offset++] = 0;
  buf.set(new Uint8Array(payload), offset);
  return buf;
}
var bufEquals = (b1, b2) => {
  if (b1.byteLength !== b2.byteLength)
    return false;
  const u1 = new Uint8Array(b1);
  const u2 = new Uint8Array(b2);
  for (let i = 0;i < u1.length; i++) {
    if (u1[i] !== u2[i])
      return false;
  }
  return true;
};
var encodeLenBytes = (len) => {
  if (len <= 127) {
    return 1;
  } else if (len <= 255) {
    return 2;
  } else if (len <= 65535) {
    return 3;
  } else if (len <= 16777215) {
    return 4;
  } else {
    throw new Error("Length too long (> 4 bytes)");
  }
};
var encodeLen = (buf, offset, len) => {
  if (len <= 127) {
    buf[offset] = len;
    return 1;
  } else if (len <= 255) {
    buf[offset] = 129;
    buf[offset + 1] = len;
    return 2;
  } else if (len <= 65535) {
    buf[offset] = 130;
    buf[offset + 1] = len >> 8;
    buf[offset + 2] = len;
    return 3;
  } else if (len <= 16777215) {
    buf[offset] = 131;
    buf[offset + 1] = len >> 16;
    buf[offset + 2] = len >> 8;
    buf[offset + 3] = len;
    return 4;
  } else {
    throw new Error("Length too long (> 4 bytes)");
  }
};
var decodeLenBytes = (buf, offset) => {
  if (buf[offset] < 128)
    return 1;
  if (buf[offset] === 128)
    throw new Error("Invalid length 0");
  if (buf[offset] === 129)
    return 2;
  if (buf[offset] === 130)
    return 3;
  if (buf[offset] === 131)
    return 4;
  throw new Error("Length too long (> 4 bytes)");
};
var decodeLen = (buf, offset) => {
  const lenBytes = decodeLenBytes(buf, offset);
  if (lenBytes === 1)
    return buf[offset];
  else if (lenBytes === 2)
    return buf[offset + 1];
  else if (lenBytes === 3)
    return (buf[offset + 1] << 8) + buf[offset + 2];
  else if (lenBytes === 4)
    return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];
  throw new Error("Length too long (> 4 bytes)");
};
var DER_COSE_OID = Uint8Array.from([
  ...[48, 12],
  ...[6, 10],
  ...[43, 6, 1, 4, 1, 131, 184, 67, 1, 1]
]);
var ED25519_OID = Uint8Array.from([
  ...[48, 5],
  ...[6, 3],
  ...[43, 101, 112]
]);
var SECP256K1_OID = Uint8Array.from([
  ...[48, 16],
  ...[6, 7],
  ...[42, 134, 72, 206, 61, 2, 1],
  ...[6, 5],
  ...[43, 129, 4, 0, 10]
]);
var unwrapDER = (derEncoded, oid) => {
  let offset = 0;
  const expect = (n, msg) => {
    if (buf[offset++] !== n) {
      throw new Error("Expected: " + msg);
    }
  };
  const buf = new Uint8Array(derEncoded);
  expect(48, "sequence");
  offset += decodeLenBytes(buf, offset);
  if (!bufEquals(buf.slice(offset, offset + oid.byteLength), oid)) {
    throw new Error("Not the expected OID.");
  }
  offset += oid.byteLength;
  expect(3, "bit string");
  const payloadLen = decodeLen(buf, offset) - 1;
  offset += decodeLenBytes(buf, offset);
  expect(0, "0 padding");
  const result = buf.slice(offset);
  if (payloadLen !== result.length) {
    throw new Error(`DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`);
  }
  return result;
};

// node_modules/@dfinity/identity/lib/esm/identity/ed25519.js
class Ed25519PublicKey {
  constructor(key) {
    this.rawKey = key;
    this.derKey = Ed25519PublicKey.derEncode(key);
  }
  static from(key) {
    return this.fromDer(key.toDer());
  }
  static fromRaw(rawKey) {
    return new Ed25519PublicKey(rawKey);
  }
  static fromDer(derKey) {
    return new Ed25519PublicKey(this.derDecode(derKey));
  }
  static derEncode(publicKey) {
    return wrapDER(publicKey, ED25519_OID).buffer;
  }
  static derDecode(key) {
    const unwrapped = unwrapDER(key, ED25519_OID);
    if (unwrapped.length !== this.RAW_KEY_LENGTH) {
      throw new Error("An Ed25519 public key must be exactly 32bytes long");
    }
    return unwrapped;
  }
  toDer() {
    return this.derKey;
  }
  toRaw() {
    return this.rawKey;
  }
}
Ed25519PublicKey.RAW_KEY_LENGTH = 32;

class Ed25519KeyIdentity extends SignIdentity {
  constructor(publicKey, _privateKey) {
    super();
    this._privateKey = _privateKey;
    this._publicKey = Ed25519PublicKey.from(publicKey);
  }
  static generate(seed) {
    if (seed && seed.length !== 32) {
      throw new Error("Ed25519 Seed needs to be 32 bytes long.");
    }
    const { publicKey, secretKey } = seed === undefined ? tweetnacl.sign.keyPair() : tweetnacl.sign.keyPair.fromSeed(seed);
    return new this(Ed25519PublicKey.fromRaw(publicKey), secretKey);
  }
  static fromParsedJson(obj) {
    const [publicKeyDer, privateKeyRaw] = obj;
    return new Ed25519KeyIdentity(Ed25519PublicKey.fromDer(fromHexString(publicKeyDer)), fromHexString(privateKeyRaw));
  }
  static fromJSON(json) {
    const parsed = JSON.parse(json);
    if (Array.isArray(parsed)) {
      if (typeof parsed[0] === "string" && typeof parsed[1] === "string") {
        return this.fromParsedJson([parsed[0], parsed[1]]);
      } else {
        throw new Error("Deserialization error: JSON must have at least 2 items.");
      }
    }
    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);
  }
  static fromKeyPair(publicKey, privateKey) {
    return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);
  }
  static fromSecretKey(secretKey) {
    const keyPair = tweetnacl.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
    return Ed25519KeyIdentity.fromKeyPair(keyPair.publicKey, keyPair.secretKey);
  }
  toJSON() {
    return [toHexString(this._publicKey.toDer()), toHexString(this._privateKey)];
  }
  getKeyPair() {
    return {
      secretKey: this._privateKey,
      publicKey: this._publicKey
    };
  }
  getPublicKey() {
    return this._publicKey;
  }
  async sign(challenge) {
    const blob = new Uint8Array(challenge);
    const signature = tweetnacl.sign.detached(blob, new Uint8Array(this._privateKey)).buffer;
    return signature;
  }
}
// node_modules/@dfinity/identity/lib/esm/identity/delegation.js
var principal12 = __toESM(require_cjs(), 1);
var cbor3 = __toESM(require_src2(), 1);
var domainSeparator2 = new TextEncoder().encode("\x1Aic-request-auth-delegation");
var requestDomainSeparator = new TextEncoder().encode(`
ic-request`);
// node_modules/@dfinity/identity/lib/esm/identity/webauthn.js
var import_borc3 = __toESM(require_src(), 1);
var tweetnacl2 = __toESM(require_nacl_fast(), 1);
var PubKeyCoseAlgo;
(function(PubKeyCoseAlgo2) {
  PubKeyCoseAlgo2[PubKeyCoseAlgo2["ECDSA_WITH_SHA256"] = -7] = "ECDSA_WITH_SHA256";
})(PubKeyCoseAlgo || (PubKeyCoseAlgo = {}));
// utils.ts
function seedToIdentity(seed) {
  const seedBuf = new Uint8Array(new ArrayBuffer(32));
  if (seed.length && seed.length > 0 && seed.length <= 32) {
    seedBuf.set(new TextEncoder().encode(seed));
    return Ed25519KeyIdentity.generate(seedBuf);
  }
  return null;
}

// src/scripts/transfer.ts
var import_rxjs = __toESM(require_cjs3(), 1);
var polling2 = __toESM(require_polling(), 1);
var strategy = __toESM(require_strategy(), 1);
var onTxStatusChanged = (localId, entry, logCallback, latestStatusPayload = null, printRequestId = false) => {
  global.transactions = [...global.transactions, JSON.stringify(entry, t)];
  let consoleEntry = `TxId: ${entry.txId}; status: ${entry.lastSeenStatus}; payload: ${JSON.stringify(latestStatusPayload, t)}`;
  if (printRequestId) {
    consoleEntry += `; submit request id: ${entry.submitRequestId}`;
  }
  logCallback(consoleEntry);
};
var handleError = (localId, e, logCallback) => {
  const errorMessage = e.errorKey !== undefined ? `Error: ${e.toString()}` : "Error: " + e.message;
  logCallback(errorMessage);
  global.transactions = [
    ...global.transactions,
    JSON.stringify({ errorMessage }, t)
  ];
};
var runOrPickupSimpleTransfer = async (localId, txArgs, client, logCallback, loggers, aggregatorPrincipal = null, submitRequestId = null, txId = null) => {
  try {
    let aggregator = null;
    if (!aggregatorPrincipal) {
      onTxStatusChanged(localId, { txArgs, lastSeenStatus: "pickAggregator", aggregatorPrincipal: null }, logCallback);
      aggregator = await client.pickAggregator();
    } else {
      aggregator = aggregatorPrincipal ? await client.createAggregatorDelegate(aggregatorPrincipal) : null;
    }
    if (!aggregator) {
      throw new Error("No available aggregator");
    }
    if (!txId) {
      if (submitRequestId) {
        logCallback("Retrieving response by request id...");
        const requestId = new Uint8Array(submitRequestId.split(",")).buffer;
        const responseBytes = await polling2.pollForResponse(await aggregator.agent, aggregator.canisterPrincipal, requestId, strategy.maxAttempts(5));
        txId = (await aggregator.parseResponse("submitAndExecute", responseBytes, null))[0];
      } else {
        const { requestId, commit } = await client.prepareSimpleTransfer(aggregator, ...txArgs);
        submitRequestId = new Uint8Array(requestId).join(",");
        onTxStatusChanged(localId, {
          txArgs,
          lastSeenStatus: "submitting",
          aggregatorPrincipal: aggregator.canisterPrincipal.toText(),
          submitRequestId
        }, logCallback, { aggregatorPrincipal: aggregator.canisterPrincipal.toText() }, true);
        txId = await commit();
      }
    }
    await import_rxjs.lastValueFrom(client.pollTx(aggregator, txId).pipe(import_rxjs.map((x2) => {
      onTxStatusChanged(localId, {
        txArgs,
        aggregatorPrincipal: aggregator.canisterPrincipal.toText(),
        txId,
        submitRequestId,
        lastSeenStatus: x2.status
      }, logCallback, x2.statusPayload);
    }), import_rxjs.catchError((e) => {
      loggers.errors();
      handleError(localId, e, logCallback);
      return import_rxjs.of(null);
    })));
  } catch (e) {
    loggers.errors();
    handleError(localId, e, logCallback);
  }
};

// src/index.ts
var import_prom_client = __toESM(require_prom_client(), 1);
var CreateSeedPrincipals = function() {
  const wallet1 = seedToIdentity(Bun.env.PRINCIPAL1_SECRET_KEY || "");
  const wallet2 = seedToIdentity(Bun.env.PRINCIPAL2_SECRET_KEY || "");
  return [wallet1, wallet2];
};
async function StartProcess() {
  const duplaWallet = CreateSeedPrincipals();
  const DuplaClients = startClients(duplaWallet);
  if (!global.transactions)
    global.transactions = [];
  requested();
  const seconds = await RegisterTransferTime(duplaWallet, DuplaClients);
  try {
    transfers_time.labels("seconds").observe(seconds);
  } catch (error) {
    console.log("error", error);
  }
  console.log("TIME: ", seconds);
  global.transactions = [];
  StartProcess();
}
async function RegisterTransferTime(wallet, duplaClients) {
  const start = Date.now();
  await MakeTransfer(wallet, duplaClients);
  return Date.now() - start;
}
var errors6 = function() {
  error_counter.inc();
};
var requested = function() {
  requested_counter.inc();
};
var MakeTransfer = function(wallet, duplaClients) {
  const localId = Date.now();
  const from2 = {
    type: "sub",
    id: BigInt(1)
  };
  const to = {
    type: "sub",
    id: BigInt(2)
  };
  return runOrPickupSimpleTransfer(localId, [from2, to, BigInt(1), "max"], duplaClients[0], () => {
  }, { errors: errors6 });
};
var startClients = function(wallet) {
  const client1 = new Ht(Bun.env.LEDGER_PRINCIPAL || "", "ic");
  client1.setIdentity(wallet[0]);
  const client2 = new Ht(Bun.env.LEDGER_PRINCIPAL || "", "ic");
  client2.setIdentity(wallet[1]);
  return [client1, client2];
};
async function Metrics(request2) {
  const data = await register.metrics();
  return new Response(data, {
    status: 200,
    headers: {
      "Content-Type": register.contentType
    }
  });
}
async function controller(request2) {
  const URI = `http://${request2.headers.get("host")}`;
  if (request2.url === URI + "/")
    return new Response("Welcome to Bun!");
  else if (request2.url.endsWith("/metrics"))
    return await Metrics(request2);
  else
    return new Response("Not found", { status: 404 });
}
var port = process.env.PORT || 3000;
var register = new import_prom_client.default.Registry;
var transfers_time = new import_prom_client.default.Histogram({
  name: "time_to_transfer_seconds",
  help: "Count of time took to transfer",
  labelNames: ["seconds"],
  buckets: import_prom_client.default.linearBuckets(500, 500, 50)
});
register.registerMetric(transfers_time);
var error_counter = new import_prom_client.default.Counter({
  name: "errors_on_transfer",
  help: "Count of errors on transfer",
  labelNames: ["errors"]
});
register.registerMetric(error_counter);
var requested_counter = new import_prom_client.default.Counter({
  name: "request_of_transfer",
  help: "Count of requests on transfer",
  labelNames: ["requested"]
});
register.registerMetric(requested_counter);
register.setDefaultLabels({
  app: "hpl-transfers"
});
StartProcess();
var server = Bun.serve({
  port,
  fetch(request2) {
    return controller(request2);
  }
});
console.log(`Listening on localhost: ${server.port}`);
