// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/@dfinity/principal/lib/esm/utils/base32.js
function encode(input) {
  let skip = 0;
  let bits = 0;
  let output = "";
  function encodeByte(byte) {
    if (skip < 0) {
      bits |= byte >> -skip;
    } else {
      bits = byte << skip & 248;
    }
    if (skip > 3) {
      skip -= 8;
      return 1;
    }
    if (skip < 4) {
      output += alphabet[bits >> 3];
      skip += 5;
    }
    return 0;
  }
  for (let i = 0;i < input.length; ) {
    i += encodeByte(input[i]);
  }
  return output + (skip < 0 ? alphabet[bits >> 3] : "");
}
function decode(input) {
  let skip = 0;
  let byte = 0;
  const output = new Uint8Array(input.length * 4 / 3 | 0);
  let o = 0;
  function decodeChar(char) {
    let val = lookupTable[char.toLowerCase()];
    if (val === undefined) {
      throw new Error(`Invalid character: ${JSON.stringify(char)}`);
    }
    val <<= 3;
    byte |= val >>> skip;
    skip += 5;
    if (skip >= 8) {
      output[o++] = byte;
      skip -= 8;
      if (skip > 0) {
        byte = val << 5 - skip & 255;
      } else {
        byte = 0;
      }
    }
  }
  for (const c of input) {
    decodeChar(c);
  }
  return output.slice(0, o);
}
var alphabet, lookupTable;
var init_base32 = __esm(() => {
  alphabet = "abcdefghijklmnopqrstuvwxyz234567";
  lookupTable = Object.create(null);
  for (let i = 0;i < alphabet.length; i++) {
    lookupTable[alphabet[i]] = i;
  }
  lookupTable["0"] = lookupTable.o;
  lookupTable["1"] = lookupTable.i;
});

// node_modules/@dfinity/principal/lib/esm/utils/getCrc.js
function getCrc32(buf) {
  const b = new Uint8Array(buf);
  let crc = -1;
  for (let i = 0;i < b.length; i++) {
    const byte = b[i];
    const t2 = (byte ^ crc) & 255;
    crc = lookUpTable[t2] ^ crc >>> 8;
  }
  return (crc ^ -1) >>> 0;
}
var lookUpTable;
var init_getCrc = __esm(() => {
  lookUpTable = new Uint32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ]);
});

// node_modules/js-sha256/src/sha256.js
var require_sha256 = __commonJS((exports, module) => {
  (function() {
    var ERROR = "input is invalid type";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA256_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = global;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && exports;
    var AMD = typeof define === "function" && define.amd;
    var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var EXTRA = [-2147483648, 8388608, 32768, 128];
    var SHIFT = [24, 16, 8, 0];
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
    var blocks = [];
    if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(outputType, is224) {
      return function(message) {
        return new Sha256(is224, true).update(message)[outputType]();
      };
    };
    var createMethod = function(is224) {
      var method = createOutputMethod("hex", is224);
      if (NODE_JS) {
        method = nodeWrap(method, is224);
      }
      method.create = function() {
        return new Sha256(is224);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      for (var i = 0;i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createOutputMethod(type, is224);
      }
      return method;
    };
    var nodeWrap = function(method, is224) {
      var crypto2 = (0, eval)("require('crypto')");
      var Buffer2 = (0, eval)("require('buffer').Buffer");
      var algorithm = is224 ? "sha224" : "sha256";
      var nodeMethod = function(message) {
        if (typeof message === "string") {
          return crypto2.createHash(algorithm).update(message, "utf8").digest("hex");
        } else {
          if (message === null || message === undefined) {
            throw new Error(ERROR);
          } else if (message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          }
        }
        if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer2) {
          return crypto2.createHash(algorithm).update(new Buffer2(message)).digest("hex");
        } else {
          return method(message);
        }
      };
      return nodeMethod;
    };
    var createHmacOutputMethod = function(outputType, is224) {
      return function(key, message) {
        return new HmacSha256(key, is224, true).update(message)[outputType]();
      };
    };
    var createHmacMethod = function(is224) {
      var method = createHmacOutputMethod("hex", is224);
      method.create = function(key) {
        return new HmacSha256(key, is224);
      };
      method.update = function(key, message) {
        return method.create(key).update(message);
      };
      for (var i = 0;i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createHmacOutputMethod(type, is224);
      }
      return method;
    };
    function Sha256(is224, sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        this.blocks = blocks;
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      if (is224) {
        this.h0 = 3238371032;
        this.h1 = 914150663;
        this.h2 = 812702999;
        this.h3 = 4144912697;
        this.h4 = 4290775857;
        this.h5 = 1750603025;
        this.h6 = 1694076839;
        this.h7 = 3204075428;
      } else {
        this.h0 = 1779033703;
        this.h1 = 3144134277;
        this.h2 = 1013904242;
        this.h3 = 2773480762;
        this.h4 = 1359893119;
        this.h5 = 2600822924;
        this.h6 = 528734635;
        this.h7 = 1541459225;
      }
      this.block = this.start = this.bytes = this.hBytes = 0;
      this.finalized = this.hashed = false;
      this.first = true;
      this.is224 = is224;
    }
    Sha256.prototype.update = function(message) {
      if (this.finalized) {
        return;
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(ERROR);
            }
          }
        } else {
          throw new Error(ERROR);
        }
        notString = true;
      }
      var code, index = 0, i, length = message.length, blocks2 = this.blocks;
      while (index < length) {
        if (this.hashed) {
          this.hashed = false;
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        if (notString) {
          for (i = this.start;index < length && i < 64; ++index) {
            blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
          }
        } else {
          for (i = this.start;index < length && i < 64; ++index) {
            code = message.charCodeAt(index);
            if (code < 128) {
              blocks2[i >> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 2048) {
              blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            } else if (code < 55296 || code >= 57344) {
              blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            } else {
              code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
              blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
              blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
            }
          }
        }
        this.lastByteIndex = i;
        this.bytes += i - this.start;
        if (i >= 64) {
          this.block = blocks2[16];
          this.start = i - 64;
          this.hash();
          this.hashed = true;
        } else {
          this.start = i;
        }
      }
      if (this.bytes > 4294967295) {
        this.hBytes += this.bytes / 4294967296 << 0;
        this.bytes = this.bytes % 4294967296;
      }
      return this;
    };
    Sha256.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks2 = this.blocks, i = this.lastByteIndex;
      blocks2[16] = this.block;
      blocks2[i >> 2] |= EXTRA[i & 3];
      this.block = blocks2[16];
      if (i >= 56) {
        if (!this.hashed) {
          this.hash();
        }
        blocks2[0] = this.block;
        blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
      }
      blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
      blocks2[15] = this.bytes << 3;
      this.hash();
    };
    Sha256.prototype.hash = function() {
      var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
      for (j = 16;j < 64; ++j) {
        t1 = blocks2[j - 15];
        s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
        t1 = blocks2[j - 2];
        s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
        blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
      }
      bc = b & c;
      for (j = 0;j < 64; j += 4) {
        if (this.first) {
          if (this.is224) {
            ab = 300032;
            t1 = blocks2[0] - 1413257819;
            h = t1 - 150054599 << 0;
            d = t1 + 24177077 << 0;
          } else {
            ab = 704751109;
            t1 = blocks2[0] - 210244248;
            h = t1 - 1521486534 << 0;
            d = t1 + 143694565 << 0;
          }
          this.first = false;
        } else {
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ab = a & b;
          maj = ab ^ a & c ^ bc;
          ch = e & f ^ ~e & g;
          t1 = h + s1 + ch + K[j] + blocks2[j];
          t2 = s0 + maj;
          h = d + t1 << 0;
          d = t1 + t2 << 0;
        }
        s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
        s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
        da = d & a;
        maj = da ^ d & b ^ ab;
        ch = h & e ^ ~h & f;
        t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
        t2 = s0 + maj;
        g = c + t1 << 0;
        c = t1 + t2 << 0;
        s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
        s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
        cd = c & d;
        maj = cd ^ c & a ^ da;
        ch = g & h ^ ~g & e;
        t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
        t2 = s0 + maj;
        f = b + t1 << 0;
        b = t1 + t2 << 0;
        s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
        s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
        bc = b & c;
        maj = bc ^ b & d ^ cd;
        ch = f & g ^ ~f & h;
        t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
        t2 = s0 + maj;
        e = a + t1 << 0;
        a = t1 + t2 << 0;
      }
      this.h0 = this.h0 + a << 0;
      this.h1 = this.h1 + b << 0;
      this.h2 = this.h2 + c << 0;
      this.h3 = this.h3 + d << 0;
      this.h4 = this.h4 + e << 0;
      this.h5 = this.h5 + f << 0;
      this.h6 = this.h6 + g << 0;
      this.h7 = this.h7 + h << 0;
    };
    Sha256.prototype.hex = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
      if (!this.is224) {
        hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
      }
      return hex;
    };
    Sha256.prototype.toString = Sha256.prototype.hex;
    Sha256.prototype.digest = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var arr = [
        h0 >> 24 & 255,
        h0 >> 16 & 255,
        h0 >> 8 & 255,
        h0 & 255,
        h1 >> 24 & 255,
        h1 >> 16 & 255,
        h1 >> 8 & 255,
        h1 & 255,
        h2 >> 24 & 255,
        h2 >> 16 & 255,
        h2 >> 8 & 255,
        h2 & 255,
        h3 >> 24 & 255,
        h3 >> 16 & 255,
        h3 >> 8 & 255,
        h3 & 255,
        h4 >> 24 & 255,
        h4 >> 16 & 255,
        h4 >> 8 & 255,
        h4 & 255,
        h5 >> 24 & 255,
        h5 >> 16 & 255,
        h5 >> 8 & 255,
        h5 & 255,
        h6 >> 24 & 255,
        h6 >> 16 & 255,
        h6 >> 8 & 255,
        h6 & 255
      ];
      if (!this.is224) {
        arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
      }
      return arr;
    };
    Sha256.prototype.array = Sha256.prototype.digest;
    Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
      var dataView = new DataView(buffer);
      dataView.setUint32(0, this.h0);
      dataView.setUint32(4, this.h1);
      dataView.setUint32(8, this.h2);
      dataView.setUint32(12, this.h3);
      dataView.setUint32(16, this.h4);
      dataView.setUint32(20, this.h5);
      dataView.setUint32(24, this.h6);
      if (!this.is224) {
        dataView.setUint32(28, this.h7);
      }
      return buffer;
    };
    function HmacSha256(key, is224, sharedMemory) {
      var i, type = typeof key;
      if (type === "string") {
        var bytes = [], length = key.length, index = 0, code;
        for (i = 0;i < length; ++i) {
          code = key.charCodeAt(i);
          if (code < 128) {
            bytes[index++] = code;
          } else if (code < 2048) {
            bytes[index++] = 192 | code >> 6;
            bytes[index++] = 128 | code & 63;
          } else if (code < 55296 || code >= 57344) {
            bytes[index++] = 224 | code >> 12;
            bytes[index++] = 128 | code >> 6 & 63;
            bytes[index++] = 128 | code & 63;
          } else {
            code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
            bytes[index++] = 240 | code >> 18;
            bytes[index++] = 128 | code >> 12 & 63;
            bytes[index++] = 128 | code >> 6 & 63;
            bytes[index++] = 128 | code & 63;
          }
        }
        key = bytes;
      } else {
        if (type === "object") {
          if (key === null) {
            throw new Error(ERROR);
          } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
            key = new Uint8Array(key);
          } else if (!Array.isArray(key)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
              throw new Error(ERROR);
            }
          }
        } else {
          throw new Error(ERROR);
        }
      }
      if (key.length > 64) {
        key = new Sha256(is224, true).update(key).array();
      }
      var oKeyPad = [], iKeyPad = [];
      for (i = 0;i < 64; ++i) {
        var b = key[i] || 0;
        oKeyPad[i] = 92 ^ b;
        iKeyPad[i] = 54 ^ b;
      }
      Sha256.call(this, is224, sharedMemory);
      this.update(iKeyPad);
      this.oKeyPad = oKeyPad;
      this.inner = true;
      this.sharedMemory = sharedMemory;
    }
    HmacSha256.prototype = new Sha256;
    HmacSha256.prototype.finalize = function() {
      Sha256.prototype.finalize.call(this);
      if (this.inner) {
        this.inner = false;
        var innerHash = this.array();
        Sha256.call(this, this.is224, this.sharedMemory);
        this.update(this.oKeyPad);
        this.update(innerHash);
        Sha256.prototype.finalize.call(this);
      }
    };
    var exports2 = createMethod();
    exports2.sha256 = exports2;
    exports2.sha224 = createMethod(true);
    exports2.sha256.hmac = createHmacMethod();
    exports2.sha224.hmac = createHmacMethod(true);
    if (COMMON_JS) {
      module.exports = exports2;
    } else {
      root.sha256 = exports2.sha256;
      root.sha224 = exports2.sha224;
      if (AMD) {
        define(function() {
          return exports2;
        });
      }
    }
  })();
});

// node_modules/@dfinity/principal/lib/esm/utils/sha224.js
function sha224(data) {
  const shaObj = import_js_sha256.sha224.create();
  shaObj.update(data);
  return new Uint8Array(shaObj.array());
}
var import_js_sha256;
var init_sha224 = __esm(() => {
  import_js_sha256 = __toESM(require_sha256(), 1);
});

// node_modules/@dfinity/principal/lib/esm/index.js
class Principal {
  constructor(_arr) {
    this._arr = _arr;
    this._isPrincipal = true;
  }
  static anonymous() {
    return new this(new Uint8Array([ANONYMOUS_SUFFIX]));
  }
  static managementCanister() {
    return this.fromHex(MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR);
  }
  static selfAuthenticating(publicKey) {
    const sha = sha224(publicKey);
    return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));
  }
  static from(other) {
    if (typeof other === "string") {
      return Principal.fromText(other);
    } else if (typeof other === "object" && other !== null && other._isPrincipal === true) {
      return new Principal(other._arr);
    }
    throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
  }
  static fromHex(hex) {
    return new this(fromHexString(hex));
  }
  static fromText(text) {
    const canisterIdNoDash = text.toLowerCase().replace(/-/g, "");
    let arr = decode(canisterIdNoDash);
    arr = arr.slice(4, arr.length);
    const principal = new this(arr);
    if (principal.toText() !== text) {
      throw new Error(`Principal "${principal.toText()}" does not have a valid checksum (original value "${text}" may not be a valid Principal ID).`);
    }
    return principal;
  }
  static fromUint8Array(arr) {
    return new this(arr);
  }
  isAnonymous() {
    return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;
  }
  toUint8Array() {
    return this._arr;
  }
  toHex() {
    return toHexString(this._arr).toUpperCase();
  }
  toText() {
    const checksumArrayBuf = new ArrayBuffer(4);
    const view = new DataView(checksumArrayBuf);
    view.setUint32(0, getCrc32(this._arr));
    const checksum = new Uint8Array(checksumArrayBuf);
    const bytes = Uint8Array.from(this._arr);
    const array = new Uint8Array([...checksum, ...bytes]);
    const result = encode(array);
    const matches = result.match(/.{1,5}/g);
    if (!matches) {
      throw new Error;
    }
    return matches.join("-");
  }
  toString() {
    return this.toText();
  }
  compareTo(other) {
    for (let i = 0;i < Math.min(this._arr.length, other._arr.length); i++) {
      if (this._arr[i] < other._arr[i])
        return "lt";
      else if (this._arr[i] > other._arr[i])
        return "gt";
    }
    if (this._arr.length < other._arr.length)
      return "lt";
    if (this._arr.length > other._arr.length)
      return "gt";
    return "eq";
  }
  ltEq(other) {
    const cmp = this.compareTo(other);
    return cmp == "lt" || cmp == "eq";
  }
  gtEq(other) {
    const cmp = this.compareTo(other);
    return cmp == "gt" || cmp == "eq";
  }
}
var SELF_AUTHENTICATING_SUFFIX, ANONYMOUS_SUFFIX, MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR, fromHexString, toHexString;
var init_esm = __esm(() => {
  init_base32();
  init_getCrc();
  init_sha224();
  SELF_AUTHENTICATING_SUFFIX = 2;
  ANONYMOUS_SUFFIX = 4;
  MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR = "aaaaa-aa";
  fromHexString = (hexString) => {
    var _a;
    return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== undefined ? _a : []).map((byte) => parseInt(byte, 16)));
  };
  toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
});

// node_modules/@dfinity/candid/lib/esm/utils/buffer.js
function concat(...buffers) {
  const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));
  let index = 0;
  for (const b of buffers) {
    result.set(new Uint8Array(b), index);
    index += b.byteLength;
  }
  return result;
}

class PipeArrayBuffer {
  constructor(buffer, length = (buffer === null || buffer === undefined ? undefined : buffer.byteLength) || 0) {
    this._buffer = buffer || new ArrayBuffer(0);
    this._view = new Uint8Array(this._buffer, 0, length);
  }
  get buffer() {
    return this._view.slice();
  }
  get byteLength() {
    return this._view.byteLength;
  }
  read(num) {
    const result = this._view.subarray(0, num);
    this._view = this._view.subarray(num);
    return result.slice().buffer;
  }
  readUint8() {
    const result = this._view[0];
    this._view = this._view.subarray(1);
    return result;
  }
  write(buf) {
    const b = new Uint8Array(buf);
    const offset = this._view.byteLength;
    if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {
      this.alloc(b.byteLength);
    } else {
      this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b.byteLength);
    }
    this._view.set(b, offset);
  }
  get end() {
    return this._view.byteLength === 0;
  }
  alloc(amount) {
    const b = new ArrayBuffer((this._buffer.byteLength + amount) * 1.2 | 0);
    const v = new Uint8Array(b, 0, this._view.byteLength + amount);
    v.set(this._view);
    this._buffer = b;
    this._view = v;
  }
}
var init_buffer = __esm(() => {
});

// node_modules/@dfinity/candid/lib/esm/utils/hash.js
function idlLabelToId(label) {
  if (/^_\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {
    const num = +label.slice(1, -1);
    if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {
      return num;
    }
  }
  return idlHash(label);
}
var idlHash;
var init_hash = __esm(() => {
  idlHash = function(s2) {
    const utf8encoder = new TextEncoder;
    const array = utf8encoder.encode(s2);
    let h = 0;
    for (const c of array) {
      h = (h * 223 + c) % 2 ** 32;
    }
    return h;
  };
});

// node_modules/@dfinity/candid/lib/esm/utils/leb128.js
function safeRead(pipe, num) {
  if (pipe.byteLength < num) {
    eob();
  }
  return pipe.read(num);
}
function safeReadUint8(pipe) {
  const byte = pipe.readUint8();
  if (byte === undefined) {
    eob();
  }
  return byte;
}
function lebEncode(value) {
  if (typeof value === "number") {
    value = BigInt(value);
  }
  if (value < BigInt(0)) {
    throw new Error("Cannot leb encode negative values.");
  }
  const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;
  const pipe = new PipeArrayBuffer(new ArrayBuffer(byteLength), 0);
  while (true) {
    const i = Number(value & BigInt(127));
    value /= BigInt(128);
    if (value === BigInt(0)) {
      pipe.write(new Uint8Array([i]));
      break;
    } else {
      pipe.write(new Uint8Array([i | 128]));
    }
  }
  return pipe.buffer;
}
function lebDecode(pipe) {
  let weight = BigInt(1);
  let value = BigInt(0);
  let byte;
  do {
    byte = safeReadUint8(pipe);
    value += BigInt(byte & 127).valueOf() * weight;
    weight *= BigInt(128);
  } while (byte >= 128);
  return value;
}
function slebEncode(value) {
  if (typeof value === "number") {
    value = BigInt(value);
  }
  const isNeg = value < BigInt(0);
  if (isNeg) {
    value = -value - BigInt(1);
  }
  const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;
  const pipe = new PipeArrayBuffer(new ArrayBuffer(byteLength), 0);
  while (true) {
    const i = getLowerBytes(value);
    value /= BigInt(128);
    if (isNeg && value === BigInt(0) && (i & 64) !== 0 || !isNeg && value === BigInt(0) && (i & 64) === 0) {
      pipe.write(new Uint8Array([i]));
      break;
    } else {
      pipe.write(new Uint8Array([i | 128]));
    }
  }
  function getLowerBytes(num) {
    const bytes = num % BigInt(128);
    if (isNeg) {
      return Number(BigInt(128) - bytes - BigInt(1));
    } else {
      return Number(bytes);
    }
  }
  return pipe.buffer;
}
function slebDecode(pipe) {
  const pipeView = new Uint8Array(pipe.buffer);
  let len = 0;
  for (;len < pipeView.byteLength; len++) {
    if (pipeView[len] < 128) {
      if ((pipeView[len] & 64) === 0) {
        return lebDecode(pipe);
      }
      break;
    }
  }
  const bytes = new Uint8Array(safeRead(pipe, len + 1));
  let value = BigInt(0);
  for (let i = bytes.byteLength - 1;i >= 0; i--) {
    value = value * BigInt(128) + BigInt(128 - (bytes[i] & 127) - 1);
  }
  return -value - BigInt(1);
}
function writeUIntLE(value, byteLength) {
  if (BigInt(value) < BigInt(0)) {
    throw new Error("Cannot write negative values.");
  }
  return writeIntLE(value, byteLength);
}
function writeIntLE(value, byteLength) {
  value = BigInt(value);
  const pipe = new PipeArrayBuffer(new ArrayBuffer(Math.min(1, byteLength)), 0);
  let i = 0;
  let mul = BigInt(256);
  let sub = BigInt(0);
  let byte = Number(value % mul);
  pipe.write(new Uint8Array([byte]));
  while (++i < byteLength) {
    if (value < 0 && sub === BigInt(0) && byte !== 0) {
      sub = BigInt(1);
    }
    byte = Number((value / mul - sub) % BigInt(256));
    pipe.write(new Uint8Array([byte]));
    mul *= BigInt(256);
  }
  return pipe.buffer;
}
function readUIntLE(pipe, byteLength) {
  let val = BigInt(safeReadUint8(pipe));
  let mul = BigInt(1);
  let i = 0;
  while (++i < byteLength) {
    mul *= BigInt(256);
    const byte = BigInt(safeReadUint8(pipe));
    val = val + mul * byte;
  }
  return val;
}
function readIntLE(pipe, byteLength) {
  let val = readUIntLE(pipe, byteLength);
  const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));
  if (val >= mul) {
    val -= mul * BigInt(2);
  }
  return val;
}
var eob;
var init_leb128 = __esm(() => {
  init_buffer();
  eob = function() {
    throw new Error("unexpected end of buffer");
  };
});

// node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js
function iexp2(n) {
  const nBig = BigInt(n);
  if (n < 0) {
    throw new RangeError("Input must be non-negative");
  }
  return BigInt(1) << nBig;
}
var init_bigint_math = __esm(() => {
});

// node_modules/@dfinity/candid/lib/esm/idl.js
var exports_idl = {};
__export(exports_idl, {
  encode: () => {
    {
      return encode2;
    }
  },
  decode: () => {
    {
      return decode2;
    }
  },
  Visitor: () => {
    {
      return Visitor;
    }
  },
  VecClass: () => {
    {
      return VecClass;
    }
  },
  Vec: () => {
    {
      return Vec;
    }
  },
  VariantClass: () => {
    {
      return VariantClass;
    }
  },
  Variant: () => {
    {
      return Variant;
    }
  },
  UnknownClass: () => {
    {
      return UnknownClass;
    }
  },
  Unknown: () => {
    {
      return Unknown;
    }
  },
  Type: () => {
    {
      return Type;
    }
  },
  TupleClass: () => {
    {
      return TupleClass;
    }
  },
  Tuple: () => {
    {
      return Tuple;
    }
  },
  TextClass: () => {
    {
      return TextClass;
    }
  },
  Text: () => {
    {
      return Text;
    }
  },
  ServiceClass: () => {
    {
      return ServiceClass;
    }
  },
  Service: () => {
    {
      return Service;
    }
  },
  ReservedClass: () => {
    {
      return ReservedClass;
    }
  },
  Reserved: () => {
    {
      return Reserved;
    }
  },
  RecordClass: () => {
    {
      return RecordClass;
    }
  },
  Record: () => {
    {
      return Record;
    }
  },
  RecClass: () => {
    {
      return RecClass;
    }
  },
  Rec: () => {
    {
      return Rec;
    }
  },
  PrincipalClass: () => {
    {
      return PrincipalClass;
    }
  },
  Principal: () => {
    {
      return Principal2;
    }
  },
  PrimitiveType: () => {
    {
      return PrimitiveType;
    }
  },
  OptClass: () => {
    {
      return OptClass;
    }
  },
  Opt: () => {
    {
      return Opt;
    }
  },
  NullClass: () => {
    {
      return NullClass;
    }
  },
  Null: () => {
    {
      return Null;
    }
  },
  NatClass: () => {
    {
      return NatClass;
    }
  },
  Nat8: () => {
    {
      return Nat8;
    }
  },
  Nat64: () => {
    {
      return Nat64;
    }
  },
  Nat32: () => {
    {
      return Nat32;
    }
  },
  Nat16: () => {
    {
      return Nat16;
    }
  },
  Nat: () => {
    {
      return Nat;
    }
  },
  IntClass: () => {
    {
      return IntClass;
    }
  },
  Int8: () => {
    {
      return Int8;
    }
  },
  Int64: () => {
    {
      return Int64;
    }
  },
  Int32: () => {
    {
      return Int32;
    }
  },
  Int16: () => {
    {
      return Int16;
    }
  },
  Int: () => {
    {
      return Int;
    }
  },
  FuncClass: () => {
    {
      return FuncClass;
    }
  },
  Func: () => {
    {
      return Func;
    }
  },
  FloatClass: () => {
    {
      return FloatClass;
    }
  },
  Float64: () => {
    {
      return Float64;
    }
  },
  Float32: () => {
    {
      return Float32;
    }
  },
  FixedNatClass: () => {
    {
      return FixedNatClass;
    }
  },
  FixedIntClass: () => {
    {
      return FixedIntClass;
    }
  },
  EmptyClass: () => {
    {
      return EmptyClass;
    }
  },
  Empty: () => {
    {
      return Empty;
    }
  },
  ConstructType: () => {
    {
      return ConstructType;
    }
  },
  BoolClass: () => {
    {
      return BoolClass;
    }
  },
  Bool: () => {
    {
      return Bool;
    }
  }
});
function encode2(argTypes, args) {
  if (args.length < argTypes.length) {
    throw Error("Wrong number of message arguments");
  }
  const typeTable = new TypeTable;
  argTypes.forEach((t2) => t2.buildTypeTable(typeTable));
  const magic = new TextEncoder().encode(magicNumber);
  const table = typeTable.encode();
  const len = lebEncode(args.length);
  const typs = concat(...argTypes.map((t2) => t2.encodeType(typeTable)));
  const vals = concat(...zipWith(argTypes, args, (t2, x) => {
    try {
      t2.covariant(x);
    } catch (e) {
      const err = new Error(e.message + "\n\n");
      throw err;
    }
    return t2.encodeValue(x);
  }));
  return concat(magic, table, len, typs, vals);
}
function decode2(retTypes, bytes) {
  const b = new PipeArrayBuffer(bytes);
  if (bytes.byteLength < magicNumber.length) {
    throw new Error("Message length smaller than magic number");
  }
  const magicBuffer = safeRead(b, magicNumber.length);
  const magic = new TextDecoder().decode(magicBuffer);
  if (magic !== magicNumber) {
    throw new Error("Wrong magic number: " + JSON.stringify(magic));
  }
  function readTypeTable(pipe) {
    const typeTable = [];
    const len = Number(lebDecode(pipe));
    for (let i = 0;i < len; i++) {
      const ty = Number(slebDecode(pipe));
      switch (ty) {
        case -18:
        case -19: {
          const t2 = Number(slebDecode(pipe));
          typeTable.push([ty, t2]);
          break;
        }
        case -20:
        case -21: {
          const fields = [];
          let objectLength = Number(lebDecode(pipe));
          let prevHash;
          while (objectLength--) {
            const hash2 = Number(lebDecode(pipe));
            if (hash2 >= Math.pow(2, 32)) {
              throw new Error("field id out of 32-bit range");
            }
            if (typeof prevHash === "number" && prevHash >= hash2) {
              throw new Error("field id collision or not sorted");
            }
            prevHash = hash2;
            const t2 = Number(slebDecode(pipe));
            fields.push([hash2, t2]);
          }
          typeTable.push([ty, fields]);
          break;
        }
        case -22: {
          const args = [];
          let argLength = Number(lebDecode(pipe));
          while (argLength--) {
            args.push(Number(slebDecode(pipe)));
          }
          const returnValues = [];
          let returnValuesLength = Number(lebDecode(pipe));
          while (returnValuesLength--) {
            returnValues.push(Number(slebDecode(pipe)));
          }
          const annotations = [];
          let annotationLength = Number(lebDecode(pipe));
          while (annotationLength--) {
            const annotation = Number(lebDecode(pipe));
            switch (annotation) {
              case 1: {
                annotations.push("query");
                break;
              }
              case 2: {
                annotations.push("oneway");
                break;
              }
              case 3: {
                annotations.push("composite_query");
                break;
              }
              default:
                throw new Error("unknown annotation");
            }
          }
          typeTable.push([ty, [args, returnValues, annotations]]);
          break;
        }
        case -23: {
          let servLength = Number(lebDecode(pipe));
          const methods = [];
          while (servLength--) {
            const nameLength = Number(lebDecode(pipe));
            const funcName = new TextDecoder().decode(safeRead(pipe, nameLength));
            const funcType = slebDecode(pipe);
            methods.push([funcName, funcType]);
          }
          typeTable.push([ty, methods]);
          break;
        }
        default:
          throw new Error("Illegal op_code: " + ty);
      }
    }
    const rawList = [];
    const length = Number(lebDecode(pipe));
    for (let i = 0;i < length; i++) {
      rawList.push(Number(slebDecode(pipe)));
    }
    return [typeTable, rawList];
  }
  const [rawTable, rawTypes] = readTypeTable(b);
  if (rawTypes.length < retTypes.length) {
    throw new Error("Wrong number of return values");
  }
  const table = rawTable.map((_) => Rec());
  function getType(t2) {
    if (t2 < -24) {
      throw new Error("future value not supported");
    }
    if (t2 < 0) {
      switch (t2) {
        case -1:
          return Null;
        case -2:
          return Bool;
        case -3:
          return Nat;
        case -4:
          return Int;
        case -5:
          return Nat8;
        case -6:
          return Nat16;
        case -7:
          return Nat32;
        case -8:
          return Nat64;
        case -9:
          return Int8;
        case -10:
          return Int16;
        case -11:
          return Int32;
        case -12:
          return Int64;
        case -13:
          return Float32;
        case -14:
          return Float64;
        case -15:
          return Text;
        case -16:
          return Reserved;
        case -17:
          return Empty;
        case -24:
          return Principal2;
        default:
          throw new Error("Illegal op_code: " + t2);
      }
    }
    if (t2 >= rawTable.length) {
      throw new Error("type index out of range");
    }
    return table[t2];
  }
  function buildType(entry) {
    switch (entry[0]) {
      case -19: {
        const ty = getType(entry[1]);
        return Vec(ty);
      }
      case -18: {
        const ty = getType(entry[1]);
        return Opt(ty);
      }
      case -20: {
        const fields = {};
        for (const [hash2, ty] of entry[1]) {
          const name = `_${hash2}_`;
          fields[name] = getType(ty);
        }
        const record = Record(fields);
        const tuple = record.tryAsTuple();
        if (Array.isArray(tuple)) {
          return Tuple(...tuple);
        } else {
          return record;
        }
      }
      case -21: {
        const fields = {};
        for (const [hash2, ty] of entry[1]) {
          const name = `_${hash2}_`;
          fields[name] = getType(ty);
        }
        return Variant(fields);
      }
      case -22: {
        const [args, returnValues, annotations] = entry[1];
        return Func(args.map((t2) => getType(t2)), returnValues.map((t2) => getType(t2)), annotations);
      }
      case -23: {
        const rec = {};
        const methods = entry[1];
        for (const [name, typeRef] of methods) {
          let type = getType(typeRef);
          if (type instanceof RecClass) {
            type = type.getType();
          }
          if (!(type instanceof FuncClass)) {
            throw new Error("Illegal service definition: services can only contain functions");
          }
          rec[name] = type;
        }
        return Service(rec);
      }
      default:
        throw new Error("Illegal op_code: " + entry[0]);
    }
  }
  rawTable.forEach((entry, i) => {
    if (entry[0] === -22) {
      const t2 = buildType(entry);
      table[i].fill(t2);
    }
  });
  rawTable.forEach((entry, i) => {
    if (entry[0] !== -22) {
      const t2 = buildType(entry);
      table[i].fill(t2);
    }
  });
  const types = rawTypes.map((t2) => getType(t2));
  const output = retTypes.map((t2, i) => {
    return t2.decodeValue(b, types[i]);
  });
  for (let ind = retTypes.length;ind < types.length; ind++) {
    types[ind].decodeValue(b, types[ind]);
  }
  if (b.byteLength > 0) {
    throw new Error("decode: Left-over bytes");
  }
  return output;
}
function Tuple(...types) {
  return new TupleClass(types);
}
function Vec(t2) {
  return new VecClass(t2);
}
function Opt(t2) {
  return new OptClass(t2);
}
function Record(t2) {
  return new RecordClass(t2);
}
function Variant(fields) {
  return new VariantClass(fields);
}
function Rec() {
  return new RecClass;
}
function Func(args, ret2, annotations = []) {
  return new FuncClass(args, ret2, annotations);
}
function Service(t2) {
  return new ServiceClass(t2);
}

class TypeTable {
  constructor() {
    this._typs = [];
    this._idx = new Map;
  }
  has(obj) {
    return this._idx.has(obj.name);
  }
  add(type, buf) {
    const idx = this._typs.length;
    this._idx.set(type.name, idx);
    this._typs.push(buf);
  }
  merge(obj, knot) {
    const idx = this._idx.get(obj.name);
    const knotIdx = this._idx.get(knot);
    if (idx === undefined) {
      throw new Error("Missing type index for " + obj);
    }
    if (knotIdx === undefined) {
      throw new Error("Missing type index for " + knot);
    }
    this._typs[idx] = this._typs[knotIdx];
    this._typs.splice(knotIdx, 1);
    this._idx.delete(knot);
  }
  encode() {
    const len = lebEncode(this._typs.length);
    const buf = concat(...this._typs);
    return concat(len, buf);
  }
  indexOf(typeName) {
    if (!this._idx.has(typeName)) {
      throw new Error("Missing type index for " + typeName);
    }
    return slebEncode(this._idx.get(typeName) || 0);
  }
}

class Visitor {
  visitType(t2, data) {
    throw new Error("Not implemented");
  }
  visitPrimitive(t2, data) {
    return this.visitType(t2, data);
  }
  visitEmpty(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitBool(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitNull(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitReserved(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitText(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitNumber(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitInt(t2, data) {
    return this.visitNumber(t2, data);
  }
  visitNat(t2, data) {
    return this.visitNumber(t2, data);
  }
  visitFloat(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitFixedInt(t2, data) {
    return this.visitNumber(t2, data);
  }
  visitFixedNat(t2, data) {
    return this.visitNumber(t2, data);
  }
  visitPrincipal(t2, data) {
    return this.visitPrimitive(t2, data);
  }
  visitConstruct(t2, data) {
    return this.visitType(t2, data);
  }
  visitVec(t2, ty, data) {
    return this.visitConstruct(t2, data);
  }
  visitOpt(t2, ty, data) {
    return this.visitConstruct(t2, data);
  }
  visitRecord(t2, fields, data) {
    return this.visitConstruct(t2, data);
  }
  visitTuple(t2, components, data) {
    const fields = components.map((ty, i) => [`_${i}_`, ty]);
    return this.visitRecord(t2, fields, data);
  }
  visitVariant(t2, fields, data) {
    return this.visitConstruct(t2, data);
  }
  visitRec(t2, ty, data) {
    return this.visitConstruct(ty, data);
  }
  visitFunc(t2, data) {
    return this.visitConstruct(t2, data);
  }
  visitService(t2, data) {
    return this.visitConstruct(t2, data);
  }
}

class Type {
  display() {
    return this.name;
  }
  valueToString(x) {
    return toReadableString(x);
  }
  buildTypeTable(typeTable) {
    if (!typeTable.has(this)) {
      this._buildTypeTableImpl(typeTable);
    }
  }
}

class PrimitiveType extends Type {
  checkType(t2) {
    if (this.name !== t2.name) {
      throw new Error(`type mismatch: type on the wire ${t2.name}, expect type ${this.name}`);
    }
    return t2;
  }
  _buildTypeTableImpl(typeTable) {
    return;
  }
}

class ConstructType extends Type {
  checkType(t2) {
    if (t2 instanceof RecClass) {
      const ty = t2.getType();
      if (typeof ty === "undefined") {
        throw new Error("type mismatch with uninitialized type");
      }
      return ty;
    }
    throw new Error(`type mismatch: type on the wire ${t2.name}, expect type ${this.name}`);
  }
  encodeType(typeTable) {
    return typeTable.indexOf(this.name);
  }
}

class EmptyClass extends PrimitiveType {
  accept(v, d) {
    return v.visitEmpty(this, d);
  }
  covariant(x) {
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue() {
    throw new Error("Empty cannot appear as a function argument");
  }
  valueToString() {
    throw new Error("Empty cannot appear as a value");
  }
  encodeType() {
    return slebEncode(-17);
  }
  decodeValue() {
    throw new Error("Empty cannot appear as an output");
  }
  get name() {
    return "empty";
  }
}

class UnknownClass extends Type {
  checkType(t2) {
    throw new Error("Method not implemented for unknown.");
  }
  accept(v, d) {
    throw v.visitType(this, d);
  }
  covariant(x) {
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue() {
    throw new Error("Unknown cannot appear as a function argument");
  }
  valueToString() {
    throw new Error("Unknown cannot appear as a value");
  }
  encodeType() {
    throw new Error("Unknown cannot be serialized");
  }
  decodeValue(b, t2) {
    let decodedValue = t2.decodeValue(b, t2);
    if (Object(decodedValue) !== decodedValue) {
      decodedValue = Object(decodedValue);
    }
    let typeFunc;
    if (t2 instanceof RecClass) {
      typeFunc = () => t2.getType();
    } else {
      typeFunc = () => t2;
    }
    Object.defineProperty(decodedValue, "type", {
      value: typeFunc,
      writable: true,
      enumerable: false,
      configurable: true
    });
    return decodedValue;
  }
  _buildTypeTableImpl() {
    throw new Error("Unknown cannot be serialized");
  }
  get name() {
    return "Unknown";
  }
}

class BoolClass extends PrimitiveType {
  accept(v, d) {
    return v.visitBool(this, d);
  }
  covariant(x) {
    if (typeof x === "boolean")
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    return new Uint8Array([x ? 1 : 0]);
  }
  encodeType() {
    return slebEncode(-2);
  }
  decodeValue(b, t2) {
    this.checkType(t2);
    switch (safeReadUint8(b)) {
      case 0:
        return false;
      case 1:
        return true;
      default:
        throw new Error("Boolean value out of range");
    }
  }
  get name() {
    return "bool";
  }
}

class NullClass extends PrimitiveType {
  accept(v, d) {
    return v.visitNull(this, d);
  }
  covariant(x) {
    if (x === null)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue() {
    return new ArrayBuffer(0);
  }
  encodeType() {
    return slebEncode(-1);
  }
  decodeValue(b, t2) {
    this.checkType(t2);
    return null;
  }
  get name() {
    return "null";
  }
}

class ReservedClass extends PrimitiveType {
  accept(v, d) {
    return v.visitReserved(this, d);
  }
  covariant(x) {
    return true;
  }
  encodeValue() {
    return new ArrayBuffer(0);
  }
  encodeType() {
    return slebEncode(-16);
  }
  decodeValue(b, t2) {
    if (t2.name !== this.name) {
      t2.decodeValue(b, t2);
    }
    return null;
  }
  get name() {
    return "reserved";
  }
}

class TextClass extends PrimitiveType {
  accept(v, d) {
    return v.visitText(this, d);
  }
  covariant(x) {
    if (typeof x === "string")
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const buf = new TextEncoder().encode(x);
    const len = lebEncode(buf.byteLength);
    return concat(len, buf);
  }
  encodeType() {
    return slebEncode(-15);
  }
  decodeValue(b, t2) {
    this.checkType(t2);
    const len = lebDecode(b);
    const buf = safeRead(b, Number(len));
    const decoder = new TextDecoder("utf8", { fatal: true });
    return decoder.decode(buf);
  }
  get name() {
    return "text";
  }
  valueToString(x) {
    return '"' + x + '"';
  }
}

class IntClass extends PrimitiveType {
  accept(v, d) {
    return v.visitInt(this, d);
  }
  covariant(x) {
    if (typeof x === "bigint" || Number.isInteger(x))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    return slebEncode(x);
  }
  encodeType() {
    return slebEncode(-4);
  }
  decodeValue(b, t2) {
    this.checkType(t2);
    return slebDecode(b);
  }
  get name() {
    return "int";
  }
  valueToString(x) {
    return x.toString();
  }
}

class NatClass extends PrimitiveType {
  accept(v, d) {
    return v.visitNat(this, d);
  }
  covariant(x) {
    if (typeof x === "bigint" && x >= BigInt(0) || Number.isInteger(x) && x >= 0)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    return lebEncode(x);
  }
  encodeType() {
    return slebEncode(-3);
  }
  decodeValue(b, t2) {
    this.checkType(t2);
    return lebDecode(b);
  }
  get name() {
    return "nat";
  }
  valueToString(x) {
    return x.toString();
  }
}

class FloatClass extends PrimitiveType {
  constructor(_bits) {
    super();
    this._bits = _bits;
    if (_bits !== 32 && _bits !== 64) {
      throw new Error("not a valid float type");
    }
  }
  accept(v, d) {
    return v.visitFloat(this, d);
  }
  covariant(x) {
    if (typeof x === "number" || x instanceof Number)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const buf = new ArrayBuffer(this._bits / 8);
    const view = new DataView(buf);
    if (this._bits === 32) {
      view.setFloat32(0, x, true);
    } else {
      view.setFloat64(0, x, true);
    }
    return buf;
  }
  encodeType() {
    const opcode = this._bits === 32 ? -13 : -14;
    return slebEncode(opcode);
  }
  decodeValue(b, t2) {
    this.checkType(t2);
    const bytes = safeRead(b, this._bits / 8);
    const view = new DataView(bytes);
    if (this._bits === 32) {
      return view.getFloat32(0, true);
    } else {
      return view.getFloat64(0, true);
    }
  }
  get name() {
    return "float" + this._bits;
  }
  valueToString(x) {
    return x.toString();
  }
}

class FixedIntClass extends PrimitiveType {
  constructor(_bits) {
    super();
    this._bits = _bits;
  }
  accept(v, d) {
    return v.visitFixedInt(this, d);
  }
  covariant(x) {
    const min = iexp2(this._bits - 1) * BigInt(-1);
    const max = iexp2(this._bits - 1) - BigInt(1);
    let ok = false;
    if (typeof x === "bigint") {
      ok = x >= min && x <= max;
    } else if (Number.isInteger(x)) {
      const v = BigInt(x);
      ok = v >= min && v <= max;
    } else {
      ok = false;
    }
    if (ok)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    return writeIntLE(x, this._bits / 8);
  }
  encodeType() {
    const offset = Math.log2(this._bits) - 3;
    return slebEncode(-9 - offset);
  }
  decodeValue(b, t2) {
    this.checkType(t2);
    const num = readIntLE(b, this._bits / 8);
    if (this._bits <= 32) {
      return Number(num);
    } else {
      return num;
    }
  }
  get name() {
    return `int${this._bits}`;
  }
  valueToString(x) {
    return x.toString();
  }
}

class FixedNatClass extends PrimitiveType {
  constructor(_bits) {
    super();
    this._bits = _bits;
  }
  accept(v, d) {
    return v.visitFixedNat(this, d);
  }
  covariant(x) {
    const max = iexp2(this._bits);
    let ok = false;
    if (typeof x === "bigint" && x >= BigInt(0)) {
      ok = x < max;
    } else if (Number.isInteger(x) && x >= 0) {
      const v = BigInt(x);
      ok = v < max;
    } else {
      ok = false;
    }
    if (ok)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    return writeUIntLE(x, this._bits / 8);
  }
  encodeType() {
    const offset = Math.log2(this._bits) - 3;
    return slebEncode(-5 - offset);
  }
  decodeValue(b, t2) {
    this.checkType(t2);
    const num = readUIntLE(b, this._bits / 8);
    if (this._bits <= 32) {
      return Number(num);
    } else {
      return num;
    }
  }
  get name() {
    return `nat${this._bits}`;
  }
  valueToString(x) {
    return x.toString();
  }
}

class VecClass extends ConstructType {
  constructor(_type) {
    super();
    this._type = _type;
    this._blobOptimization = false;
    if (_type instanceof FixedNatClass && _type._bits === 8) {
      this._blobOptimization = true;
    }
  }
  accept(v, d) {
    return v.visitVec(this, this._type, d);
  }
  covariant(x) {
    const bits = this._type instanceof FixedNatClass ? this._type._bits : this._type instanceof FixedIntClass ? this._type._bits : 0;
    if (ArrayBuffer.isView(x) && bits == x.BYTES_PER_ELEMENT * 8 || Array.isArray(x) && x.every((v, idx) => {
      try {
        return this._type.covariant(v);
      } catch (e) {
        throw new Error(`Invalid ${this.display()} argument: \n\nindex ${idx} -> ${e.message}`);
      }
    }))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const len = lebEncode(x.length);
    if (this._blobOptimization) {
      return concat(len, new Uint8Array(x));
    }
    if (ArrayBuffer.isView(x)) {
      return concat(len, new Uint8Array(x.buffer));
    }
    const buf = new PipeArrayBuffer(new ArrayBuffer(len.byteLength + x.length), 0);
    buf.write(len);
    for (const d of x) {
      const encoded = this._type.encodeValue(d);
      buf.write(new Uint8Array(encoded));
    }
    return buf.buffer;
  }
  _buildTypeTableImpl(typeTable) {
    this._type.buildTypeTable(typeTable);
    const opCode = slebEncode(-19);
    const buffer3 = this._type.encodeType(typeTable);
    typeTable.add(this, concat(opCode, buffer3));
  }
  decodeValue(b, t2) {
    const vec = this.checkType(t2);
    if (!(vec instanceof VecClass)) {
      throw new Error("Not a vector type");
    }
    const len = Number(lebDecode(b));
    if (this._type instanceof FixedNatClass) {
      if (this._type._bits == 8) {
        return new Uint8Array(b.read(len));
      }
      if (this._type._bits == 16) {
        return new Uint16Array(b.read(len * 2));
      }
      if (this._type._bits == 32) {
        return new Uint32Array(b.read(len * 4));
      }
      if (this._type._bits == 64) {
        return new BigUint64Array(b.read(len * 8));
      }
    }
    if (this._type instanceof FixedIntClass) {
      if (this._type._bits == 8) {
        return new Int8Array(b.read(len));
      }
      if (this._type._bits == 16) {
        return new Int16Array(b.read(len * 2));
      }
      if (this._type._bits == 32) {
        return new Int32Array(b.read(len * 4));
      }
      if (this._type._bits == 64) {
        return new BigInt64Array(b.read(len * 8));
      }
    }
    const rets = [];
    for (let i = 0;i < len; i++) {
      rets.push(this._type.decodeValue(b, vec._type));
    }
    return rets;
  }
  get name() {
    return `vec ${this._type.name}`;
  }
  display() {
    return `vec ${this._type.display()}`;
  }
  valueToString(x) {
    const elements = x.map((e) => this._type.valueToString(e));
    return "vec {" + elements.join("; ") + "}";
  }
}

class OptClass extends ConstructType {
  constructor(_type) {
    super();
    this._type = _type;
  }
  accept(v, d) {
    return v.visitOpt(this, this._type, d);
  }
  covariant(x) {
    try {
      if (Array.isArray(x) && (x.length === 0 || x.length === 1 && this._type.covariant(x[0])))
        return true;
    } catch (e) {
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)} \n\n-> ${e.message}`);
    }
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    if (x.length === 0) {
      return new Uint8Array([0]);
    } else {
      return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));
    }
  }
  _buildTypeTableImpl(typeTable) {
    this._type.buildTypeTable(typeTable);
    const opCode = slebEncode(-18);
    const buffer3 = this._type.encodeType(typeTable);
    typeTable.add(this, concat(opCode, buffer3));
  }
  decodeValue(b, t2) {
    const opt = this.checkType(t2);
    if (!(opt instanceof OptClass)) {
      throw new Error("Not an option type");
    }
    switch (safeReadUint8(b)) {
      case 0:
        return [];
      case 1:
        return [this._type.decodeValue(b, opt._type)];
      default:
        throw new Error("Not an option value");
    }
  }
  get name() {
    return `opt ${this._type.name}`;
  }
  display() {
    return `opt ${this._type.display()}`;
  }
  valueToString(x) {
    if (x.length === 0) {
      return "null";
    } else {
      return `opt ${this._type.valueToString(x[0])}`;
    }
  }
}

class RecordClass extends ConstructType {
  constructor(fields = {}) {
    super();
    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));
  }
  accept(v, d) {
    return v.visitRecord(this, this._fields, d);
  }
  tryAsTuple() {
    const res = [];
    for (let i = 0;i < this._fields.length; i++) {
      const [key, type] = this._fields[i];
      if (key !== `_${i}_`) {
        return null;
      }
      res.push(type);
    }
    return res;
  }
  covariant(x) {
    if (typeof x === "object" && this._fields.every(([k, t2]) => {
      if (!x.hasOwnProperty(k)) {
        throw new Error(`Record is missing key "${k}".`);
      }
      try {
        return t2.covariant(x[k]);
      } catch (e) {
        throw new Error(`Invalid ${this.display()} argument: \n\nfield ${k} -> ${e.message}`);
      }
    }))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const values = this._fields.map(([key]) => x[key]);
    const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));
    return concat(...bufs);
  }
  _buildTypeTableImpl(T) {
    this._fields.forEach(([_, value]) => value.buildTypeTable(T));
    const opCode = slebEncode(-20);
    const len = lebEncode(this._fields.length);
    const fields = this._fields.map(([key, value]) => concat(lebEncode(idlLabelToId(key)), value.encodeType(T)));
    T.add(this, concat(opCode, len, concat(...fields)));
  }
  decodeValue(b, t2) {
    const record = this.checkType(t2);
    if (!(record instanceof RecordClass)) {
      throw new Error("Not a record type");
    }
    const x = {};
    let expectedRecordIdx = 0;
    let actualRecordIdx = 0;
    while (actualRecordIdx < record._fields.length) {
      const [hash2, type] = record._fields[actualRecordIdx];
      if (expectedRecordIdx >= this._fields.length) {
        type.decodeValue(b, type);
        actualRecordIdx++;
        continue;
      }
      const [expectKey, expectType] = this._fields[expectedRecordIdx];
      const expectedId = idlLabelToId(this._fields[expectedRecordIdx][0]);
      const actualId = idlLabelToId(hash2);
      if (expectedId === actualId) {
        x[expectKey] = expectType.decodeValue(b, type);
        expectedRecordIdx++;
        actualRecordIdx++;
      } else if (actualId > expectedId) {
        if (expectType instanceof OptClass || expectType instanceof ReservedClass) {
          x[expectKey] = [];
          expectedRecordIdx++;
        } else {
          throw new Error("Cannot find required field " + expectKey);
        }
      } else {
        type.decodeValue(b, type);
        actualRecordIdx++;
      }
    }
    for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {
      if (expectType instanceof OptClass || expectType instanceof ReservedClass) {
        x[expectKey] = [];
      } else {
        throw new Error("Cannot find required field " + expectKey);
      }
    }
    return x;
  }
  get name() {
    const fields = this._fields.map(([key, value]) => key + ":" + value.name);
    return `record {${fields.join("; ")}}`;
  }
  display() {
    const fields = this._fields.map(([key, value]) => key + ":" + value.display());
    return `record {${fields.join("; ")}}`;
  }
  valueToString(x) {
    const values = this._fields.map(([key]) => x[key]);
    const fields = zipWith(this._fields, values, ([k, c], d) => k + "=" + c.valueToString(d));
    return `record {${fields.join("; ")}}`;
  }
}

class TupleClass extends RecordClass {
  constructor(_components) {
    const x = {};
    _components.forEach((e, i) => x["_" + i + "_"] = e);
    super(x);
    this._components = _components;
  }
  accept(v, d) {
    return v.visitTuple(this, this._components, d);
  }
  covariant(x) {
    if (Array.isArray(x) && x.length >= this._fields.length && this._components.every((t2, i) => {
      try {
        return t2.covariant(x[i]);
      } catch (e) {
        throw new Error(`Invalid ${this.display()} argument: \n\nindex ${i} -> ${e.message}`);
      }
    }))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));
    return concat(...bufs);
  }
  decodeValue(b, t2) {
    const tuple = this.checkType(t2);
    if (!(tuple instanceof TupleClass)) {
      throw new Error("not a tuple type");
    }
    if (tuple._components.length < this._components.length) {
      throw new Error("tuple mismatch");
    }
    const res = [];
    for (const [i, wireType] of tuple._components.entries()) {
      if (i >= this._components.length) {
        wireType.decodeValue(b, wireType);
      } else {
        res.push(this._components[i].decodeValue(b, wireType));
      }
    }
    return res;
  }
  display() {
    const fields = this._components.map((value) => value.display());
    return `record {${fields.join("; ")}}`;
  }
  valueToString(values) {
    const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));
    return `record {${fields.join("; ")}}`;
  }
}

class VariantClass extends ConstructType {
  constructor(fields = {}) {
    super();
    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));
  }
  accept(v, d) {
    return v.visitVariant(this, this._fields, d);
  }
  covariant(x) {
    if (typeof x === "object" && Object.entries(x).length === 1 && this._fields.every(([k, v]) => {
      try {
        return !x.hasOwnProperty(k) || v.covariant(x[k]);
      } catch (e) {
        throw new Error(`Invalid ${this.display()} argument: \n\nvariant ${k} -> ${e.message}`);
      }
    }))
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    for (let i = 0;i < this._fields.length; i++) {
      const [name, type] = this._fields[i];
      if (x.hasOwnProperty(name)) {
        const idx = lebEncode(i);
        const buf = type.encodeValue(x[name]);
        return concat(idx, buf);
      }
    }
    throw Error("Variant has no data: " + x);
  }
  _buildTypeTableImpl(typeTable) {
    this._fields.forEach(([, type]) => {
      type.buildTypeTable(typeTable);
    });
    const opCode = slebEncode(-21);
    const len = lebEncode(this._fields.length);
    const fields = this._fields.map(([key, value]) => concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable)));
    typeTable.add(this, concat(opCode, len, ...fields));
  }
  decodeValue(b, t2) {
    const variant = this.checkType(t2);
    if (!(variant instanceof VariantClass)) {
      throw new Error("Not a variant type");
    }
    const idx = Number(lebDecode(b));
    if (idx >= variant._fields.length) {
      throw Error("Invalid variant index: " + idx);
    }
    const [wireHash, wireType] = variant._fields[idx];
    for (const [key, expectType] of this._fields) {
      if (idlLabelToId(wireHash) === idlLabelToId(key)) {
        const value = expectType.decodeValue(b, wireType);
        return { [key]: value };
      }
    }
    throw new Error("Cannot find field hash " + wireHash);
  }
  get name() {
    const fields = this._fields.map(([key, type]) => key + ":" + type.name);
    return `variant {${fields.join("; ")}}`;
  }
  display() {
    const fields = this._fields.map(([key, type]) => key + (type.name === "null" ? "" : `:${type.display()}`));
    return `variant {${fields.join("; ")}}`;
  }
  valueToString(x) {
    for (const [name, type] of this._fields) {
      if (x.hasOwnProperty(name)) {
        const value = type.valueToString(x[name]);
        if (value === "null") {
          return `variant {${name}}`;
        } else {
          return `variant {${name}=${value}}`;
        }
      }
    }
    throw new Error("Variant has no data: " + x);
  }
}

class RecClass extends ConstructType {
  constructor() {
    super(...arguments);
    this._id = RecClass._counter++;
    this._type = undefined;
  }
  accept(v, d) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return v.visitRec(this, this._type, d);
  }
  fill(t2) {
    this._type = t2;
  }
  getType() {
    return this._type;
  }
  covariant(x) {
    if (this._type ? this._type.covariant(x) : false)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return this._type.encodeValue(x);
  }
  _buildTypeTableImpl(typeTable) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    typeTable.add(this, new Uint8Array([]));
    this._type.buildTypeTable(typeTable);
    typeTable.merge(this, this._type.name);
  }
  decodeValue(b, t2) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return this._type.decodeValue(b, t2);
  }
  get name() {
    return `rec_${this._id}`;
  }
  display() {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return `\u03BC${this.name}.${this._type.name}`;
  }
  valueToString(x) {
    if (!this._type) {
      throw Error("Recursive type uninitialized.");
    }
    return this._type.valueToString(x);
  }
}

class PrincipalClass extends PrimitiveType {
  accept(v, d) {
    return v.visitPrincipal(this, d);
  }
  covariant(x) {
    if (x && x._isPrincipal)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const buf = x.toUint8Array();
    const len = lebEncode(buf.byteLength);
    return concat(new Uint8Array([1]), len, buf);
  }
  encodeType() {
    return slebEncode(-24);
  }
  decodeValue(b, t2) {
    this.checkType(t2);
    return decodePrincipalId(b);
  }
  get name() {
    return "principal";
  }
  valueToString(x) {
    return `${this.name} "${x.toText()}"`;
  }
}

class FuncClass extends ConstructType {
  constructor(argTypes, retTypes, annotations = []) {
    super();
    this.argTypes = argTypes;
    this.retTypes = retTypes;
    this.annotations = annotations;
  }
  static argsToString(types, v) {
    if (types.length !== v.length) {
      throw new Error("arity mismatch");
    }
    return "(" + types.map((t2, i) => t2.valueToString(v[i])).join(", ") + ")";
  }
  accept(v, d) {
    return v.visitFunc(this, d);
  }
  covariant(x) {
    if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === "string")
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue([principal2, methodName]) {
    const buf = principal2.toUint8Array();
    const len = lebEncode(buf.byteLength);
    const canister = concat(new Uint8Array([1]), len, buf);
    const method = new TextEncoder().encode(methodName);
    const methodLen = lebEncode(method.byteLength);
    return concat(new Uint8Array([1]), canister, methodLen, method);
  }
  _buildTypeTableImpl(T) {
    this.argTypes.forEach((arg) => arg.buildTypeTable(T));
    this.retTypes.forEach((arg) => arg.buildTypeTable(T));
    const opCode = slebEncode(-22);
    const argLen = lebEncode(this.argTypes.length);
    const args = concat(...this.argTypes.map((arg) => arg.encodeType(T)));
    const retLen = lebEncode(this.retTypes.length);
    const rets = concat(...this.retTypes.map((arg) => arg.encodeType(T)));
    const annLen = lebEncode(this.annotations.length);
    const anns = concat(...this.annotations.map((a) => this.encodeAnnotation(a)));
    T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));
  }
  decodeValue(b) {
    const x = safeReadUint8(b);
    if (x !== 1) {
      throw new Error("Cannot decode function reference");
    }
    const canister = decodePrincipalId(b);
    const mLen = Number(lebDecode(b));
    const buf = safeRead(b, mLen);
    const decoder = new TextDecoder("utf8", { fatal: true });
    const method = decoder.decode(buf);
    return [canister, method];
  }
  get name() {
    const args = this.argTypes.map((arg) => arg.name).join(", ");
    const rets = this.retTypes.map((arg) => arg.name).join(", ");
    const annon = " " + this.annotations.join(" ");
    return `(${args}) -> (${rets})${annon}`;
  }
  valueToString([principal2, str]) {
    return `func "${principal2.toText()}".${str}`;
  }
  display() {
    const args = this.argTypes.map((arg) => arg.display()).join(", ");
    const rets = this.retTypes.map((arg) => arg.display()).join(", ");
    const annon = " " + this.annotations.join(" ");
    return `(${args}) \u2192 (${rets})${annon}`;
  }
  encodeAnnotation(ann) {
    if (ann === "query") {
      return new Uint8Array([1]);
    } else if (ann === "oneway") {
      return new Uint8Array([2]);
    } else if (ann === "composite_query") {
      return new Uint8Array([3]);
    } else {
      throw new Error("Illegal function annotation");
    }
  }
}

class ServiceClass extends ConstructType {
  constructor(fields) {
    super();
    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));
  }
  accept(v, d) {
    return v.visitService(this, d);
  }
  covariant(x) {
    if (x && x._isPrincipal)
      return true;
    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);
  }
  encodeValue(x) {
    const buf = x.toUint8Array();
    const len = lebEncode(buf.length);
    return concat(new Uint8Array([1]), len, buf);
  }
  _buildTypeTableImpl(T) {
    this._fields.forEach(([_, func]) => func.buildTypeTable(T));
    const opCode = slebEncode(-23);
    const len = lebEncode(this._fields.length);
    const meths = this._fields.map(([label, func]) => {
      const labelBuf = new TextEncoder().encode(label);
      const labelLen = lebEncode(labelBuf.length);
      return concat(labelLen, labelBuf, func.encodeType(T));
    });
    T.add(this, concat(opCode, len, ...meths));
  }
  decodeValue(b) {
    return decodePrincipalId(b);
  }
  get name() {
    const fields = this._fields.map(([key, value]) => key + ":" + value.name);
    return `service {${fields.join("; ")}}`;
  }
  valueToString(x) {
    return `service "${x.toText()}"`;
  }
}
var zipWith, decodePrincipalId, toReadableString, magicNumber, toReadableString_max, Empty, Reserved, Unknown, Bool, Null, Text, Int, Nat, Float32, Float64, Int8, Int16, Int32, Int64, Nat8, Nat16, Nat32, Nat64, Principal2;
var init_idl = __esm(() => {
  init_esm();
  init_buffer();
  init_hash();
  init_leb128();
  init_bigint_math();
  zipWith = function(xs, ys, f) {
    return xs.map((x, i) => f(x, ys[i]));
  };
  decodePrincipalId = function(b) {
    const x = safeReadUint8(b);
    if (x !== 1) {
      throw new Error("Cannot decode principal");
    }
    const len = Number(lebDecode(b));
    return Principal.fromUint8Array(new Uint8Array(safeRead(b, len)));
  };
  toReadableString = function(x) {
    const str = JSON.stringify(x, (_key, value) => typeof value === "bigint" ? `BigInt(${value})` : value);
    return str && str.length > toReadableString_max ? str.substring(0, toReadableString_max - 3) + "..." : str;
  };
  magicNumber = "DIDL";
  toReadableString_max = 400;
  RecClass._counter = 0;
  Empty = new EmptyClass;
  Reserved = new ReservedClass;
  Unknown = new UnknownClass;
  Bool = new BoolClass;
  Null = new NullClass;
  Text = new TextClass;
  Int = new IntClass;
  Nat = new NatClass;
  Float32 = new FloatClass(32);
  Float64 = new FloatClass(64);
  Int8 = new FixedIntClass(8);
  Int16 = new FixedIntClass(16);
  Int32 = new FixedIntClass(32);
  Int64 = new FixedIntClass(64);
  Nat8 = new FixedNatClass(8);
  Nat16 = new FixedNatClass(16);
  Nat32 = new FixedNatClass(32);
  Nat64 = new FixedNatClass(64);
  Principal2 = new PrincipalClass;
});

// node_modules/@dfinity/candid/lib/esm/candid-core.js
var init_candid_core = __esm(() => {
});

// node_modules/@dfinity/candid/lib/esm/candid-ui.js
var init_candid_ui = __esm(() => {
  init_idl();
  init_esm();
  init_candid_core();
});

// node_modules/@dfinity/candid/lib/esm/types.js
var init_types = __esm(() => {
});

// node_modules/@dfinity/candid/lib/esm/index.js
var init_esm2 = __esm(() => {
  init_candid_ui();
  init_candid_core();
  init_idl();
  init_hash();
  init_leb128();
  init_buffer();
  init_types();
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS((exports) => {
  var getLens = function(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  };
  var byteLength = function(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  };
  var _byteLength = function(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  };
  var toByteArray = function(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0;i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  };
  var tripletToBase64 = function(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  };
  var encodeChunk = function(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start;i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  };
  var fromByteArray = function(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes;i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  };
  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (i = 0, len = code.length;i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  var i;
  var len;
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS((exports) => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  exports.read = function(buffer4, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s2 = buffer4[offset + i];
    i += d;
    e = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (;nBits > 0; e = e * 256 + buffer4[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (;nBits > 0; m = m * 256 + buffer4[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s2 ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer4, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (;mLen >= 8; buffer4[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (;eLen > 0; buffer4[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer4[offset + i - d] |= s2 * 128;
  };
});

// node_modules/@dfinity/agent/lib/esm/errors.js
class AgentError extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    Object.setPrototypeOf(this, AgentError.prototype);
  }
}
var init_errors = __esm(() => {
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS((exports, module) => {
  (function(globalObject) {
    var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 100000000000000, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1000, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 10000000000, 100000000000, 1000000000000, 10000000000000], SQRT_BASE = 1e7, MAX = 1e9;
    function clone(configObject) {
      var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "\xA0",
        suffix: ""
      }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
      function BigNumber2(v, b) {
        var alphabet2, c, caseChanged, e, i, isNum, len, str, x = this;
        if (!(x instanceof BigNumber2))
          return new BigNumber2(v, b);
        if (b == null) {
          if (v && v._isBigNumber === true) {
            x.s = v.s;
            if (!v.c || v.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (v.e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = v.e;
              x.c = v.c.slice();
            }
            return;
          }
          if ((isNum = typeof v == "number") && v * 0 == 0) {
            x.s = 1 / v < 0 ? (v = -v, -1) : 1;
            if (v === ~~v) {
              for (e = 0, i = v;i >= 10; i /= 10, e++)
                ;
              if (e > MAX_EXP) {
                x.c = x.e = null;
              } else {
                x.e = e;
                x.c = [v];
              }
              return;
            }
            str = String(v);
          } else {
            if (!isNumeric.test(str = String(v)))
              return parseNumeric(x, str, isNum);
            x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0)
              e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
        } else {
          intCheck(b, 2, ALPHABET.length, "Base");
          if (b == 10 && alphabetHasNormalDecimalDigits) {
            x = new BigNumber2(v);
            return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
          }
          str = String(v);
          if (isNum = typeof v == "number") {
            if (v * 0 != 0)
              return parseNumeric(x, str, isNum, b);
            x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v);
            }
          } else {
            x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet2 = ALPHABET.slice(0, b);
          e = i = 0;
          for (len = str.length;i < len; i++) {
            if (alphabet2.indexOf(c = str.charAt(i)) < 0) {
              if (c == ".") {
                if (i > e) {
                  e = len;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i = -1;
                  e = 0;
                  continue;
                }
              }
              return parseNumeric(x, String(v), isNum, b);
            }
          }
          isNum = false;
          str = convertBase(str, b, 10, x.s);
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          else
            e = str.length;
        }
        for (i = 0;str.charCodeAt(i) === 48; i++)
          ;
        for (len = str.length;str.charCodeAt(--len) === 48; )
          ;
        if (str = str.slice(i, ++len)) {
          len -= i;
          if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error(tooManyDigits + x.s * v);
          }
          if ((e = e - i - 1) > MAX_EXP) {
            x.c = x.e = null;
          } else if (e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = e;
            x.c = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0)
              i += LOG_BASE;
            if (i < len) {
              if (i)
                x.c.push(+str.slice(0, i));
              for (len -= LOG_BASE;i < len; ) {
                x.c.push(+str.slice(i, i += LOG_BASE));
              }
              i = LOG_BASE - (str = str.slice(i)).length;
            } else {
              i -= len;
            }
            for (;i--; str += "0")
              ;
            x.c.push(+str);
          }
        } else {
          x.c = [x.e = 0];
        }
      }
      BigNumber2.clone = clone;
      BigNumber2.ROUND_UP = 0;
      BigNumber2.ROUND_DOWN = 1;
      BigNumber2.ROUND_CEIL = 2;
      BigNumber2.ROUND_FLOOR = 3;
      BigNumber2.ROUND_HALF_UP = 4;
      BigNumber2.ROUND_HALF_DOWN = 5;
      BigNumber2.ROUND_HALF_EVEN = 6;
      BigNumber2.ROUND_HALF_CEIL = 7;
      BigNumber2.ROUND_HALF_FLOOR = 8;
      BigNumber2.EUCLID = 9;
      BigNumber2.config = BigNumber2.set = function(obj) {
        var p, v;
        if (obj != null) {
          if (typeof obj == "object") {
            if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              DECIMAL_PLACES = v;
            }
            if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
              v = obj[p];
              intCheck(v, 0, 8, p);
              ROUNDING_MODE = v;
            }
            if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, 0, p);
                intCheck(v[1], 0, MAX, p);
                TO_EXP_NEG = v[0];
                TO_EXP_POS = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
              }
            }
            if (obj.hasOwnProperty(p = "RANGE")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, -1, p);
                intCheck(v[1], 1, MAX, p);
                MIN_EXP = v[0];
                MAX_EXP = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                if (v) {
                  MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                } else {
                  throw Error(bignumberError + p + " cannot be zero: " + v);
                }
              }
            }
            if (obj.hasOwnProperty(p = "CRYPTO")) {
              v = obj[p];
              if (v === !!v) {
                if (v) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v;
                  } else {
                    CRYPTO = !v;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v;
                }
              } else {
                throw Error(bignumberError + p + " not true or false: " + v);
              }
            }
            if (obj.hasOwnProperty(p = "MODULO_MODE")) {
              v = obj[p];
              intCheck(v, 0, 9, p);
              MODULO_MODE = v;
            }
            if (obj.hasOwnProperty(p = "POW_PRECISION")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              POW_PRECISION = v;
            }
            if (obj.hasOwnProperty(p = "FORMAT")) {
              v = obj[p];
              if (typeof v == "object")
                FORMAT = v;
              else
                throw Error(bignumberError + p + " not an object: " + v);
            }
            if (obj.hasOwnProperty(p = "ALPHABET")) {
              v = obj[p];
              if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                ALPHABET = v;
              } else {
                throw Error(bignumberError + p + " invalid: " + v);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj);
          }
        }
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET
        };
      };
      BigNumber2.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true)
          return false;
        if (!BigNumber2.DEBUG)
          return true;
        var i, n, c = v.c, e = v.e, s2 = v.s;
        out:
          if ({}.toString.call(c) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1)
                  return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1)
                i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0;i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n))
                    break out;
                }
                if (n !== 0)
                  return true;
              }
            }
          } else if (c === null && e === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
        throw Error(bignumberError + "Invalid BigNumber: " + v);
      };
      BigNumber2.maximum = BigNumber2.max = function() {
        return maxOrMin(arguments, -1);
      };
      BigNumber2.minimum = BigNumber2.min = function() {
        return maxOrMin(arguments, 1);
      };
      BigNumber2.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
          if (dp == null)
            dp = DECIMAL_PLACES;
          else
            intCheck(dp, 0, MAX);
          k = mathceil(dp / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a = crypto.getRandomValues(new Uint32Array(k *= 2));
              for (;i < k; ) {
                v = a[i] * 131072 + (a[i + 1] >>> 11);
                if (v >= 9000000000000000) {
                  b = crypto.getRandomValues(new Uint32Array(2));
                  a[i] = b[0];
                  a[i + 1] = b[1];
                } else {
                  c.push(v % 100000000000000);
                  i += 2;
                }
              }
              i = k / 2;
            } else if (crypto.randomBytes) {
              a = crypto.randomBytes(k *= 7);
              for (;i < k; ) {
                v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                if (v >= 9000000000000000) {
                  crypto.randomBytes(7).copy(a, i);
                } else {
                  c.push(v % 100000000000000);
                  i += 7;
                }
              }
              i = k / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (;i < k; ) {
              v = random53bitInt();
              if (v < 9000000000000000)
                c[i++] = v % 100000000000000;
            }
          }
          k = c[--i];
          dp %= LOG_BASE;
          if (k && dp) {
            v = POWS_TEN[LOG_BASE - dp];
            c[i] = mathfloor(k / v) * v;
          }
          for (;c[i] === 0; c.pop(), i--)
            ;
          if (i < 0) {
            c = [e = 0];
          } else {
            for (e = -1;c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
              ;
            for (i = 1, v = c[0];v >= 10; v /= 10, i++)
              ;
            if (i < LOG_BASE)
              e -= LOG_BASE - i;
          }
          rand.e = e;
          rand.c = c;
          return rand;
        };
      }();
      BigNumber2.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber2(args[0]);
        for (;i < args.length; )
          sum = sum.plus(args[i++]);
        return sum;
      };
      convertBase = function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet2) {
          var j, arr = [0], arrL, i = 0, len = str.length;
          for (;i < len; ) {
            for (arrL = arr.length;arrL--; arr[arrL] *= baseIn)
              ;
            arr[0] += alphabet2.indexOf(str.charAt(i++));
            for (j = 0;j < arr.length; j++) {
              if (arr[j] > baseOut - 1) {
                if (arr[j + 1] == null)
                  arr[j + 1] = 0;
                arr[j + 1] += arr[j] / baseOut | 0;
                arr[j] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign, callerIsToString) {
          var alphabet2, d, e, k, r, x, xc, y2, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (i >= 0) {
            k = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y2 = new BigNumber2(baseIn);
            x = y2.pow(str.length - i);
            POW_PRECISION = k;
            y2.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
            y2.e = y2.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET, decimal) : (alphabet2 = decimal, ALPHABET));
          e = k = xc.length;
          for (;xc[--k] == 0; xc.pop())
            ;
          if (!xc[0])
            return alphabet2.charAt(0);
          if (i < 0) {
            --e;
          } else {
            x.c = xc;
            x.e = e;
            x.s = sign;
            x = div(x, y2, dp, rm, baseOut);
            xc = x.c;
            r = x.r;
            e = x.e;
          }
          d = e + dp + 1;
          i = xc[d];
          k = baseOut / 2;
          r = r || d < 0 || xc[d + 1] != null;
          r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
          if (d < 1 || !xc[0]) {
            str = r ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
          } else {
            xc.length = d;
            if (r) {
              for (--baseOut;++xc[--d] > baseOut; ) {
                xc[d] = 0;
                if (!d) {
                  ++e;
                  xc = [1].concat(xc);
                }
              }
            }
            for (k = xc.length;!xc[--k]; )
              ;
            for (i = 0, str = "";i <= k; str += alphabet2.charAt(xc[i++]))
              ;
            str = toFixedPoint(str, e, alphabet2.charAt(0));
          }
          return str;
        };
      }();
      div = function() {
        function multiply(x, k, base) {
          var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
          for (x = x.slice();i--; ) {
            xlo = x[i] % SQRT_BASE;
            xhi = x[i] / SQRT_BASE | 0;
            m = khi * xlo + xhi * klo;
            temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
            x[i] = temp % base;
          }
          if (carry)
            x = [carry].concat(x);
          return x;
        }
        function compare4(a, b, aL, bL) {
          var i, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i = cmp = 0;i < aL; i++) {
              if (a[i] != b[i]) {
                cmp = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract(a, b, aL, base) {
          var i = 0;
          for (;aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (;!a[0] && a.length > 1; a.splice(0, 1))
            ;
        }
        return function(x, y2, dp, rm, base) {
          var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x.s == y2.s ? 1 : -1, xc = x.c, yc = y2.c;
          if (!xc || !xc[0] || !yc || !yc[0]) {
            return new BigNumber2(!x.s || !y2.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0);
          }
          q = new BigNumber2(s2);
          qc = q.c = [];
          e = x.e - y2.e;
          s2 = dp + e + 1;
          if (!base) {
            base = BASE;
            e = bitFloor(x.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
            s2 = s2 / LOG_BASE | 0;
          }
          for (i = 0;yc[i] == (xc[i] || 0); i++)
            ;
          if (yc[i] > (xc[i] || 0))
            e--;
          if (s2 < 0) {
            qc.push(1);
            more = true;
          } else {
            xL = xc.length;
            yL = yc.length;
            i = 0;
            s2 += 2;
            n = mathfloor(base / (yc[0] + 1));
            if (n > 1) {
              yc = multiply(yc, n, base);
              xc = multiply(xc, n, base);
              yL = yc.length;
              xL = xc.length;
            }
            xi = yL;
            rem = xc.slice(0, yL);
            remL = rem.length;
            for (;remL < yL; rem[remL++] = 0)
              ;
            yz = yc.slice();
            yz = [0].concat(yz);
            yc0 = yc[0];
            if (yc[1] >= base / 2)
              yc0++;
            do {
              n = 0;
              cmp = compare4(yc, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base + (rem[1] || 0);
                n = mathfloor(rem0 / yc0);
                if (n > 1) {
                  if (n >= base)
                    n = base - 1;
                  prod = multiply(yc, n, base);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare4(prod, rem, prodL, remL) == 1) {
                    n--;
                    subtract(prod, yL < prodL ? yz : yc, prodL, base);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n == 0) {
                    cmp = n = 1;
                  }
                  prod = yc.slice();
                  prodL = prod.length;
                }
                if (prodL < remL)
                  prod = [0].concat(prod);
                subtract(rem, prod, remL, base);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare4(yc, rem, yL, remL) < 1) {
                    n++;
                    subtract(rem, yL < remL ? yz : yc, remL, base);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n++;
                rem = [0];
              }
              qc[i++] = n;
              if (rem[0]) {
                rem[remL++] = xc[xi] || 0;
              } else {
                rem = [xc[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] != null) && s2--);
            more = rem[0] != null;
            if (!qc[0])
              qc.splice(0, 1);
          }
          if (base == BASE) {
            for (i = 1, s2 = qc[0];s2 >= 10; s2 /= 10, i++)
              ;
            round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
          } else {
            q.e = e;
            q.r = +more;
          }
          return q;
        };
      }();
      function format(n, i, rm, id) {
        var c0, e, ne, len, str;
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        if (!n.c)
          return n.toString();
        c0 = n.c[0];
        ne = n.e;
        if (i == null) {
          str = coeffToString(n.c);
          str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
        } else {
          n = round(new BigNumber2(n), i, rm);
          e = n.e;
          str = coeffToString(n.c);
          len = str.length;
          if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
            for (;len < i; str += "0", len++)
              ;
            str = toExponential(str, e);
          } else {
            i -= ne;
            str = toFixedPoint(str, e, "0");
            if (e + 1 > len) {
              if (--i > 0)
                for (str += ".";i--; str += "0")
                  ;
            } else {
              i += e - len;
              if (i > 0) {
                if (e + 1 == len)
                  str += ".";
                for (;i--; str += "0")
                  ;
              }
            }
          }
        }
        return n.s < 0 && c0 ? "-" + str : str;
      }
      function maxOrMin(args, n) {
        var k, y2, i = 1, x = new BigNumber2(args[0]);
        for (;i < args.length; i++) {
          y2 = new BigNumber2(args[i]);
          if (!y2.s || (k = compare3(x, y2)) === n || k === 0 && x.s === n) {
            x = y2;
          }
        }
        return x;
      }
      function normalise(n, c, e) {
        var i = 1, j = c.length;
        for (;!c[--j]; c.pop())
          ;
        for (j = c[0];j >= 10; j /= 10, i++)
          ;
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
          n.c = n.e = null;
        } else if (e < MIN_EXP) {
          n.c = [n.e = 0];
        } else {
          n.e = e;
          n.c = c;
        }
        return n;
      }
      parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, str, isNum, b) {
          var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s2)) {
            x.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s2 = s2.replace(basePrefix, function(m, p1, p2) {
                base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b || b == base ? p1 : m;
              });
              if (b) {
                base = b;
                s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s2)
                return new BigNumber2(s2, base);
            }
            if (BigNumber2.DEBUG) {
              throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
            }
            x.s = null;
          }
          x.c = x.e = null;
        };
      }();
      function round(x, sd, rm, r) {
        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
        if (xc) {
          out: {
            for (d = 1, k = xc[0];k >= 10; k /= 10, d++)
              ;
            i = sd - d;
            if (i < 0) {
              i += LOG_BASE;
              j = sd;
              n = xc[ni = 0];
              rd = mathfloor(n / pows10[d - j - 1] % 10);
            } else {
              ni = mathceil((i + 1) / LOG_BASE);
              if (ni >= xc.length) {
                if (r) {
                  for (;xc.length <= ni; xc.push(0))
                    ;
                  n = rd = 0;
                  d = 1;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n = k = xc[ni];
                for (d = 1;k >= 10; k /= 10, d++)
                  ;
                i %= LOG_BASE;
                j = i - LOG_BASE + d;
                rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
              }
            }
            r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
            r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xc[0]) {
              xc.length = 0;
              if (r) {
                sd -= x.e + 1;
                xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                x.e = -sd || 0;
              } else {
                xc[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xc.length = ni;
              k = 1;
              ni--;
            } else {
              xc.length = ni + 1;
              k = pows10[LOG_BASE - i];
              xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
            }
            if (r) {
              for (;; ) {
                if (ni == 0) {
                  for (i = 1, j = xc[0];j >= 10; j /= 10, i++)
                    ;
                  j = xc[0] += k;
                  for (k = 1;j >= 10; j /= 10, k++)
                    ;
                  if (i != k) {
                    x.e++;
                    if (xc[0] == BASE)
                      xc[0] = 1;
                  }
                  break;
                } else {
                  xc[ni] += k;
                  if (xc[ni] != BASE)
                    break;
                  xc[ni--] = 0;
                  k = 1;
                }
              }
            }
            for (i = xc.length;xc[--i] === 0; xc.pop())
              ;
          }
          if (x.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (x.e < MIN_EXP) {
            x.c = [x.e = 0];
          }
        }
        return x;
      }
      function valueOf(n) {
        var str, e = n.e;
        if (e === null)
          return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
        return n.s < 0 ? "-" + str : str;
      }
      P.absoluteValue = P.abs = function() {
        var x = new BigNumber2(this);
        if (x.s < 0)
          x.s = 1;
        return x;
      };
      P.comparedTo = function(y2, b) {
        return compare3(this, new BigNumber2(y2, b));
      };
      P.decimalPlaces = P.dp = function(dp, rm) {
        var c, n, v, x = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber2(x), dp + x.e + 1, rm);
        }
        if (!(c = x.c))
          return null;
        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v = c[v])
          for (;v % 10 == 0; v /= 10, n--)
            ;
        if (n < 0)
          n = 0;
        return n;
      };
      P.dividedBy = P.div = function(y2, b) {
        return div(this, new BigNumber2(y2, b), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P.dividedToIntegerBy = P.idiv = function(y2, b) {
        return div(this, new BigNumber2(y2, b), 0, 1);
      };
      P.exponentiatedBy = P.pow = function(n, m) {
        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y2, x = this;
        n = new BigNumber2(n);
        if (n.c && !n.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
        }
        if (m != null)
          m = new BigNumber2(m);
        nIsBig = n.e > 14;
        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
          y2 = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
          return m ? y2.mod(m) : y2;
        }
        nIsNeg = n.s < 0;
        if (m) {
          if (m.c ? !m.c[0] : !m.s)
            return new BigNumber2(NaN);
          isModExp = !nIsNeg && x.isInteger() && m.isInteger();
          if (isModExp)
            x = x.mod(m);
        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 240000000 : x.c[0] < 80000000000000 || nIsBig && x.c[0] <= 99999750000000))) {
          k = x.s < 0 && isOdd(n) ? -0 : 0;
          if (x.e > -1)
            k = 1 / k;
          return new BigNumber2(nIsNeg ? 1 / k : k);
        } else if (POW_PRECISION) {
          k = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber2(0.5);
          if (nIsNeg)
            n.s = 1;
          nIsOdd = isOdd(n);
        } else {
          i = Math.abs(+valueOf(n));
          nIsOdd = i % 2;
        }
        y2 = new BigNumber2(ONE);
        for (;; ) {
          if (nIsOdd) {
            y2 = y2.times(x);
            if (!y2.c)
              break;
            if (k) {
              if (y2.c.length > k)
                y2.c.length = k;
            } else if (isModExp) {
              y2 = y2.mod(m);
            }
          }
          if (i) {
            i = mathfloor(i / 2);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          } else {
            n = n.times(half);
            round(n, n.e + 1, 1);
            if (n.e > 14) {
              nIsOdd = isOdd(n);
            } else {
              i = +valueOf(n);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            }
          }
          x = x.times(x);
          if (k) {
            if (x.c && x.c.length > k)
              x.c.length = k;
          } else if (isModExp) {
            x = x.mod(m);
          }
        }
        if (isModExp)
          return y2;
        if (nIsNeg)
          y2 = ONE.div(y2);
        return m ? y2.mod(m) : k ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
      };
      P.integerValue = function(rm) {
        var n = new BigNumber2(this);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(n, n.e + 1, rm);
      };
      P.isEqualTo = P.eq = function(y2, b) {
        return compare3(this, new BigNumber2(y2, b)) === 0;
      };
      P.isFinite = function() {
        return !!this.c;
      };
      P.isGreaterThan = P.gt = function(y2, b) {
        return compare3(this, new BigNumber2(y2, b)) > 0;
      };
      P.isGreaterThanOrEqualTo = P.gte = function(y2, b) {
        return (b = compare3(this, new BigNumber2(y2, b))) === 1 || b === 0;
      };
      P.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P.isLessThan = P.lt = function(y2, b) {
        return compare3(this, new BigNumber2(y2, b)) < 0;
      };
      P.isLessThanOrEqualTo = P.lte = function(y2, b) {
        return (b = compare3(this, new BigNumber2(y2, b))) === -1 || b === 0;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = function() {
        return this.s < 0;
      };
      P.isPositive = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P.minus = function(y2, b) {
        var i, j, t2, xLTy, x = this, a = x.s;
        y2 = new BigNumber2(y2, b);
        b = y2.s;
        if (!a || !b)
          return new BigNumber2(NaN);
        if (a != b) {
          y2.s = -b;
          return x.plus(y2);
        }
        var xe = x.e / LOG_BASE, ye = y2.e / LOG_BASE, xc = x.c, yc = y2.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return xc ? (y2.s = -b, y2) : new BigNumber2(yc ? x : NaN);
          if (!xc[0] || !yc[0]) {
            return yc[0] ? (y2.s = -b, y2) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
          }
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (xLTy = a < 0) {
            a = -a;
            t2 = xc;
          } else {
            ye = xe;
            t2 = yc;
          }
          t2.reverse();
          for (b = a;b--; t2.push(0))
            ;
          t2.reverse();
        } else {
          j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
          for (a = b = 0;b < j; b++) {
            if (xc[b] != yc[b]) {
              xLTy = xc[b] < yc[b];
              break;
            }
          }
        }
        if (xLTy) {
          t2 = xc;
          xc = yc;
          yc = t2;
          y2.s = -y2.s;
        }
        b = (j = yc.length) - (i = xc.length);
        if (b > 0)
          for (;b--; xc[i++] = 0)
            ;
        b = BASE - 1;
        for (;j > a; ) {
          if (xc[--j] < yc[j]) {
            for (i = j;i && !xc[--i]; xc[i] = b)
              ;
            --xc[i];
            xc[j] += BASE;
          }
          xc[j] -= yc[j];
        }
        for (;xc[0] == 0; xc.splice(0, 1), --ye)
          ;
        if (!xc[0]) {
          y2.s = ROUNDING_MODE == 3 ? -1 : 1;
          y2.c = [y2.e = 0];
          return y2;
        }
        return normalise(y2, xc, ye);
      };
      P.modulo = P.mod = function(y2, b) {
        var q, s2, x = this;
        y2 = new BigNumber2(y2, b);
        if (!x.c || !y2.s || y2.c && !y2.c[0]) {
          return new BigNumber2(NaN);
        } else if (!y2.c || x.c && !x.c[0]) {
          return new BigNumber2(x);
        }
        if (MODULO_MODE == 9) {
          s2 = y2.s;
          y2.s = 1;
          q = div(x, y2, 0, 3);
          y2.s = s2;
          q.s *= s2;
        } else {
          q = div(x, y2, 0, MODULO_MODE);
        }
        y2 = x.minus(q.times(y2));
        if (!y2.c[0] && MODULO_MODE == 1)
          y2.s = x.s;
        return y2;
      };
      P.multipliedBy = P.times = function(y2, b) {
        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y2 = new BigNumber2(y2, b)).c;
        if (!xc || !yc || !xc[0] || !yc[0]) {
          if (!x.s || !y2.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
            y2.c = y2.e = y2.s = null;
          } else {
            y2.s *= x.s;
            if (!xc || !yc) {
              y2.c = y2.e = null;
            } else {
              y2.c = [0];
              y2.e = 0;
            }
          }
          return y2;
        }
        e = bitFloor(x.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
        y2.s *= x.s;
        xcL = xc.length;
        ycL = yc.length;
        if (xcL < ycL) {
          zc = xc;
          xc = yc;
          yc = zc;
          i = xcL;
          xcL = ycL;
          ycL = i;
        }
        for (i = xcL + ycL, zc = [];i--; zc.push(0))
          ;
        base = BASE;
        sqrtBase = SQRT_BASE;
        for (i = ycL;--i >= 0; ) {
          c = 0;
          ylo = yc[i] % sqrtBase;
          yhi = yc[i] / sqrtBase | 0;
          for (k = xcL, j = i + k;j > i; ) {
            xlo = xc[--k] % sqrtBase;
            xhi = xc[k] / sqrtBase | 0;
            m = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
            c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
            zc[j--] = xlo % base;
          }
          zc[j] = c;
        }
        if (c) {
          ++e;
        } else {
          zc.splice(0, 1);
        }
        return normalise(y2, zc, e);
      };
      P.negated = function() {
        var x = new BigNumber2(this);
        x.s = -x.s || null;
        return x;
      };
      P.plus = function(y2, b) {
        var t2, x = this, a = x.s;
        y2 = new BigNumber2(y2, b);
        b = y2.s;
        if (!a || !b)
          return new BigNumber2(NaN);
        if (a != b) {
          y2.s = -b;
          return x.minus(y2);
        }
        var xe = x.e / LOG_BASE, ye = y2.e / LOG_BASE, xc = x.c, yc = y2.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return new BigNumber2(a / 0);
          if (!xc[0] || !yc[0])
            return yc[0] ? y2 : new BigNumber2(xc[0] ? x : a * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (a > 0) {
            ye = xe;
            t2 = yc;
          } else {
            a = -a;
            t2 = xc;
          }
          t2.reverse();
          for (;a--; t2.push(0))
            ;
          t2.reverse();
        }
        a = xc.length;
        b = yc.length;
        if (a - b < 0) {
          t2 = yc;
          yc = xc;
          xc = t2;
          b = a;
        }
        for (a = 0;b; ) {
          a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
          xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
        }
        if (a) {
          xc = [a].concat(xc);
          ++ye;
        }
        return normalise(y2, xc, ye);
      };
      P.precision = P.sd = function(sd, rm) {
        var c, n, v, x = this;
        if (sd != null && sd !== !!sd) {
          intCheck(sd, 1, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber2(x), sd, rm);
        }
        if (!(c = x.c))
          return null;
        v = c.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c[v]) {
          for (;v % 10 == 0; v /= 10, n--)
            ;
          for (v = c[0];v >= 10; v /= 10, n++)
            ;
        }
        if (sd && x.e + 1 > n)
          n = x.e + 1;
        return n;
      };
      P.shiftedBy = function(k) {
        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times("1e" + k);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, r, rep, t2, x = this, c = x.c, s2 = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
        if (s2 !== 1 || !c || !c[0]) {
          return new BigNumber2(!s2 || s2 < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
        }
        s2 = Math.sqrt(+valueOf(x));
        if (s2 == 0 || s2 == 1 / 0) {
          n = coeffToString(c);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s2 = Math.sqrt(+n);
          e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s2 == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s2.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new BigNumber2(n);
        } else {
          r = new BigNumber2(s2 + "");
        }
        if (r.c[0]) {
          e = r.e;
          s2 = e + dp;
          if (s2 < 3)
            s2 = 0;
          for (;; ) {
            t2 = r;
            r = half.times(t2.plus(div(x, t2, dp, 1)));
            if (coeffToString(t2.c).slice(0, s2) === (n = coeffToString(r.c)).slice(0, s2)) {
              if (r.e < e)
                --s2;
              n = n.slice(s2 - 3, s2 + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  round(t2, t2.e + DECIMAL_PLACES + 2, 0);
                  if (t2.times(t2).eq(x)) {
                    r = t2;
                    break;
                  }
                }
                dp += 4;
                s2 += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  round(r, r.e + DECIMAL_PLACES + 2, 1);
                  m = !r.times(r).eq(x);
                }
                break;
              }
            }
          }
        }
        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
      };
      P.toExponential = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format(this, dp, rm, 1);
      };
      P.toFixed = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format(this, dp, rm);
      };
      P.toFormat = function(dp, rm, format2) {
        var str, x = this;
        if (format2 == null) {
          if (dp != null && rm && typeof rm == "object") {
            format2 = rm;
            rm = null;
          } else if (dp && typeof dp == "object") {
            format2 = dp;
            dp = rm = null;
          } else {
            format2 = FORMAT;
          }
        } else if (typeof format2 != "object") {
          throw Error(bignumberError + "Argument not an object: " + format2);
        }
        str = x.toFixed(dp, rm);
        if (x.c) {
          var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
          if (g2) {
            i = g1;
            g1 = g2;
            g2 = i;
            len -= i;
          }
          if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);
            for (;i < len; i += g1)
              intPart += groupSeparator + intDigits.substr(i, g1);
            if (g2 > 0)
              intPart += groupSeparator + intDigits.slice(i);
            if (isNeg)
              intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
        }
        return (format2.prefix || "") + str + (format2.suffix || "");
      };
      P.toFraction = function(md) {
        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s2, x = this, xc = x.c;
        if (md != null) {
          n = new BigNumber2(md);
          if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
            throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
          }
        }
        if (!xc)
          return new BigNumber2(x);
        d = new BigNumber2(ONE);
        n1 = d0 = new BigNumber2(ONE);
        d1 = n0 = new BigNumber2(ONE);
        s2 = coeffToString(xc);
        e = d.e = s2.length - x.e - 1;
        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber2(s2);
        n0.c[0] = 0;
        for (;; ) {
          q = div(n, d, 0, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.comparedTo(md) == 1)
            break;
          d0 = d1;
          d1 = d2;
          n1 = n0.plus(q.times(d2 = n1));
          n0 = d2;
          d = n.minus(q.times(d2 = d));
          n = d2;
        }
        d2 = div(md.minus(d0), d1, 0, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        e = e * 2;
        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        MAX_EXP = exp;
        return r;
      };
      P.toNumber = function() {
        return +valueOf(this);
      };
      P.toPrecision = function(sd, rm) {
        if (sd != null)
          intCheck(sd, 1, MAX);
        return format(this, sd, rm, 2);
      };
      P.toString = function(b) {
        var str, n = this, s2 = n.s, e = n.e;
        if (e === null) {
          if (s2) {
            str = "Infinity";
            if (s2 < 0)
              str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b == null) {
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
          } else if (b === 10 && alphabetHasNormalDecimalDigits) {
            n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n.c), n.e, "0");
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s2, true);
          }
          if (s2 < 0 && n.c[0])
            str = "-" + str;
        }
        return str;
      };
      P.valueOf = P.toJSON = function() {
        return valueOf(this);
      };
      P._isBigNumber = true;
      if (configObject != null)
        BigNumber2.set(configObject);
      return BigNumber2;
    }
    function bitFloor(n) {
      var i = n | 0;
      return n > 0 || n === i ? i : i - 1;
    }
    function coeffToString(a) {
      var s2, z, i = 1, j = a.length, r = a[0] + "";
      for (;i < j; ) {
        s2 = a[i++] + "";
        z = LOG_BASE - s2.length;
        for (;z--; s2 = "0" + s2)
          ;
        r += s2;
      }
      for (j = r.length;r.charCodeAt(--j) === 48; )
        ;
      return r.slice(0, j + 1 || 1);
    }
    function compare3(x, y2) {
      var a, b, xc = x.c, yc = y2.c, i = x.s, j = y2.s, k = x.e, l = y2.e;
      if (!i || !j)
        return null;
      a = xc && !xc[0];
      b = yc && !yc[0];
      if (a || b)
        return a ? b ? 0 : -j : i;
      if (i != j)
        return i;
      a = i < 0;
      b = k == l;
      if (!xc || !yc)
        return b ? 0 : !xc ^ a ? 1 : -1;
      if (!b)
        return k > l ^ a ? 1 : -1;
      j = (k = xc.length) < (l = yc.length) ? k : l;
      for (i = 0;i < j; i++)
        if (xc[i] != yc[i])
          return xc[i] > yc[i] ^ a ? 1 : -1;
      return k == l ? 0 : k > l ^ a ? 1 : -1;
    }
    function intCheck(n, min, max, name) {
      if (n < min || n > max || n !== mathfloor(n)) {
        throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
      }
    }
    function isOdd(n) {
      var k = n.c.length - 1;
      return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
    }
    function toExponential(str, e) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z) {
      var len, zs;
      if (e < 0) {
        for (zs = z + ".";++e; zs += z)
          ;
        str = zs + str;
      } else {
        len = str.length;
        if (++e > len) {
          for (zs = z, e -= len;--e; zs += z)
            ;
          str += zs;
        } else if (e < len) {
          str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      return str;
    }
    BigNumber = clone();
    BigNumber["default"] = BigNumber.BigNumber = BigNumber;
    if (typeof define == "function" && define.amd) {
      define(function() {
        return BigNumber;
      });
    } else if (typeof module != "undefined" && exports) {
      module.exports = BigNumber;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber;
    }
  })(exports);
});

// node_modules/borc/src/decoder.asm.js
var require_decoder_asm = __commonJS((exports, module) => {
  module.exports = function decodeAsm(stdlib, foreign, buffer4) {
    var heap = new stdlib.Uint8Array(buffer4);
    var pushInt = foreign.pushInt;
    var pushInt32 = foreign.pushInt32;
    var pushInt32Neg = foreign.pushInt32Neg;
    var pushInt64 = foreign.pushInt64;
    var pushInt64Neg = foreign.pushInt64Neg;
    var pushFloat = foreign.pushFloat;
    var pushFloatSingle = foreign.pushFloatSingle;
    var pushFloatDouble = foreign.pushFloatDouble;
    var pushTrue = foreign.pushTrue;
    var pushFalse = foreign.pushFalse;
    var pushUndefined = foreign.pushUndefined;
    var pushNull = foreign.pushNull;
    var pushInfinity = foreign.pushInfinity;
    var pushInfinityNeg = foreign.pushInfinityNeg;
    var pushNaN = foreign.pushNaN;
    var pushNaNNeg = foreign.pushNaNNeg;
    var pushArrayStart = foreign.pushArrayStart;
    var pushArrayStartFixed = foreign.pushArrayStartFixed;
    var pushArrayStartFixed32 = foreign.pushArrayStartFixed32;
    var pushArrayStartFixed64 = foreign.pushArrayStartFixed64;
    var pushObjectStart = foreign.pushObjectStart;
    var pushObjectStartFixed = foreign.pushObjectStartFixed;
    var pushObjectStartFixed32 = foreign.pushObjectStartFixed32;
    var pushObjectStartFixed64 = foreign.pushObjectStartFixed64;
    var pushByteString = foreign.pushByteString;
    var pushByteStringStart = foreign.pushByteStringStart;
    var pushUtf8String = foreign.pushUtf8String;
    var pushUtf8StringStart = foreign.pushUtf8StringStart;
    var pushSimpleUnassigned = foreign.pushSimpleUnassigned;
    var pushTagStart = foreign.pushTagStart;
    var pushTagStart4 = foreign.pushTagStart4;
    var pushTagStart8 = foreign.pushTagStart8;
    var pushTagUnassigned = foreign.pushTagUnassigned;
    var pushBreak = foreign.pushBreak;
    var pow = stdlib.Math.pow;
    var offset = 0;
    var inputLength = 0;
    var code = 0;
    function parse(input) {
      input = input | 0;
      offset = 0;
      inputLength = input;
      while ((offset | 0) < (inputLength | 0)) {
        code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0;
        if ((code | 0) > 0) {
          break;
        }
      }
      return code | 0;
    }
    function checkOffset2(n) {
      n = n | 0;
      if (((offset | 0) + (n | 0) | 0) < (inputLength | 0)) {
        return 0;
      }
      return 1;
    }
    function readUInt16(n) {
      n = n | 0;
      return heap[n | 0] << 8 | heap[n + 1 | 0] | 0;
    }
    function readUInt32(n) {
      n = n | 0;
      return heap[n | 0] << 24 | heap[n + 1 | 0] << 16 | heap[n + 2 | 0] << 8 | heap[n + 3 | 0] | 0;
    }
    function INT_P(octet) {
      octet = octet | 0;
      pushInt(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function UINT_P_8(octet) {
      octet = octet | 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      pushInt(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function UINT_P_16(octet) {
      octet = octet | 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      pushInt(readUInt16(offset + 1 | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function UINT_P_32(octet) {
      octet = octet | 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      pushInt32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function UINT_P_64(octet) {
      octet = octet | 0;
      if (checkOffset2(8) | 0) {
        return 1;
      }
      pushInt64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function INT_N(octet) {
      octet = octet | 0;
      pushInt(-1 - (octet - 32 | 0) | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function UINT_N_8(octet) {
      octet = octet | 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      pushInt(-1 - (heap[offset + 1 | 0] | 0) | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function UINT_N_16(octet) {
      octet = octet | 0;
      var val = 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      val = readUInt16(offset + 1 | 0) | 0;
      pushInt(-1 - (val | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function UINT_N_32(octet) {
      octet = octet | 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      pushInt32Neg(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function UINT_N_64(octet) {
      octet = octet | 0;
      if (checkOffset2(8) | 0) {
        return 1;
      }
      pushInt64Neg(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function BYTE_STRING(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var step = 0;
      step = octet - 64 | 0;
      if (checkOffset2(step | 0) | 0) {
        return 1;
      }
      start = offset + 1 | 0;
      end = (offset + 1 | 0) + (step | 0) | 0;
      pushByteString(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function BYTE_STRING_8(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      length = heap[offset + 1 | 0] | 0;
      start = offset + 2 | 0;
      end = (offset + 2 | 0) + (length | 0) | 0;
      if (checkOffset2(length + 1 | 0) | 0) {
        return 1;
      }
      pushByteString(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function BYTE_STRING_16(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      length = readUInt16(offset + 1 | 0) | 0;
      start = offset + 3 | 0;
      end = (offset + 3 | 0) + (length | 0) | 0;
      if (checkOffset2(length + 2 | 0) | 0) {
        return 1;
      }
      pushByteString(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function BYTE_STRING_32(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      length = readUInt32(offset + 1 | 0) | 0;
      start = offset + 5 | 0;
      end = (offset + 5 | 0) + (length | 0) | 0;
      if (checkOffset2(length + 4 | 0) | 0) {
        return 1;
      }
      pushByteString(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function BYTE_STRING_64(octet) {
      octet = octet | 0;
      return 1;
    }
    function BYTE_STRING_BREAK(octet) {
      octet = octet | 0;
      pushByteStringStart();
      offset = offset + 1 | 0;
      return 0;
    }
    function UTF8_STRING(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var step = 0;
      step = octet - 96 | 0;
      if (checkOffset2(step | 0) | 0) {
        return 1;
      }
      start = offset + 1 | 0;
      end = (offset + 1 | 0) + (step | 0) | 0;
      pushUtf8String(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function UTF8_STRING_8(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      length = heap[offset + 1 | 0] | 0;
      start = offset + 2 | 0;
      end = (offset + 2 | 0) + (length | 0) | 0;
      if (checkOffset2(length + 1 | 0) | 0) {
        return 1;
      }
      pushUtf8String(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function UTF8_STRING_16(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      length = readUInt16(offset + 1 | 0) | 0;
      start = offset + 3 | 0;
      end = (offset + 3 | 0) + (length | 0) | 0;
      if (checkOffset2(length + 2 | 0) | 0) {
        return 1;
      }
      pushUtf8String(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function UTF8_STRING_32(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      length = readUInt32(offset + 1 | 0) | 0;
      start = offset + 5 | 0;
      end = (offset + 5 | 0) + (length | 0) | 0;
      if (checkOffset2(length + 4 | 0) | 0) {
        return 1;
      }
      pushUtf8String(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function UTF8_STRING_64(octet) {
      octet = octet | 0;
      return 1;
    }
    function UTF8_STRING_BREAK(octet) {
      octet = octet | 0;
      pushUtf8StringStart();
      offset = offset + 1 | 0;
      return 0;
    }
    function ARRAY(octet) {
      octet = octet | 0;
      pushArrayStartFixed(octet - 128 | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function ARRAY_8(octet) {
      octet = octet | 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      pushArrayStartFixed(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function ARRAY_16(octet) {
      octet = octet | 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      pushArrayStartFixed(readUInt16(offset + 1 | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function ARRAY_32(octet) {
      octet = octet | 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      pushArrayStartFixed32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function ARRAY_64(octet) {
      octet = octet | 0;
      if (checkOffset2(8) | 0) {
        return 1;
      }
      pushArrayStartFixed64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function ARRAY_BREAK(octet) {
      octet = octet | 0;
      pushArrayStart();
      offset = offset + 1 | 0;
      return 0;
    }
    function MAP(octet) {
      octet = octet | 0;
      var step = 0;
      step = octet - 160 | 0;
      if (checkOffset2(step | 0) | 0) {
        return 1;
      }
      pushObjectStartFixed(step | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function MAP_8(octet) {
      octet = octet | 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      pushObjectStartFixed(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function MAP_16(octet) {
      octet = octet | 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      pushObjectStartFixed(readUInt16(offset + 1 | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function MAP_32(octet) {
      octet = octet | 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      pushObjectStartFixed32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function MAP_64(octet) {
      octet = octet | 0;
      if (checkOffset2(8) | 0) {
        return 1;
      }
      pushObjectStartFixed64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function MAP_BREAK(octet) {
      octet = octet | 0;
      pushObjectStart();
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_KNOWN(octet) {
      octet = octet | 0;
      pushTagStart(octet - 192 | 0 | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BIGNUM_POS(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BIGNUM_NEG(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_FRAC(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BIGNUM_FLOAT(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_UNASSIGNED(octet) {
      octet = octet | 0;
      pushTagStart(octet - 192 | 0 | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BASE64_URL(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BASE64(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BASE16(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_MORE_1(octet) {
      octet = octet | 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      pushTagStart(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function TAG_MORE_2(octet) {
      octet = octet | 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      pushTagStart(readUInt16(offset + 1 | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function TAG_MORE_4(octet) {
      octet = octet | 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      pushTagStart4(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function TAG_MORE_8(octet) {
      octet = octet | 0;
      if (checkOffset2(8) | 0) {
        return 1;
      }
      pushTagStart8(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function SIMPLE_UNASSIGNED(octet) {
      octet = octet | 0;
      pushSimpleUnassigned((octet | 0) - 224 | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_FALSE(octet) {
      octet = octet | 0;
      pushFalse();
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_TRUE(octet) {
      octet = octet | 0;
      pushTrue();
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_NULL(octet) {
      octet = octet | 0;
      pushNull();
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_UNDEFINED(octet) {
      octet = octet | 0;
      pushUndefined();
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_BYTE(octet) {
      octet = octet | 0;
      if (checkOffset2(1) | 0) {
        return 1;
      }
      pushSimpleUnassigned(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function SIMPLE_FLOAT_HALF(octet) {
      octet = octet | 0;
      var f = 0;
      var g = 0;
      var sign = 1;
      var exp = 0;
      var mant = 0;
      var r = 0;
      if (checkOffset2(2) | 0) {
        return 1;
      }
      f = heap[offset + 1 | 0] | 0;
      g = heap[offset + 2 | 0] | 0;
      if ((f | 0) & 128) {
        sign = -1;
      }
      exp = +(((f | 0) & 124) >> 2);
      mant = +(((f | 0) & 3) << 8 | g);
      if (+exp == 0) {
        pushFloat(+(+sign * 0.00000005960464477539063 * +mant));
      } else if (+exp == 31) {
        if (+sign == 1) {
          if (+mant > 0) {
            pushNaN();
          } else {
            pushInfinity();
          }
        } else {
          if (+mant > 0) {
            pushNaNNeg();
          } else {
            pushInfinityNeg();
          }
        }
      } else {
        pushFloat(+(+sign * pow(2, +(+exp - 25)) * +(1024 + mant)));
      }
      offset = offset + 3 | 0;
      return 0;
    }
    function SIMPLE_FLOAT_SINGLE(octet) {
      octet = octet | 0;
      if (checkOffset2(4) | 0) {
        return 1;
      }
      pushFloatSingle(heap[offset + 1 | 0] | 0, heap[offset + 2 | 0] | 0, heap[offset + 3 | 0] | 0, heap[offset + 4 | 0] | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function SIMPLE_FLOAT_DOUBLE(octet) {
      octet = octet | 0;
      if (checkOffset2(8) | 0) {
        return 1;
      }
      pushFloatDouble(heap[offset + 1 | 0] | 0, heap[offset + 2 | 0] | 0, heap[offset + 3 | 0] | 0, heap[offset + 4 | 0] | 0, heap[offset + 5 | 0] | 0, heap[offset + 6 | 0] | 0, heap[offset + 7 | 0] | 0, heap[offset + 8 | 0] | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function ERROR(octet) {
      octet = octet | 0;
      return 1;
    }
    function BREAK(octet) {
      octet = octet | 0;
      pushBreak();
      offset = offset + 1 | 0;
      return 0;
    }
    var jumpTable = [
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      UINT_P_8,
      UINT_P_16,
      UINT_P_32,
      UINT_P_64,
      ERROR,
      ERROR,
      ERROR,
      ERROR,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      UINT_N_8,
      UINT_N_16,
      UINT_N_32,
      UINT_N_64,
      ERROR,
      ERROR,
      ERROR,
      ERROR,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING_8,
      BYTE_STRING_16,
      BYTE_STRING_32,
      BYTE_STRING_64,
      ERROR,
      ERROR,
      ERROR,
      BYTE_STRING_BREAK,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING_8,
      UTF8_STRING_16,
      UTF8_STRING_32,
      UTF8_STRING_64,
      ERROR,
      ERROR,
      ERROR,
      UTF8_STRING_BREAK,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY_8,
      ARRAY_16,
      ARRAY_32,
      ARRAY_64,
      ERROR,
      ERROR,
      ERROR,
      ARRAY_BREAK,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP_8,
      MAP_16,
      MAP_32,
      MAP_64,
      ERROR,
      ERROR,
      ERROR,
      MAP_BREAK,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_MORE_1,
      TAG_MORE_2,
      TAG_MORE_4,
      TAG_MORE_8,
      ERROR,
      ERROR,
      ERROR,
      ERROR,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_FALSE,
      SIMPLE_TRUE,
      SIMPLE_NULL,
      SIMPLE_UNDEFINED,
      SIMPLE_BYTE,
      SIMPLE_FLOAT_HALF,
      SIMPLE_FLOAT_SINGLE,
      SIMPLE_FLOAT_DOUBLE,
      ERROR,
      ERROR,
      ERROR,
      BREAK
    ];
    return {
      parse
    };
  };
});

// node_modules/borc/src/constants.js
var require_constants = __commonJS((exports) => {
  var Bignumber = require_bignumber().BigNumber;
  exports.MT = {
    POS_INT: 0,
    NEG_INT: 1,
    BYTE_STRING: 2,
    UTF8_STRING: 3,
    ARRAY: 4,
    MAP: 5,
    TAG: 6,
    SIMPLE_FLOAT: 7
  };
  exports.TAG = {
    DATE_STRING: 0,
    DATE_EPOCH: 1,
    POS_BIGINT: 2,
    NEG_BIGINT: 3,
    DECIMAL_FRAC: 4,
    BIGFLOAT: 5,
    BASE64URL_EXPECTED: 21,
    BASE64_EXPECTED: 22,
    BASE16_EXPECTED: 23,
    CBOR: 24,
    URI: 32,
    BASE64URL: 33,
    BASE64: 34,
    REGEXP: 35,
    MIME: 36
  };
  exports.NUMBYTES = {
    ZERO: 0,
    ONE: 24,
    TWO: 25,
    FOUR: 26,
    EIGHT: 27,
    INDEFINITE: 31
  };
  exports.SIMPLE = {
    FALSE: 20,
    TRUE: 21,
    NULL: 22,
    UNDEFINED: 23
  };
  exports.SYMS = {
    NULL: Symbol("null"),
    UNDEFINED: Symbol("undef"),
    PARENT: Symbol("parent"),
    BREAK: Symbol("break"),
    STREAM: Symbol("stream")
  };
  exports.SHIFT32 = Math.pow(2, 32);
  exports.SHIFT16 = Math.pow(2, 16);
  exports.MAX_SAFE_HIGH = 2097151;
  exports.NEG_ONE = new Bignumber(-1);
  exports.TEN = new Bignumber(10);
  exports.TWO = new Bignumber(2);
  exports.PARENT = {
    ARRAY: 0,
    OBJECT: 1,
    MAP: 2,
    TAG: 3,
    BYTE_STRING: 4,
    UTF8_STRING: 5
  };
});

// node_modules/borc/src/utils.js
var require_utils = __commonJS((exports) => {
  var toHex = function(n) {
    if (n < 16) {
      return "0" + n.toString(16);
    }
    return n.toString(16);
  };
  var { Buffer: Buffer3 } = import.meta.require("buffer");
  var Bignumber = require_bignumber().BigNumber;
  var constants = require_constants();
  var SHIFT32 = constants.SHIFT32;
  var SHIFT16 = constants.SHIFT16;
  var MAX_SAFE_HIGH = 2097151;
  exports.parseHalf = function parseHalf(buf) {
    var exp, mant, sign;
    sign = buf[0] & 128 ? -1 : 1;
    exp = (buf[0] & 124) >> 2;
    mant = (buf[0] & 3) << 8 | buf[1];
    if (!exp) {
      return sign * 0.00000005960464477539063 * mant;
    } else if (exp === 31) {
      return sign * (mant ? 0 / 0 : Infinity);
    } else {
      return sign * Math.pow(2, exp - 25) * (1024 + mant);
    }
  };
  exports.arrayBufferToBignumber = function(buf) {
    const len = buf.byteLength;
    let res = "";
    for (let i = 0;i < len; i++) {
      res += toHex(buf[i]);
    }
    return new Bignumber(res, 16);
  };
  exports.buildMap = (obj) => {
    const res = new Map;
    const keys = Object.keys(obj);
    const length = keys.length;
    for (let i = 0;i < length; i++) {
      res.set(keys[i], obj[keys[i]]);
    }
    return res;
  };
  exports.buildInt32 = (f, g) => {
    return f * SHIFT16 + g;
  };
  exports.buildInt64 = (f1, f2, g1, g2) => {
    const f = exports.buildInt32(f1, f2);
    const g = exports.buildInt32(g1, g2);
    if (f > MAX_SAFE_HIGH) {
      return new Bignumber(f).times(SHIFT32).plus(g);
    } else {
      return f * SHIFT32 + g;
    }
  };
  exports.writeHalf = function writeHalf(buf, half) {
    const u32 = Buffer3.allocUnsafe(4);
    u32.writeFloatBE(half, 0);
    const u = u32.readUInt32BE(0);
    if ((u & 8191) !== 0) {
      return false;
    }
    var s16 = u >> 16 & 32768;
    const exp = u >> 23 & 255;
    const mant = u & 8388607;
    if (exp >= 113 && exp <= 142) {
      s16 += (exp - 112 << 10) + (mant >> 13);
    } else if (exp >= 103 && exp < 113) {
      if (mant & (1 << 126 - exp) - 1) {
        return false;
      }
      s16 += mant + 8388608 >> 126 - exp;
    } else {
      return false;
    }
    buf.writeUInt16BE(s16, 0);
    return true;
  };
  exports.keySorter = function(a, b) {
    var lenA = a[0].byteLength;
    var lenB = b[0].byteLength;
    if (lenA > lenB) {
      return 1;
    }
    if (lenB > lenA) {
      return -1;
    }
    return a[0].compare(b[0]);
  };
  exports.isNegativeZero = (x) => {
    return x === 0 && 1 / x < 0;
  };
  exports.nextPowerOf2 = (n) => {
    let count = 0;
    if (n && !(n & n - 1)) {
      return n;
    }
    while (n !== 0) {
      n >>= 1;
      count += 1;
    }
    return 1 << count;
  };
});

// node_modules/borc/src/simple.js
var require_simple = __commonJS((exports, module) => {
  var constants = require_constants();
  var MT = constants.MT;
  var SIMPLE = constants.SIMPLE;
  var SYMS = constants.SYMS;

  class Simple {
    constructor(value) {
      if (typeof value !== "number") {
        throw new Error("Invalid Simple type: " + typeof value);
      }
      if (value < 0 || value > 255 || (value | 0) !== value) {
        throw new Error("value must be a small positive integer: " + value);
      }
      this.value = value;
    }
    toString() {
      return "simple(" + this.value + ")";
    }
    inspect() {
      return "simple(" + this.value + ")";
    }
    encodeCBOR(gen) {
      return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
    }
    static isSimple(obj) {
      return obj instanceof Simple;
    }
    static decode(val, hasParent) {
      if (hasParent == null) {
        hasParent = true;
      }
      switch (val) {
        case SIMPLE.FALSE:
          return false;
        case SIMPLE.TRUE:
          return true;
        case SIMPLE.NULL:
          if (hasParent) {
            return null;
          } else {
            return SYMS.NULL;
          }
        case SIMPLE.UNDEFINED:
          if (hasParent) {
            return;
          } else {
            return SYMS.UNDEFINED;
          }
        case -1:
          if (!hasParent) {
            throw new Error("Invalid BREAK");
          }
          return SYMS.BREAK;
        default:
          return new Simple(val);
      }
    }
  }
  module.exports = Simple;
});

// node_modules/borc/src/tagged.js
var require_tagged = __commonJS((exports, module) => {
  class Tagged {
    constructor(tag, value, err) {
      this.tag = tag;
      this.value = value;
      this.err = err;
      if (typeof this.tag !== "number") {
        throw new Error("Invalid tag type (" + typeof this.tag + ")");
      }
      if (this.tag < 0 || (this.tag | 0) !== this.tag) {
        throw new Error("Tag must be a positive integer: " + this.tag);
      }
    }
    toString() {
      return `${this.tag}(${JSON.stringify(this.value)})`;
    }
    encodeCBOR(gen) {
      gen._pushTag(this.tag);
      return gen.pushAny(this.value);
    }
    convert(converters) {
      var er, f;
      f = converters != null ? converters[this.tag] : undefined;
      if (typeof f !== "function") {
        f = Tagged["_tag" + this.tag];
        if (typeof f !== "function") {
          return this;
        }
      }
      try {
        return f.call(Tagged, this.value);
      } catch (error) {
        er = error;
        this.err = er;
        return this;
      }
    }
  }
  module.exports = Tagged;
});

// node_modules/iso-url/src/url.js
var require_url = __commonJS((exports, module) => {
  var { URL: URL2, URLSearchParams, format } = import.meta.require("url");
  var defaultBase = "http://localhost";

  class URLWithLegacySupport extends URL2 {
    constructor(url = "", base = defaultBase) {
      super(url, base);
      this.path = this.pathname + this.search;
      this.auth = this.username && this.password ? this.username + ":" + this.password : null;
      this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
    }
    format() {
      return this.toString();
    }
  }
  module.exports = {
    URLWithLegacySupport,
    URLSearchParams,
    format,
    defaultBase
  };
});

// node_modules/iso-url/src/relative.js
var require_relative = __commonJS((exports, module) => {
  var { URLWithLegacySupport, format } = require_url();
  module.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {
    let protocol = location.protocol ? location.protocol.replace(":", "") : "http";
    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
    let urlParsed;
    try {
      urlParsed = new URLWithLegacySupport(url);
    } catch (err) {
      urlParsed = {};
    }
    const base = Object.assign({}, location, {
      protocol: protocol || urlParsed.protocol,
      host: location.host || urlParsed.host
    });
    return new URLWithLegacySupport(url, format(base)).toString();
  };
});

// node_modules/iso-url/index.js
var require_iso_url = __commonJS((exports, module) => {
  var {
    URLWithLegacySupport,
    format,
    URLSearchParams,
    defaultBase
  } = require_url();
  var relative = require_relative();
  module.exports = {
    URL: URLWithLegacySupport,
    URLSearchParams,
    format,
    relative,
    defaultBase
  };
});

// node_modules/borc/src/decoder.js
var require_decoder = __commonJS((exports, module) => {
  var { Buffer: Buffer3 } = import.meta.require("buffer");
  var ieee7542 = require_ieee754();
  var Bignumber = require_bignumber().BigNumber;
  var parser = require_decoder_asm();
  var utils = require_utils();
  var c = require_constants();
  var Simple = require_simple();
  var Tagged = require_tagged();
  var { URL: URL2 } = require_iso_url();

  class Decoder {
    constructor(opts) {
      opts = opts || {};
      if (!opts.size || opts.size < 65536) {
        opts.size = 65536;
      } else {
        opts.size = utils.nextPowerOf2(opts.size);
      }
      this._heap = new ArrayBuffer(opts.size);
      this._heap8 = new Uint8Array(this._heap);
      this._buffer = Buffer3.from(this._heap);
      this._reset();
      this._knownTags = Object.assign({
        0: (val) => new Date(val),
        1: (val) => new Date(val * 1000),
        2: (val) => utils.arrayBufferToBignumber(val),
        3: (val) => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),
        4: (v) => {
          return c.TEN.pow(v[0]).times(v[1]);
        },
        5: (v) => {
          return c.TWO.pow(v[0]).times(v[1]);
        },
        32: (val) => new URL2(val),
        35: (val) => new RegExp(val)
      }, opts.tags);
      this.parser = parser(global, {
        log: console.log.bind(console),
        pushInt: this.pushInt.bind(this),
        pushInt32: this.pushInt32.bind(this),
        pushInt32Neg: this.pushInt32Neg.bind(this),
        pushInt64: this.pushInt64.bind(this),
        pushInt64Neg: this.pushInt64Neg.bind(this),
        pushFloat: this.pushFloat.bind(this),
        pushFloatSingle: this.pushFloatSingle.bind(this),
        pushFloatDouble: this.pushFloatDouble.bind(this),
        pushTrue: this.pushTrue.bind(this),
        pushFalse: this.pushFalse.bind(this),
        pushUndefined: this.pushUndefined.bind(this),
        pushNull: this.pushNull.bind(this),
        pushInfinity: this.pushInfinity.bind(this),
        pushInfinityNeg: this.pushInfinityNeg.bind(this),
        pushNaN: this.pushNaN.bind(this),
        pushNaNNeg: this.pushNaNNeg.bind(this),
        pushArrayStart: this.pushArrayStart.bind(this),
        pushArrayStartFixed: this.pushArrayStartFixed.bind(this),
        pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),
        pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),
        pushObjectStart: this.pushObjectStart.bind(this),
        pushObjectStartFixed: this.pushObjectStartFixed.bind(this),
        pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),
        pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),
        pushByteString: this.pushByteString.bind(this),
        pushByteStringStart: this.pushByteStringStart.bind(this),
        pushUtf8String: this.pushUtf8String.bind(this),
        pushUtf8StringStart: this.pushUtf8StringStart.bind(this),
        pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),
        pushTagUnassigned: this.pushTagUnassigned.bind(this),
        pushTagStart: this.pushTagStart.bind(this),
        pushTagStart4: this.pushTagStart4.bind(this),
        pushTagStart8: this.pushTagStart8.bind(this),
        pushBreak: this.pushBreak.bind(this)
      }, this._heap);
    }
    get _depth() {
      return this._parents.length;
    }
    get _currentParent() {
      return this._parents[this._depth - 1];
    }
    get _ref() {
      return this._currentParent.ref;
    }
    _closeParent() {
      var p = this._parents.pop();
      if (p.length > 0) {
        throw new Error(`Missing ${p.length} elements`);
      }
      switch (p.type) {
        case c.PARENT.TAG:
          this._push(this.createTag(p.ref[0], p.ref[1]));
          break;
        case c.PARENT.BYTE_STRING:
          this._push(this.createByteString(p.ref, p.length));
          break;
        case c.PARENT.UTF8_STRING:
          this._push(this.createUtf8String(p.ref, p.length));
          break;
        case c.PARENT.MAP:
          if (p.values % 2 > 0) {
            throw new Error("Odd number of elements in the map");
          }
          this._push(this.createMap(p.ref, p.length));
          break;
        case c.PARENT.OBJECT:
          if (p.values % 2 > 0) {
            throw new Error("Odd number of elements in the map");
          }
          this._push(this.createObject(p.ref, p.length));
          break;
        case c.PARENT.ARRAY:
          this._push(this.createArray(p.ref, p.length));
          break;
        default:
          break;
      }
      if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {
        this._dec();
      }
    }
    _dec() {
      const p = this._currentParent;
      if (p.length < 0) {
        return;
      }
      p.length--;
      if (p.length === 0) {
        this._closeParent();
      }
    }
    _push(val, hasChildren) {
      const p = this._currentParent;
      p.values++;
      switch (p.type) {
        case c.PARENT.ARRAY:
        case c.PARENT.BYTE_STRING:
        case c.PARENT.UTF8_STRING:
          if (p.length > -1) {
            this._ref[this._ref.length - p.length] = val;
          } else {
            this._ref.push(val);
          }
          this._dec();
          break;
        case c.PARENT.OBJECT:
          if (p.tmpKey != null) {
            this._ref[p.tmpKey] = val;
            p.tmpKey = null;
            this._dec();
          } else {
            p.tmpKey = val;
            if (typeof p.tmpKey !== "string") {
              p.type = c.PARENT.MAP;
              p.ref = utils.buildMap(p.ref);
            }
          }
          break;
        case c.PARENT.MAP:
          if (p.tmpKey != null) {
            this._ref.set(p.tmpKey, val);
            p.tmpKey = null;
            this._dec();
          } else {
            p.tmpKey = val;
          }
          break;
        case c.PARENT.TAG:
          this._ref.push(val);
          if (!hasChildren) {
            this._dec();
          }
          break;
        default:
          throw new Error("Unknown parent type");
      }
    }
    _createParent(obj, type, len) {
      this._parents[this._depth] = {
        type,
        length: len,
        ref: obj,
        values: 0,
        tmpKey: null
      };
    }
    _reset() {
      this._res = [];
      this._parents = [{
        type: c.PARENT.ARRAY,
        length: -1,
        ref: this._res,
        values: 0,
        tmpKey: null
      }];
    }
    createTag(tagNumber, value) {
      const typ = this._knownTags[tagNumber];
      if (!typ) {
        return new Tagged(tagNumber, value);
      }
      return typ(value);
    }
    createMap(obj, len) {
      return obj;
    }
    createObject(obj, len) {
      return obj;
    }
    createArray(arr, len) {
      return arr;
    }
    createByteString(raw, len) {
      return Buffer3.concat(raw);
    }
    createByteStringFromHeap(start, end) {
      if (start === end) {
        return Buffer3.alloc(0);
      }
      return Buffer3.from(this._heap.slice(start, end));
    }
    createInt(val) {
      return val;
    }
    createInt32(f, g) {
      return utils.buildInt32(f, g);
    }
    createInt64(f1, f2, g1, g2) {
      return utils.buildInt64(f1, f2, g1, g2);
    }
    createFloat(val) {
      return val;
    }
    createFloatSingle(a, b, c2, d) {
      return ieee7542.read([a, b, c2, d], 0, false, 23, 4);
    }
    createFloatDouble(a, b, c2, d, e, f, g, h) {
      return ieee7542.read([a, b, c2, d, e, f, g, h], 0, false, 52, 8);
    }
    createInt32Neg(f, g) {
      return -1 - utils.buildInt32(f, g);
    }
    createInt64Neg(f1, f2, g1, g2) {
      const f = utils.buildInt32(f1, f2);
      const g = utils.buildInt32(g1, g2);
      if (f > c.MAX_SAFE_HIGH) {
        return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g));
      }
      return -1 - (f * c.SHIFT32 + g);
    }
    createTrue() {
      return true;
    }
    createFalse() {
      return false;
    }
    createNull() {
      return null;
    }
    createUndefined() {
      return;
    }
    createInfinity() {
      return Infinity;
    }
    createInfinityNeg() {
      return (-Infinity);
    }
    createNaN() {
      return NaN;
    }
    createNaNNeg() {
      return NaN;
    }
    createUtf8String(raw, len) {
      return raw.join("");
    }
    createUtf8StringFromHeap(start, end) {
      if (start === end) {
        return "";
      }
      return this._buffer.toString("utf8", start, end);
    }
    createSimpleUnassigned(val) {
      return new Simple(val);
    }
    pushInt(val) {
      this._push(this.createInt(val));
    }
    pushInt32(f, g) {
      this._push(this.createInt32(f, g));
    }
    pushInt64(f1, f2, g1, g2) {
      this._push(this.createInt64(f1, f2, g1, g2));
    }
    pushFloat(val) {
      this._push(this.createFloat(val));
    }
    pushFloatSingle(a, b, c2, d) {
      this._push(this.createFloatSingle(a, b, c2, d));
    }
    pushFloatDouble(a, b, c2, d, e, f, g, h) {
      this._push(this.createFloatDouble(a, b, c2, d, e, f, g, h));
    }
    pushInt32Neg(f, g) {
      this._push(this.createInt32Neg(f, g));
    }
    pushInt64Neg(f1, f2, g1, g2) {
      this._push(this.createInt64Neg(f1, f2, g1, g2));
    }
    pushTrue() {
      this._push(this.createTrue());
    }
    pushFalse() {
      this._push(this.createFalse());
    }
    pushNull() {
      this._push(this.createNull());
    }
    pushUndefined() {
      this._push(this.createUndefined());
    }
    pushInfinity() {
      this._push(this.createInfinity());
    }
    pushInfinityNeg() {
      this._push(this.createInfinityNeg());
    }
    pushNaN() {
      this._push(this.createNaN());
    }
    pushNaNNeg() {
      this._push(this.createNaNNeg());
    }
    pushArrayStart() {
      this._createParent([], c.PARENT.ARRAY, -1);
    }
    pushArrayStartFixed(len) {
      this._createArrayStartFixed(len);
    }
    pushArrayStartFixed32(len1, len2) {
      const len = utils.buildInt32(len1, len2);
      this._createArrayStartFixed(len);
    }
    pushArrayStartFixed64(len1, len2, len3, len4) {
      const len = utils.buildInt64(len1, len2, len3, len4);
      this._createArrayStartFixed(len);
    }
    pushObjectStart() {
      this._createObjectStartFixed(-1);
    }
    pushObjectStartFixed(len) {
      this._createObjectStartFixed(len);
    }
    pushObjectStartFixed32(len1, len2) {
      const len = utils.buildInt32(len1, len2);
      this._createObjectStartFixed(len);
    }
    pushObjectStartFixed64(len1, len2, len3, len4) {
      const len = utils.buildInt64(len1, len2, len3, len4);
      this._createObjectStartFixed(len);
    }
    pushByteStringStart() {
      this._parents[this._depth] = {
        type: c.PARENT.BYTE_STRING,
        length: -1,
        ref: [],
        values: 0,
        tmpKey: null
      };
    }
    pushByteString(start, end) {
      this._push(this.createByteStringFromHeap(start, end));
    }
    pushUtf8StringStart() {
      this._parents[this._depth] = {
        type: c.PARENT.UTF8_STRING,
        length: -1,
        ref: [],
        values: 0,
        tmpKey: null
      };
    }
    pushUtf8String(start, end) {
      this._push(this.createUtf8StringFromHeap(start, end));
    }
    pushSimpleUnassigned(val) {
      this._push(this.createSimpleUnassigned(val));
    }
    pushTagStart(tag) {
      this._parents[this._depth] = {
        type: c.PARENT.TAG,
        length: 1,
        ref: [tag]
      };
    }
    pushTagStart4(f, g) {
      this.pushTagStart(utils.buildInt32(f, g));
    }
    pushTagStart8(f1, f2, g1, g2) {
      this.pushTagStart(utils.buildInt64(f1, f2, g1, g2));
    }
    pushTagUnassigned(tagNumber) {
      this._push(this.createTag(tagNumber));
    }
    pushBreak() {
      if (this._currentParent.length > -1) {
        throw new Error("Unexpected break");
      }
      this._closeParent();
    }
    _createObjectStartFixed(len) {
      if (len === 0) {
        this._push(this.createObject({}));
        return;
      }
      this._createParent({}, c.PARENT.OBJECT, len);
    }
    _createArrayStartFixed(len) {
      if (len === 0) {
        this._push(this.createArray([]));
        return;
      }
      this._createParent(new Array(len), c.PARENT.ARRAY, len);
    }
    _decode(input) {
      if (input.byteLength === 0) {
        throw new Error("Input too short");
      }
      this._reset();
      this._heap8.set(input);
      const code = this.parser.parse(input.byteLength);
      if (this._depth > 1) {
        while (this._currentParent.length === 0) {
          this._closeParent();
        }
        if (this._depth > 1) {
          throw new Error("Undeterminated nesting");
        }
      }
      if (code > 0) {
        throw new Error("Failed to parse");
      }
      if (this._res.length === 0) {
        throw new Error("No valid result");
      }
    }
    decodeFirst(input) {
      this._decode(input);
      return this._res[0];
    }
    decodeAll(input) {
      this._decode(input);
      return this._res;
    }
    static decode(input, enc) {
      if (typeof input === "string") {
        input = Buffer3.from(input, enc || "hex");
      }
      const dec = new Decoder({ size: input.length });
      return dec.decodeFirst(input);
    }
    static decodeAll(input, enc) {
      if (typeof input === "string") {
        input = Buffer3.from(input, enc || "hex");
      }
      const dec = new Decoder({ size: input.length });
      return dec.decodeAll(input);
    }
  }
  Decoder.decodeFirst = Decoder.decode;
  module.exports = Decoder;
});

// node_modules/borc/src/diagnose.js
var require_diagnose = __commonJS((exports, module) => {
  var collectObject = function(val) {
    return (acc, key) => {
      if (acc) {
        return `${acc}, ${key}: ${val[key]}`;
      }
      return `${key}: ${val[key]}`;
    };
  };
  var { Buffer: Buffer3 } = import.meta.require("buffer");
  var Decoder = require_decoder();
  var utils = require_utils();

  class Diagnose extends Decoder {
    createTag(tagNumber, value) {
      return `${tagNumber}(${value})`;
    }
    createInt(val) {
      return super.createInt(val).toString();
    }
    createInt32(f, g) {
      return super.createInt32(f, g).toString();
    }
    createInt64(f1, f2, g1, g2) {
      return super.createInt64(f1, f2, g1, g2).toString();
    }
    createInt32Neg(f, g) {
      return super.createInt32Neg(f, g).toString();
    }
    createInt64Neg(f1, f2, g1, g2) {
      return super.createInt64Neg(f1, f2, g1, g2).toString();
    }
    createTrue() {
      return "true";
    }
    createFalse() {
      return "false";
    }
    createFloat(val) {
      const fl = super.createFloat(val);
      if (utils.isNegativeZero(val)) {
        return "-0_1";
      }
      return `${fl}_1`;
    }
    createFloatSingle(a, b, c, d) {
      const fl = super.createFloatSingle(a, b, c, d);
      return `${fl}_2`;
    }
    createFloatDouble(a, b, c, d, e, f, g, h) {
      const fl = super.createFloatDouble(a, b, c, d, e, f, g, h);
      return `${fl}_3`;
    }
    createByteString(raw, len) {
      const val = raw.join(", ");
      if (len === -1) {
        return `(_ ${val})`;
      }
      return `h'${val}`;
    }
    createByteStringFromHeap(start, end) {
      const val = Buffer3.from(super.createByteStringFromHeap(start, end)).toString("hex");
      return `h'${val}'`;
    }
    createInfinity() {
      return "Infinity_1";
    }
    createInfinityNeg() {
      return "-Infinity_1";
    }
    createNaN() {
      return "NaN_1";
    }
    createNaNNeg() {
      return "-NaN_1";
    }
    createNull() {
      return "null";
    }
    createUndefined() {
      return "undefined";
    }
    createSimpleUnassigned(val) {
      return `simple(${val})`;
    }
    createArray(arr, len) {
      const val = super.createArray(arr, len);
      if (len === -1) {
        return `[_ ${val.join(", ")}]`;
      }
      return `[${val.join(", ")}]`;
    }
    createMap(map, len) {
      const val = super.createMap(map);
      const list = Array.from(val.keys()).reduce(collectObject(val), "");
      if (len === -1) {
        return `{_ ${list}}`;
      }
      return `{${list}}`;
    }
    createObject(obj, len) {
      const val = super.createObject(obj);
      const map = Object.keys(val).reduce(collectObject(val), "");
      if (len === -1) {
        return `{_ ${map}}`;
      }
      return `{${map}}`;
    }
    createUtf8String(raw, len) {
      const val = raw.join(", ");
      if (len === -1) {
        return `(_ ${val})`;
      }
      return `"${val}"`;
    }
    createUtf8StringFromHeap(start, end) {
      const val = Buffer3.from(super.createUtf8StringFromHeap(start, end)).toString("utf8");
      return `"${val}"`;
    }
    static diagnose(input, enc) {
      if (typeof input === "string") {
        input = Buffer3.from(input, enc || "hex");
      }
      const dec = new Diagnose;
      return dec.decodeFirst(input);
    }
  }
  module.exports = Diagnose;
});

// node_modules/borc/src/encoder.js
var require_encoder = __commonJS((exports, module) => {
  var toType = function(obj) {
    return {}.toString.call(obj).slice(8, -1);
  };
  var { Buffer: Buffer3 } = import.meta.require("buffer");
  var { URL: URL2 } = require_iso_url();
  var Bignumber = require_bignumber().BigNumber;
  var utils = require_utils();
  var constants = require_constants();
  var MT = constants.MT;
  var NUMBYTES = constants.NUMBYTES;
  var SHIFT32 = constants.SHIFT32;
  var SYMS = constants.SYMS;
  var TAG = constants.TAG;
  var HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;
  var FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;
  var DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;
  var TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;
  var FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;
  var UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;
  var NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;
  var MAXINT_BN = new Bignumber("0x20000000000000");
  var BUF_NAN = Buffer3.from("f97e00", "hex");
  var BUF_INF_NEG = Buffer3.from("f9fc00", "hex");
  var BUF_INF_POS = Buffer3.from("f97c00", "hex");

  class Encoder {
    constructor(options) {
      options = options || {};
      this.streaming = typeof options.stream === "function";
      this.onData = options.stream;
      this.semanticTypes = [
        [URL2, this._pushUrl],
        [Bignumber, this._pushBigNumber]
      ];
      const addTypes = options.genTypes || [];
      const len = addTypes.length;
      for (let i = 0;i < len; i++) {
        this.addSemanticType(addTypes[i][0], addTypes[i][1]);
      }
      this._reset();
    }
    addSemanticType(type, fun) {
      const len = this.semanticTypes.length;
      for (let i = 0;i < len; i++) {
        const typ = this.semanticTypes[i][0];
        if (typ === type) {
          const old = this.semanticTypes[i][1];
          this.semanticTypes[i][1] = fun;
          return old;
        }
      }
      this.semanticTypes.push([type, fun]);
      return null;
    }
    push(val) {
      if (!val) {
        return true;
      }
      this.result[this.offset] = val;
      this.resultMethod[this.offset] = 0;
      this.resultLength[this.offset] = val.length;
      this.offset++;
      if (this.streaming) {
        this.onData(this.finalize());
      }
      return true;
    }
    pushWrite(val, method, len) {
      this.result[this.offset] = val;
      this.resultMethod[this.offset] = method;
      this.resultLength[this.offset] = len;
      this.offset++;
      if (this.streaming) {
        this.onData(this.finalize());
      }
      return true;
    }
    _pushUInt8(val) {
      return this.pushWrite(val, 1, 1);
    }
    _pushUInt16BE(val) {
      return this.pushWrite(val, 2, 2);
    }
    _pushUInt32BE(val) {
      return this.pushWrite(val, 3, 4);
    }
    _pushDoubleBE(val) {
      return this.pushWrite(val, 4, 8);
    }
    _pushNaN() {
      return this.push(BUF_NAN);
    }
    _pushInfinity(obj) {
      const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
      return this.push(half);
    }
    _pushFloat(obj) {
      const b2 = Buffer3.allocUnsafe(2);
      if (utils.writeHalf(b2, obj)) {
        if (utils.parseHalf(b2) === obj) {
          return this._pushUInt8(HALF) && this.push(b2);
        }
      }
      const b4 = Buffer3.allocUnsafe(4);
      b4.writeFloatBE(obj, 0);
      if (b4.readFloatBE(0) === obj) {
        return this._pushUInt8(FLOAT) && this.push(b4);
      }
      return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
    }
    _pushInt(obj, mt, orig) {
      const m = mt << 5;
      if (obj < 24) {
        return this._pushUInt8(m | obj);
      }
      if (obj <= 255) {
        return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);
      }
      if (obj <= 65535) {
        return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);
      }
      if (obj <= 4294967295) {
        return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
      }
      if (obj <= Number.MAX_SAFE_INTEGER) {
        return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);
      }
      if (mt === MT.NEG_INT) {
        return this._pushFloat(orig);
      }
      return this._pushFloat(obj);
    }
    _pushIntNum(obj) {
      if (obj < 0) {
        return this._pushInt(-obj - 1, MT.NEG_INT, obj);
      } else {
        return this._pushInt(obj, MT.POS_INT);
      }
    }
    _pushNumber(obj) {
      switch (false) {
        case obj === obj:
          return this._pushNaN(obj);
        case isFinite(obj):
          return this._pushInfinity(obj);
        case obj % 1 !== 0:
          return this._pushIntNum(obj);
        default:
          return this._pushFloat(obj);
      }
    }
    _pushString(obj) {
      const len = Buffer3.byteLength(obj, "utf8");
      return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len);
    }
    _pushBoolean(obj) {
      return this._pushUInt8(obj ? TRUE : FALSE);
    }
    _pushUndefined(obj) {
      return this._pushUInt8(UNDEFINED);
    }
    _pushArray(gen, obj) {
      const len = obj.length;
      if (!gen._pushInt(len, MT.ARRAY)) {
        return false;
      }
      for (let j = 0;j < len; j++) {
        if (!gen.pushAny(obj[j])) {
          return false;
        }
      }
      return true;
    }
    _pushTag(tag) {
      return this._pushInt(tag, MT.TAG);
    }
    _pushDate(gen, obj) {
      return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1000));
    }
    _pushBuffer(gen, obj) {
      return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
    }
    _pushNoFilter(gen, obj) {
      return gen._pushBuffer(gen, obj.slice());
    }
    _pushRegexp(gen, obj) {
      return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
    }
    _pushSet(gen, obj) {
      if (!gen._pushInt(obj.size, MT.ARRAY)) {
        return false;
      }
      for (const x of obj) {
        if (!gen.pushAny(x)) {
          return false;
        }
      }
      return true;
    }
    _pushUrl(gen, obj) {
      return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());
    }
    _pushBigint(obj) {
      let tag = TAG.POS_BIGINT;
      if (obj.isNegative()) {
        obj = obj.negated().minus(1);
        tag = TAG.NEG_BIGINT;
      }
      let str = obj.toString(16);
      if (str.length % 2) {
        str = "0" + str;
      }
      const buf = Buffer3.from(str, "hex");
      return this._pushTag(tag) && this._pushBuffer(this, buf);
    }
    _pushBigNumber(gen, obj) {
      if (obj.isNaN()) {
        return gen._pushNaN();
      }
      if (!obj.isFinite()) {
        return gen._pushInfinity(obj.isNegative() ? (-Infinity) : Infinity);
      }
      if (obj.isInteger()) {
        return gen._pushBigint(obj);
      }
      if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {
        return false;
      }
      const dec = obj.decimalPlaces();
      const slide = obj.multipliedBy(new Bignumber(10).pow(dec));
      if (!gen._pushIntNum(-dec)) {
        return false;
      }
      if (slide.abs().isLessThan(MAXINT_BN)) {
        return gen._pushIntNum(slide.toNumber());
      } else {
        return gen._pushBigint(slide);
      }
    }
    _pushMap(gen, obj) {
      if (!gen._pushInt(obj.size, MT.MAP)) {
        return false;
      }
      return this._pushRawMap(obj.size, Array.from(obj));
    }
    _pushObject(obj) {
      if (!obj) {
        return this._pushUInt8(NULL);
      }
      var len = this.semanticTypes.length;
      for (var i = 0;i < len; i++) {
        if (obj instanceof this.semanticTypes[i][0]) {
          return this.semanticTypes[i][1].call(obj, this, obj);
        }
      }
      var f = obj.encodeCBOR;
      if (typeof f === "function") {
        return f.call(obj, this);
      }
      var keys = Object.keys(obj);
      var keyLength = keys.length;
      if (!this._pushInt(keyLength, MT.MAP)) {
        return false;
      }
      return this._pushRawMap(keyLength, keys.map((k) => [k, obj[k]]));
    }
    _pushRawMap(len, map) {
      map = map.map(function(a) {
        a[0] = Encoder.encode(a[0]);
        return a;
      }).sort(utils.keySorter);
      for (var j = 0;j < len; j++) {
        if (!this.push(map[j][0])) {
          return false;
        }
        if (!this.pushAny(map[j][1])) {
          return false;
        }
      }
      return true;
    }
    write(obj) {
      return this.pushAny(obj);
    }
    pushAny(obj) {
      var typ = toType(obj);
      switch (typ) {
        case "Number":
          return this._pushNumber(obj);
        case "String":
          return this._pushString(obj);
        case "Boolean":
          return this._pushBoolean(obj);
        case "Object":
          return this._pushObject(obj);
        case "Array":
          return this._pushArray(this, obj);
        case "Uint8Array":
          return this._pushBuffer(this, Buffer3.isBuffer(obj) ? obj : Buffer3.from(obj));
        case "Null":
          return this._pushUInt8(NULL);
        case "Undefined":
          return this._pushUndefined(obj);
        case "Map":
          return this._pushMap(this, obj);
        case "Set":
          return this._pushSet(this, obj);
        case "URL":
          return this._pushUrl(this, obj);
        case "BigNumber":
          return this._pushBigNumber(this, obj);
        case "Date":
          return this._pushDate(this, obj);
        case "RegExp":
          return this._pushRegexp(this, obj);
        case "Symbol":
          switch (obj) {
            case SYMS.NULL:
              return this._pushObject(null);
            case SYMS.UNDEFINED:
              return this._pushUndefined(undefined);
            default:
              throw new Error("Unknown symbol: " + obj.toString());
          }
        default:
          throw new Error("Unknown type: " + typeof obj + ", " + (obj ? obj.toString() : ""));
      }
    }
    finalize() {
      if (this.offset === 0) {
        return null;
      }
      var result = this.result;
      var resultLength = this.resultLength;
      var resultMethod = this.resultMethod;
      var offset = this.offset;
      var size = 0;
      var i = 0;
      for (;i < offset; i++) {
        size += resultLength[i];
      }
      var res = Buffer3.allocUnsafe(size);
      var index = 0;
      var length = 0;
      for (i = 0;i < offset; i++) {
        length = resultLength[i];
        switch (resultMethod[i]) {
          case 0:
            result[i].copy(res, index);
            break;
          case 1:
            res.writeUInt8(result[i], index, true);
            break;
          case 2:
            res.writeUInt16BE(result[i], index, true);
            break;
          case 3:
            res.writeUInt32BE(result[i], index, true);
            break;
          case 4:
            res.writeDoubleBE(result[i], index, true);
            break;
          case 5:
            res.write(result[i], index, length, "utf8");
            break;
          default:
            throw new Error("unkown method");
        }
        index += length;
      }
      var tmp = res;
      this._reset();
      return tmp;
    }
    _reset() {
      this.result = [];
      this.resultMethod = [];
      this.resultLength = [];
      this.offset = 0;
    }
    static encode(o) {
      const enc = new Encoder;
      const ret2 = enc.pushAny(o);
      if (!ret2) {
        throw new Error("Failed to encode input");
      }
      return enc.finalize();
    }
  }
  module.exports = Encoder;
});

// node_modules/borc/src/index.js
var require_src = __commonJS((exports) => {
  exports.Diagnose = require_diagnose();
  exports.Decoder = require_decoder();
  exports.Encoder = require_encoder();
  exports.Simple = require_simple();
  exports.Tagged = require_tagged();
  exports.decodeAll = exports.Decoder.decodeAll;
  exports.decodeFirst = exports.Decoder.decodeFirst;
  exports.diagnose = exports.Diagnose.diagnose;
  exports.encode = exports.Encoder.encode;
  exports.decode = exports.Decoder.decode;
  exports.leveldb = {
    decode: exports.Decoder.decodeAll,
    encode: exports.Encoder.encode,
    buffer: true,
    name: "cbor"
  };
});

// node_modules/@dfinity/agent/lib/esm/utils/buffer.js
function concat3(...buffers) {
  const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));
  let index = 0;
  for (const b of buffers) {
    result.set(new Uint8Array(b), index);
    index += b.byteLength;
  }
  return result.buffer;
}
function toHex(buffer4) {
  return [...new Uint8Array(buffer4)].map((x) => x.toString(16).padStart(2, "0")).join("");
}
function fromHex(hex) {
  if (!hexRe.test(hex)) {
    throw new Error("Invalid hexadecimal string.");
  }
  const buffer4 = [...hex].reduce((acc, curr, i) => {
    acc[i / 2 | 0] = (acc[i / 2 | 0] || "") + curr;
    return acc;
  }, []).map((x) => Number.parseInt(x, 16));
  return new Uint8Array(buffer4).buffer;
}
function compare3(b1, b2) {
  if (b1.byteLength !== b2.byteLength) {
    return b1.byteLength - b2.byteLength;
  }
  const u1 = new Uint8Array(b1);
  const u2 = new Uint8Array(b2);
  for (let i = 0;i < u1.length; i++) {
    if (u1[i] !== u2[i]) {
      return u1[i] - u2[i];
    }
  }
  return 0;
}
var hexRe;
var init_buffer2 = __esm(() => {
  hexRe = new RegExp(/^([0-9A-F]{2})*$/i);
});

// node_modules/@dfinity/agent/lib/esm/request_id.js
function hash3(data) {
  return import_js_sha2562.sha256.create().update(new Uint8Array(data)).arrayBuffer();
}
function hashValue(value) {
  if (value instanceof import_borc.default.Tagged) {
    return hashValue(value.value);
  } else if (typeof value === "string") {
    return hashString(value);
  } else if (typeof value === "number") {
    return hash3(lebEncode(value));
  } else if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
    return hash3(value);
  } else if (Array.isArray(value)) {
    const vals = value.map(hashValue);
    return hash3(concat3(...vals));
  } else if (value && typeof value === "object" && value._isPrincipal) {
    return hash3(value.toUint8Array());
  } else if (typeof value === "object" && value !== null && typeof value.toHash === "function") {
    return hashValue(value.toHash());
  } else if (typeof value === "bigint") {
    return hash3(lebEncode(value));
  }
  throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value}`), {
    value
  });
}
function requestIdOf(request) {
  const hashed = Object.entries(request).filter(([, value]) => value !== undefined).map(([key, value]) => {
    const hashedKey = hashString(key);
    const hashedValue = hashValue(value);
    return [hashedKey, hashedValue];
  });
  const traversed = hashed;
  const sorted = traversed.sort(([k1], [k2]) => {
    return compare3(k1, k2);
  });
  const concatenated = concat3(...sorted.map((x) => concat3(...x)));
  const requestId = hash3(concatenated);
  return requestId;
}
var import_borc, import_js_sha2562, hashString;
var init_request_id = __esm(() => {
  init_esm2();
  import_borc = __toESM(require_src(), 1);
  import_js_sha2562 = __toESM(require_sha256(), 1);
  init_buffer2();
  hashString = (value) => {
    const encoded = new TextEncoder().encode(value);
    return hash3(encoded);
  };
});

// node_modules/simple-cbor/src/value.js
var require_value = __commonJS((exports) => {
  var _concat = function(a, ...args) {
    const newBuffer = new Uint8Array(a.byteLength + args.reduce((acc, b) => acc + b.byteLength, 0));
    newBuffer.set(new Uint8Array(a), 0);
    let i = a.byteLength;
    for (const b of args) {
      newBuffer.set(new Uint8Array(b), i);
      i += b.byteLength;
    }
    return newBuffer.buffer;
  };
  var _serializeValue = function(major, minor, value) {
    value = value.replace(/[^0-9a-fA-F]/g, "");
    const length = 2 ** (minor - 24);
    value = value.slice(-length * 2).padStart(length * 2, "0");
    const bytes2 = [(major << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));
    return new Uint8Array(bytes2).buffer;
  };
  var _serializeNumber = function(major, value) {
    if (value < 24) {
      return new Uint8Array([(major << 5) + value]).buffer;
    } else {
      const minor = value <= 255 ? 24 : value <= 65535 ? 25 : value <= 4294967295 ? 26 : 27;
      return _serializeValue(major, minor, value.toString(16));
    }
  };
  var _serializeString = function(str) {
    const utf8 = [];
    for (let i = 0;i < str.length; i++) {
      let charcode = str.charCodeAt(i);
      if (charcode < 128) {
        utf8.push(charcode);
      } else if (charcode < 2048) {
        utf8.push(192 | charcode >> 6, 128 | charcode & 63);
      } else if (charcode < 55296 || charcode >= 57344) {
        utf8.push(224 | charcode >> 12, 128 | charcode >> 6 & 63, 128 | charcode & 63);
      } else {
        i++;
        charcode = (charcode & 1023) << 10 | str.charCodeAt(i) & 1023;
        utf8.push(240 | charcode >> 18, 128 | charcode >> 12 & 63, 128 | charcode >> 6 & 63, 128 | charcode & 63);
      }
    }
    return _concat(new Uint8Array(_serializeNumber(3, str.length)), new Uint8Array(utf8));
  };
  var tagged = function(tag, value) {
    if (tag == 14277111) {
      return _concat(new Uint8Array([217, 217, 247]), value);
    }
    if (tag < 24) {
      return _concat(new Uint8Array([(6 << 5) + tag]), value);
    } else {
      const minor = tag <= 255 ? 24 : tag <= 65535 ? 25 : tag <= 4294967295 ? 26 : 27;
      const length = 2 ** (minor - 24);
      const value2 = tag.toString(16).slice(-length * 2).padStart(length * 2, "0");
      const bytes2 = [(6 << 5) + minor].concat(value2.match(/../g).map((byte) => parseInt(byte, 16)));
      return new Uint8Array(bytes2).buffer;
    }
  };
  var raw = function(bytes2) {
    return new Uint8Array(bytes2).buffer;
  };
  var uSmall = function(n) {
    if (isNaN(n)) {
      throw new RangeError("Invalid number.");
    }
    n = Math.min(Math.max(0, n), 23);
    const bytes2 = [(0 << 5) + n];
    return new Uint8Array(bytes2).buffer;
  };
  var u8 = function(u82, radix) {
    u82 = parseInt("" + u82, radix);
    if (isNaN(u82)) {
      throw new RangeError("Invalid number.");
    }
    u82 = Math.min(Math.max(0, u82), 255);
    u82 = u82.toString(16);
    return _serializeValue(0, 24, u82);
  };
  var u16 = function(u162, radix) {
    u162 = parseInt("" + u162, radix);
    if (isNaN(u162)) {
      throw new RangeError("Invalid number.");
    }
    u162 = Math.min(Math.max(0, u162), 65535);
    u162 = u162.toString(16);
    return _serializeValue(0, 25, u162);
  };
  var u32 = function(u322, radix) {
    u322 = parseInt("" + u322, radix);
    if (isNaN(u322)) {
      throw new RangeError("Invalid number.");
    }
    u322 = Math.min(Math.max(0, u322), 4294967295);
    u322 = u322.toString(16);
    return _serializeValue(0, 26, u322);
  };
  var u64 = function(u642, radix) {
    if (typeof u642 == "string" && radix == 16) {
      if (u642.match(/[^0-9a-fA-F]/)) {
        throw new RangeError("Invalid number.");
      }
      return _serializeValue(0, 27, u642);
    }
    u642 = parseInt("" + u642, radix);
    if (isNaN(u642)) {
      throw new RangeError("Invalid number.");
    }
    u642 = Math.min(Math.max(0, u642), MAX_U64_NUMBER);
    u642 = u642.toString(16);
    return _serializeValue(0, 27, u642);
  };
  var iSmall = function(n) {
    if (isNaN(n)) {
      throw new RangeError("Invalid number.");
    }
    if (n === 0) {
      return uSmall(0);
    }
    n = Math.min(Math.max(0, -n), 24) - 1;
    const bytes2 = [(1 << 5) + n];
    return new Uint8Array(bytes2).buffer;
  };
  var i8 = function(i82, radix) {
    i82 = parseInt("" + i82, radix);
    if (isNaN(i82)) {
      throw new RangeError("Invalid number.");
    }
    i82 = Math.min(Math.max(0, -i82 - 1), 255);
    i82 = i82.toString(16);
    return _serializeValue(1, 24, i82);
  };
  var i16 = function(i162, radix) {
    i162 = parseInt("" + i162, radix);
    if (isNaN(i162)) {
      throw new RangeError("Invalid number.");
    }
    i162 = Math.min(Math.max(0, -i162 - 1), 65535);
    i162 = i162.toString(16);
    return _serializeValue(1, 25, i162);
  };
  var i32 = function(i322, radix) {
    i322 = parseInt("" + i322, radix);
    if (isNaN(i322)) {
      throw new RangeError("Invalid number.");
    }
    i322 = Math.min(Math.max(0, -i322 - 1), 4294967295);
    i322 = i322.toString(16);
    return _serializeValue(1, 26, i322);
  };
  var i64 = function(i642, radix) {
    if (typeof i642 == "string" && radix == 16) {
      if (i642.startsWith("-")) {
        i642 = i642.slice(1);
      } else {
        i642 = "0";
      }
      if (i642.match(/[^0-9a-fA-F]/) || i642.length > 16) {
        throw new RangeError("Invalid number.");
      }
      let done = false;
      let newI64 = i642.split("").reduceRight((acc, x) => {
        if (done) {
          return x + acc;
        }
        let n = parseInt(x, 16) - 1;
        if (n >= 0) {
          done = true;
          return n.toString(16) + acc;
        } else {
          return "f" + acc;
        }
      }, "");
      if (!done) {
        return u64(0);
      }
      return _serializeValue(1, 27, newI64);
    }
    i642 = parseInt("" + i642, radix);
    if (isNaN(i642)) {
      throw new RangeError("Invalid number.");
    }
    i642 = Math.min(Math.max(0, -i642 - 1), 9007199254740992);
    i642 = i642.toString(16);
    return _serializeValue(1, 27, i642);
  };
  var number = function(n) {
    if (n >= 0) {
      if (n < 24) {
        return uSmall(n);
      } else if (n <= 255) {
        return u8(n);
      } else if (n <= 65535) {
        return u16(n);
      } else if (n <= 4294967295) {
        return u32(n);
      } else {
        return u64(n);
      }
    } else {
      if (n >= -24) {
        return iSmall(n);
      } else if (n >= -255) {
        return i8(n);
      } else if (n >= -65535) {
        return i16(n);
      } else if (n >= -4294967295) {
        return i32(n);
      } else {
        return i64(n);
      }
    }
  };
  var bytes = function(bytes2) {
    return _concat(_serializeNumber(2, bytes2.byteLength), bytes2);
  };
  var string = function(str) {
    return _serializeString(str);
  };
  var array = function(items) {
    return _concat(_serializeNumber(4, items.length), ...items);
  };
  var map = function(items, stable = false) {
    if (!(items instanceof Map)) {
      items = new Map(Object.entries(items));
    }
    let entries = Array.from(items.entries());
    if (stable) {
      entries = entries.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));
    }
    return _concat(_serializeNumber(5, items.size), ...entries.map(([k, v]) => _concat(_serializeString(k), v)));
  };
  var singleFloat = function(f) {
    const single = new Float32Array([f]);
    return _concat(new Uint8Array([(7 << 5) + 26]), new Uint8Array(single.buffer));
  };
  var doubleFloat = function(f) {
    const single = new Float64Array([f]);
    return _concat(new Uint8Array([(7 << 5) + 27]), new Uint8Array(single.buffer));
  };
  var bool = function(v) {
    return v ? true_() : false_();
  };
  var true_ = function() {
    return raw(new Uint8Array([(7 << 5) + 21]));
  };
  var false_ = function() {
    return raw(new Uint8Array([(7 << 5) + 20]));
  };
  var null_ = function() {
    return raw(new Uint8Array([(7 << 5) + 22]));
  };
  var undefined_ = function() {
    return raw(new Uint8Array([(7 << 5) + 23]));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MAX_U64_NUMBER = 9007199254740992;
  exports.tagged = tagged;
  exports.raw = raw;
  exports.uSmall = uSmall;
  exports.u8 = u8;
  exports.u16 = u16;
  exports.u32 = u32;
  exports.u64 = u64;
  exports.iSmall = iSmall;
  exports.i8 = i8;
  exports.i16 = i16;
  exports.i32 = i32;
  exports.i64 = i64;
  exports.number = number;
  exports.bytes = bytes;
  exports.string = string;
  exports.array = array;
  exports.map = map;
  exports.singleFloat = singleFloat;
  exports.doubleFloat = doubleFloat;
  exports.bool = bool;
  exports.true_ = true_;
  exports.false_ = false_;
  exports.null_ = null_;
  exports.undefined_ = undefined_;
});

// node_modules/simple-cbor/src/serializer.js
var require_serializer = __commonJS((exports) => {
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var cbor = __importStar(require_value());
  var BufferClasses = [
    ArrayBuffer,
    Uint8Array,
    Uint16Array,
    Uint32Array,
    Int8Array,
    Int16Array,
    Int32Array,
    Float32Array,
    Float64Array
  ];

  class JsonDefaultCborEncoder {
    constructor(_serializer, _stable = false) {
      this._serializer = _serializer;
      this._stable = _stable;
      this.name = "jsonDefault";
      this.priority = -100;
    }
    match(value) {
      return ["undefined", "boolean", "number", "string", "object"].indexOf(typeof value) != -1;
    }
    encode(value) {
      switch (typeof value) {
        case "undefined":
          return cbor.undefined_();
        case "boolean":
          return cbor.bool(value);
        case "number":
          if (Math.floor(value) === value) {
            return cbor.number(value);
          } else {
            return cbor.doubleFloat(value);
          }
        case "string":
          return cbor.string(value);
        case "object":
          if (value === null) {
            return cbor.null_();
          } else if (Array.isArray(value)) {
            return cbor.array(value.map((x) => this._serializer.serializeValue(x)));
          } else if (BufferClasses.find((x) => value instanceof x)) {
            return cbor.bytes(value.buffer);
          } else if (Object.getOwnPropertyNames(value).indexOf("toJSON") !== -1) {
            return this.encode(value.toJSON());
          } else if (value instanceof Map) {
            const m = new Map;
            for (const [key, item] of value.entries()) {
              m.set(key, this._serializer.serializeValue(item));
            }
            return cbor.map(m, this._stable);
          } else {
            const m = new Map;
            for (const [key, item] of Object.entries(value)) {
              m.set(key, this._serializer.serializeValue(item));
            }
            return cbor.map(m, this._stable);
          }
        default:
          throw new Error("Invalid value.");
      }
    }
  }
  exports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;

  class ToCborEncoder {
    constructor() {
      this.name = "cborEncoder";
      this.priority = -90;
    }
    match(value) {
      return typeof value == "object" && typeof value["toCBOR"] == "function";
    }
    encode(value) {
      return value.toCBOR();
    }
  }
  exports.ToCborEncoder = ToCborEncoder;

  class CborSerializer {
    constructor() {
      this._encoders = new Set;
    }
    static withDefaultEncoders(stable = false) {
      const s2 = new this;
      s2.addEncoder(new JsonDefaultCborEncoder(s2, stable));
      s2.addEncoder(new ToCborEncoder);
      return s2;
    }
    removeEncoder(name) {
      for (const encoder of this._encoders.values()) {
        if (encoder.name == name) {
          this._encoders.delete(encoder);
        }
      }
    }
    addEncoder(encoder) {
      this._encoders.add(encoder);
    }
    getEncoderFor(value) {
      let chosenEncoder = null;
      for (const encoder of this._encoders) {
        if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {
          if (encoder.match(value)) {
            chosenEncoder = encoder;
          }
        }
      }
      if (chosenEncoder === null) {
        throw new Error("Could not find an encoder for value.");
      }
      return chosenEncoder;
    }
    serializeValue(value) {
      return this.getEncoderFor(value).encode(value);
    }
    serialize(value) {
      return this.serializeValue(value);
    }
  }
  exports.CborSerializer = CborSerializer;

  class SelfDescribeCborSerializer extends CborSerializer {
    serialize(value) {
      return cbor.raw(new Uint8Array([
        ...new Uint8Array([217, 217, 247]),
        ...new Uint8Array(super.serializeValue(value))
      ]));
    }
  }
  exports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;
});

// node_modules/simple-cbor/src/index.js
var require_src2 = __commonJS((exports) => {
  var __export2 = function(m) {
    for (var p in m)
      if (!exports.hasOwnProperty(p))
        exports[p] = m[p];
  };
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __export2(require_serializer());
  var value = __importStar(require_value());
  exports.value = value;
});

// node_modules/@dfinity/agent/lib/esm/cbor.js
var exports_cbor = {};
__export(exports_cbor, {
  encode: () => {
    {
      return encode3;
    }
  },
  decode: () => {
    {
      return decode3;
    }
  },
  CborTag: () => {
    {
      return CborTag;
    }
  }
});
function encode3(value2) {
  return serializer.serialize(value2);
}
function decode3(input) {
  const buffer7 = new Uint8Array(input);
  const decoder = new Uint8ArrayDecoder({
    size: buffer7.byteLength,
    tags: {
      2: (val) => decodePositiveBigInt(val),
      3: (val) => -decodePositiveBigInt(val),
      [CborTag.Semantic]: (value2) => value2
    }
  });
  return decoder.decodeFirst(buffer7);
}

class PrincipalEncoder {
  get name() {
    return "Principal";
  }
  get priority() {
    return 0;
  }
  match(value2) {
    return value2 && value2._isPrincipal === true;
  }
  encode(v) {
    return cbor.value.bytes(v.toUint8Array());
  }
}

class BufferEncoder {
  get name() {
    return "Buffer";
  }
  get priority() {
    return 1;
  }
  match(value2) {
    return value2 instanceof ArrayBuffer || ArrayBuffer.isView(value2);
  }
  encode(v) {
    return cbor.value.bytes(new Uint8Array(v));
  }
}

class BigIntEncoder {
  get name() {
    return "BigInt";
  }
  get priority() {
    return 1;
  }
  match(value2) {
    return typeof value2 === `bigint`;
  }
  encode(v) {
    if (v > BigInt(0)) {
      return cbor.value.tagged(2, cbor.value.bytes(fromHex(v.toString(16))));
    } else {
      return cbor.value.tagged(3, cbor.value.bytes(fromHex((BigInt("-1") * v).toString(16))));
    }
  }
}

class Uint8ArrayDecoder extends import_borc2?.default.Decoder {
  createByteString(raw) {
    return concat3(...raw);
  }
  createByteStringFromHeap(start, end) {
    if (start === end) {
      return new ArrayBuffer(0);
    }
    return new Uint8Array(this._heap.slice(start, end));
  }
}
var import_borc2, cbor, import_simple_cbor, decodePositiveBigInt, serializer, CborTag;
var init_cbor = __esm(() => {
  import_borc2 = __toESM(require_src(), 1);
  cbor = __toESM(require_src2(), 1);
  import_simple_cbor = __toESM(require_src2(), 1);
  init_buffer2();
  decodePositiveBigInt = function(buf) {
    const len = buf.byteLength;
    let res = BigInt(0);
    for (let i = 0;i < len; i++) {
      res = res * BigInt(256) + BigInt(buf[i]);
    }
    return res;
  };
  serializer = import_simple_cbor.SelfDescribeCborSerializer.withDefaultEncoders(true);
  serializer.addEncoder(new PrincipalEncoder);
  serializer.addEncoder(new BufferEncoder);
  serializer.addEncoder(new BigIntEncoder);
  (function(CborTag2) {
    CborTag2[CborTag2["Uint64LittleEndian"] = 71] = "Uint64LittleEndian";
    CborTag2[CborTag2["Semantic"] = 55799] = "Semantic";
  })(CborTag || (CborTag = {}));
});

// node_modules/base64-arraybuffer/lib/base64-arraybuffer.js
var require_base64_arraybuffer = __commonJS((exports) => {
  (function() {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = new Uint8Array(256);
    for (var i = 0;i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }
    exports.encode = function(arraybuffer) {
      var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base642 = "";
      for (i2 = 0;i2 < len; i2 += 3) {
        base642 += chars[bytes[i2] >> 2];
        base642 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
        base642 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
        base642 += chars[bytes[i2 + 2] & 63];
      }
      if (len % 3 === 2) {
        base642 = base642.substring(0, base642.length - 1) + "=";
      } else if (len % 3 === 1) {
        base642 = base642.substring(0, base642.length - 2) + "==";
      }
      return base642;
    };
    exports.decode = function(base642) {
      var bufferLength = base642.length * 0.75, len = base642.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base642[base642.length - 1] === "=") {
        bufferLength--;
        if (base642[base642.length - 2] === "=") {
          bufferLength--;
        }
      }
      var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
      for (i2 = 0;i2 < len; i2 += 4) {
        encoded1 = lookup[base642.charCodeAt(i2)];
        encoded2 = lookup[base642.charCodeAt(i2 + 1)];
        encoded3 = lookup[base642.charCodeAt(i2 + 2)];
        encoded4 = lookup[base642.charCodeAt(i2 + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
  })();
});

// node_modules/@dfinity/agent/lib/esm/vendor/bls/wasm.js
var wasmBytesBase64;
var init_wasm = __esm(() => {
  wasmBytesBase64 = `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akE4ENABGiACQbgDakEBNgIAIAJBwANqQTgQ0AEaIAJB+ANqQQE2AgAgAkGABGpBOBDQARogAkEBNgK4BCACQcAEakE4ENABGiACQfgEakEBNgIAIAJBgAVqQTgQ0AEaIAJBuAVqQQE2AgAgAkHABWpBOBDQARogAkH4BWpBATYCACACQYAGakE4ENABGiACQQE2ArgGIAJBwAZqQTgQ0AEaIAJB+AZqQQE2AgAgAkGAB2pBOBDQARogAkG4B2pBATYCACACQcAHakE4ENABGiACQfgHakEBNgIAIAIgARAYAkAgASgCgAZBBEYNACAAKAKABkEERg0AIAJBgARqIgMgAEGAAmoQlgEgAyABQYACahAYDAYLIAJBwAxqIgdBOBDQARogAkEBNgL4DCACQYANakE4ENABGiACQbgNakEBNgIAIAJBgAhqIgRBOBDQARogAkEBNgK4CCACQcAIakE4ENABGiACQfgIakEBNgIAIAJBgApqIgMgAEGAA2oiBRBeIAQgAxCZASADIAFBgANqIgYQXiAEIAMQESAHELYBIAEoAoAGQQRHDQMMBAsgACABEAMMBgsgAkHADGoiAyABQYAFahBeIAJBgAxqIgQgA0HAABDRARogAkGABmogBBCnAQsgAkGABmoQZCACQYAIaiIDIAIQlgEgAxArIAJBgAJqIgQgAxCXASAGIAQQlgEgAkGABGoiByADEJYBIAMgABCWASADIAUQlwEgAxCwASACQYAKaiIEIAEQlgEgBCABQYAEahCXASAEELABIAMgBBAYIAcgAxCXASADIAUQlgECQCABKAKABkECRwRAIAJBwAxqIgMgAUGABWoQXiACQYAIaiADEKYBDAELIAJBwAxqIgMgAUGABWoQXiACQYAMaiIBIANBwAAQ0QEaIAJBgAhqIAEQpwELIAJBgAhqIgEQZCACQYAKaiIDIAEQlgEgAxArIAUgAkGABGoQlgEgBSADEJcBIAJBgAZqIgQgAxCXASABEGQgBiABEJcBIAQQsAEgBBBkIAAgAhCWASAAIAQQlwEMAwsgAkGACmoiAyAFEF4gAkHADGoiBCADEJkBIAMgAUGAAmoQXiAEIAMQEQsgACgCgAZBBEcEQCACQYAKaiIDIABBgAJqEF4gAkHADGoiBCADEJkBIAMgBhBeIAQgAxARCyACQYAEaiIDIAJB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AEHcu8AAKAIAQX4gA0EDdndxNgIACyAAIAEQoAEgAEH0vsAAKAIARw0BQey+wAAgATYCAAsPCyABQYACTwRAIAAgARAWDwsgAUEDdiICQQN0QeS7wABqIQECf0Hcu8AAKAIAIgNBASACdCICcQRAIAEoAggMAQtB3LvAACACIANyNgIAIAELIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIC+UDAQN/IwBB0CJrIgMkACADQcAWaiIEQcitwAAQSSADQcgcaiIFQYCuwAAQSSADQQhqIAQgBRBLIANBiAFqQTgQ0AEaIANBwAFqQTgQ0AEaIANB+AFqED0CQCACEIYBBEAgABBVDAELIANB+ARqIgQQPSAEIAEQfSAEEEcgA0H4B2oiARBnIAEgAhB4IAEQRiADQcgcaiICIAEQkAEgA0G4CWogAhCQASACIANBuAhqEJABIANB+AlqIAIQkAEgA0G4CmoiARA9IANBuA1qEFUgASAEEH0gA0HAE2oiARA9IAEgBBB9IAEQogEgA0HAAWogA0GIAWoQUEECayECA0AgAkEBakEBTQRAIANBuA1qIgEQngEgACABQYgGENEBGgUgA0G4DWoQGiADQcAWaiADQbgKaiADQbgJaiADQfgJahALAkACQAJAIANBwAFqIAIQUyADQYgBaiACEFNrQQFqDgMBAgACCyADQcgcaiIBIANBuApqIANB+ARqIANBuAlqIANB+AlqEAogA0HAFmogARADDAELIANByBxqIgEgA0G4CmogA0HAE2ogA0G4CWogA0H4CWoQCiADQcAWaiABEAMLIAJBAWshAiADQbgNaiADQcAWahABDAELCwsgA0HQImokAAvBAwEVfwNAIANBwAFGBEACQCAAQShqIQsgAEEUaigCACIMIQggAEEQaigCACINIQIgAEEMaigCACIOIQEgACgCCCIPIQMgAEEYaigCACIQIQogAEEcaigCACIRIQQgAEEgaigCACISIQcgAEEkaigCACITIQYDQCAHIQkgBCEHIAohBCAFQYACRg0BIAEgAnEhFCABIAJzIRUgBSALaigCACAFQcCiwABqKAIAIAkgBEF/c3EgBCAHcXIgBmogBEEadyAEQRV3cyAEQQd3c2pqaiIGIAhqIQogBUEEaiEFIAIhCCABIQIgAyIBQR53IAFBE3dzIAFBCndzIBQgASAVcXNqIAZqIQMgCSEGDAALAAsFIAAgA2oiAkHoAGogAkEoaigCACACQcwAaigCACACQeAAaigCACIBQQ93IAFBDXdzIAFBCnZzamogAkEsaigCACIBQRl3IAFBDndzIAFBA3ZzajYCACADQQRqIQMMAQsLIAAgBiATajYCJCAAIAkgEmo2AiAgACAHIBFqNgIcIAAgBCAQajYCGCAAIAggDGo2AhQgACACIA1qNgIQIAAgASAOajYCDCAAIAMgD2o2AggL5AEBAn8jAEGAA2siAyQAIAMQPSAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbyAAIAFBgANqIAJBAXNBAWtBH3YQbyAAIAFBgAZqIAJBAnNBAWtBH3YQbyAAIAFBgAlqIAJBA3NBAWtBH3YQbyAAIAFBgAxqIAJBBHNBAWtBH3YQbyAAIAFBgA9qIAJBBXNBAWtBH3YQbyAAIAFBgBJqIAJBBnNBAWtBH3YQbyAAIAFBgBVqIAJBB3NBAWtBH3YQbyADIAAQfSADEKIBIAAgAyAEQQFxEG8gA0GAA2okAAvlAwEIfyMAQZAGayICJAAgAEFAayEIAkAgAUH4AGooAgAgASgCOGqsIABB+ABqKAIAIgcgACgCOCIEaqx+Qv///w9XDQAgBEEBSgR/IAAQHiAAKAJ4BSAHC0EBTA0AIAgQHgsgAkHYpMAAEEkgAkE4aiIHQfAAENABGiACIQNBACECA0AgAkE4RgRAAkAgB0E4aiEEQQAhAgNAIAJBOEYNASACIARqIAIgA2opAwA3AwAgAkEIaiECDAALAAsFIAIgB2pCADcDACACQQhqIQIMAQsLIANBqAFqIgYgABBdIANB4AFqIgUgARBdIANBmAJqIgIgACABEAUgA0GIA2oiBCAIIAFBQGsiARAFIAYgCBBgIAYQQiAFIAEQYCAFEEIgA0H4A2oiCSAGIAUQBUEAIQEgA0HoBGoiBkHwABDQASEFA0AgAUHwAEcEQCABIAVqIAEgAmopAwA3AwAgAUEIaiEBDAELCyAGIAQQYkEAIQEDQCABQfAARwRAIAEgBGoiBSABIAdqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAiAEEGIgAhBIIAkgBhBjIAkQSCADQdgFaiIBIAIQayAAIAEQaiAAQQM2AjggASAJEGsgCCABEGogAEECNgJ4IANBkAZqJAALowIBCH8jAEGABmsiAiQAIAIgAEGAAWoiBxBeIAJBgAFqIgQgBxBeIAQQLSACQYACaiIFIAIQXiAFIABBgAJqIgMQESACQYADaiIBIAMQXiABEC0gAyAEEJkBIAMgBBCaASADEKkBIAMQuAEgAxC4ASADEKkBIAFBDBCrASABEHwgARCpASACQYAEaiIIIAEQXiAIIAMQESACQYAFaiIGIAQQXiAGIAEQmgEgBhCpASADIAUQESAFIAEQmQEgBSABEJoBIAEgBRCaASABEKkBIAQgARB7IAQQqQEgBiAEEBEgBiAIEJoBIAUgABCZASAFIAIQESAAIAQQmQEgABCpASAAIAUQESAAELgBIAAQqQEgByAGEJkBIAcQqQEgAkGABmokAAu8AgEGfyMAQYAIayIBJAAgASAAEIwBIAFBgAJqIgMgAEGABGoiBRCMASABQYAEaiIEIABBgAJqIgYQjAEgAUGABmoiAkE4ENABGiABQQE2ArgGIAFBwAZqQTgQ0AEaIAFB+AZqQQE2AgAgAUGAB2pBOBDQARogAUG4B2pBATYCACABQcAHakE4ENABGiABQfgHakEBNgIAIAAQISACIAAQlgEgAiAAEJcBIAAgAhCXASAAELABIAEQyQEgARCzASAAIAEQlwEgAxAhIAMQZCACIAMQlgEgAiADEJcBIAMgAhCXASADELABIAQQISACIAQQlgEgAiAEEJcBIAQgAhCXASAEELABIAYQsgEgBhCzASAFEMkBIAUQswEgBiADEJcBIAUgBBCXASAAQQU2AoAGIAAQnAEgAUGACGokAAv/AQEHfyMAQcACayIBJAAgASAAQUBrIgYQkAEgARBMIAFBQGsiAyAGEJABIAMgAEGAAWoiAhBKIAFBgAFqIgQgAhCQASAEEEwgAiABEK4BIAIgARB3IAIQQiACEIIBIAIQggEgAhBCIARBDBA0IAFBwAFqIgcgBBCQASAHIAIQSiABQYACaiIFIAEQkAEgBSAEEHcgBRBCIAIgAxBKIAMgBBCuASADIAQQdyAEIAMQdyABIAQQfiABEEIgBSABEEogBSAHEHcgAyAAEK4BIAMgBhBKIAAgARCuASAAEEIgACADEEogABCCASAAEEIgBiAFEK4BIAYQQiABQcACaiQAC84CAgd/An4CQAJAAkBBDSABQTpuIgJrIgRBDU0EQEEMIAJrIgNBDk8NASAAIAAgA0EDdGopAwBBOiABIAJBOmxrIgNrrSIKhyAAIARBA3RqKQMAIAOtIgmGhDcDaCAEQQ1rIQUgAEHgAGohBCACQQFqIQZBACACQQN0ayEHQQshAwNAAkAgA0ECaiAGTQRAIAFBrAZPDQEgACACQQN0aiAAKQMAIAmGQv//////////A4M3AwADQCACRQ0HIABCADcDACACQQFrIQIgAEEIaiEADAALAAsgAyAFakEOTw0EIAQgBCAHaiIIQQhrKQMAIAqHIAgpAwAgCYZC//////////8Dg4Q3AwAgA0EBayEDIARBCGshBAwBCwsgAkEOQYCywAAQOwALIARBDkHQscAAEDsACyADQQ5B4LHAABA7AAtBf0EOQfCxwAAQOwALC6cCAQR/IABCADcCECAAAn9BACABQYACSQ0AGkEfIAFB////B0sNABogAUEGIAFBCHZnIgNrdkEBcSADQQF0a0E+agsiBDYCHCAEQQJ0Qey9wABqIQMgACECAkACQAJAAkBB4LvAACgCACIAQQEgBHQiBXEEQCADKAIAIQMgBBCfASEAIAMQywEgAUcNASADIQAMAgtB4LvAACAAIAVyNgIAIAMgAjYCAAwDCyABIAB0IQQDQCADIARBHXZBBHFqQRBqIgUoAgAiAEUNAiAEQQF0IQQgACIDEMsBIAFHDQALCyAAKAIIIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCCACQQA2AhgPCyAFIAI2AgALIAIgAzYCGCACIAI2AgggAiACNgIMC7YCAQV/IAAoAhghBAJAAkAgACAAKAIMRgRAIABBFEEQIABBFGoiASgCACIDG2ooAgAiAg0BQQAhAQwCCyAAKAIIIgIgACgCDCIBNgIMIAEgAjYCCAwBCyABIABBEGogAxshAwNAIAMhBSACIgFBFGoiAygCACICRQRAIAFBEGohAyABKAIQIQILIAINAAsgBUEANgIACwJAIARFDQACQCAAIAAoAhxBAnRB7L3AAGoiAigCAEcEQCAEQRBBFCAEKAIQIABGG2ogATYCACABDQEMAgsgAiABNgIAIAENAEHgu8AAQeC7wAAoAgBBfiAAKAIcd3E2AgAPCyABIAQ2AhggACgCECICBEAgASACNgIQIAIgATYCGAsgAEEUaigCACIARQ0AIAFBFGogADYCACAAIAE2AhgLC+UBAQZ/IwBBgARrIgIkACACIAAQXiACQYABaiIFIABBgAFqIgYQXiACQYACaiIDQTgQ0AEaIAJBATYCuAIgAkHAAmpBOBDQARogAkH4AmpBATYCACACQYADaiIEIAYQXiACIAEQESAFIAFBgAFqIgcQESADIAcQmQEgAyABEJoBIAQgABCaASADEKkBIAQQqQEgBCADEBEgAyACEJkBIAMQNiAEIAMQmgEgBBCpASADIAUQmQEgAxA2IAYgBBCZASAGIAMQmgEgBRB8IAAgBRCZASAAIAIQmgEgABCwASACQYAEaiQAC28BDH9BjL/AACgCACICRQRAQZy/wABB/x82AgBBAA8LQYS/wAAhBgNAIAIiASgCCCECIAEoAgQhAyABKAIAIQQgAUEMaigCABogASEGIAVBAWohBSACDQALQZy/wAAgBUH/HyAFQf8fSxs2AgBBAAuAAgEGfyMAQYAIayIBJAAgACgCgAZBAUcEQCABIAAQjAEgAUGAAmoiAiAAQYACaiIEEIwBIAFBgARqIgUgAEGABGoiAxCMASABQYAGaiIGIAAQjAEgARAhIAIgAxAYIAIQswEgAhCwASAFECEgBiAEEBggBhCzASADIAAQlwEgAyAEEJcBIAMQsAEgAxAhIAAgARCWASABIAIQlwEgARCwASABIAUQlwEgASAGEJcBIAEQsAEgARArIAIQZCAFEGQgACACEJcBIAQgBRCWASAEIAYQlwEgAyABEJcBIABBBEEFIAAoAoAGQX5xQQJGGzYCgAYgABCdAQsgAUGACGokAAuZAgEBfyMAQYANayIDJAAgAyABEGkgAxCdASADQYgGaiIBIAIQXSABEEIgA0HABmoiAiABEF0gAkEDECkaIAIQQiADQfgGaiADEGkCQCACEFdFBEAgA0HABmoQKkECayECA0AgAkEBakEBTQRAIANB+AZqIgEQnAEMAwUgA0H4BmoQEwJAAkACQCADQcAGaiACEFMgA0GIBmogAhBTa0EBag4DAQIAAgsgA0H4BmogAxAHDAELIAMQngEgA0H4BmogAxAHIAMQngELIAJBAWshAgwBCwALAAsgA0H4BmoiARC3ASABQYABahC2ASABQYACahCxASABQYAEahCxASABQQE2AoAGCyAAIAFBiAYQ0QEaIANBgA1qJAALhgICBH8BfiMAQTBrIgIkACABQQRqIQQgASgCBEUEQCABKAIAIQMgAkEQaiIFQQA2AgAgAkIBNwMIIAIgAkEIajYCFCACQShqIANBEGopAgA3AwAgAkEgaiADQQhqKQIANwMAIAIgAykCADcDGCACQRRqIAJBGGoQDBogBEEIaiAFKAIANgIAIAQgAikDCDcCAAsgAkEgaiIDIARBCGooAgA2AgAgAUEMakEANgIAIAQpAgAhBiABQgE3AgQgAiAGNwMYQQxBBBC5ASIBRQRAQQxBBBDPAQALIAEgAikDGDcCACABQQhqIAMoAgA2AgAgAEGEt8AANgIEIAAgATYCACACQTBqJAAL5AEBAn8jAEHAAWsiAyQAIAMQZyAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbiAAIAFBwAFqIAJBAXNBAWtBH3YQbiAAIAFBgANqIAJBAnNBAWtBH3YQbiAAIAFBwARqIAJBA3NBAWtBH3YQbiAAIAFBgAZqIAJBBHNBAWtBH3YQbiAAIAFBwAdqIAJBBXNBAWtBH3YQbiAAIAFBgAlqIAJBBnNBAWtBH3YQbiAAIAFBwApqIAJBB3NBAWtBH3YQbiADIAAQeCADEKQBIAAgAyAEQQFxEG4gA0HAAWokAAvDAwIGfwN+IwBB8ABrIgEkACABQcCywAAQSSABQThqIAEQXSAAEEICQAJAAkAgAQJ/IAAoAjgiAkEQTARAIAJBAWsQNQwBCyABKQMwIghCAXwiByAIVA0BIAApAzAiCEKAgICAgICAgIB/USAHQn9RcQ0CIAFBOGoiAiAIIAd/pxApIQcgASABKQNoIAdCOoZ8NwNoIAAgAhBhIAAQQkECCyIEECgDQCAERQ0DQQAhAyABIAEpAwgiCEI5hkKAgICAgICAgAKDIAEpAwBCAYeEIgc3AwAgACkDACAHfSEHIABBCGohBSAAIAFBOGoiAkEBA38gAiADaiAHQv//////////A4M3AwAgB0I6hyEHIANBKEYEfyABIAEpAzBCAYciCDcDMCACIAApAzAgCH0gB3wiBzcDMCAHQj+IpwUgASADaiIGQQhqIAhCAYcgBkEQaikDACIIQjmGQoCAgICAgICAAoOEIgk3AwAgAyAFaikDACAHfCAJfSEHIANBCGohAwwBCwtrEDAgBEEBayEEDAALAAtB4LPAAEEZQcSzwAAQWQALQYC0wABBH0HEs8AAEFkACyAAQQE2AjggAUHwAGokAAvuAQECfyMAQbABayIDJAAgA0EwENABIQMCQAJAA0AgAkEwRgRAIANBMGogAxBwIAFBMGohAUEAIQIDQCACQTBGDQMgAkEwRg0EIAIgA2ogASACai0AADoAACACQQFqIQIMAAsACyACQeAARwRAIAIgA2ogASACai0AADoAACACQQFqIQIMAQsLQeAAQeAAQYCmwAAQOwALIANB8ABqIgEgAxBwIABBOBDQASIAQQE2AjggAEFAa0E4ENABIABB+ABqQQE2AgAgACABEK4BIANBMGoQrgEgA0GwAWokAA8LIAJBMGpB4ABBkKbAABA7AAuPAgEDfyMAQSBrIgUkAEEBIQZB2LvAAEHYu8AAKAIAIgdBAWo2AgACQEGgv8AALQAABEBBpL/AACgCAEEBaiEGDAELQaC/wABBAToAAAtBpL/AACAGNgIAAkACQCAHQQBIIAZBAktyDQAgBSAEOgAYIAUgAzYCFCAFIAI2AhBBzLvAACgCACICQQBIDQBBzLvAACACQQFqIgI2AgBBzLvAAEHUu8AAKAIAIgMEf0HQu8AAKAIAIAUgACABKAIQEQAAIAUgBSkDADcDCCAFQQhqIAMoAhQRAABBzLvAACgCAAUgAgtBAWs2AgAgBkEBSw0AIAQNAQsACyMAQRBrIgIkACACIAE2AgwgAiAANgIIAAucAQEEfyMAQYADayICJAAgAiAAEF4gAkGAAWoiASAAQYABaiIEEF4gAkGAAmoiAyAAEF4gAyAEEBEgAiAEEJoBIAEQfCABIAAQmgEgAhCpASABEKkBIAAgAhCZASAAIAEQESABIAMQmQEgARB8IAEgAxCaASABEKkBIAEQNiAAIAEQmgEgAxC4ASAEIAMQmQEgABCwASACQYADaiQAC7kBAQJ/IwBBIGsiAyQAAkAgASABIAJqIgFLDQAgAEEEaigCACICQQF0IgQgASABIARJGyIBQQggAUEISxshAQJAIAIEQCADQRhqQQE2AgAgAyACNgIUIAMgACgCADYCEAwBCyADQQA2AhALIAMgASADQRBqECYgAygCAARAIANBCGooAgAiAEUNASADKAIEIAAQzwEACyADKAIEIQIgAEEEaiABNgIAIAAgAjYCACADQSBqJAAPCxBlAAusAQECfyMAQYADayIDJAAgA0EIaiABEJABAkAgAgRAIANBCGogAhCuAQwBCyADQQhqEDoLIANByABqIgJB8LTAABBJIANBgAFqIAIQjgEgA0HAAWoiAiADQQhqIgQQkAEgAhBMIAIgARBKIAAgARCQASAAIAQQSiADQYACaiACEJABIAAQViEBIANBwAJqIgIgABCQASACEEMgAhBCIAAgAiABEHIgA0GAA2okAAueAQEFfyMAQYABayICJAAgAkE4ENABIgJBATYCOCACQUBrIgNBOBDQARogAkEBNgJ4IAIgABCuASACIAFBgAFqIgUQSiADIAEQrgEgAyAAQYABaiIGEEoCQCACIAMQWEUNACACIABBQGsQrgEgAiAFEEogAkFAayIAIAFBQGsQrgEgACAGEEogAiAAEFhFDQBBASEECyACQYABaiQAIAQLpwEBA38jAEEwayICJAAgAUEEaiEDIAEoAgRFBEAgASgCACEBIAJBEGoiBEEANgIAIAJCATcDCCACIAJBCGo2AhQgAkEoaiABQRBqKQIANwMAIAJBIGogAUEIaikCADcDACACIAEpAgA3AxggAkEUaiACQRhqEAwaIANBCGogBCgCADYCACADIAIpAwg3AgALIABBhLfAADYCBCAAIAM2AgAgAkEwaiQAC5UBAQJ/AkACQAJAAkACfwJAAkACf0EBIgMgAUEASA0AGiACKAIAIgRFDQEgAigCBCICDQQgAQ0CQQEMAwshA0EAIQEMBgsgAQ0AQQEMAQsgAUEBELkBCyICRQ0BDAILIAQgARCsASICDQELIAAgATYCBEEBIQEMAQsgACACNgIEQQAhAwsgACADNgIAIABBCGogATYCAAvvMwISfwV+IwBBMGsiDiQAIA5BEGogACABEFsgDiAOKAIUIgA2AhwgDiAOKAIQIgg2AhggDkEIaiACIAMQWyAOIA4oAgwiATYCJCAOIA4oAggiAzYCICAOIAQgBRBbIA4gDigCBCIFNgIsIA4gDigCACINNgIoIAAhBCMAQZAVayICJAAjAEGwBmsiCiQAIApBEGpBOBDQARogCkHQAGpBOBDQASEVIApBiAFqQQE2AgAgCkEBNgJIIApBkAFqIgBB2KTAABBJIAAQKiEPIApByAFqIhNBgAIQ0AEaIApB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ABBJAkACQAJAAkADQAJAIAxBMEYEQCAAIAAtAABBH3E6AAAgAEHoAGogABC+ASAEDQFBAEEAQZiBwAAQOwALIAQgDEYNAiAAIAxqIAggDGotAAA6AAAgDEEBaiEMDAELC0EAIQwgCCwAACIJQQBIDQIgCEEwaiEDIARBMCAEQTBLG0EwayEIA0AgDEEwRgRAIABBoAFqIgQgABC+ASMAQYABayIDJAAgARBnIAEgAEHoAGoQwAEgAUFAayIIIAQQwAEgAUGAAWoQygEgARBCIAMgARBPIANBQGsiBCAIEJABIAQQTCAEIAMQWEUEQCABEJIBCyADQYABaiQADAULIAggDEYNAiAAIAxqIAMgDGotAAA6AAAgDEEBaiEMDAALAAsgBCAEQYiBwAAQOwALIAxBMGogBEGogcAAEDsACyMAQcABayIDJAAgAEGgAWoiBBBnIANBOBDQASIDQQE2AjggBCAAQegAahDAASAEEEIgBEGAAWoQygEgA0FAayIIIAQQTwJAAkACQCAIIAMQWkEBRgRAIANBgAFqIgggA0FAayADECMgCBBWDQEMAgsgBBCSAQwCCyADQYABaiIIEEMgCBBCCyAEQUBrIANBgAFqEK4BCyADQcABaiQAIAlBIHEiA0EAIABB4AFqEE0iBEEBRxtBASADIARBAUdyGwRAIABBoAFqEKQBCyABIABBoAFqQcABENEBGgsgAEHgAmokAAJ/QQAhAyMAQcAFayIAJAACQCABEIYBDQAgAEEIaiIIQZCtwAAQSSAAQYAEaiIEQbiuwAAQSSAAQUBrIgkgBBCOASAAQYABaiIEEGcgBCABEHggBCAJEEogAEHAAmoiBCABIAgQvQEgASAEECQNACAAQYAEaiIEIABBwAJqIgEgAEEIahC9ASABIARBwAEQ0QEaIAEQpAEgAEGAAWogARAkRQ0AQQEhAwsgAEHABWokAEF/IANFDQAaIAJBwAFqEKQBIAJBgANqIQhBACEAIwBB4ARrIgEkACABQeAAENABIQECQCAFBEADQCAAQeAARgRAIAEgAS0AAEEfcToAACABQeAAaiABEB9BACEAAkAgDSwAACILQQBOBEAgDUHgAGohAyAFQeAAIAVB4ABLG0HgAGshBANAIABB4ABGBEAgAUHgAWoiACABEB8gCCABQeAAaiAAED8MAwsgACAERwRA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AWoQmQEgACAEEBEgAEGAAWoiASAFQYABahCZASABIAgQESAAIAEQeg0BC0EADAELQQELIQEgAEGAAmokACANQcAHaiQAQX8gAUUNABojAEHgA2siACQAIABBgAFqIgFBwKjAABBJIABBuAFqIgNB+KjAABBJIAAgASADEEsgAEHwAmoiAUGwqcAAEEkgAEGoA2oiA0HoqcAAEEkgAEHwAWoiBCABIAMQSyACQYAGaiIBIAAgBBA/IABB4ANqJAAgAkGACWohByACQYADaiEIIwBBkDRrIgAkACAAQYAoaiIDQcitwAAQSSAAQYguaiIEQYCuwAAQSSAAIAMgBBBLIABBgAFqQTgQ0AEaIABBuAFqQTgQ0AEaIABB8AFqED0CQCACQcABaiIEEIYBRQRAIAIQhgEEQCAHIAEgBBAODAILIABB8ARqIgMQPSADIAEQfSADEEcgAEHwB2oiBRBnIAUgBBB4IAUQRiAAQbAJaiIEED0gBCAIEH0gBBBHIABBsAxqIggQZyAIIAIQeCAIEEYgAEGILmoiASAFEJABIABB8A1qIAEQkAEgASAAQbAIahCQASAAQbAOaiABEJABIAEgCBCQASAAQfAOaiABEJABIAEgAEHwDGoQkAEgAEGwD2ogARCQASAAQfAPaiIBED0gAEHwEmoiBRA9IABB8BVqEFUgASADEH0gBSAEEH0gAEH4G2oiARA9IAEgAxB9IAEQogEgAEH4HmoiARA9IAEgBBB9IAEQogEgAEG4AWogAEGAAWoQUEECayEBA0AgAUEBakEBTQRAIABB8BVqIgEQngEgByABQYgGENEBGgwDBSAAQfAVaiIEEBogAEH4IWoiAyAAQfAPaiAAQfANaiAAQbAOahALIABBgChqIgUgAEHwEmogAEHwDmogAEGwD2oQCyADIAUQAyAEIAMQAQJAAkACQCAAQbgBaiABEFMgAEGAAWogARBTa0EBag4DAQIAAgsgAEGILmoiAyAAQfAPaiAAQfAEaiAAQfANaiAAQbAOahAKIABB+CFqIgQgA0GIBhDRARogAyAAQfASaiAAQbAJaiAAQfAOaiAAQbAPahAKIAQgAxADIABB8BVqIAQQAQwBCyAAQYguaiIDIABB8A9qIABB+BtqIABB8A1qIABBsA5qEAogAEH4IWoiBCADQYgGENEBGiADIABB8BJqIABB+B5qIABB8A5qIABBsA9qEAogBCADEAMgAEHwFWogBBABCyABQQFrIQEMAQsACwALIAcgCCACEA4LIABBkDRqJAAjAEHgH2siCCQAIAhB0BNqIgFByK3AABBJIAhB2BlqIg1BgK7AABBJIAggASANEEsgCEGAAWoiC0GQrcAAEEkgAkGID2oiACAHEGkgCEG4AWoiBSAAEGkjAEGACGsiAyQAIAMgBRCMASADQYACaiIJIAVBgAJqIg8QjAEgA0GABGoiCiAFEIwBIANBgAZqIgRBOBDQARogA0EBNgK4BiADQcAGakE4ENABGiADQfgGakEBNgIAIANBgAdqQTgQ0AEaIANBuAdqQQE2AgAgA0HAB2pBOBDQARogA0H4B2pBATYCACAFEJ0BIAMQISAJIAVBgARqIgwQGCAJEGQgAyAJEHkgAxCwASAJIAwQlgEgCRAhIAkQZCAKIA8QGCAJIAoQeSAJELABIAogDxCWASAKECEgBCAFEJYBIAQgDBAYIAogBBB5IAoQsAEgBCAPEJYBIAQgChAYIAQQZCAFIAMQGCAEIAUQlwEgDCAJEBggDBBkIAQgDBCXASAEELABIwBBgAJrIgYkACAGIAQQXiAGQYABaiIQIARBgAFqIhIQXiAGEC0gEBAtIBAQfCAQEKkBIAYgEBB7IAYQPiAEIAYQESAGEDYgBhCpASASIAYQESAGQYACaiQAIAUgAxCWASAFIAQQGCAPIAkQlgEgDyAEEBggDCAKEJYBIAwgBBAYIAVBBTYCgAYgA0GACGokACAAEJ4BIAAgBRAHIAUgABBtIAAgCBAyIAAgCBAyIAAgBRAHIAhBwAdqIgQgABBpIAQQEyAEIAAQByANIAAgCxAbIAhByA1qIgMgDRBpIAMQngEgASAAEGkgARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gASAIEDIgACADEG0gACABEAcgDSAAIAsQGyADIA0QbSANIAMgCxAbIAMgDRBtIAEgABBtIAEgCBAyIAEgCBAyIAMgARAHIAEgABBtIAEQngEgACADEG0gACABEAcgACAEEAcgABCcASAIQeAfaiQAIAcgAEGIBhDRARpBACEAIwBBgAJrIgEkACABEGwCQCAHIAEQegR/IAdBgAFqIAFBgAFqEHoFQQALRQ0AIAdBgAJqEIcBRQ0AIAdBgARqEIcBIQALIAFBgAJqJABBACAADQAaQX8LIAJBkBVqJAAgDkEoahC0ASAOQSBqELQBIA5BGGoQtAEgDkEwaiQAC58BAgJ/BX4gAEEwaiICKQMAIAFBP3GtIgSGIQUgACkDKCIGQTogAWtBP3GtIgiHIQdBBiEBA38gAiAFIAeENwMAIAFBAU0EfyAAIAApAwAgBIZC//////////8DgzcDACAAKQMwQiSHpwUgAUEBayEBIAJBEGsiA0EIaiECIAYgBIZC//////////8DgyEHIAMpAwAiBiAIhyEFDAELCxoLiAECA34DfyMAQRBrIgUkAAN+IAZBOEYEfiAFQRBqJAAgAwUgBSAAIAZqIgcpAwAiAiACQj+HIAGsIgIgAkI/hxAvIAcgBSkDACIEIAN8IgJC//////////8DgzcDACACIARUrSAFQQhqKQMAIANCP4d8fEIGhiACQjqIhCEDIAZBCGohBgwBCwsLigECA38BfiMAQUBqIgIkACACQQhqIgEgABBdIAEQQiACQThqIQFBBiEDQdwCIQACQAJAA0AgA0EATgRAIAEpAwAiBEIAUg0CIAFBCGshASAAQTprIQAgA0EBayEDDAELC0EAIQAMAQsDQCAEUA0BIABBAWohACAEQgJ/IQQMAAsACyACQUBrJAAgAAuHAQEDfyMAQYACayIBJAAgABCwASABIAAQXiABQYABaiICQTgQ0AEaIAFBATYCuAEgAUHAAWpBOBDQARogAUH4AWpBATYCACABIABBgAFqIgMQmgEgARA2IAIgARCZASACIAMQmgEgAyABEJkBIAMgABCaASAAIAIQmQEgABCwASABQYACaiQAC30CBH4BfyABQT9xrSECQTogAWtBP3GtIQRBACEBIAApAwAiBSEDA38gAUEwRgR/IAAgACkDMCAChzcDMCAFQn8gAoZCf4WDpwUgACABaiIGIAMgAocgBkEIaikDACIDIASGQv//////////A4OENwMAIAFBCGohAQwBCwsaC2kBBH8jAEHAAWsiASQAIAEgABCQASABQUBrIgIgABCQASABQYABaiIDIABBQGsiBBCQASABIAQQdyACIAAQdyACEEIgBCACEEogAxBDIAAgAxB3IAEQQiAAEEIgACABEEogAUHAAWokAAuCAQIBfwF+IABB8AAQ0AEhAANAIAJBOEYEQAJAIAAgASkDMCIDQjqHNwM4IAAgA0L//////////wODNwMwIABBQGshAEEAIQIDQCACQTBGDQEgACACakIANwMAIAJBCGohAgwACwALBSAAIAJqIAEgAmopAwA3AwAgAkEIaiECDAELCwtuAQZ+IAAgA0L/////D4MiBSABQv////8PgyIGfiIHIAUgAUIgiCIIfiIJIAYgA0IgiCIGfnwiBUIghnwiCjcDACAAIAcgClatIAYgCH4gBSAJVK1CIIYgBUIgiIR8fCABIAR+IAIgA358fDcDCAtqAgF/BX4gASkDCCAAKQMAhSIGQgGGQgGHIQdBACACa6whCAN+IANBOEYEfiAFBSAAIANqIgIgAikDACIEIAaFIAEgA2opAwAgBIUgCIOFIgQgB4U3AwAgBCAFhSEFIANBCGohAwwBCwsaC18CAX8EfkIBIQNBMCECA38gAkF4RgR/IARCAYYgA3ynQQFrBSABIAJqKQMAIgUgACACaikDACIGfUI6hyADgyAEhCEEIAJBCGshAiAFIAaFQgF9QjqHIAODIQMMAQsLC2kBBH8jAEGAAmsiAiQAIAIgARBeIAJBgAFqIgMgARBeIAIQLSADIAIQESAAIAMQmAEgAEGAAmoiBCADEJgBIABBgARqIgUgAxCYASAEIAEQpgEgBSACEKYBIABBBTYCgAYgAkGAAmokAAtiAQJ/IwBBQGoiAiQAIAAQQiACIAAQkAECQCABBEAgACABEK4BDAELIAAQOgtBACEBA0AgA0UEQCAAEExBASABQQFqIAFBAUYiAxshAQwBCwsgACACEEogABAeIAJBQGskAAtnAQJ/IwBBQGoiAyQAAkAgASABQR91IgJqIAJzIgIgACgCOGxBgICAEE4EQCADIAIQOSAAIAMQSgwBCyAAIAIQKRogACAAKAI4IAJsNgI4CyABQQBIBEAgABBDIAAQQgsgA0FAayQAC2cAIABBAXYgAHIiAEECdiAAciIAQQR2IAByIgBBCHYgAHIiAEEQdiAAciIAIABBAXZB1arVqgVxayIAQQJ2QbPmzJkDcSAAQbPmzJkDcWoiAEEEdiAAakGPnrz4AHFBgYKECGxBGHYLYQEDfyMAQYABayIBJAAgASAAEJABIAFBQGsiAkE4ENABGiABQQE2AnggASAAQUBrIgMQdyABEEMgAiABEK4BIAIgAxB3IAMgARCuASADIAAQdyAAIAIQrgEgAUGAAWokAAtVAgJ/AX4jAEHwAGsiASQAIAFBwLLAABBJIAApAwAhAyABQThqIgIgABBdIABBARAsIAIgARBgIAIQQiACQQEQLCAAIAIgA0ICgacQMCABQfAAaiQAC5gBAQZ/IwBBwAFrIgMkACAAIAEQXiAAEC0gA0GIAWoiBkHop8AAEEkjAEFAaiIEJAAgA0EIaiICQTgQ0AEiBUEBNgI4IAVBQGtBOBDQASAFQfgAakEBNgIAIAQgBhCOASAFIAQQrgEQwQEgBEFAayQAIAIQqQEgAhB8IAIQqQEgACABEBEgACACEJoBIAAQtQEgA0HAAWokAAtZAQJ/IwBBQGoiAyQAIABBOBDQASIAQQE2AjgCQCABQQBOBEAgACABEJMBDAELIANBCGoiAkHAssAAEEkgAiABEJMBIAIQQiAAIAIQagsgABBUIANBQGskAAu9CAEKfyMAQYABayIHJAAgB0EIaiIDQcCywAAQSSADQQEQlAECQAJAA0AgAUEwRgRAIANBMGogAykDMEIBhzcDACADQThqIQEDQCACRQ0EIAFCADcDACACQQFrIQIgAUEIaiEBDAALAAsgAUE4Rg0BIAFBOEcEQCABIANqIAEgA2oiBEEIaikDAEI5hkL//////////wODIAQpAwBCAYeENwMAIAVBAWohBSABQQhqIQEMAQsLQQdBB0GEm8AAEDsACyAFQQdB9JrAABA7AAsgA0EBEJQBIANBARAsIAdBQGshBUEAIQIjAEGgCmsiASQAIAFBOBDQASIBQUBrQTgQ0AEhBiABQYABakE4ENABGiABQcABakE4ENABGiABQYACakE4ENABGiABQcACakE4ENABGiABQYADakE4ENABGiABQcADakE4ENABGiABQYAEakE4ENABGiABQcAEakE4ENABGiABQYAFakE4ENABGiABQcAFakE4ENABGiABQYAGakE4ENABGiABQcAGakE4ENABGiABQYAHakE4ENABGiABQcAHakE4ENABGiABQfgHakEBNgIAIAFBuAdqQQE2AgAgAUH4BmpBATYCACABQbgGakEBNgIAIAFB+AVqQQE2AgAgAUG4BWpBATYCACABQfgEakEBNgIAIAFBuARqQQE2AgAgAUH4A2pBATYCACABQbgDakEBNgIAIAFB+AJqQQE2AgAgAUG4AmpBATYCACABQfgBakEBNgIAIAFBuAFqQQE2AgAgAUH4AGpBATYCACABQQE2AjggAUGBCGpB5wAQ0AEaIAFB6AhqIgQgABCQASAEEEIgAUGoCWoiBCADEF0gBBBCIAQQKkEDaiIIQQJ2IgNBAWohCQJAA0AgAiAJRgRAIAEQygEgBiABQegIahCuASABQeAJakE4ENABGiABQQE2ApgKQYB5IQIMAgsgAUGoCWoiBCAEQQQQjwEiChCUASAEEEIgAkHnAEcEQCABQYEIaiACaiAKOgAAIAFBqAlqQQQQLCACQQFqIQIMAQsLQecAQecAQaC0wAAQOwALA0AgAgRAIAFB4AlqIgQgASACaiIGQcAHahCuASAGQYAIaiIGIAQQrgEgBiABQegIahBKIAJBQGshAgwBCwsCQAJAAkACQCAIQZwDSQRAIAFBgQhqIANqLAAAIgJBEE8NASAFIAEgAkEGdGoQkAEgA0EBayICQeYASyEEA0AgAkF/Rg0DIAUQTCAFEEwgBRBMIAUQTCAEDQQgAUGBCGogAmotAAAiA0EQSQRAIAUgASADQQZ0ahBKIAJBAWshAgwBCwsgA0EYdEEYdUEQQeC0wAAQOwALIANB5wBBsLTAABA7AAsgAkEQQcC0wAAQOwALIAUQHiABQaAKaiQADAELIAJB5wBB0LTAABA7AAsgACAFEK4BIAdBgAFqJAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQE2AgAgA0ICNwIMIANB2LjAADYCCCADQQE2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEGYAC2UBAn8gACAAKAIAIgJBCGoiAzYCACAAIAJBA3ZBPHFqQShqIgIgAUH/AXEgAigCAEEIdHI2AgACQAJAIANFBEAgAEEANgIAIAAgACgCBEEBajYCBAwBCyADQf8DcQ0BCyAAEA8LC1wAIABBOBDQASIAQQE2AjggAEFAa0E4ENABGiAAQfgAakEBNgIAIABBgAFqEFEgAEGAAmpBOBDQARogAEG4AmpBATYCACAAQcACakE4ENABGiAAQfgCakEBNgIAC1sBA38jAEGAAWsiASQAIAAQqQEgASAAEJABIAFBQGsiAiAAQUBrIgMQkAEgARBMIAIQTCABIAIQdyABQQAQMyAAIAEQSiABEEMgARBCIAMgARBKIAFBgAFqJAALYQEBfyMAQYACayIDJAAgABA9IAAgARCZASAAQYABaiIBIAIQmQEgAEGAAmoQtwEgABCpASADIAAQOCADQYABaiICIAEQXiACEC0gAiADEHpFBEAgABCbAQsgA0GAAmokAAtUAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqIAJBCGoQDCACQSBqJAALZwAjAEEwayIBJABBpLvAAC0AAARAIAFBHGpBATYCACABQgI3AgwgAUGQtsAANgIIIAFBATYCJCABIAA2AiwgASABQSBqNgIYIAEgAUEsajYCICABQQhqQbi2wAAQZgALIAFBMGokAAtiAgF+An8gACkDACEBA34gACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkEoRgR+IAAgACkDMCABfCIBNwMwIAFCJIcFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLGgt8AQV/IwBBQGoiAyQAIANBCGoiAkHAssAAEEkgAiAAKAI4QQFrEDUiBBAoA0AgAUE4RwRAIAAgAWoiBSABIAJqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAEEBIARBAWp0IgI2AjggAkH///8PSgRAIAAQHgsgA0FAayQAC3sBAn8gAEEoaiECA0AgAUGAAkYEQCAAQufMp9DW0Ouzu383AgggAEIANwIAIABBIGpCq7OP/JGjs/DbADcCACAAQRhqQv+kuYjFkdqCm383AgAgAEEQakLy5rvjo6f9p6V/NwIABSABIAJqQQA2AgAgAUEEaiEBDAELCwtUACAAQTgQ0AEiAEEBNgI4IABBQGtBOBDQARogAEH4AGpBATYCACAAQYABakE4ENABGiAAQbgBakEBNgIAIABBwAFqQTgQ0AEaIABB+AFqQQE2AgALWAECfyMAQUBqIgEkAAJAIAAQhgENACABQQEQOSAAQYABaiICIAEQWA0AIAJBABAzIAAgAhBKIAAQHiAAQUBrIgAgAhBKIAAQHiACIAEQrgELIAFBQGskAAtZAQJ/IwBBgAFrIgEkAAJAIAAQigENACABEFEgAEGAAmoiAiABEHoNACACED4gACACEBEgABC1ASAAQYABaiIAIAIQESAAELUBIAIgARCZAQsgAUGAAWokAAtbAgF+An8gACkDACEBA0AgACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkHgAEYEQCAAIAApA2ggAXw3A2gFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLC08BAX8gAEE4ENABGgJAA0AgAkEHRwRAIAJBB0YNAiAAIAEpAwA3AwAgAEEIaiEAIAFBCGohASACQQFqIQIMAQsLDwtBB0EHQeSawAAQOwALVAECfyMAQbABayICJAAgATQCOCAANAI4fkL///8PVQRAIAAQHgsgAkEIaiIDIAAgARAFIAJB+ABqIgEgAxBrIAAgARBqIABBAjYCOCACQbABaiQAC1EBAn8jAEFAaiIDJAAgAEE4ENABIgBBATYCOCAAQUBrQTgQ0AEgAEH4AGpBATYCACADIAEQjgEgACADEK4BIAMgAhCOASADEK4BIANBQGskAAvwDAIRfwh+IwBBsAFrIg8kACAANAI4IhIgEn5C////D1YEQCAAEB4LIwBB0AFrIgEkACAPQQhqIgZBCGpB0AAQ0AEaIAFBwAFqIAApAwAiFyAXQj+HIhYgFyAWEC8gBiABKQPAASISQv//////////A4M3AwAgAUHIAWopAwAiFUIGhiASQjqIhCETIBVCOoghGCAAQQhqIgwhDSAAIQlBASEKQQEhBwJAA0AgCkEERgRAIABBGGohCiAAQRBqIQkgAEEoaiEMIAApAzAhF0EHIQUgAUHIAGohCwNAIAVBC0kEQCABQUBrIAVBA3QiCCAAakEwaykDACISIBJCP4cgFyAXQj+HIhYQLyAFQQFqIg1BAXYhByALKQMAIRUgASkDQCESIAkhAiAMIQQgBUEFayIOIQMDQCADIAdJBEAgASACKQMAIhQgFEI/hyAEKQMAIhQgFEI/hxAvIAEpAwAiFCASfCISIBRUrSABQQhqKQMAIBV8fCEVIAJBCGohAiAEQQhrIQQgA0EBaiEDDAELCyAGIAhqIBJCAYYiFCATfCITQv//////////A4M3AwAgAUEwaiAAIA5BA3RqKQMAIhkgGUI/hyAXIBYQLyATIBRU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aikDADcDACACQQhqIQIMAQsLC4QJAg1/Cn4jAEFAaiILJAAgC0EIaiIJQcCywAAQSSMAQZACayICJAAgAEEwENABIQogAkHoAGpB8AAQ0AEaIAJB4AFqQTAQ0AEaIAoQcSACIAEiDCkDACIQQv3/8//P///5AX5C//////////8DgyISNwPYASACQdgAaiASQgAgCSkDACIXIBdCP4ciGBAvIBAgAikDWCIPfCITIA9UrSACQeAAaikDACAQQj+HfHwiEEI6hyABKQMIIg9CP4d8IA8gEEIGhiATQjqIhCITfCIQIBNUrXwhD0EBIQBCACETAkACQANAAkAgAEEHRgRAQQYhB0EAIQhBByEADAELIABBAXYiAUEBaiEGIAggAWshAyABQQN0IgFBCGohBCAHIAFrIQUgAkHIAGogCSAAQQN0Ig1qKQMAIhUgFUI/hyIWIBJCABAvIAJB0ABqKQMAIBAgECATfCIRVq0gDyAUfHx8IBEgAikDSHwiDyARVK18IRAgAEEBaiEBA0AgACAGTQRAIAJB2AFqIA1qIA9C/f/z/8////kBfkL//////////wODIhE3AwAgAkE4aiARQgAgFyAYEC8gAkEoaiARQgAgFSAWEC8gAkHoAGogAEEEdGoiACACQTBqKQMAIhE3AwggACACKQMoIhU3AwAgDyACKQM4IhZ8Ig8gFlStIAJBQGspAwAgEHx8IhBCOocgDCABQQN0aikDACIWQj+HfCAWIBBCBoYgD0I6iIQiD3wiECAPVK18IQ8gEyAVfCITIBVUrSARIBR8fCEUIAdBCGohByAIQQFqIQggASEADAMLIANBB08NAyACQRhqIAQgCWopAwAgBSAJaikDAH0iESARQj+HIAJB2AFqIg4gBWopAwAgBCAOaikDAH0iESARQj+HEC8gAikDGCIRIA98Ig8gEVStIAJBIGopAwAgEHx8IRAgBkEBaiEGIARBCGohBCAFQQhrIQUgA0EBayEDDAALAAsLA0ACQAJAIABBDUcEQCAHIABBAXYiBmshAyAIIAZBA3QiAWshBCABQQhqIQUgDyAUfCAQIBN8Ig8gEFStfCEQIABBAWohAQNAIAZBBUsNAyADQQdPDQIgAkEIaiAFIAlqKQMAIAQgCWpBMGopAwB9IhIgEkI/hyACIARqQYgCaikDACACQdgBaiAFaikDAH0iEiASQj+HEC8gAikDCCISIA98Ig8gElStIAJBEGopAwAgEHx8IRAgBkEBaiEGIARBCGshBCADQQFrIQMgBUEIaiEFDAALAAsgCiAQQv//////////A4M3AzAgAkGQAmokAAwECyADQQdBpJzAABA7AAsgAEEDdCAKakE4ayAPQv//////////A4M3AwAgEEI6hyAMIAFBA3RqKQMAIhJCP4d8IBIgEEIGhiAPQjqIhCIPfCIQIA9UrXwhDyAUIABBBHQgAmpBCGoiAEEIaikDAH0gEyAAKQMAIhJUrX0hFCAIQQhqIQggB0EBaiEHIBMgEn0hEyABIQAMAAsACyADQQdBlJzAABA7AAsgC0FAayQACy4BAX8jAEGAAWsiASQAIAAQRSABEFEgACABEJkBIABBgAFqELYBIAFBgAFqJAALMwAgACABEJYBIABBgAJqIAFBgAJqEJYBIABBgARqIAFBgARqEJYBIAAgASgCgAY2AoAGCygAIAAgASACEHIgAEFAayABQUBrIAIQciAAQYABaiABQYABaiACEHILLQAgACABIAIQjQEgAEGAAWogAUGAAWogAhCNASAAQYACaiABQYACaiACEI0BCycBAn8jAEFAaiICJAAgAkEIaiIDIAEQvgEgACADEI4BIAJBQGskAAsiAQF/A0AgAUE4RwRAIAAgAWpCADcDACABQQhqIQEMAQsLCyUAIAAgASACEDAgAEEAIAJrIAAoAjgiACABKAI4c3EgAHM2AjgLJwAgACAAKAIEQQFxIAFyQQJyNgIEIAAgAWoiACAAKAIEQQFyNgIECyMAA0AgAgRAIAAgAS0AABA8IAJBAWshAiABQQFqIQEMAQsLCywAIAAQiwEgACABEJYBIABBgAJqIAIQlgEgAEGABGogAxCWASAAQQU2AoAGCyMBAX8jAEFAaiIBJAAgASAAEJABIAEQHiABEFcgAUFAayQACykAIAAgARBgIAAgACgCOCABKAI4aiIBNgI4IAFB////D0oEQCAAEB4LCyUAIAAgARCuASAAQUBrIAFBQGsQrgEgAEGAAWogAUGAAWoQrgELKAEBfyMAQYACayICJAAgAiABEIwBIAIQKyAAIAIQlwEgAkGAAmokAAscAQF/IAAgARBYBH8gAEFAayABQUBrEFgFQQALCycBAX8jAEGAAWsiAiQAIAIg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DCELDQALCyAMpyICQeMASwRAIABBAmsiACAGQQlqaiAMpyICIAJB//8DcUHkAG4iAkHkAGxrQf//A3FBAXRB6LjAAGovAAA7AAALAkAgAkEKTwRAIABBAmsiACAGQQlqaiACQQF0Qei4wABqLwAAOwAADAELIABBAWsiACAGQQlqaiACQTBqOgAACwJ/IAZBCWogAGohCEErQYCAxAAgASgCACIDQQFxIgIbIQQgAkEnIABrIglqIQJBlLjAAEEAIANBBHEbIQUCQAJAIAEoAghFBEBBASEAIAEgBCAFEFINAQwCCwJAAkACQAJAIAIgAUEMaigCACIDSQRAIAEtAABBCHENBEEAIQAgAyACayICIQNBASABLQAgIgcgB0EDRhtBA3FBAWsOAgECAwtBASEAIAEgBCAFEFINBAwFC0EAIQMgAiEADAELIAJBAXYhACACQQFqQQF2IQMLIABBAWohACABQRxqKAIAIQcgASgCBCECIAEoAhghCgJAA0AgAEEBayIARQ0BIAogAiAHKAIQEQQARQ0AC0EBDAQLQQEhACACQYCAxABGDQEgASAEIAUQUg0BIAEoAhggCCAJIAEoAhwoAgwRBQANASABKAIcIQQgASgCGCEBQQAhAAJ/A0AgAyAAIANGDQEaIABBAWohACABIAIgBCgCEBEEAEUNAAsgAEEBawsgA0khAAwBCyABKAIEIQcgAUEwNgIEIAEtACAhCkEBIQAgAUEBOgAgIAEgBCAFEFINAEEAIQAgAyACayICIQMCQAJAAkBBASABLQAgIgQgBEEDRhtBA3FBAWsOAgABAgtBACEDIAIhAAwBCyACQQF2IQAgAkEBakEBdiEDCyAAQQFqIQAgAUEcaigCACECIAEoAgQhBCABKAIYIQUCQANAIABBAWsiAEUNASAFIAQgAigCEBEEAEUNAAtBAQwDC0EBIQAgBEGAgMQARg0AIAEoAhggCCAJIAEoAhwoAgwRBQANACABKAIcIQAgASgCGCEFQQAhAgJAA0AgAiADRg0BIAJBAWohAiAFIAQgACgCEBEEAEUNAAtBASEAIAJBAWsgA0kNAQsgASAKOgAgIAEgBzYCBEEADAILIAAMAQsgASgCGCAIIAkgAUEcaigCACgCDBEFAAsgBkEwaiQACwsAIAAQNiAAELABCysCAX8BfkIBIQIDQCAAIAFq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AAANAEHgs8AAC8EHYXR0ZW1wdCB0byBkaXZpZGUgYnkgemVybwAAAAAAAABhdHRlbXB0IHRvIGRpdmlkZSB3aXRoIG92ZXJmbG93ALAZEAASAAAADAIAAA0AAACwGRAAEgAAABgCAAAmAAAAsBkQABIAAAAYAgAAIwAAALAZEAASAAAAHgIAABcAAACwGRAAEgAAAB4CAAAUAAAAqqr//////gHu//9UrP//AupBYg9rDyoBw5z9ShTOEwJLd2TXrEtDAu3pxpKm+V8Cox4RoAEAAAADAAAABAAAAAQAAAAEAAAABQAAAAYAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAoAAOsaEAAVAAAAABsQAA4AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnMgGxAAGAAAAEkBAAAJAAAAbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5yc0gbEAAcAAAARgIAAB8AAABIGxAAHAAAAEcCAAAeAAAABwAAAAwAAAAEAAAACAAAAAMAAAAIAAAABAAAAAkAAAAKAAAAEAAAAAQAAAALAAAADAAAAAMAAAAIAAAABAAAAA0AAAAOAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAA6BsQABEAAADMGxAAHAAAAAUCAAAFAAAAEAAAAAAAAAABAAAAEQAAAGluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAAkHBAAIAAAAEQcEAASAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5yc3JhbmdlIGVuZCBpbmRleCAAAABxHRAAEAAAADAdEAAiAAAAUh0QAB8AAABJAAAABQB7CXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS42MS4wIChmZTViMTNkNjggMjAyMi0wNS0xOCkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4SMC4yLjgxICgwNjJhYTVmNzAp`;
});

// node_modules/@dfinity/agent/lib/esm/vendor/bls/bls.js
function bls_init() {
  let ret2 = wasm2.bls_init();
  return ret2;
}
function bls_verify(sig, m, w) {
  const [ptr0, len0] = passArray8ToWasm0(sig, wasm2.__wbindgen_malloc);
  const [ptr1, len1] = passArray8ToWasm0(m, wasm2.__wbindgen_malloc);
  const [ptr2, len2] = passArray8ToWasm0(w, wasm2.__wbindgen_malloc);
  const ret2 = wasm2.bls_verify(ptr0, len0, ptr1, len1, ptr2, len2);
  return ret2;
}
async function load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
async function init() {
  const imports = {};
  const { instance, module } = await load(wasmBytes, imports);
  wasm2 = instance.exports;
  init.__wbindgen_wasm_module = module;
  return wasm2;
}
var base64Arraybuffer, getUint8Memory0, passArray8ToWasm0, wasm2, wasmBytes, cachegetUint8Memory0, bls_default;
var init_bls = __esm(() => {
  base64Arraybuffer = __toESM(require_base64_arraybuffer(), 1);
  init_wasm();
  getUint8Memory0 = function() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm2.memory.buffer) {
      cachegetUint8Memory0 = new Uint8Array(wasm2.memory.buffer);
    }
    return cachegetUint8Memory0;
  };
  passArray8ToWasm0 = function(arg, malloc) {
    const ptr = malloc(arg.length * 1);
    getUint8Memory0().set(arg, ptr / 1);
    return [ptr, arg.length];
  };
  wasmBytes = base64Arraybuffer.decode(wasmBytesBase64);
  cachegetUint8Memory0 = null;
  bls_default = init;
});

// node_modules/@dfinity/agent/lib/esm/utils/bls.js
async function blsVerify(pk, sig, msg) {
  if (!verify) {
    await bls_default();
    if (bls_init() !== 0) {
      throw new Error("Cannot initialize BLS");
    }
    verify = (pk1, sig1, msg1) => {
      return bls_verify(sig1, msg1, pk1) === 0;
    };
  }
  return verify(pk, sig, msg);
}
var verify;
var init_bls2 = __esm(() => {
  init_bls();
});

// node_modules/@dfinity/agent/lib/esm/certificate.js
async function reconstruct(t2) {
  switch (t2[0]) {
    case 0:
      return hash3(domain_sep("ic-hashtree-empty"));
    case 4:
      return t2[1];
    case 3:
      return hash3(concat3(domain_sep("ic-hashtree-leaf"), t2[1]));
    case 2:
      return hash3(concat3(domain_sep("ic-hashtree-labeled"), t2[1], await reconstruct(t2[2])));
    case 1:
      return hash3(concat3(domain_sep("ic-hashtree-fork"), await reconstruct(t2[1]), await reconstruct(t2[2])));
    default:
      throw new Error("unreachable");
  }
}
function lookup_path(path, tree) {
  if (path.length === 0) {
    switch (tree[0]) {
      case 3: {
        return new Uint8Array(tree[1]).buffer;
      }
      default: {
        return;
      }
    }
  }
  const label = typeof path[0] === "string" ? new TextEncoder().encode(path[0]) : path[0];
  const t2 = find_label(label, flatten_forks(tree));
  if (t2) {
    return lookup_path(path.slice(1), t2);
  }
}

class CertificateVerificationError extends AgentError {
  constructor(reason) {
    super(`Invalid certificate: ${reason}`);
  }
}

class Certificate {
  constructor(certificate, _rootKey, _canisterId, _blsVerify) {
    this._rootKey = _rootKey;
    this._canisterId = _canisterId;
    this._blsVerify = _blsVerify;
    this.cert = decode3(new Uint8Array(certificate));
  }
  static async create(options) {
    let blsVerify2 = options.blsVerify;
    if (!blsVerify2) {
      blsVerify2 = blsVerify;
    }
    const cert = new Certificate(options.certificate, options.rootKey, options.canisterId, blsVerify2);
    await cert.verify();
    return cert;
  }
  lookup(path) {
    return lookup_path(path, this.cert.tree);
  }
  async verify() {
    const rootHash = await reconstruct(this.cert.tree);
    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);
    const sig = this.cert.signature;
    const key = extractDER(derKey);
    const msg = concat3(domain_sep("ic-state-root"), rootHash);
    let sigVer = false;
    try {
      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));
    } catch (err) {
      sigVer = false;
    }
    if (!sigVer) {
      throw new CertificateVerificationError("Signature verification failed");
    }
  }
  async _checkDelegationAndGetKey(d) {
    if (!d) {
      return this._rootKey;
    }
    const cert = await Certificate.create({
      certificate: d.certificate,
      rootKey: this._rootKey,
      canisterId: this._canisterId
    });
    const rangeLookup = cert.lookup(["subnet", d.subnet_id, "canister_ranges"]);
    if (!rangeLookup) {
      throw new CertificateVerificationError(`Could not find canister ranges for subnet 0x${toHex(d.subnet_id)}`);
    }
    const ranges_arr = decode3(rangeLookup);
    const ranges = ranges_arr.map((v) => [
      Principal.fromUint8Array(v[0]),
      Principal.fromUint8Array(v[1])
    ]);
    const canisterInRange = ranges.some((r) => r[0].ltEq(this._canisterId) && r[1].gtEq(this._canisterId));
    if (!canisterInRange) {
      throw new CertificateVerificationError(`Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(d.subnet_id)}`);
    }
    const publicKeyLookup = cert.lookup(["subnet", d.subnet_id, "public_key"]);
    if (!publicKeyLookup) {
      throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);
    }
    return publicKeyLookup;
  }
}
var isBufferEqual, extractDER, domain_sep, flatten_forks, find_label, DER_PREFIX, KEY_LENGTH;
var init_certificate = __esm(() => {
  init_cbor();
  init_errors();
  init_request_id();
  init_buffer2();
  init_esm();
  init_bls2();
  isBufferEqual = function(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    const a8 = new Uint8Array(a);
    const b8 = new Uint8Array(b);
    for (let i = 0;i < a8.length; i++) {
      if (a8[i] !== b8[i]) {
        return false;
      }
    }
    return true;
  };
  extractDER = function(buf) {
    const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;
    if (buf.byteLength !== expectedLength) {
      throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);
    }
    const prefix = buf.slice(0, DER_PREFIX.byteLength);
    if (!isBufferEqual(prefix, DER_PREFIX)) {
      throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);
    }
    return buf.slice(DER_PREFIX.byteLength);
  };
  domain_sep = function(s2) {
    const len = new Uint8Array([s2.length]);
    const str = new TextEncoder().encode(s2);
    return concat3(len, str);
  };
  flatten_forks = function(t2) {
    switch (t2[0]) {
      case 0:
        return [];
      case 1:
        return flatten_forks(t2[1]).concat(flatten_forks(t2[2]));
      default:
        return [t2];
    }
  };
  find_label = function(l, trees) {
    if (trees.length === 0) {
      return;
    }
    for (const t2 of trees) {
      if (t2[0] === 2) {
        const p = t2[1];
        if (isBufferEqual(l, p)) {
          return t2[2];
        }
      }
    }
  };
  DER_PREFIX = fromHex("308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100");
  KEY_LENGTH = 96;
});

// node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js
var exports_canisterStatus = {};
__export(exports_canisterStatus, {
  request: () => {
    {
      return request;
    }
  },
  encodePath: () => {
    {
      return encodePath;
    }
  }
});
var request, encodePath, decodeHex, decodeLeb128, decodeCbor, decodeUtf8, decodeTime, decodeControllers;
var init_canisterStatus = __esm(() => {
  init_esm2();
  init_esm();
  init_errors();
  init_certificate();
  init_buffer2();
  init_cbor();
  request = async (options) => {
    const { canisterId, agent, paths } = options;
    const uniquePaths = [...new Set(paths)];
    const encodedPaths = uniquePaths.map((path) => {
      return encodePath(path, canisterId);
    });
    const status = new Map;
    const promises = uniquePaths.map((path, index) => {
      return (async () => {
        var _a;
        try {
          const response = await agent.readState(canisterId, {
            paths: [encodedPaths[index]]
          });
          const cert = await Certificate.create({
            certificate: response.certificate,
            rootKey: agent.rootKey,
            canisterId
          });
          const data = cert.lookup(encodePath(uniquePaths[index], canisterId));
          if (!data) {
            console.warn(`Expected to find result for path ${path}, but instead found nothing.`);
            if (typeof path === "string") {
              status.set(path, null);
            } else {
              status.set(path.key, null);
            }
          } else {
            switch (path) {
              case "time": {
                status.set(path, decodeTime(data));
                break;
              }
              case "controllers": {
                status.set(path, decodeControllers(data));
                break;
              }
              case "module_hash": {
                status.set(path, decodeHex(data));
                break;
              }
              case "candid": {
                status.set(path, new TextDecoder().decode(data));
                break;
              }
              default: {
                if (typeof path !== "string" && ("key" in path) && ("path" in path)) {
                  switch (path.decodeStrategy) {
                    case "raw":
                      status.set(path.key, data);
                      break;
                    case "leb128": {
                      status.set(path.key, decodeLeb128(data));
                      break;
                    }
                    case "cbor": {
                      status.set(path.key, decodeCbor(data));
                      break;
                    }
                    case "hex": {
                      status.set(path.key, decodeHex(data));
                      break;
                    }
                    case "utf-8": {
                      status.set(path.key, decodeUtf8(data));
                    }
                  }
                }
              }
            }
          }
        } catch (error) {
          if ((_a = error === null || error === undefined ? undefined : error.message) === null || _a === undefined ? undefined : _a.includes("Invalid certificate")) {
            throw new AgentError(error.message);
          }
          if (typeof path !== "string" && ("key" in path) && ("path" in path)) {
            status.set(path.key, null);
          } else {
            status.set(path, null);
          }
          console.group();
          console.warn(`Expected to find result for path ${path}, but instead found nothing.`);
          console.warn(error);
          console.groupEnd();
        }
      })();
    });
    await Promise.all(promises);
    return status;
  };
  encodePath = (path, canisterId) => {
    const encoder = new TextEncoder;
    const encode4 = (arg) => {
      return new DataView(encoder.encode(arg).buffer).buffer;
    };
    const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;
    switch (path) {
      case "time":
        return [encode4("time")];
      case "controllers":
        return [encode4("canister"), canisterBuffer, encode4("controllers")];
      case "module_hash":
        return [encode4("canister"), canisterBuffer, encode4("module_hash")];
      case "subnet":
        return [encode4("subnet")];
      case "candid":
        return [encode4("canister"), canisterBuffer, encode4("metadata"), encode4("candid:service")];
      default: {
        if (("key" in path) && ("path" in path)) {
          if (typeof path["path"] === "string" || path["path"] instanceof ArrayBuffer) {
            const metaPath = path.path;
            const encoded = typeof metaPath === "string" ? encode4(metaPath) : metaPath;
            return [encode4("canister"), canisterBuffer, encode4("metadata"), encoded];
          } else {
            return path["path"];
          }
        }
      }
    }
    throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`);
  };
  decodeHex = (buf) => {
    return toHex(buf);
  };
  decodeLeb128 = (buf) => {
    return lebDecode(new PipeArrayBuffer(buf));
  };
  decodeCbor = (buf) => {
    return decode3(buf);
  };
  decodeUtf8 = (buf) => {
    return new TextDecoder().decode(buf);
  };
  decodeTime = (buf) => {
    const decoded = decodeLeb128(buf);
    return new Date(Number(decoded / BigInt(1e6)));
  };
  decodeControllers = (buf) => {
    const [tag, ...controllersRaw] = decodeCbor(buf);
    return controllersRaw.map((buf2) => {
      return Principal.fromUint8Array(new Uint8Array(buf2));
    });
  };
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS((exports, module) => {
  (function(nacl) {
    var gf = function(init2) {
      var i, r = new Float64Array(16);
      if (init2)
        for (i = 0;i < init2.length; i++)
          r[i] = init2[i];
      return r;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y2 = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x2, i, h2, l) {
      x2[i] = h2 >> 24 & 255;
      x2[i + 1] = h2 >> 16 & 255;
      x2[i + 2] = h2 >> 8 & 255;
      x2[i + 3] = h2 & 255;
      x2[i + 4] = l >> 24 & 255;
      x2[i + 5] = l >> 16 & 255;
      x2[i + 6] = l >> 8 & 255;
      x2[i + 7] = l & 255;
    }
    function vn(x2, xi, y2, yi, n) {
      var i, d = 0;
      for (i = 0;i < n; i++)
        d |= x2[xi + i] ^ y2[yi + i];
      return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x2, xi, y2, yi) {
      return vn(x2, xi, y2, yi, 16);
    }
    function crypto_verify_32(x2, xi, y2, yi) {
      return vn(x2, xi, y2, yi, 32);
    }
    function core_salsa20(o, p, k2, c2) {
      var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0;i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x4 >>> 0 & 255;
      o[17] = x4 >>> 8 & 255;
      o[18] = x4 >>> 16 & 255;
      o[19] = x4 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p, k2, c2) {
      var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0;i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k2, c2) {
      core_salsa20(out, inp, k2, c2);
    }
    function crypto_core_hsalsa20(out, inp, k2, c2) {
      core_hsalsa20(out, inp, k2, c2);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c2, cpos, m, mpos, b2, n, k2) {
      var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
      var u, i;
      for (i = 0;i < 16; i++)
        z2[i] = 0;
      for (i = 0;i < 8; i++)
        z2[i] = n[i];
      while (b2 >= 64) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0;i < 64; i++)
          c2[cpos + i] = m[mpos + i] ^ x2[i];
        u = 1;
        for (i = 8;i < 16; i++) {
          u = u + (z2[i] & 255) | 0;
          z2[i] = u & 255;
          u >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0;i < b2; i++)
          c2[cpos + i] = m[mpos + i] ^ x2[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c2, cpos, b2, n, k2) {
      var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
      var u, i;
      for (i = 0;i < 16; i++)
        z2[i] = 0;
      for (i = 0;i < 8; i++)
        z2[i] = n[i];
      while (b2 >= 64) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0;i < 64; i++)
          c2[cpos + i] = x2[i];
        u = 1;
        for (i = 8;i < 16; i++) {
          u = u + (z2[i] & 255) | 0;
          z2[i] = u & 255;
          u >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x2, z2, k2, sigma);
        for (i = 0;i < b2; i++)
          c2[cpos + i] = x2[i];
      }
      return 0;
    }
    function crypto_stream(c2, cpos, d, n, k2) {
      var s2 = new Uint8Array(32);
      crypto_core_hsalsa20(s2, n, k2, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0;i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20(c2, cpos, d, sn, s2);
    }
    function crypto_stream_xor(c2, cpos, m, mpos, d, n, k2) {
      var s2 = new Uint8Array(32);
      crypto_core_hsalsa20(s2, n, k2, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0;i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c2, cpos, m, mpos, d, sn, s2);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c2;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes >= 16) {
        t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c2 = 0;
        d0 = c2;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c2 = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c2 += d0 >>> 13;
        d0 &= 8191;
        d1 = c2;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c2 = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c2 += d1 >>> 13;
        d1 &= 8191;
        d2 = c2;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c2 = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c2 += d2 >>> 13;
        d2 &= 8191;
        d3 = c2;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c2 = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c2 += d3 >>> 13;
        d3 &= 8191;
        d4 = c2;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c2 = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c2 += d4 >>> 13;
        d4 &= 8191;
        d5 = c2;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c2 = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c2 += d5 >>> 13;
        d5 &= 8191;
        d6 = c2;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c2 = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c2 += d6 >>> 13;
        d6 &= 8191;
        d7 = c2;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c2 = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c2 += d7 >>> 13;
        d7 &= 8191;
        d8 = c2;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c2 = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c2 += d8 >>> 13;
        d8 &= 8191;
        d9 = c2;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c2 = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c2 += d9 >>> 13;
        d9 &= 8191;
        c2 = (c2 << 2) + c2 | 0;
        c2 = c2 + d0 | 0;
        d0 = c2 & 8191;
        c2 = c2 >>> 13;
        d1 += c2;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g2 = new Uint16Array(10);
      var c2, mask, f, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (;i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c2 = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2;i < 10; i++) {
        this.h[i] += c2;
        c2 = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c2 * 5;
      c2 = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c2;
      c2 = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c2;
      g2[0] = this.h[0] + 5;
      c2 = g2[0] >>> 13;
      g2[0] &= 8191;
      for (i = 1;i < 10; i++) {
        g2[i] = this.h[i] + c2;
        c2 = g2[i] >>> 13;
        g2[i] &= 8191;
      }
      g2[9] -= 1 << 13;
      mask = (c2 ^ 1) - 1;
      for (i = 0;i < 10; i++)
        g2[i] &= mask;
      mask = ~mask;
      for (i = 0;i < 10; i++)
        this.h[i] = this.h[i] & mask | g2[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f = this.h[0] + this.pad[0];
      this.h[0] = f & 65535;
      for (i = 1;i < 8; i++) {
        f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
        this.h[i] = f & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (i = 0;i < want; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0;i < bytes; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k2) {
      var s2 = new poly1305(k2);
      s2.update(m, mpos, n);
      s2.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h2, hpos, m, mpos, n, k2) {
      var x2 = new Uint8Array(16);
      crypto_onetimeauth(x2, 0, m, mpos, n, k2);
      return crypto_verify_16(h2, hpos, x2, 0);
    }
    function crypto_secretbox(c2, m, d, n, k2) {
      var i;
      if (d < 32)
        return -1;
      crypto_stream_xor(c2, 0, m, 0, d, n, k2);
      crypto_onetimeauth(c2, 16, c2, 32, d - 32, c2);
      for (i = 0;i < 16; i++)
        c2[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m, c2, d, n, k2) {
      var i;
      var x2 = new Uint8Array(32);
      if (d < 32)
        return -1;
      crypto_stream(x2, 0, 32, n, k2);
      if (crypto_onetimeauth_verify(c2, 16, c2, 32, d - 32, x2) !== 0)
        return -1;
      crypto_stream_xor(m, 0, c2, 0, d, n, k2);
      for (i = 0;i < 32; i++)
        m[i] = 0;
      return 0;
    }
    function set25519(r, a) {
      var i;
      for (i = 0;i < 16; i++)
        r[i] = a[i] | 0;
    }
    function car25519(o) {
      var i, v, c2 = 1;
      for (i = 0;i < 16; i++) {
        v = o[i] + c2 + 65535;
        c2 = Math.floor(v / 65536);
        o[i] = v - c2 * 65536;
      }
      o[0] += c2 - 1 + 37 * (c2 - 1);
    }
    function sel25519(p, q2, b2) {
      var t2, c2 = ~(b2 - 1);
      for (var i = 0;i < 16; i++) {
        t2 = c2 & (p[i] ^ q2[i]);
        p[i] ^= t2;
        q2[i] ^= t2;
      }
    }
    function pack25519(o, n) {
      var i, j, b2;
      var m = gf(), t2 = gf();
      for (i = 0;i < 16; i++)
        t2[i] = n[i];
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (j = 0;j < 2; j++) {
        m[0] = t2[0] - 65517;
        for (i = 1;i < 15; i++) {
          m[i] = t2[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t2[15] - 32767 - (m[14] >> 16 & 1);
        b2 = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t2, m, 1 - b2);
      }
      for (i = 0;i < 16; i++) {
        o[2 * i] = t2[i] & 255;
        o[2 * i + 1] = t2[i] >> 8;
      }
    }
    function neq25519(a, b2) {
      var c2 = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c2, a);
      pack25519(d, b2);
      return crypto_verify_32(c2, 0, d, 0);
    }
    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0;i < 16; i++)
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A2(o, a, b2) {
      for (var i = 0;i < 16; i++)
        o[i] = a[i] + b2[i];
    }
    function Z(o, a, b2) {
      for (var i = 0;i < 16; i++)
        o[i] = a[i] - b2[i];
    }
    function M2(o, a, b2) {
      var v, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b22;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b22;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b22;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b22;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b22;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b22;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b22;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b22;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b22;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b22;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b22;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b22;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b22;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b22;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b22;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b22;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v = t0 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t0 = v - c2 * 65536;
      v = t1 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t1 = v - c2 * 65536;
      v = t2 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t2 = v - c2 * 65536;
      v = t3 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t3 = v - c2 * 65536;
      v = t4 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t4 = v - c2 * 65536;
      v = t5 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t5 = v - c2 * 65536;
      v = t6 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t6 = v - c2 * 65536;
      v = t7 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t7 = v - c2 * 65536;
      v = t8 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t8 = v - c2 * 65536;
      v = t9 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t9 = v - c2 * 65536;
      v = t10 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t10 = v - c2 * 65536;
      v = t11 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t11 = v - c2 * 65536;
      v = t12 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t12 = v - c2 * 65536;
      v = t13 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t13 = v - c2 * 65536;
      v = t14 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t14 = v - c2 * 65536;
      v = t15 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t15 = v - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v = t0 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t0 = v - c2 * 65536;
      v = t1 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t1 = v - c2 * 65536;
      v = t2 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t2 = v - c2 * 65536;
      v = t3 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t3 = v - c2 * 65536;
      v = t4 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t4 = v - c2 * 65536;
      v = t5 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t5 = v - c2 * 65536;
      v = t6 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t6 = v - c2 * 65536;
      v = t7 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t7 = v - c2 * 65536;
      v = t8 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t8 = v - c2 * 65536;
      v = t9 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t9 = v - c2 * 65536;
      v = t10 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t10 = v - c2 * 65536;
      v = t11 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t11 = v - c2 * 65536;
      v = t12 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t12 = v - c2 * 65536;
      v = t13 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t13 = v - c2 * 65536;
      v = t14 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t14 = v - c2 * 65536;
      v = t15 + c2 + 65535;
      c2 = Math.floor(v / 65536);
      t15 = v - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S2(o, a) {
      M2(o, a, a);
    }
    function inv25519(o, i) {
      var c2 = gf();
      var a;
      for (a = 0;a < 16; a++)
        c2[a] = i[a];
      for (a = 253;a >= 0; a--) {
        S2(c2, c2);
        if (a !== 2 && a !== 4)
          M2(c2, c2, i);
      }
      for (a = 0;a < 16; a++)
        o[a] = c2[a];
    }
    function pow2523(o, i) {
      var c2 = gf();
      var a;
      for (a = 0;a < 16; a++)
        c2[a] = i[a];
      for (a = 250;a >= 0; a--) {
        S2(c2, c2);
        if (a !== 1)
          M2(c2, c2, i);
      }
      for (a = 0;a < 16; a++)
        o[a] = c2[a];
    }
    function crypto_scalarmult(q2, n, p) {
      var z2 = new Uint8Array(32);
      var x2 = new Float64Array(80), r, i;
      var a = gf(), b2 = gf(), c2 = gf(), d = gf(), e = gf(), f = gf();
      for (i = 0;i < 31; i++)
        z2[i] = n[i];
      z2[31] = n[31] & 127 | 64;
      z2[0] &= 248;
      unpack25519(x2, p);
      for (i = 0;i < 16; i++) {
        b2[i] = x2[i];
        d[i] = a[i] = c2[i] = 0;
      }
      a[0] = d[0] = 1;
      for (i = 254;i >= 0; --i) {
        r = z2[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b2, r);
        sel25519(c2, d, r);
        A2(e, a, c2);
        Z(a, a, c2);
        A2(c2, b2, d);
        Z(b2, b2, d);
        S2(d, e);
        S2(f, a);
        M2(a, c2, a);
        M2(c2, b2, e);
        A2(e, a, c2);
        Z(a, a, c2);
        S2(b2, a);
        Z(c2, d, f);
        M2(a, c2, _121665);
        A2(a, a, d);
        M2(c2, c2, a);
        M2(a, d, f);
        M2(d, b2, x2);
        S2(b2, e);
        sel25519(a, b2, r);
        sel25519(c2, d, r);
      }
      for (i = 0;i < 16; i++) {
        x2[i + 16] = a[i];
        x2[i + 32] = c2[i];
        x2[i + 48] = b2[i];
        x2[i + 64] = d[i];
      }
      var x32 = x2.subarray(32);
      var x16 = x2.subarray(16);
      inv25519(x32, x32);
      M2(x16, x16, x32);
      pack25519(q2, x16);
      return 0;
    }
    function crypto_scalarmult_base(q2, n) {
      return crypto_scalarmult(q2, n, _9);
    }
    function crypto_box_keypair(y2, x2) {
      randombytes(x2, 32);
      return crypto_scalarmult_base(y2, x2);
    }
    function crypto_box_beforenm(k2, y2, x2) {
      var s2 = new Uint8Array(32);
      crypto_scalarmult(s2, x2, y2);
      return crypto_core_hsalsa20(k2, _0, s2, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c2, m, d, n, y2, x2) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x2);
      return crypto_box_afternm(c2, m, d, n, k2);
    }
    function crypto_box_open(m, c2, d, n, y2, x2) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x2);
      return crypto_box_open_afternm(m, c2, d, n, k2);
    }
    var K2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h2, l, a, b2, c2, d;
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0;i < 16; i++) {
          j = 8 * i + pos;
          wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
          wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
        }
        for (i = 0;i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h2 = ah7;
          l = al7;
          a = l & 65535;
          b2 = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          h2 = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          h2 = K2[i * 2];
          l = K2[i * 2 + 1];
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          h2 = wh[i % 16];
          l = wl[i % 16];
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d += c2 >>> 16;
          th = c2 & 65535 | d << 16;
          tl = a & 65535 | b2 << 16;
          h2 = th;
          l = tl;
          a = l & 65535;
          b2 = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d += c2 >>> 16;
          bh7 = c2 & 65535 | d << 16;
          bl7 = a & 65535 | b2 << 16;
          h2 = bh3;
          l = bl3;
          a = l & 65535;
          b2 = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = th;
          l = tl;
          a += l & 65535;
          b2 += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b2 += a >>> 16;
          c2 += b2 >>> 16;
          d += c2 >>> 16;
          bh3 = c2 & 65535 | d << 16;
          bl3 = a & 65535 | b2 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j = 0;j < 16; j++) {
              h2 = wh[j];
              l = wl[j];
              a = l & 65535;
              b2 = l >>> 16;
              c2 = h2 & 65535;
              d = h2 >>> 16;
              h2 = wh[(j + 9) % 16];
              l = wl[(j + 9) % 16];
              a += l & 65535;
              b2 += l >>> 16;
              c2 += h2 & 65535;
              d += h2 >>> 16;
              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l & 65535;
              b2 += l >>> 16;
              c2 += h2 & 65535;
              d += h2 >>> 16;
              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l & 65535;
              b2 += l >>> 16;
              c2 += h2 & 65535;
              d += h2 >>> 16;
              b2 += a >>> 16;
              c2 += b2 >>> 16;
              d += c2 >>> 16;
              wh[j] = c2 & 65535 | d << 16;
              wl[j] = a & 65535 | b2 << 16;
            }
          }
        }
        h2 = ah0;
        l = al0;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[0];
        l = hl[0];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[0] = ah0 = c2 & 65535 | d << 16;
        hl[0] = al0 = a & 65535 | b2 << 16;
        h2 = ah1;
        l = al1;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[1];
        l = hl[1];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[1] = ah1 = c2 & 65535 | d << 16;
        hl[1] = al1 = a & 65535 | b2 << 16;
        h2 = ah2;
        l = al2;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[2];
        l = hl[2];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[2] = ah2 = c2 & 65535 | d << 16;
        hl[2] = al2 = a & 65535 | b2 << 16;
        h2 = ah3;
        l = al3;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[3];
        l = hl[3];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[3] = ah3 = c2 & 65535 | d << 16;
        hl[3] = al3 = a & 65535 | b2 << 16;
        h2 = ah4;
        l = al4;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[4];
        l = hl[4];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[4] = ah4 = c2 & 65535 | d << 16;
        hl[4] = al4 = a & 65535 | b2 << 16;
        h2 = ah5;
        l = al5;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[5];
        l = hl[5];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[5] = ah5 = c2 & 65535 | d << 16;
        hl[5] = al5 = a & 65535 | b2 << 16;
        h2 = ah6;
        l = al6;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[6];
        l = hl[6];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[6] = ah6 = c2 & 65535 | d << 16;
        hl[6] = al6 = a & 65535 | b2 << 16;
        h2 = ah7;
        l = al7;
        a = l & 65535;
        b2 = l >>> 16;
        c2 = h2 & 65535;
        d = h2 >>> 16;
        h2 = hh[7];
        l = hl[7];
        a += l & 65535;
        b2 += l >>> 16;
        c2 += h2 & 65535;
        d += h2 >>> 16;
        b2 += a >>> 16;
        c2 += b2 >>> 16;
        d += c2 >>> 16;
        hh[7] = ah7 = c2 & 65535 | d << 16;
        hl[7] = al7 = a & 65535 | b2 << 16;
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8), hl = new Int32Array(8), x2 = new Uint8Array(256), i, b2 = n;
      hh[0] = 1779033703;
      hh[1] = 3144134277;
      hh[2] = 1013904242;
      hh[3] = 2773480762;
      hh[4] = 1359893119;
      hh[5] = 2600822924;
      hh[6] = 528734635;
      hh[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;
      for (i = 0;i < n; i++)
        x2[i] = m[b2 - n + i];
      x2[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x2[n - 9] = 0;
      ts64(x2, n - 8, b2 / 536870912 | 0, b2 << 3);
      crypto_hashblocks_hl(hh, hl, x2, n);
      for (i = 0;i < 8; i++)
        ts64(out, 8 * i, hh[i], hl[i]);
      return 0;
    }
    function add(p, q2) {
      var a = gf(), b2 = gf(), c2 = gf(), d = gf(), e = gf(), f = gf(), g2 = gf(), h2 = gf(), t2 = gf();
      Z(a, p[1], p[0]);
      Z(t2, q2[1], q2[0]);
      M2(a, a, t2);
      A2(b2, p[0], p[1]);
      A2(t2, q2[0], q2[1]);
      M2(b2, b2, t2);
      M2(c2, p[3], q2[3]);
      M2(c2, c2, D22);
      M2(d, p[2], q2[2]);
      A2(d, d, d);
      Z(e, b2, a);
      Z(f, d, c2);
      A2(g2, d, c2);
      A2(h2, b2, a);
      M2(p[0], e, f);
      M2(p[1], h2, g2);
      M2(p[2], g2, f);
      M2(p[3], e, h2);
    }
    function cswap(p, q2, b2) {
      var i;
      for (i = 0;i < 4; i++) {
        sel25519(p[i], q2[i], b2);
      }
    }
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M2(tx, p[0], zi);
      M2(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q2, s2) {
      var b2, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255;i >= 0; --i) {
        b2 = s2[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q2, b2);
        add(q2, p);
        add(p, p);
        cswap(p, q2, b2);
      }
    }
    function scalarbase(p, s2) {
      var q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X2);
      set25519(q2[1], Y2);
      set25519(q2[2], gf1);
      M2(q2[3], X2, Y2);
      scalarmult(p, q2, s2);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;
      if (!seeded)
        randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i = 0;i < 32; i++)
        sk[i + 32] = pk[i];
      return 0;
    }
    var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r, x2) {
      var carry, i, j, k2;
      for (i = 63;i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k2 = i - 12;j < k2; ++j) {
          x2[j] += carry - 16 * x2[i] * L2[j - (i - 32)];
          carry = Math.floor((x2[j] + 128) / 256);
          x2[j] -= carry * 256;
        }
        x2[j] += carry;
        x2[i] = 0;
      }
      carry = 0;
      for (j = 0;j < 32; j++) {
        x2[j] += carry - (x2[31] >> 4) * L2[j];
        carry = x2[j] >> 8;
        x2[j] &= 255;
      }
      for (j = 0;j < 32; j++)
        x2[j] -= carry * L2[j];
      for (i = 0;i < 32; i++) {
        x2[i + 1] += x2[i] >> 8;
        r[i] = x2[i] & 255;
      }
    }
    function reduce(r) {
      var x2 = new Float64Array(64), i;
      for (i = 0;i < 64; i++)
        x2[i] = r[i];
      for (i = 0;i < 64; i++)
        r[i] = 0;
      modL(r, x2);
    }
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64), h2 = new Uint8Array(64), r = new Uint8Array(64);
      var i, j, x2 = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0;i < n; i++)
        sm[64 + i] = m[i];
      for (i = 0;i < 32; i++)
        sm[32 + i] = d[32 + i];
      crypto_hash(r, sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i = 32;i < 64; i++)
        sm[i] = sk[i];
      crypto_hash(h2, sm, n + 64);
      reduce(h2);
      for (i = 0;i < 64; i++)
        x2[i] = 0;
      for (i = 0;i < 32; i++)
        x2[i] = r[i];
      for (i = 0;i < 32; i++) {
        for (j = 0;j < 32; j++) {
          x2[i + j] += h2[i] * d[j];
        }
      }
      modL(sm.subarray(32), x2);
      return smlen;
    }
    function unpackneg(r, p) {
      var t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S2(num, r[1]);
      M2(den, num, D2);
      Z(num, num, r[2]);
      A2(den, r[2], den);
      S2(den2, den);
      S2(den4, den2);
      M2(den6, den4, den2);
      M2(t2, den6, num);
      M2(t2, t2, den);
      pow2523(t2, t2);
      M2(t2, t2, num);
      M2(t2, t2, den);
      M2(t2, t2, den);
      M2(r[0], t2, den);
      S2(chk, r[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num))
        M2(r[0], r[0], I2);
      S2(chk, r[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r[0]) === p[31] >> 7)
        Z(r[0], gf0, r[0]);
      M2(r[3], r[0], r[1]);
      return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i;
      var t2 = new Uint8Array(32), h2 = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
      if (n < 64)
        return -1;
      if (unpackneg(q2, pk))
        return -1;
      for (i = 0;i < n; i++)
        m[i] = sm[i];
      for (i = 0;i < 32; i++)
        m[i + 32] = pk[i];
      crypto_hash(h2, m, n);
      reduce(h2);
      scalarmult(p, q2, h2);
      scalarbase(q2, sm.subarray(32));
      add(p, q2);
      pack(t2, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t2, 0)) {
        for (i = 0;i < n; i++)
          m[i] = 0;
        return -1;
      }
      for (i = 0;i < n; i++)
        m[i] = sm[i + 64];
      return n;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
      gf,
      D: D2,
      L: L2,
      pack25519,
      unpack25519,
      M: M2,
      A: A2,
      S: S2,
      Z,
      pow2523,
      add,
      set25519,
      modL,
      scalarmult,
      scalarbase
    };
    function checkLengths(k2, n) {
      if (k2.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      for (var i = 0;i < arguments.length; i++) {
        if (!(arguments[i] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0;i < arr.length; i++)
        arr[i] = 0;
    }
    nacl.randomBytes = function(n) {
      var b2 = new Uint8Array(n);
      randombytes(b2, n);
      return b2;
    };
    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c2 = new Uint8Array(m.length);
      for (var i = 0;i < msg.length; i++)
        m[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c2, m, m.length, nonce, key);
      return c2.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c2 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c2.length);
      for (var i = 0;i < box.length; i++)
        c2[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c2.length < 32)
        return null;
      if (crypto_secretbox_open(m, c2, c2.length, nonce, key) !== 0)
        return null;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q2, n, p);
      return q2;
    };
    nacl.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q2, n);
      return q2;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k2);
    };
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k2, publicKey, secretKey);
      return k2;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k2);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m = new Uint8Array(mlen);
      for (var i = 0;i < m.length; i++)
        m[i] = tmp[i];
      return m;
    };
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0;i < sig.length; i++)
        sig[i] = signedMsg[i];
      return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0;i < crypto_sign_BYTES; i++)
        sm[i] = sig[i];
      for (i = 0;i < msg.length; i++)
        sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0;i < pk.length; i++)
        pk[i] = secretKey[32 + i];
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0;i < 32; i++)
        sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h2 = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h2, msg, msg.length);
      return h2;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x2, y2) {
      checkArrayTypes(x2, y2);
      if (x2.length === 0 || y2.length === 0)
        return false;
      if (x2.length !== y2.length)
        return false;
      return vn(x2, 0, y2, 0, x2.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto2 && crypto2.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function(x2, n) {
          var i, v = new Uint8Array(n);
          for (i = 0;i < n; i += QUOTA) {
            crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0;i < n; i++)
            x2[i] = v[i];
          cleanup(v);
        });
      } else if (typeof require !== "undefined") {
        crypto2 = import.meta.require("crypto");
        if (crypto2 && crypto2.randomBytes) {
          nacl.setPRNG(function(x2, n) {
            var i, v = crypto2.randomBytes(n);
            for (i = 0;i < n; i++)
              x2[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();
  })(typeof module !== "undefined" && exports ? exports : self.nacl = self.nacl || {});
});

// node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = __commonJS((exports) => {
  var isFunction = function(value4) {
    return typeof value4 === "function";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isFunction = undefined;
  exports.isFunction = isFunction;
});

// node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS((exports) => {
  var createErrorClass = function(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createErrorClass = undefined;
  exports.createErrorClass = createErrorClass;
});

// node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnsubscriptionError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors6) {
      _super(this);
      this.message = errors6 ? errors6.length + " errors occurred during unsubscription:\n" + errors6.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors6;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS((exports) => {
  var arrRemove = function(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.arrRemove = undefined;
  exports.arrRemove = arrRemove;
});

// node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS((exports) => {
  var isSubscription = function(value4) {
    return value4 instanceof Subscription || value4 && ("closed" in value4) && isFunction_1.isFunction(value4.remove) && isFunction_1.isFunction(value4.add) && isFunction_1.isFunction(value4.unsubscribe);
  };
  var execFinalizer = function(finalizer) {
    if (isFunction_1.isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = undefined;
  var isFunction_1 = require_isFunction();
  var UnsubscriptionError_1 = require_UnsubscriptionError();
  var arrRemove_1 = require_arrRemove();
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors6;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next();!_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction_1.isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors6 = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next();!_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors6 = errors6 !== null && errors6 !== undefined ? errors6 : [];
                if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                  errors6 = __spreadArray(__spreadArray([], __read(errors6)), __read(err.errors));
                } else {
                  errors6.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                _b.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors6) {
          throw new UnsubscriptionError_1.UnsubscriptionError(errors6);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== undefined ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove_1.arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2;
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  exports.Subscription = Subscription;
  exports.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  exports.isSubscription = isSubscription;
});

// node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.config = undefined;
  exports.config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutProvider = undefined;
  exports.timeoutProvider = {
    setTimeout: function(handler, timeout2) {
      var args = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = exports.timeoutProvider.delegate;
      if (delegate === null || delegate === undefined ? undefined : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
      }
      return setTimeout.apply(undefined, __spreadArray([handler, timeout2], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = exports.timeoutProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS((exports) => {
  var reportUnhandledError = function(err) {
    timeoutProvider_1.timeoutProvider.setTimeout(function() {
      var onUnhandledError = config_1.config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportUnhandledError = undefined;
  var config_1 = require_config();
  var timeoutProvider_1 = require_timeoutProvider();
  exports.reportUnhandledError = reportUnhandledError;
});

// node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = __commonJS((exports) => {
  var noop = function() {
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noop = undefined;
  exports.noop = noop;
});

// node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS((exports) => {
  var errorNotification = function(error) {
    return createNotification("E", undefined, error);
  };
  var nextNotification = function(value4) {
    return createNotification("N", value4, undefined);
  };
  var createNotification = function(kind, value4, error) {
    return {
      kind,
      value: value4,
      error
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = undefined;
  exports.COMPLETE_NOTIFICATION = function() {
    return createNotification("C", undefined, undefined);
  }();
  exports.errorNotification = errorNotification;
  exports.nextNotification = nextNotification;
  exports.createNotification = createNotification;
});

// node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS((exports) => {
  var errorContext = function(cb) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context, errorThrown = _a.errorThrown, error = _a.error;
        context = null;
        if (errorThrown) {
          throw error;
        }
      }
    } else {
      cb();
    }
  };
  var captureError = function(err) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.captureError = exports.errorContext = undefined;
  var config_1 = require_config();
  var context = null;
  exports.errorContext = errorContext;
  exports.captureError = captureError;
});

// node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS((exports) => {
  var bind = function(fn, thisArg) {
    return _bind.call(fn, thisArg);
  };
  var handleUnhandledError = function(error) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      errorContext_1.captureError(error);
    } else {
      reportUnhandledError_1.reportUnhandledError(error);
    }
  };
  var defaultErrorHandler = function(err) {
    throw err;
  };
  var handleStoppedNotification = function(notification, subscriber) {
    var onStoppedNotification = config_1.config.onStoppedNotification;
    onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = undefined;
  var isFunction_1 = require_isFunction();
  var Subscription_1 = require_Subscription();
  var config_1 = require_config();
  var reportUnhandledError_1 = require_reportUnhandledError();
  var noop_1 = require_noop();
  var NotificationFactories_1 = require_NotificationFactories();
  var timeoutProvider_1 = require_timeoutProvider();
  var errorContext_1 = require_errorContext();
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (Subscription_1.isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = exports.EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value4) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.nextNotification(value4), this);
      } else {
        this._next(value4);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value4) {
      this.destination.next(value4);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription_1.Subscription);
  exports.Subscriber = Subscriber;
  var _bind = Function.prototype.bind;
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value4) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value4);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== undefined ? observerOrNext : undefined,
          error: error !== null && error !== undefined ? error : undefined,
          complete: complete !== null && complete !== undefined ? complete : undefined
        };
      } else {
        var context_1;
        if (_this && config_1.config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  exports.SafeSubscriber = SafeSubscriber;
  exports.EMPTY_OBSERVER = {
    closed: true,
    next: noop_1.noop,
    error: defaultErrorHandler,
    complete: noop_1.noop
  };
});

// node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observable = undefined;
  exports.observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
});

// node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS((exports) => {
  var identity2 = function(x2) {
    return x2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.identity = undefined;
  exports.identity = identity2;
});

// node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS((exports) => {
  var pipe = function() {
    var fns = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
  };
  var pipeFromArray = function(fns) {
    if (fns.length === 0) {
      return identity_1.identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pipeFromArray = exports.pipe = undefined;
  var identity_1 = require_identity();
  exports.pipe = pipe;
  exports.pipeFromArray = pipeFromArray;
});

// node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS((exports) => {
  var getPromiseCtor = function(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== undefined ? promiseCtor : config_1.config.Promise) !== null && _a !== undefined ? _a : Promise;
  };
  var isObserver = function(value4) {
    return value4 && isFunction_1.isFunction(value4.next) && isFunction_1.isFunction(value4.error) && isFunction_1.isFunction(value4.complete);
  };
  var isSubscriber = function(value4) {
    return value4 && value4 instanceof Subscriber_1.Subscriber || isObserver(value4) && Subscription_1.isSubscription(value4);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Observable = undefined;
  var Subscriber_1 = require_Subscriber();
  var Subscription_1 = require_Subscription();
  var observable_1 = require_observable();
  var pipe_1 = require_pipe();
  var config_1 = require_config();
  var isFunction_1 = require_isFunction();
  var errorContext_1 = require_errorContext();
  var Observable = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable = new Observable2;
      observable.source = this;
      observable.operator = operator;
      return observable;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
      errorContext_1.errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value4) {
            try {
              next(value4);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === undefined ? undefined : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable_1.observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipe_1.pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value4;
        _this.subscribe(function(x2) {
          return value4 = x2;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value4);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  exports.Observable = Observable;
});

// node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS((exports) => {
  var hasLift = function(source) {
    return isFunction_1.isFunction(source === null || source === undefined ? undefined : source.lift);
  };
  var operate = function(init2) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init2(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.operate = exports.hasLift = undefined;
  var isFunction_1 = require_isFunction();
  exports.hasLift = hasLift;
  exports.operate = operate;
});

// node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS((exports) => {
  var createOperatorSubscriber = function(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperatorSubscriber = exports.createOperatorSubscriber = undefined;
  var Subscriber_1 = require_Subscriber();
  exports.createOperatorSubscriber = createOperatorSubscriber;
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value4) {
        try {
          onNext(value4);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === undefined || _a.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber_1.Subscriber);
  exports.OperatorSubscriber = OperatorSubscriber;
});

// node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS((exports) => {
  var refCount = function() {
    return lift_1.operate(function(source, subscriber) {
      var connection = null;
      source._refCount++;
      var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, undefined, function() {
        if (!source || source._refCount <= 0 || 0 < --source._refCount) {
          connection = null;
          return;
        }
        var sharedConnection = source._connection;
        var conn = connection;
        connection = null;
        if (sharedConnection && (!conn || sharedConnection === conn)) {
          sharedConnection.unsubscribe();
        }
        subscriber.unsubscribe();
      });
      source.subscribe(refCounter);
      if (!refCounter.closed) {
        connection = source.connect();
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.refCount = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.refCount = refCount;
});

// node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectableObservable = undefined;
  var Observable_1 = require_Observable();
  var Subscription_1 = require_Subscription();
  var refCount_1 = require_refCount();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var lift_1 = require_lift();
  var ConnectableObservable = function(_super) {
    __extends(ConnectableObservable2, _super);
    function ConnectableObservable2(source, subjectFactory) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subjectFactory = subjectFactory;
      _this._subject = null;
      _this._refCount = 0;
      _this._connection = null;
      if (lift_1.hasLift(source)) {
        _this.lift = source.lift;
      }
      return _this;
    }
    ConnectableObservable2.prototype._subscribe = function(subscriber) {
      return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable2.prototype.getSubject = function() {
      var subject = this._subject;
      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }
      return this._subject;
    };
    ConnectableObservable2.prototype._teardown = function() {
      this._refCount = 0;
      var _connection = this._connection;
      this._subject = this._connection = null;
      _connection === null || _connection === undefined || _connection.unsubscribe();
    };
    ConnectableObservable2.prototype.connect = function() {
      var _this = this;
      var connection = this._connection;
      if (!connection) {
        connection = this._connection = new Subscription_1.Subscription;
        var subject_1 = this.getSubject();
        connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, undefined, function() {
          _this._teardown();
          subject_1.complete();
        }, function(err) {
          _this._teardown();
          subject_1.error(err);
        }, function() {
          return _this._teardown();
        })));
        if (connection.closed) {
          this._connection = null;
          connection = Subscription_1.Subscription.EMPTY;
        }
      }
      return connection;
    };
    ConnectableObservable2.prototype.refCount = function() {
      return refCount_1.refCount()(this);
    };
    return ConnectableObservable2;
  }(Observable_1.Observable);
  exports.ConnectableObservable = ConnectableObservable;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.performanceTimestampProvider = undefined;
  exports.performanceTimestampProvider = {
    now: function() {
      return (exports.performanceTimestampProvider.delegate || performance).now();
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrameProvider = undefined;
  var Subscription_1 = require_Subscription();
  exports.animationFrameProvider = {
    schedule: function(callback) {
      var request2 = requestAnimationFrame;
      var cancel = cancelAnimationFrame;
      var delegate = exports.animationFrameProvider.delegate;
      if (delegate) {
        request2 = delegate.requestAnimationFrame;
        cancel = delegate.cancelAnimationFrame;
      }
      var handle = request2(function(timestamp) {
        cancel = undefined;
        callback(timestamp);
      });
      return new Subscription_1.Subscription(function() {
        return cancel === null || cancel === undefined ? undefined : cancel(handle);
      });
    },
    requestAnimationFrame: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.requestAnimationFrame) || requestAnimationFrame).apply(undefined, __spreadArray([], __read(args)));
    },
    cancelAnimationFrame: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(undefined, __spreadArray([], __read(args)));
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS((exports) => {
  var animationFrames = function(timestampProvider) {
    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
  };
  var animationFramesFactory = function(timestampProvider) {
    return new Observable_1.Observable(function(subscriber) {
      var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
      var start = provider.now();
      var id = 0;
      var run = function() {
        if (!subscriber.closed) {
          id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
            id = 0;
            var now = provider.now();
            subscriber.next({
              timestamp: timestampProvider ? now : timestamp,
              elapsed: now - start
            });
            run();
          });
        }
      };
      run();
      return function() {
        if (id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        }
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrames = undefined;
  var Observable_1 = require_Observable();
  var performanceTimestampProvider_1 = require_performanceTimestampProvider();
  var animationFrameProvider_1 = require_animationFrameProvider();
  exports.animationFrames = animationFrames;
  var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
});

// node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ObjectUnsubscribedError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnonymousSubject = exports.Subject = undefined;
  var Observable_1 = require_Observable();
  var Subscription_1 = require_Subscription();
  var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
  var arrRemove_1 = require_arrRemove();
  var errorContext_1 = require_errorContext();
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError;
      }
    };
    Subject2.prototype.next = function(value4) {
      var _this = this;
      errorContext_1.errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next();!_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value4);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === undefined ? undefined : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return Subscription_1.EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription_1.Subscription(function() {
        _this.currentObservers = null;
        arrRemove_1.arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable = new Observable_1.Observable;
      observable.source = this;
      return observable;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable_1.Observable);
  exports.Subject = Subject;
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value4) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === undefined ? undefined : _a.next) === null || _b === undefined || _b.call(_a, value4);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === undefined ? undefined : _a.error) === null || _b === undefined || _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === undefined ? undefined : _a.complete) === null || _b === undefined || _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === undefined ? undefined : _a.subscribe(subscriber)) !== null && _b !== undefined ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);
  exports.AnonymousSubject = AnonymousSubject;
});

// node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BehaviorSubject = undefined;
  var Subject_1 = require_Subject();
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value4) {
      _super.prototype.next.call(this, this._value = value4);
    };
    return BehaviorSubject2;
  }(Subject_1.Subject);
  exports.BehaviorSubject = BehaviorSubject;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dateTimestampProvider = undefined;
  exports.dateTimestampProvider = {
    now: function() {
      return (exports.dateTimestampProvider.delegate || Date).now();
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplaySubject = undefined;
  var Subject_1 = require_Subject();
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var ReplaySubject = function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === undefined) {
        _bufferSize = Infinity;
      }
      if (_windowTime === undefined) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === undefined) {
        _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function(value4) {
      var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
      if (!isStopped) {
        _buffer.push(value4);
        !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value4);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
      var copy2 = _buffer.slice();
      for (var i = 0;i < copy2.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy2[i]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function() {
      var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now = _timestampProvider.now();
        var last = 0;
        for (var i = 1;i < _buffer.length && _buffer[i] <= now; i += 2) {
          last = i;
        }
        last && _buffer.splice(0, last + 1);
      }
    };
    return ReplaySubject2;
  }(Subject_1.Subject);
  exports.ReplaySubject = ReplaySubject;
});

// node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncSubject = undefined;
  var Subject_1 = require_Subject();
  var AsyncSubject = function(_super) {
    __extends(AsyncSubject2, _super);
    function AsyncSubject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._value = null;
      _this._hasValue = false;
      _this._isComplete = false;
      return _this;
    }
    AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped || _isComplete) {
        _hasValue && subscriber.next(_value);
        subscriber.complete();
      }
    };
    AsyncSubject2.prototype.next = function(value4) {
      if (!this.isStopped) {
        this._value = value4;
        this._hasValue = true;
      }
    };
    AsyncSubject2.prototype.complete = function() {
      var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
      if (!_isComplete) {
        this._isComplete = true;
        _hasValue && _super.prototype.next.call(this, _value);
        _super.prototype.complete.call(this);
      }
    };
    return AsyncSubject2;
  }(Subject_1.Subject);
  exports.AsyncSubject = AsyncSubject;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Action = undefined;
  var Subscription_1 = require_Subscription();
  var Action = function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return this;
    };
    return Action2;
  }(Subscription_1.Subscription);
  exports.Action = Action;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.intervalProvider = undefined;
  exports.intervalProvider = {
    setInterval: function(handler, timeout2) {
      var args = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = exports.intervalProvider.delegate;
      if (delegate === null || delegate === undefined ? undefined : delegate.setInterval) {
        return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
      }
      return setInterval.apply(undefined, __spreadArray([handler, timeout2], __read(args)));
    },
    clearInterval: function(handle) {
      var delegate = exports.intervalProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncAction = undefined;
  var Action_1 = require_Action();
  var intervalProvider_1 = require_intervalProvider();
  var arrRemove_1 = require_arrRemove();
  var AsyncAction = function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state, delay) {
      var _a;
      if (delay === undefined) {
        delay = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay);
      }
      this.pending = true;
      this.delay = delay;
      this.id = (_a = this.id) !== null && _a !== undefined ? _a : this.requestAsyncId(scheduler, this.id, delay);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null && this.delay === delay && this.pending === false) {
        return id;
      }
      if (id != null) {
        intervalProvider_1.intervalProvider.clearInterval(id);
      }
      return;
    };
    AsyncAction2.prototype.execute = function(state, delay) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error = this._execute(state, delay);
      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a = this, id = _a.id, scheduler = _a.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove_1.arrRemove(actions, this);
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action_1.Action);
  exports.AsyncAction = AsyncAction;
});

// node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS((exports) => {
  var findAndClearHandle = function(handle) {
    if (handle in activeHandles) {
      delete activeHandles[handle];
      return true;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TestTools = exports.Immediate = undefined;
  var nextHandle = 1;
  var resolved;
  var activeHandles = {};
  exports.Immediate = {
    setImmediate: function(cb) {
      var handle = nextHandle++;
      activeHandles[handle] = true;
      if (!resolved) {
        resolved = Promise.resolve();
      }
      resolved.then(function() {
        return findAndClearHandle(handle) && cb();
      });
      return handle;
    },
    clearImmediate: function(handle) {
      findAndClearHandle(handle);
    }
  };
  exports.TestTools = {
    pending: function() {
      return Object.keys(activeHandles).length;
    }
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.immediateProvider = undefined;
  var Immediate_1 = require_Immediate();
  var setImmediate2 = Immediate_1.Immediate.setImmediate;
  var clearImmediate = Immediate_1.Immediate.clearImmediate;
  exports.immediateProvider = {
    setImmediate: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.setImmediate) || setImmediate2).apply(undefined, __spreadArray([], __read(args)));
    },
    clearImmediate: function(handle) {
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearImmediate) || clearImmediate)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsapAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var immediateProvider_1 = require_immediateProvider();
  var AsapAction = function(_super) {
    __extends(AsapAction2, _super);
    function AsapAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
    };
    AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      var _a;
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null ? delay > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      }
      var actions = scheduler.actions;
      if (id != null && ((_a = actions[actions.length - 1]) === null || _a === undefined ? undefined : _a.id) !== id) {
        immediateProvider_1.immediateProvider.clearImmediate(id);
        if (scheduler._scheduled === id) {
          scheduler._scheduled = undefined;
        }
      }
      return;
    };
    return AsapAction2;
  }(AsyncAction_1.AsyncAction);
  exports.AsapAction = AsapAction;
});

// node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Scheduler = undefined;
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var Scheduler = function() {
    function Scheduler2(schedulerActionCtor, now) {
      if (now === undefined) {
        now = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }
    Scheduler2.prototype.schedule = function(work, delay, state) {
      if (delay === undefined) {
        delay = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };
    Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
    return Scheduler2;
  }();
  exports.Scheduler = Scheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncScheduler = undefined;
  var Scheduler_1 = require_Scheduler();
  var AsyncScheduler = function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === undefined) {
        now = Scheduler_1.Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error;
      this._active = true;
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsyncScheduler2;
  }(Scheduler_1.Scheduler);
  exports.AsyncScheduler = AsyncScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsapScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var AsapScheduler = function(_super) {
    __extends(AsapScheduler2, _super);
    function AsapScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = undefined;
      var actions = this.actions;
      var error;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsapScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.AsapScheduler = AsapScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.asap = exports.asapScheduler = undefined;
  var AsapAction_1 = require_AsapAction();
  var AsapScheduler_1 = require_AsapScheduler();
  exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
  exports.asap = exports.asapScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.async = exports.asyncScheduler = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var AsyncScheduler_1 = require_AsyncScheduler();
  exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
  exports.async = exports.asyncScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueueAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var QueueAction = function(_super) {
    __extends(QueueAction2, _super);
    function QueueAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    QueueAction2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay > 0) {
        return _super.prototype.schedule.call(this, state, delay);
      }
      this.delay = delay;
      this.state = state;
      this.scheduler.flush(this);
      return this;
    };
    QueueAction2.prototype.execute = function(state, delay) {
      return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
    };
    QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null && delay > 0 || delay == null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.flush(this);
      return 0;
    };
    return QueueAction2;
  }(AsyncAction_1.AsyncAction);
  exports.QueueAction = QueueAction;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueueScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var QueueScheduler = function(_super) {
    __extends(QueueScheduler2, _super);
    function QueueScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.QueueScheduler = QueueScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.queue = exports.queueScheduler = undefined;
  var QueueAction_1 = require_QueueAction();
  var QueueScheduler_1 = require_QueueScheduler();
  exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
  exports.queue = exports.queueScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnimationFrameAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var animationFrameProvider_1 = require_animationFrameProvider();
  var AnimationFrameAction = function(_super) {
    __extends(AnimationFrameAction2, _super);
    function AnimationFrameAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
        return scheduler.flush(undefined);
      }));
    };
    AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      var _a;
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null ? delay > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      }
      var actions = scheduler.actions;
      if (id != null && ((_a = actions[actions.length - 1]) === null || _a === undefined ? undefined : _a.id) !== id) {
        animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        scheduler._scheduled = undefined;
      }
      return;
    };
    return AnimationFrameAction2;
  }(AsyncAction_1.AsyncAction);
  exports.AnimationFrameAction = AnimationFrameAction;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnimationFrameScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var AnimationFrameScheduler = function(_super) {
    __extends(AnimationFrameScheduler2, _super);
    function AnimationFrameScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = undefined;
      var actions = this.actions;
      var error;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AnimationFrameScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.AnimationFrameScheduler = AnimationFrameScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrame = exports.animationFrameScheduler = undefined;
  var AnimationFrameAction_1 = require_AnimationFrameAction();
  var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
  exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
  exports.animationFrame = exports.animationFrameScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VirtualAction = exports.VirtualTimeScheduler = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var Subscription_1 = require_Subscription();
  var AsyncScheduler_1 = require_AsyncScheduler();
  var VirtualTimeScheduler = function(_super) {
    __extends(VirtualTimeScheduler2, _super);
    function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
      if (schedulerActionCtor === undefined) {
        schedulerActionCtor = VirtualAction;
      }
      if (maxFrames === undefined) {
        maxFrames = Infinity;
      }
      var _this = _super.call(this, schedulerActionCtor, function() {
        return _this.frame;
      }) || this;
      _this.maxFrames = maxFrames;
      _this.frame = 0;
      _this.index = -1;
      return _this;
    }
    VirtualTimeScheduler2.prototype.flush = function() {
      var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
      var error;
      var action;
      while ((action = actions[0]) && action.delay <= maxFrames) {
        actions.shift();
        this.frame = action.delay;
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      }
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    VirtualTimeScheduler2.frameTimeFactor = 10;
    return VirtualTimeScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.VirtualTimeScheduler = VirtualTimeScheduler;
  var VirtualAction = function(_super) {
    __extends(VirtualAction2, _super);
    function VirtualAction2(scheduler, work, index) {
      if (index === undefined) {
        index = scheduler.index += 1;
      }
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.index = index;
      _this.active = true;
      _this.index = scheduler.index = index;
      return _this;
    }
    VirtualAction2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (Number.isFinite(delay)) {
        if (!this.id) {
          return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
      } else {
        return Subscription_1.Subscription.EMPTY;
      }
    };
    VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      this.delay = scheduler.frame + delay;
      var actions = scheduler.actions;
      actions.push(this);
      actions.sort(VirtualAction2.sortActions);
      return 1;
    };
    VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return;
    };
    VirtualAction2.prototype._execute = function(state, delay) {
      if (this.active === true) {
        return _super.prototype._execute.call(this, state, delay);
      }
    };
    VirtualAction2.sortActions = function(a, b2) {
      if (a.delay === b2.delay) {
        if (a.index === b2.index) {
          return 0;
        } else if (a.index > b2.index) {
          return 1;
        } else {
          return -1;
        }
      } else if (a.delay > b2.delay) {
        return 1;
      } else {
        return -1;
      }
    };
    return VirtualAction2;
  }(AsyncAction_1.AsyncAction);
  exports.VirtualAction = VirtualAction;
});

// node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = __commonJS((exports) => {
  var empty = function(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
  };
  var emptyScheduled = function(scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      return scheduler.schedule(function() {
        return subscriber.complete();
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.empty = exports.EMPTY = undefined;
  var Observable_1 = require_Observable();
  exports.EMPTY = new Observable_1.Observable(function(subscriber) {
    return subscriber.complete();
  });
  exports.empty = empty;
});

// node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS((exports) => {
  var isScheduler = function(value4) {
    return value4 && isFunction_1.isFunction(value4.schedule);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isScheduler = undefined;
  var isFunction_1 = require_isFunction();
  exports.isScheduler = isScheduler;
});

// node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS((exports) => {
  var last = function(arr) {
    return arr[arr.length - 1];
  };
  var popResultSelector = function(args) {
    return isFunction_1.isFunction(last(args)) ? args.pop() : undefined;
  };
  var popScheduler = function(args) {
    return isScheduler_1.isScheduler(last(args)) ? args.pop() : undefined;
  };
  var popNumber = function(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.popNumber = exports.popScheduler = exports.popResultSelector = undefined;
  var isFunction_1 = require_isFunction();
  var isScheduler_1 = require_isScheduler();
  exports.popResultSelector = popResultSelector;
  exports.popScheduler = popScheduler;
  exports.popNumber = popNumber;
});

// node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isArrayLike = undefined;
  exports.isArrayLike = function(x2) {
    return x2 && typeof x2.length === "number" && typeof x2 !== "function";
  };
});

// node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS((exports) => {
  var isPromise = function(value4) {
    return isFunction_1.isFunction(value4 === null || value4 === undefined ? undefined : value4.then);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPromise = undefined;
  var isFunction_1 = require_isFunction();
  exports.isPromise = isPromise;
});

// node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS((exports) => {
  var isInteropObservable = function(input) {
    return isFunction_1.isFunction(input[observable_1.observable]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isInteropObservable = undefined;
  var observable_1 = require_observable();
  var isFunction_1 = require_isFunction();
  exports.isInteropObservable = isInteropObservable;
});

// node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS((exports) => {
  var isAsyncIterable = function(obj) {
    return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === undefined ? undefined : obj[Symbol.asyncIterator]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAsyncIterable = undefined;
  var isFunction_1 = require_isFunction();
  exports.isAsyncIterable = isAsyncIterable;
});

// node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS((exports) => {
  var createInvalidObservableTypeError = function(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createInvalidObservableTypeError = undefined;
  exports.createInvalidObservableTypeError = createInvalidObservableTypeError;
});

// node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS((exports) => {
  var getSymbolIterator = function() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iterator = exports.getSymbolIterator = undefined;
  exports.getSymbolIterator = getSymbolIterator;
  exports.iterator = getSymbolIterator();
});

// node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS((exports) => {
  var isIterable = function(input) {
    return isFunction_1.isFunction(input === null || input === undefined ? undefined : input[iterator_1.iterator]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isIterable = undefined;
  var iterator_1 = require_iterator();
  var isFunction_1 = require_isFunction();
  exports.isIterable = isIterable;
});

// node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS((exports) => {
  var readableStreamLikeToAsyncGenerator = function(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value4, done;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            if (false)
              ;
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value4 = _a.value, done = _a.done;
            if (!done)
              return [3, 5];
            return [4, __await(undefined)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value4)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  };
  var isReadableStreamLike = function(obj) {
    return isFunction_1.isFunction(obj === null || obj === undefined ? undefined : obj.getReader);
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y2, t2, g2;
    return g2 = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y2 = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g2[n])
        i[n] = function(v) {
          return new Promise(function(a, b2) {
            q2.push([n, v, a, b2]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g2[n](v));
      } catch (e) {
        settle(q2[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
    }
    function fulfill(value4) {
      resume("next", value4);
    }
    function reject(value4) {
      resume("throw", value4);
    }
    function settle(f, v) {
      if (f(v), q2.shift(), q2.length)
        resume(q2[0][0], q2[0][1]);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = undefined;
  var isFunction_1 = require_isFunction();
  exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
  exports.isReadableStreamLike = isReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS((exports) => {
  var innerFrom = function(input) {
    if (input instanceof Observable_1.Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return fromArrayLike2(input);
      }
      if (isPromise_1.isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable_1.isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  };
  var fromInteropObservable = function(obj) {
    return new Observable_1.Observable(function(subscriber) {
      var obs = obj[observable_1.observable]();
      if (isFunction_1.isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  };
  var fromArrayLike2 = function(array) {
    return new Observable_1.Observable(function(subscriber) {
      for (var i = 0;i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    });
  };
  var fromPromise = function(promise) {
    return new Observable_1.Observable(function(subscriber) {
      promise.then(function(value4) {
        if (!subscriber.closed) {
          subscriber.next(value4);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError_1.reportUnhandledError);
    });
  };
  var fromIterable = function(iterable) {
    return new Observable_1.Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next();!iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value4 = iterable_1_1.value;
          subscriber.next(value4);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  };
  var fromAsyncIterable = function(asyncIterable) {
    return new Observable_1.Observable(function(subscriber) {
      process2(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  };
  var fromReadableStreamLike = function(readableStream) {
    return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
  };
  var process2 = function(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, undefined, undefined, function() {
      var value4, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value4 = asyncIterable_1_1.value;
            subscriber.next(value4);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value4) {
      return value4 instanceof P2 ? value4 : new P2(function(resolve) {
        resolve(value4);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value4) {
        try {
          step(generator.next(value4));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value4) {
        try {
          step(generator["throw"](value4));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y2, t2, g2;
    return g2 = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y2 = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = undefined;
  var isArrayLike_1 = require_isArrayLike();
  var isPromise_1 = require_isPromise();
  var Observable_1 = require_Observable();
  var isInteropObservable_1 = require_isInteropObservable();
  var isAsyncIterable_1 = require_isAsyncIterable();
  var throwUnobservableError_1 = require_throwUnobservableError();
  var isIterable_1 = require_isIterable();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  var isFunction_1 = require_isFunction();
  var reportUnhandledError_1 = require_reportUnhandledError();
  var observable_1 = require_observable();
  exports.innerFrom = innerFrom;
  exports.fromInteropObservable = fromInteropObservable;
  exports.fromArrayLike = fromArrayLike2;
  exports.fromPromise = fromPromise;
  exports.fromIterable = fromIterable;
  exports.fromAsyncIterable = fromAsyncIterable;
  exports.fromReadableStreamLike = fromReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS((exports) => {
  var executeSchedule = function(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === undefined) {
      delay = 0;
    }
    if (repeat === undefined) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.executeSchedule = undefined;
  exports.executeSchedule = executeSchedule;
});

// node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS((exports) => {
  var observeOn = function(scheduler, delay) {
    if (delay === undefined) {
      delay = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value4);
        }, delay);
      }, function() {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay);
      }, function(err) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeOn = undefined;
  var executeSchedule_1 = require_executeSchedule();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.observeOn = observeOn;
});

// node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS((exports) => {
  var subscribeOn = function(scheduler, delay) {
    if (delay === undefined) {
      delay = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.subscribeOn = undefined;
  var lift_1 = require_lift();
  exports.subscribeOn = subscribeOn;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS((exports) => {
  var scheduleObservable = function(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleObservable = undefined;
  var innerFrom_1 = require_innerFrom();
  var observeOn_1 = require_observeOn();
  var subscribeOn_1 = require_subscribeOn();
  exports.scheduleObservable = scheduleObservable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS((exports) => {
  var schedulePromise = function(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.schedulePromise = undefined;
  var innerFrom_1 = require_innerFrom();
  var observeOn_1 = require_observeOn();
  var subscribeOn_1 = require_subscribeOn();
  exports.schedulePromise = schedulePromise;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS((exports) => {
  var scheduleArray = function(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var i = 0;
      return scheduler.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleArray = undefined;
  var Observable_1 = require_Observable();
  exports.scheduleArray = scheduleArray;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS((exports) => {
  var scheduleIterable = function(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var iterator;
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        iterator = input[iterator_1.iterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var _a;
          var value4;
          var done;
          try {
            _a = iterator.next(), value4 = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value4);
          }
        }, 0, true);
      });
      return function() {
        return isFunction_1.isFunction(iterator === null || iterator === undefined ? undefined : iterator.return) && iterator.return();
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleIterable = undefined;
  var Observable_1 = require_Observable();
  var iterator_1 = require_iterator();
  var isFunction_1 = require_isFunction();
  var executeSchedule_1 = require_executeSchedule();
  exports.scheduleIterable = scheduleIterable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS((exports) => {
  var scheduleAsyncIterable = function(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable_1.Observable(function(subscriber) {
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        var iterator = input[Symbol.asyncIterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleAsyncIterable = undefined;
  var Observable_1 = require_Observable();
  var executeSchedule_1 = require_executeSchedule();
  exports.scheduleAsyncIterable = scheduleAsyncIterable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS((exports) => {
  var scheduleReadableStreamLike = function(input, scheduler) {
    return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleReadableStreamLike = undefined;
  var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  exports.scheduleReadableStreamLike = scheduleReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS((exports) => {
  var scheduled = function(input, scheduler) {
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return scheduleObservable_1.scheduleObservable(input, scheduler);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return scheduleArray_1.scheduleArray(input, scheduler);
      }
      if (isPromise_1.isPromise(input)) {
        return schedulePromise_1.schedulePromise(input, scheduler);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable_1.isIterable(input)) {
        return scheduleIterable_1.scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduled = undefined;
  var scheduleObservable_1 = require_scheduleObservable();
  var schedulePromise_1 = require_schedulePromise();
  var scheduleArray_1 = require_scheduleArray();
  var scheduleIterable_1 = require_scheduleIterable();
  var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
  var isInteropObservable_1 = require_isInteropObservable();
  var isPromise_1 = require_isPromise();
  var isArrayLike_1 = require_isArrayLike();
  var isIterable_1 = require_isIterable();
  var isAsyncIterable_1 = require_isAsyncIterable();
  var throwUnobservableError_1 = require_throwUnobservableError();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
  exports.scheduled = scheduled;
});

// node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS((exports) => {
  var from2 = function(input, scheduler) {
    return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.from = undefined;
  var scheduled_1 = require_scheduled();
  var innerFrom_1 = require_innerFrom();
  exports.from = from2;
});

// node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS((exports) => {
  var of = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    return from_1.from(args, scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.of = undefined;
  var args_1 = require_args();
  var from_1 = require_from();
  exports.of = of;
});

// node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS((exports) => {
  var throwError = function(errorOrErrorFactory, scheduler) {
    var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
      return errorOrErrorFactory;
    };
    var init2 = function(subscriber) {
      return subscriber.error(errorFactory());
    };
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      return scheduler.schedule(init2, 0, subscriber);
    } : init2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throwError = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  exports.throwError = throwError;
});

// node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS((exports) => {
  var observeNotification = function(notification, observer) {
    var _a, _b, _c;
    var _d = notification, kind = _d.kind, value4 = _d.value, error = _d.error;
    if (typeof kind !== "string") {
      throw new TypeError('Invalid notification, missing "kind"');
    }
    kind === "N" ? (_a = observer.next) === null || _a === undefined || _a.call(observer, value4) : kind === "E" ? (_b = observer.error) === null || _b === undefined || _b.call(observer, error) : (_c = observer.complete) === null || _c === undefined || _c.call(observer);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeNotification = exports.Notification = exports.NotificationKind = undefined;
  var empty_1 = require_empty();
  var of_1 = require_of();
  var throwError_1 = require_throwError();
  var isFunction_1 = require_isFunction();
  var NotificationKind;
  (function(NotificationKind2) {
    NotificationKind2["NEXT"] = "N";
    NotificationKind2["ERROR"] = "E";
    NotificationKind2["COMPLETE"] = "C";
  })(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
  var Notification = function() {
    function Notification2(kind, value4, error) {
      this.kind = kind;
      this.value = value4;
      this.error = error;
      this.hasValue = kind === "N";
    }
    Notification2.prototype.observe = function(observer) {
      return observeNotification(this, observer);
    };
    Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
      var _a = this, kind = _a.kind, value4 = _a.value, error = _a.error;
      return kind === "N" ? nextHandler === null || nextHandler === undefined ? undefined : nextHandler(value4) : kind === "E" ? errorHandler === null || errorHandler === undefined ? undefined : errorHandler(error) : completeHandler === null || completeHandler === undefined ? undefined : completeHandler();
    };
    Notification2.prototype.accept = function(nextOrObserver, error, complete) {
      var _a;
      return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === undefined ? undefined : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
    };
    Notification2.prototype.toObservable = function() {
      var _a = this, kind = _a.kind, value4 = _a.value, error = _a.error;
      var result = kind === "N" ? of_1.of(value4) : kind === "E" ? throwError_1.throwError(function() {
        return error;
      }) : kind === "C" ? empty_1.EMPTY : 0;
      if (!result) {
        throw new TypeError("Unexpected notification kind " + kind);
      }
      return result;
    };
    Notification2.createNext = function(value4) {
      return new Notification2("N", value4);
    };
    Notification2.createError = function(err) {
      return new Notification2("E", undefined, err);
    };
    Notification2.createComplete = function() {
      return Notification2.completeNotification;
    };
    Notification2.completeNotification = new Notification2("C");
    return Notification2;
  }();
  exports.Notification = Notification;
  exports.observeNotification = observeNotification;
});

// node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS((exports) => {
  var isObservable = function(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObservable = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  exports.isObservable = isObservable;
});

// node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmptyError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS((exports) => {
  var lastValueFrom = function(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
      var _hasValue = false;
      var _value;
      source.subscribe({
        next: function(value4) {
          _value = value4;
          _hasValue = true;
        },
        error: reject,
        complete: function() {
          if (_hasValue) {
            resolve(_value);
          } else if (hasConfig) {
            resolve(config.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError);
          }
        }
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lastValueFrom = undefined;
  var EmptyError_1 = require_EmptyError();
  exports.lastValueFrom = lastValueFrom;
});

// node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS((exports) => {
  var firstValueFrom = function(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
      var subscriber = new Subscriber_1.SafeSubscriber({
        next: function(value4) {
          resolve(value4);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function() {
          if (hasConfig) {
            resolve(config.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError);
          }
        }
      });
      source.subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.firstValueFrom = undefined;
  var EmptyError_1 = require_EmptyError();
  var Subscriber_1 = require_Subscriber();
  exports.firstValueFrom = firstValueFrom;
});

// node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ArgumentOutOfRangeError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
    return function ArgumentOutOfRangeErrorImpl() {
      _super(this);
      this.name = "ArgumentOutOfRangeError";
      this.message = "argument out of range";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NotFoundError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
    return function NotFoundErrorImpl(message) {
      _super(this);
      this.name = "NotFoundError";
      this.message = message;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SequenceError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
    return function SequenceErrorImpl(message) {
      _super(this);
      this.name = "SequenceError";
      this.message = message;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS((exports) => {
  var isValidDate = function(value4) {
    return value4 instanceof Date && !isNaN(value4);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidDate = undefined;
  exports.isValidDate = isValidDate;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS((exports) => {
  var timeout2 = function(config, schedulerArg) {
    var _a = isDate_1.isValidDate(config) ? { first: config } : typeof config === "number" ? { each: config } : config, first = _a.first, each = _a.each, _b = _a.with, _with = _b === undefined ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === undefined ? schedulerArg !== null && schedulerArg !== undefined ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === undefined ? null : _d;
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return lift_1.operate(function(source, subscriber) {
      var originalSourceSubscription;
      var timerSubscription;
      var lastValue = null;
      var seen = 0;
      var startTimer = function(delay) {
        timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          try {
            originalSourceSubscription.unsubscribe();
            innerFrom_1.innerFrom(_with({
              meta,
              lastValue,
              seen
            })).subscribe(subscriber);
          } catch (err) {
            subscriber.error(err);
          }
        }, delay);
      };
      originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        timerSubscription === null || timerSubscription === undefined || timerSubscription.unsubscribe();
        seen++;
        subscriber.next(lastValue = value4);
        each > 0 && startTimer(each);
      }, undefined, undefined, function() {
        if (!(timerSubscription === null || timerSubscription === undefined ? undefined : timerSubscription.closed)) {
          timerSubscription === null || timerSubscription === undefined || timerSubscription.unsubscribe();
        }
        lastValue = null;
      }));
      !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
    });
  };
  var timeoutErrorFactory = function(info) {
    throw new exports.TimeoutError(info);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeout = exports.TimeoutError = undefined;
  var async_1 = require_async();
  var isDate_1 = require_isDate();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var createErrorClass_1 = require_createErrorClass();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var executeSchedule_1 = require_executeSchedule();
  exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
    return function TimeoutErrorImpl(info) {
      if (info === undefined) {
        info = null;
      }
      _super(this);
      this.message = "Timeout has occurred";
      this.name = "TimeoutError";
      this.info = info;
    };
  });
  exports.timeout = timeout2;
});

// node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS((exports) => {
  var map = function(project, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        subscriber.next(project.call(thisArg, value4, index++));
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.map = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.map = map;
});

// node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS((exports) => {
  var callOrApply = function(fn, args) {
    return isArray(args) ? fn.apply(undefined, __spreadArray([], __read(args))) : fn(args);
  };
  var mapOneOrManyArgs = function(fn) {
    return map_1.map(function(args) {
      return callOrApply(fn, args);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapOneOrManyArgs = undefined;
  var map_1 = require_map();
  var isArray = Array.isArray;
  exports.mapOneOrManyArgs = mapOneOrManyArgs;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS((exports) => {
  var bindCallbackInternals = function(isNodeStyle, callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
      if (isScheduler_1.isScheduler(resultSelector)) {
        scheduler = resultSelector;
      } else {
        return function() {
          var args = [];
          for (var _i = 0;_i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
        };
      }
    }
    if (scheduler) {
      return function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
      };
    }
    return function() {
      var _this = this;
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var subject = new AsyncSubject_1.AsyncSubject;
      var uninitialized = true;
      return new Observable_1.Observable(function(subscriber) {
        var subs = subject.subscribe(subscriber);
        if (uninitialized) {
          uninitialized = false;
          var isAsync_1 = false;
          var isComplete_1 = false;
          callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
            function() {
              var results = [];
              for (var _i2 = 0;_i2 < arguments.length; _i2++) {
                results[_i2] = arguments[_i2];
              }
              if (isNodeStyle) {
                var err = results.shift();
                if (err != null) {
                  subject.error(err);
                  return;
                }
              }
              subject.next(1 < results.length ? results : results[0]);
              isComplete_1 = true;
              if (isAsync_1) {
                subject.complete();
              }
            }
          ]));
          if (isComplete_1) {
            subject.complete();
          }
          isAsync_1 = true;
        }
        return subs;
      });
    };
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindCallbackInternals = undefined;
  var isScheduler_1 = require_isScheduler();
  var Observable_1 = require_Observable();
  var subscribeOn_1 = require_subscribeOn();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var observeOn_1 = require_observeOn();
  var AsyncSubject_1 = require_AsyncSubject();
  exports.bindCallbackInternals = bindCallbackInternals;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS((exports) => {
  var bindCallback = function(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindCallback = undefined;
  var bindCallbackInternals_1 = require_bindCallbackInternals();
  exports.bindCallback = bindCallback;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS((exports) => {
  var bindNodeCallback = function(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindNodeCallback = undefined;
  var bindCallbackInternals_1 = require_bindCallbackInternals();
  exports.bindNodeCallback = bindNodeCallback;
});

// node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS((exports) => {
  var argsArgArrayOrObject = function(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key) {
            return first_1[key];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  };
  var isPOJO = function(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsArgArrayOrObject = undefined;
  var isArray = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var getKeys = Object.keys;
  exports.argsArgArrayOrObject = argsArgArrayOrObject;
});

// node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS((exports) => {
  var createObject = function(keys, values) {
    return keys.reduce(function(result, key, i) {
      return result[key] = values[i], result;
    }, {});
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createObject = undefined;
  exports.createObject = createObject;
});

// node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS((exports) => {
  var combineLatest = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var resultSelector = args_1.popResultSelector(args);
    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
    if (observables.length === 0) {
      return from_1.from([], scheduler);
    }
    var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject_1.createObject(keys, values);
    } : identity_1.identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  };
  var combineLatestInit = function(observables, scheduler, valueTransform) {
    if (valueTransform === undefined) {
      valueTransform = identity_1.identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i2) {
          maybeSchedule(scheduler, function() {
            var source = from_1.from(observables[i2], scheduler);
            var hasFirstValue = false;
            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
              values[i2] = value4;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i = 0;i < length; i++) {
          _loop_1(i);
        }
      }, subscriber);
    };
  };
  var maybeSchedule = function(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule_1.executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestInit = exports.combineLatest = undefined;
  var Observable_1 = require_Observable();
  var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
  var from_1 = require_from();
  var identity_1 = require_identity();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var args_1 = require_args();
  var createObject_1 = require_createObject();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var executeSchedule_1 = require_executeSchedule();
  exports.combineLatest = combineLatest;
  exports.combineLatestInit = combineLatestInit;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS((exports) => {
  var mergeInternals = function(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer17 = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer17.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value4) {
      return active < concurrent ? doInnerSub(value4) : buffer17.push(value4);
    };
    var doInnerSub = function(value4) {
      expand && subscriber.next(value4);
      active++;
      var innerComplete = false;
      innerFrom_1.innerFrom(project(value4, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === undefined || onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, undefined, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer17.shift();
              if (innerSubScheduler) {
                executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer17.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === undefined || additionalFinalizer();
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeInternals = undefined;
  var innerFrom_1 = require_innerFrom();
  var executeSchedule_1 = require_executeSchedule();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.mergeInternals = mergeInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS((exports) => {
  var mergeMap = function(project, resultSelector, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap(function(a, i) {
        return map_1.map(function(b2, ii) {
          return resultSelector(a, b2, i, ii);
        })(innerFrom_1.innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeMap = undefined;
  var map_1 = require_map();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  var isFunction_1 = require_isFunction();
  exports.mergeMap = mergeMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS((exports) => {
  var mergeAll = function(concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeAll = undefined;
  var mergeMap_1 = require_mergeMap();
  var identity_1 = require_identity();
  exports.mergeAll = mergeAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS((exports) => {
  var concatAll = function() {
    return mergeAll_1.mergeAll(1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatAll = undefined;
  var mergeAll_1 = require_mergeAll();
  exports.concatAll = concatAll;
});

// node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS((exports) => {
  var concat4 = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = undefined;
  var concatAll_1 = require_concatAll();
  var args_1 = require_args();
  var from_1 = require_from();
  exports.concat = concat4;
});

// node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS((exports) => {
  var defer = function(observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defer = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  exports.defer = defer;
});

// node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS((exports) => {
  var connectable = function(source, config) {
    if (config === undefined) {
      config = DEFAULT_CONFIG;
    }
    var connection = null;
    var { connector, resetOnDisconnect: _a } = config, resetOnDisconnect = _a === undefined ? true : _a;
    var subject = connector();
    var result = new Observable_1.Observable(function(subscriber) {
      return subject.subscribe(subscriber);
    });
    result.connect = function() {
      if (!connection || connection.closed) {
        connection = defer_1.defer(function() {
          return source;
        }).subscribe(subject);
        if (resetOnDisconnect) {
          connection.add(function() {
            return subject = connector();
          });
        }
      }
      return connection;
    };
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.connectable = undefined;
  var Subject_1 = require_Subject();
  var Observable_1 = require_Observable();
  var defer_1 = require_defer();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject;
    },
    resetOnDisconnect: true
  };
  exports.connectable = connectable;
});

// node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS((exports) => {
  var forkJoin = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
    var result = new Observable_1.Observable(function(subscriber) {
      var length = sources.length;
      if (!length) {
        subscriber.complete();
        return;
      }
      var values = new Array(length);
      var remainingCompletions = length;
      var remainingEmissions = length;
      var _loop_1 = function(sourceIndex2) {
        var hasValue = false;
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
          if (!hasValue) {
            hasValue = true;
            remainingEmissions--;
          }
          values[sourceIndex2] = value4;
        }, function() {
          return remainingCompletions--;
        }, undefined, function() {
          if (!remainingCompletions || !hasValue) {
            if (!remainingEmissions) {
              subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
            }
            subscriber.complete();
          }
        }));
      };
      for (var sourceIndex = 0;sourceIndex < length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
    });
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.forkJoin = undefined;
  var Observable_1 = require_Observable();
  var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
  var innerFrom_1 = require_innerFrom();
  var args_1 = require_args();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var createObject_1 = require_createObject();
  exports.forkJoin = forkJoin;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS((exports) => {
  var fromEvent = function(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
      resultSelector = options;
      options = undefined;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
    if (!add) {
      if (isArrayLike_1.isArrayLike(target)) {
        return mergeMap_1.mergeMap(function(subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom_1.innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add(handler);
      return function() {
        return remove(handler);
      };
    });
  };
  var toCommonHandlerRegistry = function(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  };
  var isNodeStyleEventEmitter = function(target) {
    return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
  };
  var isJQueryStyleEventEmitter = function(target) {
    return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
  };
  var isEventTarget = function(target) {
    return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromEvent = undefined;
  var innerFrom_1 = require_innerFrom();
  var Observable_1 = require_Observable();
  var mergeMap_1 = require_mergeMap();
  var isArrayLike_1 = require_isArrayLike();
  var isFunction_1 = require_isFunction();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  exports.fromEvent = fromEvent;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS((exports) => {
  var fromEventPattern = function(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
      return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var e = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          e[_i] = arguments[_i];
        }
        return subscriber.next(e.length === 1 ? e[0] : e);
      };
      var retValue = addHandler(handler);
      return isFunction_1.isFunction(removeHandler) ? function() {
        return removeHandler(handler, retValue);
      } : undefined;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromEventPattern = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  exports.fromEventPattern = fromEventPattern;
});

// node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS((exports) => {
  var generate = function(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
    var _a, _b;
    var resultSelector;
    var initialState;
    if (arguments.length === 1) {
      _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === undefined ? identity_1.identity : _b, scheduler = _a.scheduler;
    } else {
      initialState = initialStateOrOptions;
      if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrScheduler;
      } else {
        resultSelector = resultSelectorOrScheduler;
      }
    }
    function gen() {
      var state;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            state = initialState;
            _a2.label = 1;
          case 1:
            if (!(!condition || condition(state)))
              return [3, 4];
            return [4, resultSelector(state)];
          case 2:
            _a2.sent();
            _a2.label = 3;
          case 3:
            state = iterate(state);
            return [3, 1];
          case 4:
            return [2];
        }
      });
    }
    return defer_1.defer(scheduler ? function() {
      return scheduleIterable_1.scheduleIterable(gen(), scheduler);
    } : gen);
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y2, t2, g2;
    return g2 = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y2 = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generate = undefined;
  var identity_1 = require_identity();
  var isScheduler_1 = require_isScheduler();
  var defer_1 = require_defer();
  var scheduleIterable_1 = require_scheduleIterable();
  exports.generate = generate;
});

// node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS((exports) => {
  var iif = function(condition, trueResult, falseResult) {
    return defer_1.defer(function() {
      return condition() ? trueResult : falseResult;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iif = undefined;
  var defer_1 = require_defer();
  exports.iif = iif;
});

// node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS((exports) => {
  var timer = function(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === undefined) {
      dueTime = 0;
    }
    if (scheduler === undefined) {
      scheduler = async_1.async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler_1.isScheduler(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable_1.Observable(function(subscriber) {
      var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n++);
          if (0 <= intervalDuration) {
            this.schedule(undefined, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timer = undefined;
  var Observable_1 = require_Observable();
  var async_1 = require_async();
  var isScheduler_1 = require_isScheduler();
  var isDate_1 = require_isDate();
  exports.timer = timer;
});

// node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS((exports) => {
  var interval = function(period, scheduler) {
    if (period === undefined) {
      period = 0;
    }
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    if (period < 0) {
      period = 0;
    }
    return timer_1.timer(period, period, scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = undefined;
  var async_1 = require_async();
  var timer_1 = require_timer();
  exports.interval = interval;
});

// node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS((exports) => {
  var merge = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var concurrent = args_1.popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var mergeAll_1 = require_mergeAll();
  var innerFrom_1 = require_innerFrom();
  var empty_1 = require_empty();
  var args_1 = require_args();
  var from_1 = require_from();
  exports.merge = merge;
});

// node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS((exports) => {
  var never = function() {
    return exports.NEVER;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.never = exports.NEVER = undefined;
  var Observable_1 = require_Observable();
  var noop_1 = require_noop();
  exports.NEVER = new Observable_1.Observable(noop_1.noop);
  exports.never = never;
});

// node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS((exports) => {
  var argsOrArgArray = function(args) {
    return args.length === 1 && isArray(args[0]) ? args[0] : args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsOrArgArray = undefined;
  var isArray = Array.isArray;
  exports.argsOrArgArray = argsOrArgArray;
});

// node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS((exports) => {
  var onErrorResumeNext = function() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return new Observable_1.Observable(function(subscriber) {
      var sourceIndex = 0;
      var subscribeNext = function() {
        if (sourceIndex < nextSources.length) {
          var nextSource = undefined;
          try {
            nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
          } catch (err) {
            subscribeNext();
            return;
          }
          var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, undefined, noop_1.noop, noop_1.noop);
          nextSource.subscribe(innerSubscriber);
          innerSubscriber.add(subscribeNext);
        } else {
          subscriber.complete();
        }
      };
      subscribeNext();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.onErrorResumeNext = undefined;
  var Observable_1 = require_Observable();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  exports.onErrorResumeNext = onErrorResumeNext;
});

// node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS((exports) => {
  var pairs = function(obj, scheduler) {
    return from_1.from(Object.entries(obj), scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pairs = undefined;
  var from_1 = require_from();
  exports.pairs = pairs;
});

// node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS((exports) => {
  var not = function(pred, thisArg) {
    return function(value4, index) {
      return !pred.call(thisArg, value4, index);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.not = undefined;
  exports.not = not;
});

// node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS((exports) => {
  var filter = function(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return predicate.call(thisArg, value4, index++) && subscriber.next(value4);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filter = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.filter = filter;
});

// node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS((exports) => {
  var partition = function(source, predicate, thisArg) {
    return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.partition = undefined;
  var not_1 = require_not();
  var filter_1 = require_filter();
  var innerFrom_1 = require_innerFrom();
  exports.partition = partition;
});

// node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS((exports) => {
  var race = function() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    sources = argsOrArgArray_1.argsOrArgArray(sources);
    return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
  };
  var raceInit = function(sources) {
    return function(subscriber) {
      var subscriptions = [];
      var _loop_1 = function(i2) {
        subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
          if (subscriptions) {
            for (var s2 = 0;s2 < subscriptions.length; s2++) {
              s2 !== i2 && subscriptions[s2].unsubscribe();
            }
            subscriptions = null;
          }
          subscriber.next(value4);
        })));
      };
      for (var i = 0;subscriptions && !subscriber.closed && i < sources.length; i++) {
        _loop_1(i);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.raceInit = exports.race = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.race = race;
  exports.raceInit = raceInit;
});

// node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS((exports) => {
  var range = function(start, count, scheduler) {
    if (count == null) {
      count = start;
      start = 0;
    }
    if (count <= 0) {
      return empty_1.EMPTY;
    }
    var end = count + start;
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      var n = start;
      return scheduler.schedule(function() {
        if (n < end) {
          subscriber.next(n++);
          this.schedule();
        } else {
          subscriber.complete();
        }
      });
    } : function(subscriber) {
      var n = start;
      while (n < end && !subscriber.closed) {
        subscriber.next(n++);
      }
      subscriber.complete();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.range = undefined;
  var Observable_1 = require_Observable();
  var empty_1 = require_empty();
  exports.range = range;
});

// node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS((exports) => {
  var using = function(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      var resource = resourceFactory();
      var result = observableFactory(resource);
      var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
      source.subscribe(subscriber);
      return function() {
        if (resource) {
          resource.unsubscribe();
        }
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.using = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var empty_1 = require_empty();
  exports.using = using;
});

// node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS((exports) => {
  var zip = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    var sources = argsOrArgArray_1.argsOrArgArray(args);
    return sources.length ? new Observable_1.Observable(function(subscriber) {
      var buffers = sources.map(function() {
        return [];
      });
      var completed = sources.map(function() {
        return false;
      });
      subscriber.add(function() {
        buffers = completed = null;
      });
      var _loop_1 = function(sourceIndex2) {
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
          buffers[sourceIndex2].push(value4);
          if (buffers.every(function(buffer17) {
            return buffer17.length;
          })) {
            var result = buffers.map(function(buffer17) {
              return buffer17.shift();
            });
            subscriber.next(resultSelector ? resultSelector.apply(undefined, __spreadArray([], __read(result))) : result);
            if (buffers.some(function(buffer17, i) {
              return !buffer17.length && completed[i];
            })) {
              subscriber.complete();
            }
          }
        }, function() {
          completed[sourceIndex2] = true;
          !buffers[sourceIndex2].length && subscriber.complete();
        }));
      };
      for (var sourceIndex = 0;!subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
      return function() {
        buffers = completed = null;
      };
    }) : empty_1.EMPTY;
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zip = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var empty_1 = require_empty();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var args_1 = require_args();
  exports.zip = zip;
});

// node_modules/rxjs/dist/cjs/internal/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS((exports) => {
  var audit = function(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var isComplete = false;
      var endDuration = function() {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value4 = lastValue;
          lastValue = null;
          subscriber.next(value4);
        }
        isComplete && subscriber.complete();
      };
      var cleanupDuration = function() {
        durationSubscriber = null;
        isComplete && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        hasValue = true;
        lastValue = value4;
        if (!durationSubscriber) {
          innerFrom_1.innerFrom(durationSelector(value4)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
        }
      }, function() {
        isComplete = true;
        (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.audit = undefined;
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.audit = audit;
});

// node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS((exports) => {
  var auditTime = function(duration, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return audit_1.audit(function() {
      return timer_1.timer(duration, scheduler);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.auditTime = undefined;
  var async_1 = require_async();
  var audit_1 = require_audit();
  var timer_1 = require_timer();
  exports.auditTime = auditTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = __commonJS((exports) => {
  var buffer17 = function(closingNotifier) {
    return lift_1.operate(function(source, subscriber) {
      var currentBuffer = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return currentBuffer.push(value4);
      }, function() {
        subscriber.next(currentBuffer);
        subscriber.complete();
      }));
      innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        var b2 = currentBuffer;
        currentBuffer = [];
        subscriber.next(b2);
      }, noop_1.noop));
      return function() {
        currentBuffer = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buffer = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.buffer = buffer17;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS((exports) => {
  var bufferCount = function(bufferSize, startBufferEvery) {
    if (startBufferEvery === undefined) {
      startBufferEvery = null;
    }
    startBufferEvery = startBufferEvery !== null && startBufferEvery !== undefined ? startBufferEvery : bufferSize;
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      var count = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var e_1, _a, e_2, _b;
        var toEmit = null;
        if (count++ % startBufferEvery === 0) {
          buffers.push([]);
        }
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next();!buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer17 = buffers_1_1.value;
            buffer17.push(value4);
            if (bufferSize <= buffer17.length) {
              toEmit = toEmit !== null && toEmit !== undefined ? toEmit : [];
              toEmit.push(buffer17);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
              _a.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (toEmit) {
          try {
            for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next();!toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
              var buffer17 = toEmit_1_1.value;
              arrRemove_1.arrRemove(buffers, buffer17);
              subscriber.next(buffer17);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                _b.call(toEmit_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      }, function() {
        var e_3, _a;
        try {
          for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next();!buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
            var buffer17 = buffers_2_1.value;
            subscriber.next(buffer17);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
              _a.call(buffers_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        subscriber.complete();
      }, undefined, function() {
        buffers = null;
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferCount = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  exports.bufferCount = bufferCount;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS((exports) => {
  var bufferTime = function(bufferTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== undefined ? _a : async_1.asyncScheduler;
    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== undefined ? _b : null;
    var maxBufferSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var bufferRecords = [];
      var restartOnEmit = false;
      var emit = function(record) {
        var { buffer: buffer17, subs } = record;
        subs.unsubscribe();
        arrRemove_1.arrRemove(bufferRecords, record);
        subscriber.next(buffer17);
        restartOnEmit && startBuffer();
      };
      var startBuffer = function() {
        if (bufferRecords) {
          var subs = new Subscription_1.Subscription;
          subscriber.add(subs);
          var buffer17 = [];
          var record_1 = {
            buffer: buffer17,
            subs
          };
          bufferRecords.push(record_1);
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return emit(record_1);
          }, bufferTimeSpan);
        }
      };
      if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
      } else {
        restartOnEmit = true;
      }
      startBuffer();
      var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var e_1, _a2;
        var recordsCopy = bufferRecords.slice();
        try {
          for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next();!recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
            var record = recordsCopy_1_1.value;
            var buffer17 = record.buffer;
            buffer17.push(value4);
            maxBufferSize <= buffer17.length && emit(record);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
              _a2.call(recordsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (bufferRecords === null || bufferRecords === undefined ? undefined : bufferRecords.length) {
          subscriber.next(bufferRecords.shift().buffer);
        }
        bufferTimeSubscriber === null || bufferTimeSubscriber === undefined || bufferTimeSubscriber.unsubscribe();
        subscriber.complete();
        subscriber.unsubscribe();
      }, undefined, function() {
        return bufferRecords = null;
      });
      source.subscribe(bufferTimeSubscriber);
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferTime = undefined;
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  var async_1 = require_async();
  var args_1 = require_args();
  var executeSchedule_1 = require_executeSchedule();
  exports.bufferTime = bufferTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS((exports) => {
  var bufferToggle = function(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var buffer17 = [];
        buffers.push(buffer17);
        var closingSubscription = new Subscription_1.Subscription;
        var emitBuffer = function() {
          arrRemove_1.arrRemove(buffers, buffer17);
          subscriber.next(buffer17);
          closingSubscription.unsubscribe();
        };
        closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var e_1, _a;
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next();!buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer17 = buffers_1_1.value;
            buffer17.push(value4);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
              _a.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (buffers.length > 0) {
          subscriber.next(buffers.shift());
        }
        subscriber.complete();
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferToggle = undefined;
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var arrRemove_1 = require_arrRemove();
  exports.bufferToggle = bufferToggle;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS((exports) => {
  var bufferWhen = function(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffer17 = null;
      var closingSubscriber = null;
      var openBuffer = function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        var b2 = buffer17;
        buffer17 = [];
        b2 && subscriber.next(b2);
        innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
      };
      openBuffer();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return buffer17 === null || buffer17 === undefined ? undefined : buffer17.push(value4);
      }, function() {
        buffer17 && subscriber.next(buffer17);
        subscriber.complete();
      }, undefined, function() {
        return buffer17 = closingSubscriber = null;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferWhen = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.bufferWhen = bufferWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS((exports) => {
  var catchError = function(selector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function(err) {
        handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.catchError = undefined;
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var lift_1 = require_lift();
  exports.catchError = catchError;
});

// node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS((exports) => {
  var scanInternals = function(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state = seed;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var i = index++;
        state = hasState ? accumulator(state, value4, i) : (hasState = true, value4);
        emitOnNext && subscriber.next(state);
      }, emitBeforeComplete && function() {
        hasState && subscriber.next(state);
        subscriber.complete();
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scanInternals = undefined;
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.scanInternals = scanInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS((exports) => {
  var reduce = function(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reduce = undefined;
  var scanInternals_1 = require_scanInternals();
  var lift_1 = require_lift();
  exports.reduce = reduce;
});

// node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS((exports) => {
  var toArray = function() {
    return lift_1.operate(function(source, subscriber) {
      reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toArray = undefined;
  var reduce_1 = require_reduce();
  var lift_1 = require_lift();
  var arrReducer = function(arr, value4) {
    return arr.push(value4), arr;
  };
  exports.toArray = toArray;
});

// node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS((exports) => {
  var joinAllInternals = function(joinFn, project) {
    return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
      return joinFn(sources);
    }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.joinAllInternals = undefined;
  var identity_1 = require_identity();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var pipe_1 = require_pipe();
  var mergeMap_1 = require_mergeMap();
  var toArray_1 = require_toArray();
  exports.joinAllInternals = joinAllInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS((exports) => {
  var combineLatestAll = function(project) {
    return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestAll = undefined;
  var combineLatest_1 = require_combineLatest();
  var joinAllInternals_1 = require_joinAllInternals();
  exports.combineLatestAll = combineLatestAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineAll = undefined;
  var combineLatestAll_1 = require_combineLatestAll();
  exports.combineAll = combineLatestAll_1.combineLatestAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS((exports) => {
  var combineLatest = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    return resultSelector ? pipe_1.pipe(combineLatest.apply(undefined, __spreadArray([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
      combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatest = undefined;
  var combineLatest_1 = require_combineLatest();
  var lift_1 = require_lift();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var pipe_1 = require_pipe();
  var args_1 = require_args();
  exports.combineLatest = combineLatest;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS((exports) => {
  var combineLatestWith = function() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return combineLatest_1.combineLatest.apply(undefined, __spreadArray([], __read(otherSources)));
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestWith = undefined;
  var combineLatest_1 = require_combineLatest2();
  exports.combineLatestWith = combineLatestWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS((exports) => {
  var concatMap = function(project, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatMap = undefined;
  var mergeMap_1 = require_mergeMap();
  var isFunction_1 = require_isFunction();
  exports.concatMap = concatMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS((exports) => {
  var concatMapTo = function(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
      return innerObservable;
    }, resultSelector) : concatMap_1.concatMap(function() {
      return innerObservable;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatMapTo = undefined;
  var concatMap_1 = require_concatMap();
  var isFunction_1 = require_isFunction();
  exports.concatMapTo = concatMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS((exports) => {
  var concat4 = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    return lift_1.operate(function(source, subscriber) {
      concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = undefined;
  var lift_1 = require_lift();
  var concatAll_1 = require_concatAll();
  var args_1 = require_args();
  var from_1 = require_from();
  exports.concat = concat4;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS((exports) => {
  var concatWith = function() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return concat_1.concat.apply(undefined, __spreadArray([], __read(otherSources)));
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatWith = undefined;
  var concat_1 = require_concat2();
  exports.concatWith = concatWith;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS((exports) => {
  var fromSubscribable = function(subscribable) {
    return new Observable_1.Observable(function(subscriber) {
      return subscribable.subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromSubscribable = undefined;
  var Observable_1 = require_Observable();
  exports.fromSubscribable = fromSubscribable;
});

// node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = __commonJS((exports) => {
  var connect = function(selector, config) {
    if (config === undefined) {
      config = DEFAULT_CONFIG;
    }
    var connector = config.connector;
    return lift_1.operate(function(source, subscriber) {
      var subject = connector();
      innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
      subscriber.add(source.subscribe(subject));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.connect = undefined;
  var Subject_1 = require_Subject();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var fromSubscribable_1 = require_fromSubscribable();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject;
    }
  };
  exports.connect = connect;
});

// node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS((exports) => {
  var count = function(predicate) {
    return reduce_1.reduce(function(total, value4, i) {
      return !predicate || predicate(value4, i) ? total + 1 : total;
    }, 0);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.count = undefined;
  var reduce_1 = require_reduce();
  exports.count = count;
});

// node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS((exports) => {
  var debounce = function(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var emit = function() {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value4 = lastValue;
          lastValue = null;
          subscriber.next(value4);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        hasValue = true;
        lastValue = value4;
        durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
        innerFrom_1.innerFrom(durationSelector(value4)).subscribe(durationSubscriber);
      }, function() {
        emit();
        subscriber.complete();
      }, undefined, function() {
        lastValue = durationSubscriber = null;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debounce = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.debounce = debounce;
});

// node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS((exports) => {
  var debounceTime = function(dueTime, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var activeTask = null;
      var lastValue = null;
      var lastTime = null;
      var emit = function() {
        if (activeTask) {
          activeTask.unsubscribe();
          activeTask = null;
          var value4 = lastValue;
          lastValue = null;
          subscriber.next(value4);
        }
      };
      function emitWhenIdle() {
        var targetTime = lastTime + dueTime;
        var now = scheduler.now();
        if (now < targetTime) {
          activeTask = this.schedule(undefined, targetTime - now);
          subscriber.add(activeTask);
          return;
        }
        emit();
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        lastValue = value4;
        lastTime = scheduler.now();
        if (!activeTask) {
          activeTask = scheduler.schedule(emitWhenIdle, dueTime);
          subscriber.add(activeTask);
        }
      }, function() {
        emit();
        subscriber.complete();
      }, undefined, function() {
        lastValue = activeTask = null;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debounceTime = undefined;
  var async_1 = require_async();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.debounceTime = debounceTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS((exports) => {
  var defaultIfEmpty = function(defaultValue) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        hasValue = true;
        subscriber.next(value4);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultIfEmpty = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.defaultIfEmpty = defaultIfEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS((exports) => {
  var take = function(count) {
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        if (++seen <= count) {
          subscriber.next(value4);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.take = undefined;
  var empty_1 = require_empty();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.take = take;
});

// node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS((exports) => {
  var ignoreElements = function() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ignoreElements = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  exports.ignoreElements = ignoreElements;
});

// node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS((exports) => {
  var mapTo = function(value4) {
    return map_1.map(function() {
      return value4;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapTo = undefined;
  var map_1 = require_map();
  exports.mapTo = mapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS((exports) => {
  var delayWhen = function(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
      return function(source) {
        return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
      };
    }
    return mergeMap_1.mergeMap(function(value4, index) {
      return innerFrom_1.innerFrom(delayDurationSelector(value4, index)).pipe(take_1.take(1), mapTo_1.mapTo(value4));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delayWhen = undefined;
  var concat_1 = require_concat();
  var take_1 = require_take();
  var ignoreElements_1 = require_ignoreElements();
  var mapTo_1 = require_mapTo();
  var mergeMap_1 = require_mergeMap();
  var innerFrom_1 = require_innerFrom();
  exports.delayWhen = delayWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS((exports) => {
  var delay = function(due, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    var duration = timer_1.timer(due, scheduler);
    return delayWhen_1.delayWhen(function() {
      return duration;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = undefined;
  var async_1 = require_async();
  var delayWhen_1 = require_delayWhen();
  var timer_1 = require_timer();
  exports.delay = delay;
});

// node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS((exports) => {
  var dematerialize = function() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
        return Notification_1.observeNotification(notification, subscriber);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dematerialize = undefined;
  var Notification_1 = require_Notification();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.dematerialize = dematerialize;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS((exports) => {
  var distinct = function(keySelector, flushes) {
    return lift_1.operate(function(source, subscriber) {
      var distinctKeys = new Set;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var key = keySelector ? keySelector(value4) : value4;
        if (!distinctKeys.has(key)) {
          distinctKeys.add(key);
          subscriber.next(value4);
        }
      }));
      flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return distinctKeys.clear();
      }, noop_1.noop));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinct = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  exports.distinct = distinct;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS((exports) => {
  var distinctUntilChanged = function(comparator, keySelector) {
    if (keySelector === undefined) {
      keySelector = identity_1.identity;
    }
    comparator = comparator !== null && comparator !== undefined ? comparator : defaultCompare;
    return lift_1.operate(function(source, subscriber) {
      var previousKey;
      var first = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var currentKey = keySelector(value4);
        if (first || !comparator(previousKey, currentKey)) {
          first = false;
          previousKey = currentKey;
          subscriber.next(value4);
        }
      }));
    });
  };
  var defaultCompare = function(a, b2) {
    return a === b2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinctUntilChanged = undefined;
  var identity_1 = require_identity();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.distinctUntilChanged = distinctUntilChanged;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS((exports) => {
  var distinctUntilKeyChanged = function(key, compare4) {
    return distinctUntilChanged_1.distinctUntilChanged(function(x2, y2) {
      return compare4 ? compare4(x2[key], y2[key]) : x2[key] === y2[key];
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinctUntilKeyChanged = undefined;
  var distinctUntilChanged_1 = require_distinctUntilChanged();
  exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
});

// node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS((exports) => {
  var throwIfEmpty = function(errorFactory) {
    if (errorFactory === undefined) {
      errorFactory = defaultErrorFactory;
    }
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        hasValue = true;
        subscriber.next(value4);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  };
  var defaultErrorFactory = function() {
    return new EmptyError_1.EmptyError;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throwIfEmpty = undefined;
  var EmptyError_1 = require_EmptyError();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.throwIfEmpty = throwIfEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS((exports) => {
  var elementAt = function(index, defaultValue) {
    if (index < 0) {
      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    }
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(filter_1.filter(function(v, i) {
        return i === index;
      }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.elementAt = undefined;
  var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
  var filter_1 = require_filter();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var take_1 = require_take();
  exports.elementAt = elementAt;
});

// node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS((exports) => {
  var endWith = function() {
    var values = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    return function(source) {
      return concat_1.concat(source, of_1.of.apply(undefined, __spreadArray([], __read(values))));
    };
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.endWith = undefined;
  var concat_1 = require_concat();
  var of_1 = require_of();
  exports.endWith = endWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS((exports) => {
  var every = function(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        if (!predicate.call(thisArg, value4, index++, source)) {
          subscriber.next(false);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.every = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.every = every;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS((exports) => {
  var exhaustMap = function(project, resultSelector) {
    if (resultSelector) {
      return function(source) {
        return source.pipe(exhaustMap(function(a, i) {
          return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function(b2, ii) {
            return resultSelector(a, b2, i, ii);
          }));
        }));
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      var innerSub = null;
      var isComplete = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
        if (!innerSub) {
          innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
            innerSub = null;
            isComplete && subscriber.complete();
          });
          innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
        }
      }, function() {
        isComplete = true;
        !innerSub && subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaustMap = undefined;
  var map_1 = require_map();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.exhaustMap = exhaustMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS((exports) => {
  var exhaustAll = function() {
    return exhaustMap_1.exhaustMap(identity_1.identity);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaustAll = undefined;
  var exhaustMap_1 = require_exhaustMap();
  var identity_1 = require_identity();
  exports.exhaustAll = exhaustAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaust = undefined;
  var exhaustAll_1 = require_exhaustAll();
  exports.exhaust = exhaustAll_1.exhaustAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS((exports) => {
  var expand = function(project, concurrent, scheduler) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.expand = undefined;
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  exports.expand = expand;
});

// node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS((exports) => {
  var finalize = function(callback) {
    return lift_1.operate(function(source, subscriber) {
      try {
        source.subscribe(subscriber);
      } finally {
        subscriber.add(callback);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.finalize = undefined;
  var lift_1 = require_lift();
  exports.finalize = finalize;
});

// node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS((exports) => {
  var find = function(predicate, thisArg) {
    return lift_1.operate(createFind(predicate, thisArg, "value"));
  };
  var createFind = function(predicate, thisArg, emit) {
    var findIndex = emit === "index";
    return function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var i = index++;
        if (predicate.call(thisArg, value4, i, source)) {
          subscriber.next(findIndex ? i : value4);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(findIndex ? -1 : undefined);
        subscriber.complete();
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFind = exports.find = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.find = find;
  exports.createFind = createFind;
});

// node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS((exports) => {
  var findIndex = function(predicate, thisArg) {
    return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.findIndex = undefined;
  var lift_1 = require_lift();
  var find_1 = require_find();
  exports.findIndex = findIndex;
});

// node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS((exports) => {
  var first = function(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError;
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.first = undefined;
  var EmptyError_1 = require_EmptyError();
  var filter_1 = require_filter();
  var take_1 = require_take();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var identity_1 = require_identity();
  exports.first = first;
});

// node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS((exports) => {
  var groupBy = function(keySelector, elementOrOptions, duration, connector) {
    return lift_1.operate(function(source, subscriber) {
      var element;
      if (!elementOrOptions || typeof elementOrOptions === "function") {
        element = elementOrOptions;
      } else {
        duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
      }
      var groups = new Map;
      var notify = function(cb) {
        groups.forEach(cb);
        cb(subscriber);
      };
      var handleError = function(err) {
        return notify(function(consumer) {
          return consumer.error(err);
        });
      };
      var activeGroups = 0;
      var teardownAttempted = false;
      var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value4) {
        try {
          var key_1 = keySelector(value4);
          var group_1 = groups.get(key_1);
          if (!group_1) {
            groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject);
            var grouped = createGroupedObservable(key_1, group_1);
            subscriber.next(grouped);
            if (duration) {
              var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                group_1.complete();
                durationSubscriber_1 === null || durationSubscriber_1 === undefined || durationSubscriber_1.unsubscribe();
              }, undefined, undefined, function() {
                return groups.delete(key_1);
              });
              groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
            }
          }
          group_1.next(element ? element(value4) : value4);
        } catch (err) {
          handleError(err);
        }
      }, function() {
        return notify(function(consumer) {
          return consumer.complete();
        });
      }, handleError, function() {
        return groups.clear();
      }, function() {
        teardownAttempted = true;
        return activeGroups === 0;
      });
      source.subscribe(groupBySourceSubscriber);
      function createGroupedObservable(key, groupSubject) {
        var result = new Observable_1.Observable(function(groupSubscriber) {
          activeGroups++;
          var innerSub = groupSubject.subscribe(groupSubscriber);
          return function() {
            innerSub.unsubscribe();
            --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
          };
        });
        result.key = key;
        return result;
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.groupBy = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.groupBy = groupBy;
});

// node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS((exports) => {
  var isEmpty = function() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        subscriber.next(false);
        subscriber.complete();
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEmpty = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.isEmpty = isEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS((exports) => {
  var takeLast = function(count) {
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var buffer17 = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        buffer17.push(value4);
        count < buffer17.length && buffer17.shift();
      }, function() {
        var e_1, _a;
        try {
          for (var buffer_1 = __values(buffer17), buffer_1_1 = buffer_1.next();!buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
            var value4 = buffer_1_1.value;
            subscriber.next(value4);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
              _a.call(buffer_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      }, undefined, function() {
        buffer17 = null;
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeLast = undefined;
  var empty_1 = require_empty();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.takeLast = takeLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS((exports) => {
  var last = function(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError;
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.last = undefined;
  var EmptyError_1 = require_EmptyError();
  var filter_1 = require_filter();
  var takeLast_1 = require_takeLast();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var identity_1 = require_identity();
  exports.last = last;
});

// node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS((exports) => {
  var materialize = function() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        subscriber.next(Notification_1.Notification.createNext(value4));
      }, function() {
        subscriber.next(Notification_1.Notification.createComplete());
        subscriber.complete();
      }, function(err) {
        subscriber.next(Notification_1.Notification.createError(err));
        subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.materialize = undefined;
  var Notification_1 = require_Notification();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.materialize = materialize;
});

// node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS((exports) => {
  var max = function(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y2) {
      return comparer(x2, y2) > 0 ? x2 : y2;
    } : function(x2, y2) {
      return x2 > y2 ? x2 : y2;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.max = undefined;
  var reduce_1 = require_reduce();
  var isFunction_1 = require_isFunction();
  exports.max = max;
});

// node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flatMap = undefined;
  var mergeMap_1 = require_mergeMap();
  exports.flatMap = mergeMap_1.mergeMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS((exports) => {
  var mergeMapTo = function(innerObservable, resultSelector, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, resultSelector, concurrent);
    }
    if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return mergeMap_1.mergeMap(function() {
      return innerObservable;
    }, concurrent);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeMapTo = undefined;
  var mergeMap_1 = require_mergeMap();
  var isFunction_1 = require_isFunction();
  exports.mergeMapTo = mergeMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS((exports) => {
  var mergeScan = function(accumulator, seed, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    return lift_1.operate(function(source, subscriber) {
      var state = seed;
      return mergeInternals_1.mergeInternals(source, subscriber, function(value4, index) {
        return accumulator(state, value4, index);
      }, concurrent, function(value4) {
        state = value4;
      }, false, undefined, function() {
        return state = null;
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeScan = undefined;
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  exports.mergeScan = mergeScan;
});

// node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS((exports) => {
  var merge = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var concurrent = args_1.popNumber(args, Infinity);
    args = argsOrArgArray_1.argsOrArgArray(args);
    return lift_1.operate(function(source, subscriber) {
      mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var lift_1 = require_lift();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var mergeAll_1 = require_mergeAll();
  var args_1 = require_args();
  var from_1 = require_from();
  exports.merge = merge;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS((exports) => {
  var mergeWith = function() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return merge_1.merge.apply(undefined, __spreadArray([], __read(otherSources)));
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeWith = undefined;
  var merge_1 = require_merge2();
  exports.mergeWith = mergeWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS((exports) => {
  var min = function(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y2) {
      return comparer(x2, y2) < 0 ? x2 : y2;
    } : function(x2, y2) {
      return x2 < y2 ? x2 : y2;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.min = undefined;
  var reduce_1 = require_reduce();
  var isFunction_1 = require_isFunction();
  exports.min = min;
});

// node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS((exports) => {
  var multicast = function(subjectOrSubjectFactory, selector) {
    var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
      return subjectOrSubjectFactory;
    };
    if (isFunction_1.isFunction(selector)) {
      return connect_1.connect(selector, {
        connector: subjectFactory
      });
    }
    return function(source) {
      return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multicast = undefined;
  var ConnectableObservable_1 = require_ConnectableObservable();
  var isFunction_1 = require_isFunction();
  var connect_1 = require_connect();
  exports.multicast = multicast;
});

// node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS((exports) => {
  var onErrorResumeNextWith = function() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return function(source) {
      return onErrorResumeNext_1.onErrorResumeNext.apply(undefined, __spreadArray([source], __read(nextSources)));
    };
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.onErrorResumeNext = exports.onErrorResumeNextWith = undefined;
  var argsOrArgArray_1 = require_argsOrArgArray();
  var onErrorResumeNext_1 = require_onErrorResumeNext();
  exports.onErrorResumeNextWith = onErrorResumeNextWith;
  exports.onErrorResumeNext = onErrorResumeNextWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS((exports) => {
  var pairwise = function() {
    return lift_1.operate(function(source, subscriber) {
      var prev;
      var hasPrev = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var p = prev;
        prev = value4;
        hasPrev && subscriber.next([p, value4]);
        hasPrev = true;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pairwise = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.pairwise = pairwise;
});

// node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS((exports) => {
  var pluck = function() {
    var properties = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
      throw new Error("list of properties cannot be empty.");
    }
    return map_1.map(function(x2) {
      var currentProp = x2;
      for (var i = 0;i < length; i++) {
        var p = currentProp === null || currentProp === undefined ? undefined : currentProp[properties[i]];
        if (typeof p !== "undefined") {
          currentProp = p;
        } else {
          return;
        }
      }
      return currentProp;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pluck = undefined;
  var map_1 = require_map();
  exports.pluck = pluck;
});

// node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS((exports) => {
  var publish = function(selector) {
    return selector ? function(source) {
      return connect_1.connect(selector)(source);
    } : function(source) {
      return multicast_1.multicast(new Subject_1.Subject)(source);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publish = undefined;
  var Subject_1 = require_Subject();
  var multicast_1 = require_multicast();
  var connect_1 = require_connect();
  exports.publish = publish;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS((exports) => {
  var publishBehavior = function(initialValue) {
    return function(source) {
      var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishBehavior = undefined;
  var BehaviorSubject_1 = require_BehaviorSubject();
  var ConnectableObservable_1 = require_ConnectableObservable();
  exports.publishBehavior = publishBehavior;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS((exports) => {
  var publishLast = function() {
    return function(source) {
      var subject = new AsyncSubject_1.AsyncSubject;
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishLast = undefined;
  var AsyncSubject_1 = require_AsyncSubject();
  var ConnectableObservable_1 = require_ConnectableObservable();
  exports.publishLast = publishLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS((exports) => {
  var publishReplay = function(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
    if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
      timestampProvider = selectorOrScheduler;
    }
    var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;
    return function(source) {
      return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishReplay = undefined;
  var ReplaySubject_1 = require_ReplaySubject();
  var multicast_1 = require_multicast();
  var isFunction_1 = require_isFunction();
  exports.publishReplay = publishReplay;
});

// node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS((exports) => {
  var raceWith = function() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.raceWith = undefined;
  var race_1 = require_race();
  var lift_1 = require_lift();
  var identity_1 = require_identity();
  exports.raceWith = raceWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS((exports) => {
  var repeat = function(countOrConfig) {
    var _a;
    var count = Infinity;
    var delay;
    if (countOrConfig != null) {
      if (typeof countOrConfig === "object") {
        _a = countOrConfig.count, count = _a === undefined ? Infinity : _a, delay = countOrConfig.delay;
      } else {
        count = countOrConfig;
      }
    }
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var sourceSub;
      var resubscribe = function() {
        sourceSub === null || sourceSub === undefined || sourceSub.unsubscribe();
        sourceSub = null;
        if (delay != null) {
          var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
          var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            notifierSubscriber_1.unsubscribe();
            subscribeToSource();
          });
          notifier.subscribe(notifierSubscriber_1);
        } else {
          subscribeToSource();
        }
      };
      var subscribeToSource = function() {
        var syncUnsub = false;
        sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
          if (++soFar < count) {
            if (sourceSub) {
              resubscribe();
            } else {
              syncUnsub = true;
            }
          } else {
            subscriber.complete();
          }
        }));
        if (syncUnsub) {
          resubscribe();
        }
      };
      subscribeToSource();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.repeat = undefined;
  var empty_1 = require_empty();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var timer_1 = require_timer();
  exports.repeat = repeat;
});

// node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS((exports) => {
  var repeatWhen = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var completions$;
      var isNotifierComplete = false;
      var isMainComplete = false;
      var checkComplete = function() {
        return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
      };
      var getCompletionSubject = function() {
        if (!completions$) {
          completions$ = new Subject_1.Subject;
          innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            if (innerSub) {
              subscribeForRepeatWhen();
            } else {
              syncResub = true;
            }
          }, function() {
            isNotifierComplete = true;
            checkComplete();
          }));
        }
        return completions$;
      };
      var subscribeForRepeatWhen = function() {
        isMainComplete = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
          isMainComplete = true;
          !checkComplete() && getCompletionSubject().next();
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRepeatWhen();
        }
      };
      subscribeForRepeatWhen();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.repeatWhen = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.repeatWhen = repeatWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS((exports) => {
  var retry = function(configOrCount) {
    if (configOrCount === undefined) {
      configOrCount = Infinity;
    }
    var config;
    if (configOrCount && typeof configOrCount === "object") {
      config = configOrCount;
    } else {
      config = {
        count: configOrCount
      };
    }
    var _a = config.count, count = _a === undefined ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === undefined ? false : _b;
    return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var innerSub;
      var subscribeForRetry = function() {
        var syncUnsub = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
          if (resetOnSuccess) {
            soFar = 0;
          }
          subscriber.next(value4);
        }, undefined, function(err) {
          if (soFar++ < count) {
            var resub_1 = function() {
              if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                subscribeForRetry();
              } else {
                syncUnsub = true;
              }
            };
            if (delay != null) {
              var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
              var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                notifierSubscriber_1.unsubscribe();
                resub_1();
              }, function() {
                subscriber.complete();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              resub_1();
            }
          } else {
            subscriber.error(err);
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          subscribeForRetry();
        }
      };
      subscribeForRetry();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retry = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var identity_1 = require_identity();
  var timer_1 = require_timer();
  var innerFrom_1 = require_innerFrom();
  exports.retry = retry;
});

// node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS((exports) => {
  var retryWhen = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var errors$;
      var subscribeForRetryWhen = function() {
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function(err) {
          if (!errors$) {
            errors$ = new Subject_1.Subject;
            innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              return innerSub ? subscribeForRetryWhen() : syncResub = true;
            }));
          }
          if (errors$) {
            errors$.next(err);
          }
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRetryWhen();
        }
      };
      subscribeForRetryWhen();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryWhen = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.retryWhen = retryWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS((exports) => {
  var sample = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        hasValue = true;
        lastValue = value4;
      }));
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        if (hasValue) {
          hasValue = false;
          var value4 = lastValue;
          lastValue = null;
          subscriber.next(value4);
        }
      }, noop_1.noop));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sample = undefined;
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.sample = sample;
});

// node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS((exports) => {
  var sampleTime = function(period, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return sample_1.sample(interval_1.interval(period, scheduler));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sampleTime = undefined;
  var async_1 = require_async();
  var sample_1 = require_sample();
  var interval_1 = require_interval();
  exports.sampleTime = sampleTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS((exports) => {
  var scan = function(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scan = undefined;
  var lift_1 = require_lift();
  var scanInternals_1 = require_scanInternals();
  exports.scan = scan;
});

// node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS((exports) => {
  var sequenceEqual = function(compareTo, comparator) {
    if (comparator === undefined) {
      comparator = function(a, b2) {
        return a === b2;
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var aState = createState();
      var bState = createState();
      var emit = function(isEqual) {
        subscriber.next(isEqual);
        subscriber.complete();
      };
      var createSubscriber = function(selfState, otherState) {
        var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
          var { buffer: buffer17, complete } = otherState;
          if (buffer17.length === 0) {
            complete ? emit(false) : selfState.buffer.push(a);
          } else {
            !comparator(a, buffer17.shift()) && emit(false);
          }
        }, function() {
          selfState.complete = true;
          var { complete, buffer: buffer17 } = otherState;
          complete && emit(buffer17.length === 0);
          sequenceEqualSubscriber === null || sequenceEqualSubscriber === undefined || sequenceEqualSubscriber.unsubscribe();
        });
        return sequenceEqualSubscriber;
      };
      source.subscribe(createSubscriber(aState, bState));
      innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
    });
  };
  var createState = function() {
    return {
      buffer: [],
      complete: false
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sequenceEqual = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.sequenceEqual = sequenceEqual;
});

// node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS((exports) => {
  var share = function(options) {
    if (options === undefined) {
      options = {};
    }
    var _a = options.connector, connector = _a === undefined ? function() {
      return new Subject_1.Subject;
    } : _a, _b = options.resetOnError, resetOnError = _b === undefined ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === undefined ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === undefined ? true : _d;
    return function(wrapperSource) {
      var connection;
      var resetConnection;
      var subject;
      var refCount = 0;
      var hasCompleted = false;
      var hasErrored = false;
      var cancelReset = function() {
        resetConnection === null || resetConnection === undefined || resetConnection.unsubscribe();
        resetConnection = undefined;
      };
      var reset = function() {
        cancelReset();
        connection = subject = undefined;
        hasCompleted = hasErrored = false;
      };
      var resetAndUnsubscribe = function() {
        var conn = connection;
        reset();
        conn === null || conn === undefined || conn.unsubscribe();
      };
      return lift_1.operate(function(source, subscriber) {
        refCount++;
        if (!hasErrored && !hasCompleted) {
          cancelReset();
        }
        var dest = subject = subject !== null && subject !== undefined ? subject : connector();
        subscriber.add(function() {
          refCount--;
          if (refCount === 0 && !hasErrored && !hasCompleted) {
            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
          }
        });
        dest.subscribe(subscriber);
        if (!connection && refCount > 0) {
          connection = new Subscriber_1.SafeSubscriber({
            next: function(value4) {
              return dest.next(value4);
            },
            error: function(err) {
              hasErrored = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnError, err);
              dest.error(err);
            },
            complete: function() {
              hasCompleted = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnComplete);
              dest.complete();
            }
          });
          innerFrom_1.innerFrom(source).subscribe(connection);
        }
      })(wrapperSource);
    };
  };
  var handleReset = function(reset, on) {
    var args = [];
    for (var _i = 2;_i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    if (on === true) {
      reset();
      return;
    }
    if (on === false) {
      return;
    }
    var onSubscriber = new Subscriber_1.SafeSubscriber({
      next: function() {
        onSubscriber.unsubscribe();
        reset();
      }
    });
    return innerFrom_1.innerFrom(on.apply(undefined, __spreadArray([], __read(args)))).subscribe(onSubscriber);
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.share = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var Subscriber_1 = require_Subscriber();
  var lift_1 = require_lift();
  exports.share = share;
});

// node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS((exports) => {
  var shareReplay = function(configOrBufferSize, windowTime, scheduler) {
    var _a, _b, _c;
    var bufferSize;
    var refCount = false;
    if (configOrBufferSize && typeof configOrBufferSize === "object") {
      _a = configOrBufferSize.bufferSize, bufferSize = _a === undefined ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === undefined ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === undefined ? false : _c, scheduler = configOrBufferSize.scheduler;
    } else {
      bufferSize = configOrBufferSize !== null && configOrBufferSize !== undefined ? configOrBufferSize : Infinity;
    }
    return share_1.share({
      connector: function() {
        return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
      },
      resetOnError: true,
      resetOnComplete: false,
      resetOnRefCountZero: refCount
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shareReplay = undefined;
  var ReplaySubject_1 = require_ReplaySubject();
  var share_1 = require_share();
  exports.shareReplay = shareReplay;
});

// node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS((exports) => {
  var single = function(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var singleValue;
      var seenValue = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        seenValue = true;
        if (!predicate || predicate(value4, index++, source)) {
          hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
          hasValue = true;
          singleValue = value4;
        }
      }, function() {
        if (hasValue) {
          subscriber.next(singleValue);
          subscriber.complete();
        } else {
          subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError);
        }
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.single = undefined;
  var EmptyError_1 = require_EmptyError();
  var SequenceError_1 = require_SequenceError();
  var NotFoundError_1 = require_NotFoundError();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.single = single;
});

// node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS((exports) => {
  var skip = function(count) {
    return filter_1.filter(function(_2, index) {
      return count <= index;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skip = undefined;
  var filter_1 = require_filter();
  exports.skip = skip;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS((exports) => {
  var skipLast = function(skipCount) {
    return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var ring = new Array(skipCount);
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var valueIndex = seen++;
        if (valueIndex < skipCount) {
          ring[valueIndex] = value4;
        } else {
          var index = valueIndex % skipCount;
          var oldValue = ring[index];
          ring[index] = value4;
          subscriber.next(oldValue);
        }
      }));
      return function() {
        ring = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipLast = undefined;
  var identity_1 = require_identity();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.skipLast = skipLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS((exports) => {
  var skipUntil = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        skipSubscriber === null || skipSubscriber === undefined || skipSubscriber.unsubscribe();
        taking = true;
      }, noop_1.noop);
      innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return taking && subscriber.next(value4);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipUntil = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var noop_1 = require_noop();
  exports.skipUntil = skipUntil;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS((exports) => {
  var skipWhile = function(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return (taking || (taking = !predicate(value4, index++))) && subscriber.next(value4);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipWhile = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.skipWhile = skipWhile;
});

// node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS((exports) => {
  var startWith = function() {
    var values = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(values);
    return lift_1.operate(function(source, subscriber) {
      (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.startWith = undefined;
  var concat_1 = require_concat();
  var args_1 = require_args();
  var lift_1 = require_lift();
  exports.startWith = startWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS((exports) => {
  var switchMap = function(project, resultSelector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        innerSubscriber === null || innerSubscriber === undefined || innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom_1.innerFrom(project(value4, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value4, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchMap = undefined;
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.switchMap = switchMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS((exports) => {
  var switchAll = function() {
    return switchMap_1.switchMap(identity_1.identity);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchAll = undefined;
  var switchMap_1 = require_switchMap();
  var identity_1 = require_identity();
  exports.switchAll = switchAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS((exports) => {
  var switchMapTo = function(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
      return innerObservable;
    }, resultSelector) : switchMap_1.switchMap(function() {
      return innerObservable;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchMapTo = undefined;
  var switchMap_1 = require_switchMap();
  var isFunction_1 = require_isFunction();
  exports.switchMapTo = switchMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS((exports) => {
  var switchScan = function(accumulator, seed) {
    return lift_1.operate(function(source, subscriber) {
      var state = seed;
      switchMap_1.switchMap(function(value4, index) {
        return accumulator(state, value4, index);
      }, function(_2, innerValue) {
        return state = innerValue, innerValue;
      })(source).subscribe(subscriber);
      return function() {
        state = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchScan = undefined;
  var switchMap_1 = require_switchMap();
  var lift_1 = require_lift();
  exports.switchScan = switchScan;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS((exports) => {
  var takeUntil = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop_1.noop));
      !subscriber.closed && source.subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeUntil = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var noop_1 = require_noop();
  exports.takeUntil = takeUntil;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS((exports) => {
  var takeWhile = function(predicate, inclusive) {
    if (inclusive === undefined) {
      inclusive = false;
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var result = predicate(value4, index++);
        (result || inclusive) && subscriber.next(value4);
        !result && subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeWhile = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.takeWhile = takeWhile;
});

// node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS((exports) => {
  var tap = function(observerOrNext, error, complete) {
    var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
    return tapObserver ? lift_1.operate(function(source, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === undefined || _a.call(tapObserver);
      var isUnsub = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === undefined || _a2.call(tapObserver, value4);
        subscriber.next(value4);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === undefined || _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === undefined || _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === undefined || _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === undefined || _b.call(tapObserver);
      }));
    }) : identity_1.identity;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tap = undefined;
  var isFunction_1 = require_isFunction();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var identity_1 = require_identity();
  exports.tap = tap;
});

// node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS((exports) => {
  var throttle2 = function(durationSelector, config) {
    return lift_1.operate(function(source, subscriber) {
      var _a = config !== null && config !== undefined ? config : {}, _b = _a.leading, leading = _b === undefined ? true : _b, _c = _a.trailing, trailing = _c === undefined ? false : _c;
      var hasValue = false;
      var sendValue = null;
      var throttled = null;
      var isComplete = false;
      var endThrottling = function() {
        throttled === null || throttled === undefined || throttled.unsubscribe();
        throttled = null;
        if (trailing) {
          send();
          isComplete && subscriber.complete();
        }
      };
      var cleanupThrottling = function() {
        throttled = null;
        isComplete && subscriber.complete();
      };
      var startThrottle = function(value4) {
        return throttled = innerFrom_1.innerFrom(durationSelector(value4)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
      };
      var send = function() {
        if (hasValue) {
          hasValue = false;
          var value4 = sendValue;
          sendValue = null;
          subscriber.next(value4);
          !isComplete && startThrottle(value4);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        hasValue = true;
        sendValue = value4;
        !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value4));
      }, function() {
        isComplete = true;
        !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttle = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.throttle = throttle2;
});

// node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS((exports) => {
  var throttleTime = function(duration, scheduler, config) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    var duration$ = timer_1.timer(duration, scheduler);
    return throttle_1.throttle(function() {
      return duration$;
    }, config);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttleTime = undefined;
  var async_1 = require_async();
  var throttle_1 = require_throttle();
  var timer_1 = require_timer();
  exports.throttleTime = throttleTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS((exports) => {
  var timeInterval = function(scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var last = scheduler.now();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var now = scheduler.now();
        var interval = now - last;
        last = now;
        subscriber.next(new TimeInterval(value4, interval));
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TimeInterval = exports.timeInterval = undefined;
  var async_1 = require_async();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.timeInterval = timeInterval;
  var TimeInterval = function() {
    function TimeInterval2(value4, interval) {
      this.value = value4;
      this.interval = interval;
    }
    return TimeInterval2;
  }();
  exports.TimeInterval = TimeInterval;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS((exports) => {
  var timeoutWith = function(due, withObservable, scheduler) {
    var first;
    var each;
    var _with;
    scheduler = scheduler !== null && scheduler !== undefined ? scheduler : async_1.async;
    if (isDate_1.isValidDate(due)) {
      first = due;
    } else if (typeof due === "number") {
      each = due;
    }
    if (withObservable) {
      _with = function() {
        return withObservable;
      };
    } else {
      throw new TypeError("No observable provided to switch to");
    }
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return timeout_1.timeout({
      first,
      each,
      scheduler,
      with: _with
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutWith = undefined;
  var async_1 = require_async();
  var isDate_1 = require_isDate();
  var timeout_1 = require_timeout();
  exports.timeoutWith = timeoutWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var timestamp = function(timestampProvider) {
    if (timestampProvider === undefined) {
      timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
    }
    return map_1.map(function(value4) {
      return { value: value4, timestamp: timestampProvider.now() };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timestamp = undefined;
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var map_1 = require_map();
  exports.timestamp = timestamp;
});

// node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS((exports) => {
  var window2 = function(windowBoundaries) {
    return lift_1.operate(function(source, subscriber) {
      var windowSubject = new Subject_1.Subject;
      subscriber.next(windowSubject.asObservable());
      var errorHandler = function(err) {
        windowSubject.error(err);
        subscriber.error(err);
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return windowSubject === null || windowSubject === undefined ? undefined : windowSubject.next(value4);
      }, function() {
        windowSubject.complete();
        subscriber.complete();
      }, errorHandler));
      innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        windowSubject.complete();
        subscriber.next(windowSubject = new Subject_1.Subject);
      }, noop_1.noop, errorHandler));
      return function() {
        windowSubject === null || windowSubject === undefined || windowSubject.unsubscribe();
        windowSubject = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.window = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  exports.window = window2;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS((exports) => {
  var windowCount = function(windowSize, startWindowEvery) {
    if (startWindowEvery === undefined) {
      startWindowEvery = 0;
    }
    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
    return lift_1.operate(function(source, subscriber) {
      var windows = [new Subject_1.Subject];
      var starts = [];
      var count = 0;
      subscriber.next(windows[0].asObservable());
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var e_1, _a;
        try {
          for (var windows_1 = __values(windows), windows_1_1 = windows_1.next();!windows_1_1.done; windows_1_1 = windows_1.next()) {
            var window_1 = windows_1_1.value;
            window_1.next(value4);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
              _a.call(windows_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var c2 = count - windowSize + 1;
        if (c2 >= 0 && c2 % startEvery === 0) {
          windows.shift().complete();
        }
        if (++count % startEvery === 0) {
          var window_2 = new Subject_1.Subject;
          windows.push(window_2);
          subscriber.next(window_2.asObservable());
        }
      }, function() {
        while (windows.length > 0) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, function(err) {
        while (windows.length > 0) {
          windows.shift().error(err);
        }
        subscriber.error(err);
      }, function() {
        starts = null;
        windows = null;
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowCount = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.windowCount = windowCount;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS((exports) => {
  var windowTime = function(windowTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== undefined ? _a : async_1.asyncScheduler;
    var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== undefined ? _b : null;
    var maxWindowSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var windowRecords = [];
      var restartOnClose = false;
      var closeWindow = function(record) {
        var { window: window2, subs } = record;
        window2.complete();
        subs.unsubscribe();
        arrRemove_1.arrRemove(windowRecords, record);
        restartOnClose && startWindow();
      };
      var startWindow = function() {
        if (windowRecords) {
          var subs = new Subscription_1.Subscription;
          subscriber.add(subs);
          var window_1 = new Subject_1.Subject;
          var record_1 = {
            window: window_1,
            subs,
            seen: 0
          };
          windowRecords.push(record_1);
          subscriber.next(window_1.asObservable());
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return closeWindow(record_1);
          }, windowTimeSpan);
        }
      };
      if (windowCreationInterval !== null && windowCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
      } else {
        restartOnClose = true;
      }
      startWindow();
      var loop = function(cb) {
        return windowRecords.slice().forEach(cb);
      };
      var terminate = function(cb) {
        loop(function(_a2) {
          var window2 = _a2.window;
          return cb(window2);
        });
        cb(subscriber);
        subscriber.unsubscribe();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        loop(function(record) {
          record.window.next(value4);
          maxWindowSize <= ++record.seen && closeWindow(record);
        });
      }, function() {
        return terminate(function(consumer) {
          return consumer.complete();
        });
      }, function(err) {
        return terminate(function(consumer) {
          return consumer.error(err);
        });
      }));
      return function() {
        windowRecords = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowTime = undefined;
  var Subject_1 = require_Subject();
  var async_1 = require_async();
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  var args_1 = require_args();
  var executeSchedule_1 = require_executeSchedule();
  exports.windowTime = windowTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS((exports) => {
  var windowToggle = function(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var windows = [];
      var handleError = function(err) {
        while (0 < windows.length) {
          windows.shift().error(err);
        }
        subscriber.error(err);
      };
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var window2 = new Subject_1.Subject;
        windows.push(window2);
        var closingSubscription = new Subscription_1.Subscription;
        var closeWindow = function() {
          arrRemove_1.arrRemove(windows, window2);
          window2.complete();
          closingSubscription.unsubscribe();
        };
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
        } catch (err) {
          handleError(err);
          return;
        }
        subscriber.next(window2.asObservable());
        closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        var e_1, _a;
        var windowsCopy = windows.slice();
        try {
          for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next();!windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
            var window_1 = windowsCopy_1_1.value;
            window_1.next(value4);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
              _a.call(windowsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (0 < windows.length) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, handleError, function() {
        while (0 < windows.length) {
          windows.shift().unsubscribe();
        }
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowToggle = undefined;
  var Subject_1 = require_Subject();
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var arrRemove_1 = require_arrRemove();
  exports.windowToggle = windowToggle;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS((exports) => {
  var windowWhen = function(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var window2;
      var closingSubscriber;
      var handleError = function(err) {
        window2.error(err);
        subscriber.error(err);
      };
      var openWindow = function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        window2 === null || window2 === undefined || window2.complete();
        window2 = new Subject_1.Subject;
        subscriber.next(window2.asObservable());
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector());
        } catch (err) {
          handleError(err);
          return;
        }
        closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
      };
      openWindow();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        return window2.next(value4);
      }, function() {
        window2.complete();
        subscriber.complete();
      }, handleError, function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        window2 = null;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowWhen = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.windowWhen = windowWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS((exports) => {
  var withLatestFrom = function() {
    var inputs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      inputs[_i] = arguments[_i];
    }
    var project = args_1.popResultSelector(inputs);
    return lift_1.operate(function(source, subscriber) {
      var len = inputs.length;
      var otherValues = new Array(len);
      var hasValue = inputs.map(function() {
        return false;
      });
      var ready = false;
      var _loop_1 = function(i2) {
        innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
          otherValues[i2] = value4;
          if (!ready && !hasValue[i2]) {
            hasValue[i2] = true;
            (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
          }
        }, noop_1.noop));
      };
      for (var i = 0;i < len; i++) {
        _loop_1(i);
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value4) {
        if (ready) {
          var values = __spreadArray([value4], __read(otherValues));
          subscriber.next(project ? project.apply(undefined, __spreadArray([], __read(values))) : values);
        }
      }));
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.withLatestFrom = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var identity_1 = require_identity();
  var noop_1 = require_noop();
  var args_1 = require_args();
  exports.withLatestFrom = withLatestFrom;
});

// node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS((exports) => {
  var zipAll = function(project) {
    return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zipAll = undefined;
  var zip_1 = require_zip();
  var joinAllInternals_1 = require_joinAllInternals();
  exports.zipAll = zipAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS((exports) => {
  var zip = function() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    return lift_1.operate(function(source, subscriber) {
      zip_1.zip.apply(undefined, __spreadArray([source], __read(sources))).subscribe(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zip = undefined;
  var zip_1 = require_zip();
  var lift_1 = require_lift();
  exports.zip = zip;
});

// node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS((exports) => {
  var zipWith2 = function() {
    var otherInputs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherInputs[_i] = arguments[_i];
    }
    return zip_1.zip.apply(undefined, __spreadArray([], __read(otherInputs)));
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length;i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zipWith = undefined;
  var zip_1 = require_zip2();
  exports.zipWith = zipWith2;
});

// node_modules/rxjs/dist/cjs/index.js
var require_cjs = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m[k2];
    } });
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = undefined;
  exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = undefined;
  exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = undefined;
  exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = undefined;
  var Observable_1 = require_Observable();
  Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
    return Observable_1.Observable;
  } });
  var ConnectableObservable_1 = require_ConnectableObservable();
  Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
    return ConnectableObservable_1.ConnectableObservable;
  } });
  var observable_1 = require_observable();
  Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
    return observable_1.observable;
  } });
  var animationFrames_1 = require_animationFrames();
  Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
    return animationFrames_1.animationFrames;
  } });
  var Subject_1 = require_Subject();
  Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
    return Subject_1.Subject;
  } });
  var BehaviorSubject_1 = require_BehaviorSubject();
  Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
    return BehaviorSubject_1.BehaviorSubject;
  } });
  var ReplaySubject_1 = require_ReplaySubject();
  Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
    return ReplaySubject_1.ReplaySubject;
  } });
  var AsyncSubject_1 = require_AsyncSubject();
  Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
    return AsyncSubject_1.AsyncSubject;
  } });
  var asap_1 = require_asap();
  Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
    return asap_1.asap;
  } });
  Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
    return asap_1.asapScheduler;
  } });
  var async_1 = require_async();
  Object.defineProperty(exports, "async", { enumerable: true, get: function() {
    return async_1.async;
  } });
  Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
    return async_1.asyncScheduler;
  } });
  var queue_1 = require_queue();
  Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
    return queue_1.queue;
  } });
  Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
    return queue_1.queueScheduler;
  } });
  var animationFrame_1 = require_animationFrame();
  Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
    return animationFrame_1.animationFrame;
  } });
  Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
    return animationFrame_1.animationFrameScheduler;
  } });
  var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
  Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualTimeScheduler;
  } });
  Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualAction;
  } });
  var Scheduler_1 = require_Scheduler();
  Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
    return Scheduler_1.Scheduler;
  } });
  var Subscription_1 = require_Subscription();
  Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
    return Subscription_1.Subscription;
  } });
  var Subscriber_1 = require_Subscriber();
  Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
    return Subscriber_1.Subscriber;
  } });
  var Notification_1 = require_Notification();
  Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
    return Notification_1.Notification;
  } });
  Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
    return Notification_1.NotificationKind;
  } });
  var pipe_1 = require_pipe();
  Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
    return pipe_1.pipe;
  } });
  var noop_1 = require_noop();
  Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
    return noop_1.noop;
  } });
  var identity_1 = require_identity();
  Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
    return identity_1.identity;
  } });
  var isObservable_1 = require_isObservable();
  Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
    return isObservable_1.isObservable;
  } });
  var lastValueFrom_1 = require_lastValueFrom();
  Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
    return lastValueFrom_1.lastValueFrom;
  } });
  var firstValueFrom_1 = require_firstValueFrom();
  Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
    return firstValueFrom_1.firstValueFrom;
  } });
  var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
  Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
    return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
  } });
  var EmptyError_1 = require_EmptyError();
  Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
    return EmptyError_1.EmptyError;
  } });
  var NotFoundError_1 = require_NotFoundError();
  Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
    return NotFoundError_1.NotFoundError;
  } });
  var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
  Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
    return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
  } });
  var SequenceError_1 = require_SequenceError();
  Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
    return SequenceError_1.SequenceError;
  } });
  var timeout_1 = require_timeout();
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return timeout_1.TimeoutError;
  } });
  var UnsubscriptionError_1 = require_UnsubscriptionError();
  Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
    return UnsubscriptionError_1.UnsubscriptionError;
  } });
  var bindCallback_1 = require_bindCallback();
  Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
    return bindCallback_1.bindCallback;
  } });
  var bindNodeCallback_1 = require_bindNodeCallback();
  Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
    return bindNodeCallback_1.bindNodeCallback;
  } });
  var combineLatest_1 = require_combineLatest();
  Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
    return combineLatest_1.combineLatest;
  } });
  var concat_1 = require_concat();
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return concat_1.concat;
  } });
  var connectable_1 = require_connectable();
  Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
    return connectable_1.connectable;
  } });
  var defer_1 = require_defer();
  Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
    return defer_1.defer;
  } });
  var empty_1 = require_empty();
  Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
    return empty_1.empty;
  } });
  var forkJoin_1 = require_forkJoin();
  Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
    return forkJoin_1.forkJoin;
  } });
  var from_1 = require_from();
  Object.defineProperty(exports, "from", { enumerable: true, get: function() {
    return from_1.from;
  } });
  var fromEvent_1 = require_fromEvent();
  Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
    return fromEvent_1.fromEvent;
  } });
  var fromEventPattern_1 = require_fromEventPattern();
  Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
    return fromEventPattern_1.fromEventPattern;
  } });
  var generate_1 = require_generate();
  Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
    return generate_1.generate;
  } });
  var iif_1 = require_iif();
  Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
    return iif_1.iif;
  } });
  var interval_1 = require_interval();
  Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
    return interval_1.interval;
  } });
  var merge_1 = require_merge();
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_1.merge;
  } });
  var never_1 = require_never();
  Object.defineProperty(exports, "never", { enumerable: true, get: function() {
    return never_1.never;
  } });
  var of_1 = require_of();
  Object.defineProperty(exports, "of", { enumerable: true, get: function() {
    return of_1.of;
  } });
  var onErrorResumeNext_1 = require_onErrorResumeNext();
  Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
    return onErrorResumeNext_1.onErrorResumeNext;
  } });
  var pairs_1 = require_pairs();
  Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
    return pairs_1.pairs;
  } });
  var partition_1 = require_partition();
  Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
    return partition_1.partition;
  } });
  var race_1 = require_race();
  Object.defineProperty(exports, "race", { enumerable: true, get: function() {
    return race_1.race;
  } });
  var range_1 = require_range();
  Object.defineProperty(exports, "range", { enumerable: true, get: function() {
    return range_1.range;
  } });
  var throwError_1 = require_throwError();
  Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
    return throwError_1.throwError;
  } });
  var timer_1 = require_timer();
  Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
    return timer_1.timer;
  } });
  var using_1 = require_using();
  Object.defineProperty(exports, "using", { enumerable: true, get: function() {
    return using_1.using;
  } });
  var zip_1 = require_zip();
  Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
    return zip_1.zip;
  } });
  var scheduled_1 = require_scheduled();
  Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
    return scheduled_1.scheduled;
  } });
  var empty_2 = require_empty();
  Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
    return empty_2.EMPTY;
  } });
  var never_2 = require_never();
  Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
    return never_2.NEVER;
  } });
  __exportStar(require_types(), exports);
  var config_1 = require_config();
  Object.defineProperty(exports, "config", { enumerable: true, get: function() {
    return config_1.config;
  } });
  var audit_1 = require_audit();
  Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
    return audit_1.audit;
  } });
  var auditTime_1 = require_auditTime();
  Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
    return auditTime_1.auditTime;
  } });
  var buffer_1 = require_buffer();
  Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
    return buffer_1.buffer;
  } });
  var bufferCount_1 = require_bufferCount();
  Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
    return bufferCount_1.bufferCount;
  } });
  var bufferTime_1 = require_bufferTime();
  Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
    return bufferTime_1.bufferTime;
  } });
  var bufferToggle_1 = require_bufferToggle();
  Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
    return bufferToggle_1.bufferToggle;
  } });
  var bufferWhen_1 = require_bufferWhen();
  Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
    return bufferWhen_1.bufferWhen;
  } });
  var catchError_1 = require_catchError();
  Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
    return catchError_1.catchError;
  } });
  var combineAll_1 = require_combineAll();
  Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
    return combineAll_1.combineAll;
  } });
  var combineLatestAll_1 = require_combineLatestAll();
  Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
    return combineLatestAll_1.combineLatestAll;
  } });
  var combineLatestWith_1 = require_combineLatestWith();
  Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
    return combineLatestWith_1.combineLatestWith;
  } });
  var concatAll_1 = require_concatAll();
  Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
    return concatAll_1.concatAll;
  } });
  var concatMap_1 = require_concatMap();
  Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
    return concatMap_1.concatMap;
  } });
  var concatMapTo_1 = require_concatMapTo();
  Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
    return concatMapTo_1.concatMapTo;
  } });
  var concatWith_1 = require_concatWith();
  Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
    return concatWith_1.concatWith;
  } });
  var connect_1 = require_connect();
  Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
    return connect_1.connect;
  } });
  var count_1 = require_count();
  Object.defineProperty(exports, "count", { enumerable: true, get: function() {
    return count_1.count;
  } });
  var debounce_1 = require_debounce();
  Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
    return debounce_1.debounce;
  } });
  var debounceTime_1 = require_debounceTime();
  Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
    return debounceTime_1.debounceTime;
  } });
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
    return defaultIfEmpty_1.defaultIfEmpty;
  } });
  var delay_1 = require_delay();
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_1.delay;
  } });
  var delayWhen_1 = require_delayWhen();
  Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
    return delayWhen_1.delayWhen;
  } });
  var dematerialize_1 = require_dematerialize();
  Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
    return dematerialize_1.dematerialize;
  } });
  var distinct_1 = require_distinct();
  Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
    return distinct_1.distinct;
  } });
  var distinctUntilChanged_1 = require_distinctUntilChanged();
  Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
    return distinctUntilChanged_1.distinctUntilChanged;
  } });
  var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
  Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
    return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
  } });
  var elementAt_1 = require_elementAt();
  Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
    return elementAt_1.elementAt;
  } });
  var endWith_1 = require_endWith();
  Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
    return endWith_1.endWith;
  } });
  var every_1 = require_every();
  Object.defineProperty(exports, "every", { enumerable: true, get: function() {
    return every_1.every;
  } });
  var exhaust_1 = require_exhaust();
  Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
    return exhaust_1.exhaust;
  } });
  var exhaustAll_1 = require_exhaustAll();
  Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
    return exhaustAll_1.exhaustAll;
  } });
  var exhaustMap_1 = require_exhaustMap();
  Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
    return exhaustMap_1.exhaustMap;
  } });
  var expand_1 = require_expand();
  Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
    return expand_1.expand;
  } });
  var filter_1 = require_filter();
  Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
    return filter_1.filter;
  } });
  var finalize_1 = require_finalize();
  Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
    return finalize_1.finalize;
  } });
  var find_1 = require_find();
  Object.defineProperty(exports, "find", { enumerable: true, get: function() {
    return find_1.find;
  } });
  var findIndex_1 = require_findIndex();
  Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
    return findIndex_1.findIndex;
  } });
  var first_1 = require_first();
  Object.defineProperty(exports, "first", { enumerable: true, get: function() {
    return first_1.first;
  } });
  var groupBy_1 = require_groupBy();
  Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
    return groupBy_1.groupBy;
  } });
  var ignoreElements_1 = require_ignoreElements();
  Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
    return ignoreElements_1.ignoreElements;
  } });
  var isEmpty_1 = require_isEmpty();
  Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
    return isEmpty_1.isEmpty;
  } });
  var last_1 = require_last();
  Object.defineProperty(exports, "last", { enumerable: true, get: function() {
    return last_1.last;
  } });
  var map_1 = require_map();
  Object.defineProperty(exports, "map", { enumerable: true, get: function() {
    return map_1.map;
  } });
  var mapTo_1 = require_mapTo();
  Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
    return mapTo_1.mapTo;
  } });
  var materialize_1 = require_materialize();
  Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
    return materialize_1.materialize;
  } });
  var max_1 = require_max();
  Object.defineProperty(exports, "max", { enumerable: true, get: function() {
    return max_1.max;
  } });
  var mergeAll_1 = require_mergeAll();
  Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
    return mergeAll_1.mergeAll;
  } });
  var flatMap_1 = require_flatMap();
  Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
    return flatMap_1.flatMap;
  } });
  var mergeMap_1 = require_mergeMap();
  Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
    return mergeMap_1.mergeMap;
  } });
  var mergeMapTo_1 = require_mergeMapTo();
  Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
    return mergeMapTo_1.mergeMapTo;
  } });
  var mergeScan_1 = require_mergeScan();
  Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
    return mergeScan_1.mergeScan;
  } });
  var mergeWith_1 = require_mergeWith();
  Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
    return mergeWith_1.mergeWith;
  } });
  var min_1 = require_min();
  Object.defineProperty(exports, "min", { enumerable: true, get: function() {
    return min_1.min;
  } });
  var multicast_1 = require_multicast();
  Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
    return multicast_1.multicast;
  } });
  var observeOn_1 = require_observeOn();
  Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
    return observeOn_1.observeOn;
  } });
  var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
  Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
    return onErrorResumeNextWith_1.onErrorResumeNextWith;
  } });
  var pairwise_1 = require_pairwise();
  Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
    return pairwise_1.pairwise;
  } });
  var pluck_1 = require_pluck();
  Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
    return pluck_1.pluck;
  } });
  var publish_1 = require_publish();
  Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
    return publish_1.publish;
  } });
  var publishBehavior_1 = require_publishBehavior();
  Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
    return publishBehavior_1.publishBehavior;
  } });
  var publishLast_1 = require_publishLast();
  Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
    return publishLast_1.publishLast;
  } });
  var publishReplay_1 = require_publishReplay();
  Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
    return publishReplay_1.publishReplay;
  } });
  var raceWith_1 = require_raceWith();
  Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
    return raceWith_1.raceWith;
  } });
  var reduce_1 = require_reduce();
  Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
    return reduce_1.reduce;
  } });
  var repeat_1 = require_repeat();
  Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
    return repeat_1.repeat;
  } });
  var repeatWhen_1 = require_repeatWhen();
  Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
    return repeatWhen_1.repeatWhen;
  } });
  var retry_1 = require_retry();
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var retryWhen_1 = require_retryWhen();
  Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
    return retryWhen_1.retryWhen;
  } });
  var refCount_1 = require_refCount();
  Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
    return refCount_1.refCount;
  } });
  var sample_1 = require_sample();
  Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
    return sample_1.sample;
  } });
  var sampleTime_1 = require_sampleTime();
  Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
    return sampleTime_1.sampleTime;
  } });
  var scan_1 = require_scan();
  Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
    return scan_1.scan;
  } });
  var sequenceEqual_1 = require_sequenceEqual();
  Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
    return sequenceEqual_1.sequenceEqual;
  } });
  var share_1 = require_share();
  Object.defineProperty(exports, "share", { enumerable: true, get: function() {
    return share_1.share;
  } });
  var shareReplay_1 = require_shareReplay();
  Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
    return shareReplay_1.shareReplay;
  } });
  var single_1 = require_single();
  Object.defineProperty(exports, "single", { enumerable: true, get: function() {
    return single_1.single;
  } });
  var skip_1 = require_skip();
  Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
    return skip_1.skip;
  } });
  var skipLast_1 = require_skipLast();
  Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
    return skipLast_1.skipLast;
  } });
  var skipUntil_1 = require_skipUntil();
  Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
    return skipUntil_1.skipUntil;
  } });
  var skipWhile_1 = require_skipWhile();
  Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
    return skipWhile_1.skipWhile;
  } });
  var startWith_1 = require_startWith();
  Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
    return startWith_1.startWith;
  } });
  var subscribeOn_1 = require_subscribeOn();
  Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
    return subscribeOn_1.subscribeOn;
  } });
  var switchAll_1 = require_switchAll();
  Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
    return switchAll_1.switchAll;
  } });
  var switchMap_1 = require_switchMap();
  Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
    return switchMap_1.switchMap;
  } });
  var switchMapTo_1 = require_switchMapTo();
  Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
    return switchMapTo_1.switchMapTo;
  } });
  var switchScan_1 = require_switchScan();
  Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
    return switchScan_1.switchScan;
  } });
  var take_1 = require_take();
  Object.defineProperty(exports, "take", { enumerable: true, get: function() {
    return take_1.take;
  } });
  var takeLast_1 = require_takeLast();
  Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
    return takeLast_1.takeLast;
  } });
  var takeUntil_1 = require_takeUntil();
  Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
    return takeUntil_1.takeUntil;
  } });
  var takeWhile_1 = require_takeWhile();
  Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
    return takeWhile_1.takeWhile;
  } });
  var tap_1 = require_tap();
  Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
    return tap_1.tap;
  } });
  var throttle_1 = require_throttle();
  Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
    return throttle_1.throttle;
  } });
  var throttleTime_1 = require_throttleTime();
  Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
    return throttleTime_1.throttleTime;
  } });
  var throwIfEmpty_1 = require_throwIfEmpty();
  Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
    return throwIfEmpty_1.throwIfEmpty;
  } });
  var timeInterval_1 = require_timeInterval();
  Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
    return timeInterval_1.timeInterval;
  } });
  var timeout_2 = require_timeout();
  Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
    return timeout_2.timeout;
  } });
  var timeoutWith_1 = require_timeoutWith();
  Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
    return timeoutWith_1.timeoutWith;
  } });
  var timestamp_1 = require_timestamp();
  Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
    return timestamp_1.timestamp;
  } });
  var toArray_1 = require_toArray();
  Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
    return toArray_1.toArray;
  } });
  var window_1 = require_window();
  Object.defineProperty(exports, "window", { enumerable: true, get: function() {
    return window_1.window;
  } });
  var windowCount_1 = require_windowCount();
  Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
    return windowCount_1.windowCount;
  } });
  var windowTime_1 = require_windowTime();
  Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
    return windowTime_1.windowTime;
  } });
  var windowToggle_1 = require_windowToggle();
  Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
    return windowToggle_1.windowToggle;
  } });
  var windowWhen_1 = require_windowWhen();
  Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
    return windowWhen_1.windowWhen;
  } });
  var withLatestFrom_1 = require_withLatestFrom();
  Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
    return withLatestFrom_1.withLatestFrom;
  } });
  var zipAll_1 = require_zipAll();
  Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
    return zipAll_1.zipAll;
  } });
  var zipWith_1 = require_zipWith();
  Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
    return zipWith_1.zipWith;
  } });
});

// node_modules/@dfinity/agent/lib/cjs/agent/api.js
var require_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplicaRejectCode = undefined;
  var ReplicaRejectCode2;
  (function(ReplicaRejectCode3) {
    ReplicaRejectCode3[ReplicaRejectCode3["SysFatal"] = 1] = "SysFatal";
    ReplicaRejectCode3[ReplicaRejectCode3["SysTransient"] = 2] = "SysTransient";
    ReplicaRejectCode3[ReplicaRejectCode3["DestinationInvalid"] = 3] = "DestinationInvalid";
    ReplicaRejectCode3[ReplicaRejectCode3["CanisterReject"] = 4] = "CanisterReject";
    ReplicaRejectCode3[ReplicaRejectCode3["CanisterError"] = 5] = "CanisterError";
  })(ReplicaRejectCode2 = exports.ReplicaRejectCode || (exports.ReplicaRejectCode = {}));
});

// node_modules/@dfinity/principal/lib/cjs/utils/base32.js
var require_base32 = __commonJS((exports) => {
  var encode4 = function(input) {
    let skip = 0;
    let bits = 0;
    let output = "";
    function encodeByte(byte) {
      if (skip < 0) {
        bits |= byte >> -skip;
      } else {
        bits = byte << skip & 248;
      }
      if (skip > 3) {
        skip -= 8;
        return 1;
      }
      if (skip < 4) {
        output += alphabet2[bits >> 3];
        skip += 5;
      }
      return 0;
    }
    for (let i = 0;i < input.length; ) {
      i += encodeByte(input[i]);
    }
    return output + (skip < 0 ? alphabet2[bits >> 3] : "");
  };
  var decode5 = function(input) {
    let skip = 0;
    let byte = 0;
    const output = new Uint8Array(input.length * 4 / 3 | 0);
    let o = 0;
    function decodeChar(char) {
      let val = lookupTable2[char.toLowerCase()];
      if (val === undefined) {
        throw new Error(`Invalid character: ${JSON.stringify(char)}`);
      }
      val <<= 3;
      byte |= val >>> skip;
      skip += 5;
      if (skip >= 8) {
        output[o++] = byte;
        skip -= 8;
        if (skip > 0) {
          byte = val << 5 - skip & 255;
        } else {
          byte = 0;
        }
      }
    }
    for (const c2 of input) {
      decodeChar(c2);
    }
    return output.slice(0, o);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decode = exports.encode = undefined;
  var alphabet2 = "abcdefghijklmnopqrstuvwxyz234567";
  var lookupTable2 = Object.create(null);
  for (let i = 0;i < alphabet2.length; i++) {
    lookupTable2[alphabet2[i]] = i;
  }
  lookupTable2["0"] = lookupTable2.o;
  lookupTable2["1"] = lookupTable2.i;
  exports.encode = encode4;
  exports.decode = decode5;
});

// node_modules/@dfinity/principal/lib/cjs/utils/getCrc.js
var require_getCrc = __commonJS((exports) => {
  var getCrc322 = function(buf) {
    const b2 = new Uint8Array(buf);
    let crc = -1;
    for (let i = 0;i < b2.length; i++) {
      const byte = b2[i];
      const t2 = (byte ^ crc) & 255;
      crc = lookUpTable2[t2] ^ crc >>> 8;
    }
    return (crc ^ -1) >>> 0;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCrc32 = undefined;
  var lookUpTable2 = new Uint32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ]);
  exports.getCrc32 = getCrc322;
});

// node_modules/@dfinity/principal/lib/cjs/utils/sha224.js
var require_sha224 = __commonJS((exports) => {
  var sha2243 = function(data) {
    const shaObj = js_sha256_1.sha224.create();
    shaObj.update(data);
    return new Uint8Array(shaObj.array());
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sha224 = undefined;
  var js_sha256_1 = require_sha256();
  exports.sha224 = sha2243;
});

// node_modules/@dfinity/principal/lib/cjs/index.js
var require_cjs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Principal = undefined;
  var base32_1 = require_base32();
  var getCrc_1 = require_getCrc();
  var sha224_1 = require_sha224();
  var SELF_AUTHENTICATING_SUFFIX2 = 2;
  var ANONYMOUS_SUFFIX2 = 4;
  var MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR2 = "aaaaa-aa";
  var fromHexString3 = (hexString) => {
    var _a;
    return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== undefined ? _a : []).map((byte) => parseInt(byte, 16)));
  };
  var toHexString3 = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");

  class Principal3 {
    constructor(_arr) {
      this._arr = _arr;
      this._isPrincipal = true;
    }
    static anonymous() {
      return new this(new Uint8Array([ANONYMOUS_SUFFIX2]));
    }
    static managementCanister() {
      return this.fromHex(MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR2);
    }
    static selfAuthenticating(publicKey) {
      const sha = (0, sha224_1.sha224)(publicKey);
      return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX2]));
    }
    static from(other) {
      if (typeof other === "string") {
        return Principal3.fromText(other);
      } else if (typeof other === "object" && other !== null && other._isPrincipal === true) {
        return new Principal3(other._arr);
      }
      throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);
    }
    static fromHex(hex) {
      return new this(fromHexString3(hex));
    }
    static fromText(text) {
      const canisterIdNoDash = text.toLowerCase().replace(/-/g, "");
      let arr = (0, base32_1.decode)(canisterIdNoDash);
      arr = arr.slice(4, arr.length);
      const principal15 = new this(arr);
      if (principal15.toText() !== text) {
        throw new Error(`Principal "${principal15.toText()}" does not have a valid checksum (original value "${text}" may not be a valid Principal ID).`);
      }
      return principal15;
    }
    static fromUint8Array(arr) {
      return new this(arr);
    }
    isAnonymous() {
      return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX2;
    }
    toUint8Array() {
      return this._arr;
    }
    toHex() {
      return toHexString3(this._arr).toUpperCase();
    }
    toText() {
      const checksumArrayBuf = new ArrayBuffer(4);
      const view = new DataView(checksumArrayBuf);
      view.setUint32(0, (0, getCrc_1.getCrc32)(this._arr));
      const checksum = new Uint8Array(checksumArrayBuf);
      const bytes = Uint8Array.from(this._arr);
      const array = new Uint8Array([...checksum, ...bytes]);
      const result = (0, base32_1.encode)(array);
      const matches = result.match(/.{1,5}/g);
      if (!matches) {
        throw new Error;
      }
      return matches.join("-");
    }
    toString() {
      return this.toText();
    }
    compareTo(other) {
      for (let i = 0;i < Math.min(this._arr.length, other._arr.length); i++) {
        if (this._arr[i] < other._arr[i])
          return "lt";
        else if (this._arr[i] > other._arr[i])
          return "gt";
      }
      if (this._arr.length < other._arr.length)
        return "lt";
      if (this._arr.length > other._arr.length)
        return "gt";
      return "eq";
    }
    ltEq(other) {
      const cmp = this.compareTo(other);
      return cmp == "lt" || cmp == "eq";
    }
    gtEq(other) {
      const cmp = this.compareTo(other);
      return cmp == "gt" || cmp == "eq";
    }
  }
  exports.Principal = Principal3;
});

// node_modules/@dfinity/agent/lib/cjs/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AgentError = undefined;

  class AgentError2 extends Error {
    constructor(message) {
      super(message);
      this.message = message;
      Object.setPrototypeOf(this, AgentError2.prototype);
    }
  }
  exports.AgentError = AgentError2;
});

// node_modules/@dfinity/candid/lib/cjs/utils/buffer.js
var require_buffer2 = __commonJS((exports) => {
  var concat4 = function(...buffers) {
    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));
    let index = 0;
    for (const b2 of buffers) {
      result.set(new Uint8Array(b2), index);
      index += b2.byteLength;
    }
    return result;
  };
  var toHexString3 = function(bytes) {
    return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
  };
  var fromHexString3 = function(hexString) {
    var _a;
    return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== undefined ? _a : []).map((byte) => parseInt(byte, 16)));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PipeArrayBuffer = exports.fromHexString = exports.toHexString = exports.concat = undefined;
  exports.concat = concat4;
  exports.toHexString = toHexString3;
  exports.fromHexString = fromHexString3;

  class PipeArrayBuffer2 {
    constructor(buffer17, length = (buffer17 === null || buffer17 === undefined ? undefined : buffer17.byteLength) || 0) {
      this._buffer = buffer17 || new ArrayBuffer(0);
      this._view = new Uint8Array(this._buffer, 0, length);
    }
    get buffer() {
      return this._view.slice();
    }
    get byteLength() {
      return this._view.byteLength;
    }
    read(num) {
      const result = this._view.subarray(0, num);
      this._view = this._view.subarray(num);
      return result.slice().buffer;
    }
    readUint8() {
      const result = this._view[0];
      this._view = this._view.subarray(1);
      return result;
    }
    write(buf) {
      const b2 = new Uint8Array(buf);
      const offset = this._view.byteLength;
      if (this._view.byteOffset + this._view.byteLength + b2.byteLength >= this._buffer.byteLength) {
        this.alloc(b2.byteLength);
      } else {
        this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b2.byteLength);
      }
      this._view.set(b2, offset);
    }
    get end() {
      return this._view.byteLength === 0;
    }
    alloc(amount) {
      const b2 = new ArrayBuffer((this._buffer.byteLength + amount) * 1.2 | 0);
      const v = new Uint8Array(b2, 0, this._view.byteLength + amount);
      v.set(this._view);
      this._buffer = b2;
      this._view = v;
    }
  }
  exports.PipeArrayBuffer = PipeArrayBuffer2;
});

// node_modules/@dfinity/candid/lib/cjs/utils/hash.js
var require_hash = __commonJS((exports) => {
  var idlHash2 = function(s2) {
    const utf8encoder = new TextEncoder;
    const array = utf8encoder.encode(s2);
    let h2 = 0;
    for (const c2 of array) {
      h2 = (h2 * 223 + c2) % 2 ** 32;
    }
    return h2;
  };
  var idlLabelToId2 = function(label) {
    if (/^_\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {
      const num = +label.slice(1, -1);
      if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {
        return num;
      }
    }
    return idlHash2(label);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.idlLabelToId = undefined;
  exports.idlLabelToId = idlLabelToId2;
});

// node_modules/@dfinity/candid/lib/cjs/utils/leb128.js
var require_leb128 = __commonJS((exports) => {
  var eob2 = function() {
    throw new Error("unexpected end of buffer");
  };
  var safeRead2 = function(pipe, num) {
    if (pipe.byteLength < num) {
      eob2();
    }
    return pipe.read(num);
  };
  var safeReadUint82 = function(pipe) {
    const byte = pipe.readUint8();
    if (byte === undefined) {
      eob2();
    }
    return byte;
  };
  var lebEncode2 = function(value4) {
    if (typeof value4 === "number") {
      value4 = BigInt(value4);
    }
    if (value4 < BigInt(0)) {
      throw new Error("Cannot leb encode negative values.");
    }
    const byteLength2 = (value4 === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value4)))) + 1;
    const pipe = new buffer_1.PipeArrayBuffer(new ArrayBuffer(byteLength2), 0);
    while (true) {
      const i = Number(value4 & BigInt(127));
      value4 /= BigInt(128);
      if (value4 === BigInt(0)) {
        pipe.write(new Uint8Array([i]));
        break;
      } else {
        pipe.write(new Uint8Array([i | 128]));
      }
    }
    return pipe.buffer;
  };
  var lebDecode2 = function(pipe) {
    let weight = BigInt(1);
    let value4 = BigInt(0);
    let byte;
    do {
      byte = safeReadUint82(pipe);
      value4 += BigInt(byte & 127).valueOf() * weight;
      weight *= BigInt(128);
    } while (byte >= 128);
    return value4;
  };
  var slebEncode2 = function(value4) {
    if (typeof value4 === "number") {
      value4 = BigInt(value4);
    }
    const isNeg = value4 < BigInt(0);
    if (isNeg) {
      value4 = -value4 - BigInt(1);
    }
    const byteLength2 = (value4 === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value4)))) + 1;
    const pipe = new buffer_1.PipeArrayBuffer(new ArrayBuffer(byteLength2), 0);
    while (true) {
      const i = getLowerBytes(value4);
      value4 /= BigInt(128);
      if (isNeg && value4 === BigInt(0) && (i & 64) !== 0 || !isNeg && value4 === BigInt(0) && (i & 64) === 0) {
        pipe.write(new Uint8Array([i]));
        break;
      } else {
        pipe.write(new Uint8Array([i | 128]));
      }
    }
    function getLowerBytes(num) {
      const bytes = num % BigInt(128);
      if (isNeg) {
        return Number(BigInt(128) - bytes - BigInt(1));
      } else {
        return Number(bytes);
      }
    }
    return pipe.buffer;
  };
  var slebDecode2 = function(pipe) {
    const pipeView = new Uint8Array(pipe.buffer);
    let len = 0;
    for (;len < pipeView.byteLength; len++) {
      if (pipeView[len] < 128) {
        if ((pipeView[len] & 64) === 0) {
          return lebDecode2(pipe);
        }
        break;
      }
    }
    const bytes = new Uint8Array(safeRead2(pipe, len + 1));
    let value4 = BigInt(0);
    for (let i = bytes.byteLength - 1;i >= 0; i--) {
      value4 = value4 * BigInt(128) + BigInt(128 - (bytes[i] & 127) - 1);
    }
    return -value4 - BigInt(1);
  };
  var writeUIntLE3 = function(value4, byteLength2) {
    if (BigInt(value4) < BigInt(0)) {
      throw new Error("Cannot write negative values.");
    }
    return writeIntLE3(value4, byteLength2);
  };
  var writeIntLE3 = function(value4, byteLength2) {
    value4 = BigInt(value4);
    const pipe = new buffer_1.PipeArrayBuffer(new ArrayBuffer(Math.min(1, byteLength2)), 0);
    let i = 0;
    let mul = BigInt(256);
    let sub = BigInt(0);
    let byte = Number(value4 % mul);
    pipe.write(new Uint8Array([byte]));
    while (++i < byteLength2) {
      if (value4 < 0 && sub === BigInt(0) && byte !== 0) {
        sub = BigInt(1);
      }
      byte = Number((value4 / mul - sub) % BigInt(256));
      pipe.write(new Uint8Array([byte]));
      mul *= BigInt(256);
    }
    return pipe.buffer;
  };
  var readUIntLE3 = function(pipe, byteLength2) {
    let val = BigInt(safeReadUint82(pipe));
    let mul = BigInt(1);
    let i = 0;
    while (++i < byteLength2) {
      mul *= BigInt(256);
      const byte = BigInt(safeReadUint82(pipe));
      val = val + mul * byte;
    }
    return val;
  };
  var readIntLE3 = function(pipe, byteLength2) {
    let val = readUIntLE3(pipe, byteLength2);
    const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength2 - 1) + BigInt(7));
    if (val >= mul) {
      val -= mul * BigInt(2);
    }
    return val;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readIntLE = exports.readUIntLE = exports.writeIntLE = exports.writeUIntLE = exports.slebDecode = exports.slebEncode = exports.lebDecode = exports.lebEncode = exports.safeReadUint8 = exports.safeRead = undefined;
  var buffer_1 = require_buffer2();
  exports.safeRead = safeRead2;
  exports.safeReadUint8 = safeReadUint82;
  exports.lebEncode = lebEncode2;
  exports.lebDecode = lebDecode2;
  exports.slebEncode = slebEncode2;
  exports.slebDecode = slebDecode2;
  exports.writeUIntLE = writeUIntLE3;
  exports.writeIntLE = writeIntLE3;
  exports.readUIntLE = readUIntLE3;
  exports.readIntLE = readIntLE3;
});

// node_modules/@dfinity/candid/lib/cjs/utils/bigint-math.js
var require_bigint_math = __commonJS((exports) => {
  var ilog2 = function(n) {
    const nBig = BigInt(n);
    if (n <= 0) {
      throw new RangeError("Input must be positive");
    }
    return nBig.toString(2).length - 1;
  };
  var iexp22 = function(n) {
    const nBig = BigInt(n);
    if (n < 0) {
      throw new RangeError("Input must be non-negative");
    }
    return BigInt(1) << nBig;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iexp2 = exports.ilog2 = undefined;
  exports.ilog2 = ilog2;
  exports.iexp2 = iexp22;
});

// node_modules/@dfinity/candid/lib/cjs/idl.js
var require_idl = __commonJS((exports) => {
  var zipWith2 = function(xs, ys, f) {
    return xs.map((x2, i) => f(x2, ys[i]));
  };
  var decodePrincipalId2 = function(b2) {
    const x2 = (0, leb128_1.safeReadUint8)(b2);
    if (x2 !== 1) {
      throw new Error("Cannot decode principal");
    }
    const len = Number((0, leb128_1.lebDecode)(b2));
    return principal_1.Principal.fromUint8Array(new Uint8Array((0, leb128_1.safeRead)(b2, len)));
  };
  var toReadableString2 = function(x2) {
    const str = JSON.stringify(x2, (_key, value4) => typeof value4 === "bigint" ? `BigInt(${value4})` : value4);
    return str && str.length > toReadableString_max2 ? str.substring(0, toReadableString_max2 - 3) + "..." : str;
  };
  var encode4 = function(argTypes, args) {
    if (args.length < argTypes.length) {
      throw Error("Wrong number of message arguments");
    }
    const typeTable = new TypeTable2;
    argTypes.forEach((t2) => t2.buildTypeTable(typeTable));
    const magic = new TextEncoder().encode(magicNumber2);
    const table = typeTable.encode();
    const len = (0, leb128_1.lebEncode)(args.length);
    const typs = (0, buffer_1.concat)(...argTypes.map((t2) => t2.encodeType(typeTable)));
    const vals = (0, buffer_1.concat)(...zipWith2(argTypes, args, (t2, x2) => {
      try {
        t2.covariant(x2);
      } catch (e) {
        const err = new Error(e.message + "\n\n");
        throw err;
      }
      return t2.encodeValue(x2);
    }));
    return (0, buffer_1.concat)(magic, table, len, typs, vals);
  };
  var decode5 = function(retTypes, bytes) {
    const b2 = new buffer_1.PipeArrayBuffer(bytes);
    if (bytes.byteLength < magicNumber2.length) {
      throw new Error("Message length smaller than magic number");
    }
    const magicBuffer = (0, leb128_1.safeRead)(b2, magicNumber2.length);
    const magic = new TextDecoder().decode(magicBuffer);
    if (magic !== magicNumber2) {
      throw new Error("Wrong magic number: " + JSON.stringify(magic));
    }
    function readTypeTable(pipe) {
      const typeTable = [];
      const len = Number((0, leb128_1.lebDecode)(pipe));
      for (let i = 0;i < len; i++) {
        const ty = Number((0, leb128_1.slebDecode)(pipe));
        switch (ty) {
          case -18:
          case -19: {
            const t2 = Number((0, leb128_1.slebDecode)(pipe));
            typeTable.push([ty, t2]);
            break;
          }
          case -20:
          case -21: {
            const fields = [];
            let objectLength = Number((0, leb128_1.lebDecode)(pipe));
            let prevHash;
            while (objectLength--) {
              const hash4 = Number((0, leb128_1.lebDecode)(pipe));
              if (hash4 >= Math.pow(2, 32)) {
                throw new Error("field id out of 32-bit range");
              }
              if (typeof prevHash === "number" && prevHash >= hash4) {
                throw new Error("field id collision or not sorted");
              }
              prevHash = hash4;
              const t2 = Number((0, leb128_1.slebDecode)(pipe));
              fields.push([hash4, t2]);
            }
            typeTable.push([ty, fields]);
            break;
          }
          case -22: {
            const args = [];
            let argLength = Number((0, leb128_1.lebDecode)(pipe));
            while (argLength--) {
              args.push(Number((0, leb128_1.slebDecode)(pipe)));
            }
            const returnValues = [];
            let returnValuesLength = Number((0, leb128_1.lebDecode)(pipe));
            while (returnValuesLength--) {
              returnValues.push(Number((0, leb128_1.slebDecode)(pipe)));
            }
            const annotations = [];
            let annotationLength = Number((0, leb128_1.lebDecode)(pipe));
            while (annotationLength--) {
              const annotation = Number((0, leb128_1.lebDecode)(pipe));
              switch (annotation) {
                case 1: {
                  annotations.push("query");
                  break;
                }
                case 2: {
                  annotations.push("oneway");
                  break;
                }
                case 3: {
                  annotations.push("composite_query");
                  break;
                }
                default:
                  throw new Error("unknown annotation");
              }
            }
            typeTable.push([ty, [args, returnValues, annotations]]);
            break;
          }
          case -23: {
            let servLength = Number((0, leb128_1.lebDecode)(pipe));
            const methods = [];
            while (servLength--) {
              const nameLength = Number((0, leb128_1.lebDecode)(pipe));
              const funcName = new TextDecoder().decode((0, leb128_1.safeRead)(pipe, nameLength));
              const funcType = (0, leb128_1.slebDecode)(pipe);
              methods.push([funcName, funcType]);
            }
            typeTable.push([ty, methods]);
            break;
          }
          default:
            throw new Error("Illegal op_code: " + ty);
        }
      }
      const rawList = [];
      const length = Number((0, leb128_1.lebDecode)(pipe));
      for (let i = 0;i < length; i++) {
        rawList.push(Number((0, leb128_1.slebDecode)(pipe)));
      }
      return [typeTable, rawList];
    }
    const [rawTable, rawTypes] = readTypeTable(b2);
    if (rawTypes.length < retTypes.length) {
      throw new Error("Wrong number of return values");
    }
    const table = rawTable.map((_2) => Rec2());
    function getType(t2) {
      if (t2 < -24) {
        throw new Error("future value not supported");
      }
      if (t2 < 0) {
        switch (t2) {
          case -1:
            return exports.Null;
          case -2:
            return exports.Bool;
          case -3:
            return exports.Nat;
          case -4:
            return exports.Int;
          case -5:
            return exports.Nat8;
          case -6:
            return exports.Nat16;
          case -7:
            return exports.Nat32;
          case -8:
            return exports.Nat64;
          case -9:
            return exports.Int8;
          case -10:
            return exports.Int16;
          case -11:
            return exports.Int32;
          case -12:
            return exports.Int64;
          case -13:
            return exports.Float32;
          case -14:
            return exports.Float64;
          case -15:
            return exports.Text;
          case -16:
            return exports.Reserved;
          case -17:
            return exports.Empty;
          case -24:
            return exports.Principal;
          default:
            throw new Error("Illegal op_code: " + t2);
        }
      }
      if (t2 >= rawTable.length) {
        throw new Error("type index out of range");
      }
      return table[t2];
    }
    function buildType(entry) {
      switch (entry[0]) {
        case -19: {
          const ty = getType(entry[1]);
          return Vec2(ty);
        }
        case -18: {
          const ty = getType(entry[1]);
          return Opt2(ty);
        }
        case -20: {
          const fields = {};
          for (const [hash4, ty] of entry[1]) {
            const name = `_${hash4}_`;
            fields[name] = getType(ty);
          }
          const record = Record2(fields);
          const tuple = record.tryAsTuple();
          if (Array.isArray(tuple)) {
            return Tuple2(...tuple);
          } else {
            return record;
          }
        }
        case -21: {
          const fields = {};
          for (const [hash4, ty] of entry[1]) {
            const name = `_${hash4}_`;
            fields[name] = getType(ty);
          }
          return Variant2(fields);
        }
        case -22: {
          const [args, returnValues, annotations] = entry[1];
          return Func2(args.map((t2) => getType(t2)), returnValues.map((t2) => getType(t2)), annotations);
        }
        case -23: {
          const rec = {};
          const methods = entry[1];
          for (const [name, typeRef] of methods) {
            let type = getType(typeRef);
            if (type instanceof RecClass2) {
              type = type.getType();
            }
            if (!(type instanceof FuncClass2)) {
              throw new Error("Illegal service definition: services can only contain functions");
            }
            rec[name] = type;
          }
          return Service2(rec);
        }
        default:
          throw new Error("Illegal op_code: " + entry[0]);
      }
    }
    rawTable.forEach((entry, i) => {
      if (entry[0] === -22) {
        const t2 = buildType(entry);
        table[i].fill(t2);
      }
    });
    rawTable.forEach((entry, i) => {
      if (entry[0] !== -22) {
        const t2 = buildType(entry);
        table[i].fill(t2);
      }
    });
    const types5 = rawTypes.map((t2) => getType(t2));
    const output = retTypes.map((t2, i) => {
      return t2.decodeValue(b2, types5[i]);
    });
    for (let ind = retTypes.length;ind < types5.length; ind++) {
      types5[ind].decodeValue(b2, types5[ind]);
    }
    if (b2.byteLength > 0) {
      throw new Error("decode: Left-over bytes");
    }
    return output;
  };
  var Tuple2 = function(...types5) {
    return new TupleClass2(types5);
  };
  var Vec2 = function(t2) {
    return new VecClass2(t2);
  };
  var Opt2 = function(t2) {
    return new OptClass2(t2);
  };
  var Record2 = function(t2) {
    return new RecordClass2(t2);
  };
  var Variant2 = function(fields) {
    return new VariantClass2(fields);
  };
  var Rec2 = function() {
    return new RecClass2;
  };
  var Func2 = function(args, ret2, annotations = []) {
    return new FuncClass2(args, ret2, annotations);
  };
  var Service2 = function(t2) {
    return new ServiceClass2(t2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Variant = exports.Record = exports.Opt = exports.Vec = exports.Tuple = exports.Principal = exports.Nat64 = exports.Nat32 = exports.Nat16 = exports.Nat8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Float64 = exports.Float32 = exports.Nat = exports.Int = exports.Text = exports.Null = exports.Bool = exports.Unknown = exports.Reserved = exports.Empty = exports.decode = exports.encode = exports.ServiceClass = exports.FuncClass = exports.PrincipalClass = exports.RecClass = exports.VariantClass = exports.TupleClass = exports.RecordClass = exports.OptClass = exports.VecClass = exports.FixedNatClass = exports.FixedIntClass = exports.FloatClass = exports.NatClass = exports.IntClass = exports.TextClass = exports.ReservedClass = exports.NullClass = exports.BoolClass = exports.UnknownClass = exports.EmptyClass = exports.ConstructType = exports.PrimitiveType = exports.Type = exports.Visitor = undefined;
  exports.Service = exports.Func = exports.Rec = undefined;
  var principal_1 = require_cjs2();
  var buffer_1 = require_buffer2();
  var hash_1 = require_hash();
  var leb128_1 = require_leb128();
  var bigint_math_1 = require_bigint_math();
  var magicNumber2 = "DIDL";
  var toReadableString_max2 = 400;

  class TypeTable2 {
    constructor() {
      this._typs = [];
      this._idx = new Map;
    }
    has(obj) {
      return this._idx.has(obj.name);
    }
    add(type, buf) {
      const idx = this._typs.length;
      this._idx.set(type.name, idx);
      this._typs.push(buf);
    }
    merge(obj, knot) {
      const idx = this._idx.get(obj.name);
      const knotIdx = this._idx.get(knot);
      if (idx === undefined) {
        throw new Error("Missing type index for " + obj);
      }
      if (knotIdx === undefined) {
        throw new Error("Missing type index for " + knot);
      }
      this._typs[idx] = this._typs[knotIdx];
      this._typs.splice(knotIdx, 1);
      this._idx.delete(knot);
    }
    encode() {
      const len = (0, leb128_1.lebEncode)(this._typs.length);
      const buf = (0, buffer_1.concat)(...this._typs);
      return (0, buffer_1.concat)(len, buf);
    }
    indexOf(typeName) {
      if (!this._idx.has(typeName)) {
        throw new Error("Missing type index for " + typeName);
      }
      return (0, leb128_1.slebEncode)(this._idx.get(typeName) || 0);
    }
  }

  class Visitor2 {
    visitType(t2, data) {
      throw new Error("Not implemented");
    }
    visitPrimitive(t2, data) {
      return this.visitType(t2, data);
    }
    visitEmpty(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitBool(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitNull(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitReserved(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitText(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitNumber(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitInt(t2, data) {
      return this.visitNumber(t2, data);
    }
    visitNat(t2, data) {
      return this.visitNumber(t2, data);
    }
    visitFloat(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitFixedInt(t2, data) {
      return this.visitNumber(t2, data);
    }
    visitFixedNat(t2, data) {
      return this.visitNumber(t2, data);
    }
    visitPrincipal(t2, data) {
      return this.visitPrimitive(t2, data);
    }
    visitConstruct(t2, data) {
      return this.visitType(t2, data);
    }
    visitVec(t2, ty, data) {
      return this.visitConstruct(t2, data);
    }
    visitOpt(t2, ty, data) {
      return this.visitConstruct(t2, data);
    }
    visitRecord(t2, fields, data) {
      return this.visitConstruct(t2, data);
    }
    visitTuple(t2, components, data) {
      const fields = components.map((ty, i) => [`_${i}_`, ty]);
      return this.visitRecord(t2, fields, data);
    }
    visitVariant(t2, fields, data) {
      return this.visitConstruct(t2, data);
    }
    visitRec(t2, ty, data) {
      return this.visitConstruct(ty, data);
    }
    visitFunc(t2, data) {
      return this.visitConstruct(t2, data);
    }
    visitService(t2, data) {
      return this.visitConstruct(t2, data);
    }
  }
  exports.Visitor = Visitor2;

  class Type2 {
    display() {
      return this.name;
    }
    valueToString(x2) {
      return toReadableString2(x2);
    }
    buildTypeTable(typeTable) {
      if (!typeTable.has(this)) {
        this._buildTypeTableImpl(typeTable);
      }
    }
  }
  exports.Type = Type2;

  class PrimitiveType2 extends Type2 {
    checkType(t2) {
      if (this.name !== t2.name) {
        throw new Error(`type mismatch: type on the wire ${t2.name}, expect type ${this.name}`);
      }
      return t2;
    }
    _buildTypeTableImpl(typeTable) {
      return;
    }
  }
  exports.PrimitiveType = PrimitiveType2;

  class ConstructType2 extends Type2 {
    checkType(t2) {
      if (t2 instanceof RecClass2) {
        const ty = t2.getType();
        if (typeof ty === "undefined") {
          throw new Error("type mismatch with uninitialized type");
        }
        return ty;
      }
      throw new Error(`type mismatch: type on the wire ${t2.name}, expect type ${this.name}`);
    }
    encodeType(typeTable) {
      return typeTable.indexOf(this.name);
    }
  }
  exports.ConstructType = ConstructType2;

  class EmptyClass2 extends PrimitiveType2 {
    accept(v, d) {
      return v.visitEmpty(this, d);
    }
    covariant(x2) {
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue() {
      throw new Error("Empty cannot appear as a function argument");
    }
    valueToString() {
      throw new Error("Empty cannot appear as a value");
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-17);
    }
    decodeValue() {
      throw new Error("Empty cannot appear as an output");
    }
    get name() {
      return "empty";
    }
  }
  exports.EmptyClass = EmptyClass2;

  class UnknownClass2 extends Type2 {
    checkType(t2) {
      throw new Error("Method not implemented for unknown.");
    }
    accept(v, d) {
      throw v.visitType(this, d);
    }
    covariant(x2) {
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue() {
      throw new Error("Unknown cannot appear as a function argument");
    }
    valueToString() {
      throw new Error("Unknown cannot appear as a value");
    }
    encodeType() {
      throw new Error("Unknown cannot be serialized");
    }
    decodeValue(b2, t2) {
      let decodedValue = t2.decodeValue(b2, t2);
      if (Object(decodedValue) !== decodedValue) {
        decodedValue = Object(decodedValue);
      }
      let typeFunc;
      if (t2 instanceof RecClass2) {
        typeFunc = () => t2.getType();
      } else {
        typeFunc = () => t2;
      }
      Object.defineProperty(decodedValue, "type", {
        value: typeFunc,
        writable: true,
        enumerable: false,
        configurable: true
      });
      return decodedValue;
    }
    _buildTypeTableImpl() {
      throw new Error("Unknown cannot be serialized");
    }
    get name() {
      return "Unknown";
    }
  }
  exports.UnknownClass = UnknownClass2;

  class BoolClass2 extends PrimitiveType2 {
    accept(v, d) {
      return v.visitBool(this, d);
    }
    covariant(x2) {
      if (typeof x2 === "boolean")
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      return new Uint8Array([x2 ? 1 : 0]);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-2);
    }
    decodeValue(b2, t2) {
      this.checkType(t2);
      switch ((0, leb128_1.safeReadUint8)(b2)) {
        case 0:
          return false;
        case 1:
          return true;
        default:
          throw new Error("Boolean value out of range");
      }
    }
    get name() {
      return "bool";
    }
  }
  exports.BoolClass = BoolClass2;

  class NullClass2 extends PrimitiveType2 {
    accept(v, d) {
      return v.visitNull(this, d);
    }
    covariant(x2) {
      if (x2 === null)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue() {
      return new ArrayBuffer(0);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-1);
    }
    decodeValue(b2, t2) {
      this.checkType(t2);
      return null;
    }
    get name() {
      return "null";
    }
  }
  exports.NullClass = NullClass2;

  class ReservedClass2 extends PrimitiveType2 {
    accept(v, d) {
      return v.visitReserved(this, d);
    }
    covariant(x2) {
      return true;
    }
    encodeValue() {
      return new ArrayBuffer(0);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-16);
    }
    decodeValue(b2, t2) {
      if (t2.name !== this.name) {
        t2.decodeValue(b2, t2);
      }
      return null;
    }
    get name() {
      return "reserved";
    }
  }
  exports.ReservedClass = ReservedClass2;

  class TextClass2 extends PrimitiveType2 {
    accept(v, d) {
      return v.visitText(this, d);
    }
    covariant(x2) {
      if (typeof x2 === "string")
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      const buf = new TextEncoder().encode(x2);
      const len = (0, leb128_1.lebEncode)(buf.byteLength);
      return (0, buffer_1.concat)(len, buf);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-15);
    }
    decodeValue(b2, t2) {
      this.checkType(t2);
      const len = (0, leb128_1.lebDecode)(b2);
      const buf = (0, leb128_1.safeRead)(b2, Number(len));
      const decoder = new TextDecoder("utf8", { fatal: true });
      return decoder.decode(buf);
    }
    get name() {
      return "text";
    }
    valueToString(x2) {
      return '"' + x2 + '"';
    }
  }
  exports.TextClass = TextClass2;

  class IntClass2 extends PrimitiveType2 {
    accept(v, d) {
      return v.visitInt(this, d);
    }
    covariant(x2) {
      if (typeof x2 === "bigint" || Number.isInteger(x2))
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      return (0, leb128_1.slebEncode)(x2);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-4);
    }
    decodeValue(b2, t2) {
      this.checkType(t2);
      return (0, leb128_1.slebDecode)(b2);
    }
    get name() {
      return "int";
    }
    valueToString(x2) {
      return x2.toString();
    }
  }
  exports.IntClass = IntClass2;

  class NatClass2 extends PrimitiveType2 {
    accept(v, d) {
      return v.visitNat(this, d);
    }
    covariant(x2) {
      if (typeof x2 === "bigint" && x2 >= BigInt(0) || Number.isInteger(x2) && x2 >= 0)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      return (0, leb128_1.lebEncode)(x2);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-3);
    }
    decodeValue(b2, t2) {
      this.checkType(t2);
      return (0, leb128_1.lebDecode)(b2);
    }
    get name() {
      return "nat";
    }
    valueToString(x2) {
      return x2.toString();
    }
  }
  exports.NatClass = NatClass2;

  class FloatClass2 extends PrimitiveType2 {
    constructor(_bits) {
      super();
      this._bits = _bits;
      if (_bits !== 32 && _bits !== 64) {
        throw new Error("not a valid float type");
      }
    }
    accept(v, d) {
      return v.visitFloat(this, d);
    }
    covariant(x2) {
      if (typeof x2 === "number" || x2 instanceof Number)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      const buf = new ArrayBuffer(this._bits / 8);
      const view = new DataView(buf);
      if (this._bits === 32) {
        view.setFloat32(0, x2, true);
      } else {
        view.setFloat64(0, x2, true);
      }
      return buf;
    }
    encodeType() {
      const opcode = this._bits === 32 ? -13 : -14;
      return (0, leb128_1.slebEncode)(opcode);
    }
    decodeValue(b2, t2) {
      this.checkType(t2);
      const bytes = (0, leb128_1.safeRead)(b2, this._bits / 8);
      const view = new DataView(bytes);
      if (this._bits === 32) {
        return view.getFloat32(0, true);
      } else {
        return view.getFloat64(0, true);
      }
    }
    get name() {
      return "float" + this._bits;
    }
    valueToString(x2) {
      return x2.toString();
    }
  }
  exports.FloatClass = FloatClass2;

  class FixedIntClass2 extends PrimitiveType2 {
    constructor(_bits) {
      super();
      this._bits = _bits;
    }
    accept(v, d) {
      return v.visitFixedInt(this, d);
    }
    covariant(x2) {
      const min = (0, bigint_math_1.iexp2)(this._bits - 1) * BigInt(-1);
      const max = (0, bigint_math_1.iexp2)(this._bits - 1) - BigInt(1);
      let ok = false;
      if (typeof x2 === "bigint") {
        ok = x2 >= min && x2 <= max;
      } else if (Number.isInteger(x2)) {
        const v = BigInt(x2);
        ok = v >= min && v <= max;
      } else {
        ok = false;
      }
      if (ok)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      return (0, leb128_1.writeIntLE)(x2, this._bits / 8);
    }
    encodeType() {
      const offset = Math.log2(this._bits) - 3;
      return (0, leb128_1.slebEncode)(-9 - offset);
    }
    decodeValue(b2, t2) {
      this.checkType(t2);
      const num = (0, leb128_1.readIntLE)(b2, this._bits / 8);
      if (this._bits <= 32) {
        return Number(num);
      } else {
        return num;
      }
    }
    get name() {
      return `int${this._bits}`;
    }
    valueToString(x2) {
      return x2.toString();
    }
  }
  exports.FixedIntClass = FixedIntClass2;

  class FixedNatClass2 extends PrimitiveType2 {
    constructor(_bits) {
      super();
      this._bits = _bits;
    }
    accept(v, d) {
      return v.visitFixedNat(this, d);
    }
    covariant(x2) {
      const max = (0, bigint_math_1.iexp2)(this._bits);
      let ok = false;
      if (typeof x2 === "bigint" && x2 >= BigInt(0)) {
        ok = x2 < max;
      } else if (Number.isInteger(x2) && x2 >= 0) {
        const v = BigInt(x2);
        ok = v < max;
      } else {
        ok = false;
      }
      if (ok)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      return (0, leb128_1.writeUIntLE)(x2, this._bits / 8);
    }
    encodeType() {
      const offset = Math.log2(this._bits) - 3;
      return (0, leb128_1.slebEncode)(-5 - offset);
    }
    decodeValue(b2, t2) {
      this.checkType(t2);
      const num = (0, leb128_1.readUIntLE)(b2, this._bits / 8);
      if (this._bits <= 32) {
        return Number(num);
      } else {
        return num;
      }
    }
    get name() {
      return `nat${this._bits}`;
    }
    valueToString(x2) {
      return x2.toString();
    }
  }
  exports.FixedNatClass = FixedNatClass2;

  class VecClass2 extends ConstructType2 {
    constructor(_type) {
      super();
      this._type = _type;
      this._blobOptimization = false;
      if (_type instanceof FixedNatClass2 && _type._bits === 8) {
        this._blobOptimization = true;
      }
    }
    accept(v, d) {
      return v.visitVec(this, this._type, d);
    }
    covariant(x2) {
      const bits = this._type instanceof FixedNatClass2 ? this._type._bits : this._type instanceof FixedIntClass2 ? this._type._bits : 0;
      if (ArrayBuffer.isView(x2) && bits == x2.BYTES_PER_ELEMENT * 8 || Array.isArray(x2) && x2.every((v, idx) => {
        try {
          return this._type.covariant(v);
        } catch (e) {
          throw new Error(`Invalid ${this.display()} argument: \n\nindex ${idx} -> ${e.message}`);
        }
      }))
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      const len = (0, leb128_1.lebEncode)(x2.length);
      if (this._blobOptimization) {
        return (0, buffer_1.concat)(len, new Uint8Array(x2));
      }
      if (ArrayBuffer.isView(x2)) {
        return (0, buffer_1.concat)(len, new Uint8Array(x2.buffer));
      }
      const buf = new buffer_1.PipeArrayBuffer(new ArrayBuffer(len.byteLength + x2.length), 0);
      buf.write(len);
      for (const d of x2) {
        const encoded = this._type.encodeValue(d);
        buf.write(new Uint8Array(encoded));
      }
      return buf.buffer;
    }
    _buildTypeTableImpl(typeTable) {
      this._type.buildTypeTable(typeTable);
      const opCode = (0, leb128_1.slebEncode)(-19);
      const buffer17 = this._type.encodeType(typeTable);
      typeTable.add(this, (0, buffer_1.concat)(opCode, buffer17));
    }
    decodeValue(b2, t2) {
      const vec = this.checkType(t2);
      if (!(vec instanceof VecClass2)) {
        throw new Error("Not a vector type");
      }
      const len = Number((0, leb128_1.lebDecode)(b2));
      if (this._type instanceof FixedNatClass2) {
        if (this._type._bits == 8) {
          return new Uint8Array(b2.read(len));
        }
        if (this._type._bits == 16) {
          return new Uint16Array(b2.read(len * 2));
        }
        if (this._type._bits == 32) {
          return new Uint32Array(b2.read(len * 4));
        }
        if (this._type._bits == 64) {
          return new BigUint64Array(b2.read(len * 8));
        }
      }
      if (this._type instanceof FixedIntClass2) {
        if (this._type._bits == 8) {
          return new Int8Array(b2.read(len));
        }
        if (this._type._bits == 16) {
          return new Int16Array(b2.read(len * 2));
        }
        if (this._type._bits == 32) {
          return new Int32Array(b2.read(len * 4));
        }
        if (this._type._bits == 64) {
          return new BigInt64Array(b2.read(len * 8));
        }
      }
      const rets = [];
      for (let i = 0;i < len; i++) {
        rets.push(this._type.decodeValue(b2, vec._type));
      }
      return rets;
    }
    get name() {
      return `vec ${this._type.name}`;
    }
    display() {
      return `vec ${this._type.display()}`;
    }
    valueToString(x2) {
      const elements = x2.map((e) => this._type.valueToString(e));
      return "vec {" + elements.join("; ") + "}";
    }
  }
  exports.VecClass = VecClass2;

  class OptClass2 extends ConstructType2 {
    constructor(_type) {
      super();
      this._type = _type;
    }
    accept(v, d) {
      return v.visitOpt(this, this._type, d);
    }
    covariant(x2) {
      try {
        if (Array.isArray(x2) && (x2.length === 0 || x2.length === 1 && this._type.covariant(x2[0])))
          return true;
      } catch (e) {
        throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)} \n\n-> ${e.message}`);
      }
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      if (x2.length === 0) {
        return new Uint8Array([0]);
      } else {
        return (0, buffer_1.concat)(new Uint8Array([1]), this._type.encodeValue(x2[0]));
      }
    }
    _buildTypeTableImpl(typeTable) {
      this._type.buildTypeTable(typeTable);
      const opCode = (0, leb128_1.slebEncode)(-18);
      const buffer17 = this._type.encodeType(typeTable);
      typeTable.add(this, (0, buffer_1.concat)(opCode, buffer17));
    }
    decodeValue(b2, t2) {
      const opt = this.checkType(t2);
      if (!(opt instanceof OptClass2)) {
        throw new Error("Not an option type");
      }
      switch ((0, leb128_1.safeReadUint8)(b2)) {
        case 0:
          return [];
        case 1:
          return [this._type.decodeValue(b2, opt._type)];
        default:
          throw new Error("Not an option value");
      }
    }
    get name() {
      return `opt ${this._type.name}`;
    }
    display() {
      return `opt ${this._type.display()}`;
    }
    valueToString(x2) {
      if (x2.length === 0) {
        return "null";
      } else {
        return `opt ${this._type.valueToString(x2[0])}`;
      }
    }
  }
  exports.OptClass = OptClass2;

  class RecordClass2 extends ConstructType2 {
    constructor(fields = {}) {
      super();
      this._fields = Object.entries(fields).sort((a, b2) => (0, hash_1.idlLabelToId)(a[0]) - (0, hash_1.idlLabelToId)(b2[0]));
    }
    accept(v, d) {
      return v.visitRecord(this, this._fields, d);
    }
    tryAsTuple() {
      const res = [];
      for (let i = 0;i < this._fields.length; i++) {
        const [key, type] = this._fields[i];
        if (key !== `_${i}_`) {
          return null;
        }
        res.push(type);
      }
      return res;
    }
    covariant(x2) {
      if (typeof x2 === "object" && this._fields.every(([k2, t2]) => {
        if (!x2.hasOwnProperty(k2)) {
          throw new Error(`Record is missing key "${k2}".`);
        }
        try {
          return t2.covariant(x2[k2]);
        } catch (e) {
          throw new Error(`Invalid ${this.display()} argument: \n\nfield ${k2} -> ${e.message}`);
        }
      }))
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      const values = this._fields.map(([key]) => x2[key]);
      const bufs = zipWith2(this._fields, values, ([, c2], d) => c2.encodeValue(d));
      return (0, buffer_1.concat)(...bufs);
    }
    _buildTypeTableImpl(T2) {
      this._fields.forEach(([_2, value4]) => value4.buildTypeTable(T2));
      const opCode = (0, leb128_1.slebEncode)(-20);
      const len = (0, leb128_1.lebEncode)(this._fields.length);
      const fields = this._fields.map(([key, value4]) => (0, buffer_1.concat)((0, leb128_1.lebEncode)((0, hash_1.idlLabelToId)(key)), value4.encodeType(T2)));
      T2.add(this, (0, buffer_1.concat)(opCode, len, (0, buffer_1.concat)(...fields)));
    }
    decodeValue(b2, t2) {
      const record = this.checkType(t2);
      if (!(record instanceof RecordClass2)) {
        throw new Error("Not a record type");
      }
      const x2 = {};
      let expectedRecordIdx = 0;
      let actualRecordIdx = 0;
      while (actualRecordIdx < record._fields.length) {
        const [hash4, type] = record._fields[actualRecordIdx];
        if (expectedRecordIdx >= this._fields.length) {
          type.decodeValue(b2, type);
          actualRecordIdx++;
          continue;
        }
        const [expectKey, expectType] = this._fields[expectedRecordIdx];
        const expectedId = (0, hash_1.idlLabelToId)(this._fields[expectedRecordIdx][0]);
        const actualId = (0, hash_1.idlLabelToId)(hash4);
        if (expectedId === actualId) {
          x2[expectKey] = expectType.decodeValue(b2, type);
          expectedRecordIdx++;
          actualRecordIdx++;
        } else if (actualId > expectedId) {
          if (expectType instanceof OptClass2 || expectType instanceof ReservedClass2) {
            x2[expectKey] = [];
            expectedRecordIdx++;
          } else {
            throw new Error("Cannot find required field " + expectKey);
          }
        } else {
          type.decodeValue(b2, type);
          actualRecordIdx++;
        }
      }
      for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {
        if (expectType instanceof OptClass2 || expectType instanceof ReservedClass2) {
          x2[expectKey] = [];
        } else {
          throw new Error("Cannot find required field " + expectKey);
        }
      }
      return x2;
    }
    get name() {
      const fields = this._fields.map(([key, value4]) => key + ":" + value4.name);
      return `record {${fields.join("; ")}}`;
    }
    display() {
      const fields = this._fields.map(([key, value4]) => key + ":" + value4.display());
      return `record {${fields.join("; ")}}`;
    }
    valueToString(x2) {
      const values = this._fields.map(([key]) => x2[key]);
      const fields = zipWith2(this._fields, values, ([k2, c2], d) => k2 + "=" + c2.valueToString(d));
      return `record {${fields.join("; ")}}`;
    }
  }
  exports.RecordClass = RecordClass2;

  class TupleClass2 extends RecordClass2 {
    constructor(_components) {
      const x2 = {};
      _components.forEach((e, i) => x2["_" + i + "_"] = e);
      super(x2);
      this._components = _components;
    }
    accept(v, d) {
      return v.visitTuple(this, this._components, d);
    }
    covariant(x2) {
      if (Array.isArray(x2) && x2.length >= this._fields.length && this._components.every((t2, i) => {
        try {
          return t2.covariant(x2[i]);
        } catch (e) {
          throw new Error(`Invalid ${this.display()} argument: \n\nindex ${i} -> ${e.message}`);
        }
      }))
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      const bufs = zipWith2(this._components, x2, (c2, d) => c2.encodeValue(d));
      return (0, buffer_1.concat)(...bufs);
    }
    decodeValue(b2, t2) {
      const tuple = this.checkType(t2);
      if (!(tuple instanceof TupleClass2)) {
        throw new Error("not a tuple type");
      }
      if (tuple._components.length < this._components.length) {
        throw new Error("tuple mismatch");
      }
      const res = [];
      for (const [i, wireType] of tuple._components.entries()) {
        if (i >= this._components.length) {
          wireType.decodeValue(b2, wireType);
        } else {
          res.push(this._components[i].decodeValue(b2, wireType));
        }
      }
      return res;
    }
    display() {
      const fields = this._components.map((value4) => value4.display());
      return `record {${fields.join("; ")}}`;
    }
    valueToString(values) {
      const fields = zipWith2(this._components, values, (c2, d) => c2.valueToString(d));
      return `record {${fields.join("; ")}}`;
    }
  }
  exports.TupleClass = TupleClass2;

  class VariantClass2 extends ConstructType2 {
    constructor(fields = {}) {
      super();
      this._fields = Object.entries(fields).sort((a, b2) => (0, hash_1.idlLabelToId)(a[0]) - (0, hash_1.idlLabelToId)(b2[0]));
    }
    accept(v, d) {
      return v.visitVariant(this, this._fields, d);
    }
    covariant(x2) {
      if (typeof x2 === "object" && Object.entries(x2).length === 1 && this._fields.every(([k2, v]) => {
        try {
          return !x2.hasOwnProperty(k2) || v.covariant(x2[k2]);
        } catch (e) {
          throw new Error(`Invalid ${this.display()} argument: \n\nvariant ${k2} -> ${e.message}`);
        }
      }))
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      for (let i = 0;i < this._fields.length; i++) {
        const [name, type] = this._fields[i];
        if (x2.hasOwnProperty(name)) {
          const idx = (0, leb128_1.lebEncode)(i);
          const buf = type.encodeValue(x2[name]);
          return (0, buffer_1.concat)(idx, buf);
        }
      }
      throw Error("Variant has no data: " + x2);
    }
    _buildTypeTableImpl(typeTable) {
      this._fields.forEach(([, type]) => {
        type.buildTypeTable(typeTable);
      });
      const opCode = (0, leb128_1.slebEncode)(-21);
      const len = (0, leb128_1.lebEncode)(this._fields.length);
      const fields = this._fields.map(([key, value4]) => (0, buffer_1.concat)((0, leb128_1.lebEncode)((0, hash_1.idlLabelToId)(key)), value4.encodeType(typeTable)));
      typeTable.add(this, (0, buffer_1.concat)(opCode, len, ...fields));
    }
    decodeValue(b2, t2) {
      const variant = this.checkType(t2);
      if (!(variant instanceof VariantClass2)) {
        throw new Error("Not a variant type");
      }
      const idx = Number((0, leb128_1.lebDecode)(b2));
      if (idx >= variant._fields.length) {
        throw Error("Invalid variant index: " + idx);
      }
      const [wireHash, wireType] = variant._fields[idx];
      for (const [key, expectType] of this._fields) {
        if ((0, hash_1.idlLabelToId)(wireHash) === (0, hash_1.idlLabelToId)(key)) {
          const value4 = expectType.decodeValue(b2, wireType);
          return { [key]: value4 };
        }
      }
      throw new Error("Cannot find field hash " + wireHash);
    }
    get name() {
      const fields = this._fields.map(([key, type]) => key + ":" + type.name);
      return `variant {${fields.join("; ")}}`;
    }
    display() {
      const fields = this._fields.map(([key, type]) => key + (type.name === "null" ? "" : `:${type.display()}`));
      return `variant {${fields.join("; ")}}`;
    }
    valueToString(x2) {
      for (const [name, type] of this._fields) {
        if (x2.hasOwnProperty(name)) {
          const value4 = type.valueToString(x2[name]);
          if (value4 === "null") {
            return `variant {${name}}`;
          } else {
            return `variant {${name}=${value4}}`;
          }
        }
      }
      throw new Error("Variant has no data: " + x2);
    }
  }
  exports.VariantClass = VariantClass2;

  class RecClass2 extends ConstructType2 {
    constructor() {
      super(...arguments);
      this._id = RecClass2._counter++;
      this._type = undefined;
    }
    accept(v, d) {
      if (!this._type) {
        throw Error("Recursive type uninitialized.");
      }
      return v.visitRec(this, this._type, d);
    }
    fill(t2) {
      this._type = t2;
    }
    getType() {
      return this._type;
    }
    covariant(x2) {
      if (this._type ? this._type.covariant(x2) : false)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      if (!this._type) {
        throw Error("Recursive type uninitialized.");
      }
      return this._type.encodeValue(x2);
    }
    _buildTypeTableImpl(typeTable) {
      if (!this._type) {
        throw Error("Recursive type uninitialized.");
      }
      typeTable.add(this, new Uint8Array([]));
      this._type.buildTypeTable(typeTable);
      typeTable.merge(this, this._type.name);
    }
    decodeValue(b2, t2) {
      if (!this._type) {
        throw Error("Recursive type uninitialized.");
      }
      return this._type.decodeValue(b2, t2);
    }
    get name() {
      return `rec_${this._id}`;
    }
    display() {
      if (!this._type) {
        throw Error("Recursive type uninitialized.");
      }
      return `\u03BC${this.name}.${this._type.name}`;
    }
    valueToString(x2) {
      if (!this._type) {
        throw Error("Recursive type uninitialized.");
      }
      return this._type.valueToString(x2);
    }
  }
  exports.RecClass = RecClass2;
  RecClass2._counter = 0;

  class PrincipalClass2 extends PrimitiveType2 {
    accept(v, d) {
      return v.visitPrincipal(this, d);
    }
    covariant(x2) {
      if (x2 && x2._isPrincipal)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      const buf = x2.toUint8Array();
      const len = (0, leb128_1.lebEncode)(buf.byteLength);
      return (0, buffer_1.concat)(new Uint8Array([1]), len, buf);
    }
    encodeType() {
      return (0, leb128_1.slebEncode)(-24);
    }
    decodeValue(b2, t2) {
      this.checkType(t2);
      return decodePrincipalId2(b2);
    }
    get name() {
      return "principal";
    }
    valueToString(x2) {
      return `${this.name} "${x2.toText()}"`;
    }
  }
  exports.PrincipalClass = PrincipalClass2;

  class FuncClass2 extends ConstructType2 {
    constructor(argTypes, retTypes, annotations = []) {
      super();
      this.argTypes = argTypes;
      this.retTypes = retTypes;
      this.annotations = annotations;
    }
    static argsToString(types5, v) {
      if (types5.length !== v.length) {
        throw new Error("arity mismatch");
      }
      return "(" + types5.map((t2, i) => t2.valueToString(v[i])).join(", ") + ")";
    }
    accept(v, d) {
      return v.visitFunc(this, d);
    }
    covariant(x2) {
      if (Array.isArray(x2) && x2.length === 2 && x2[0] && x2[0]._isPrincipal && typeof x2[1] === "string")
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue([principal15, methodName]) {
      const buf = principal15.toUint8Array();
      const len = (0, leb128_1.lebEncode)(buf.byteLength);
      const canister = (0, buffer_1.concat)(new Uint8Array([1]), len, buf);
      const method = new TextEncoder().encode(methodName);
      const methodLen = (0, leb128_1.lebEncode)(method.byteLength);
      return (0, buffer_1.concat)(new Uint8Array([1]), canister, methodLen, method);
    }
    _buildTypeTableImpl(T2) {
      this.argTypes.forEach((arg) => arg.buildTypeTable(T2));
      this.retTypes.forEach((arg) => arg.buildTypeTable(T2));
      const opCode = (0, leb128_1.slebEncode)(-22);
      const argLen = (0, leb128_1.lebEncode)(this.argTypes.length);
      const args = (0, buffer_1.concat)(...this.argTypes.map((arg) => arg.encodeType(T2)));
      const retLen = (0, leb128_1.lebEncode)(this.retTypes.length);
      const rets = (0, buffer_1.concat)(...this.retTypes.map((arg) => arg.encodeType(T2)));
      const annLen = (0, leb128_1.lebEncode)(this.annotations.length);
      const anns = (0, buffer_1.concat)(...this.annotations.map((a) => this.encodeAnnotation(a)));
      T2.add(this, (0, buffer_1.concat)(opCode, argLen, args, retLen, rets, annLen, anns));
    }
    decodeValue(b2) {
      const x2 = (0, leb128_1.safeReadUint8)(b2);
      if (x2 !== 1) {
        throw new Error("Cannot decode function reference");
      }
      const canister = decodePrincipalId2(b2);
      const mLen = Number((0, leb128_1.lebDecode)(b2));
      const buf = (0, leb128_1.safeRead)(b2, mLen);
      const decoder = new TextDecoder("utf8", { fatal: true });
      const method = decoder.decode(buf);
      return [canister, method];
    }
    get name() {
      const args = this.argTypes.map((arg) => arg.name).join(", ");
      const rets = this.retTypes.map((arg) => arg.name).join(", ");
      const annon = " " + this.annotations.join(" ");
      return `(${args}) -> (${rets})${annon}`;
    }
    valueToString([principal15, str]) {
      return `func "${principal15.toText()}".${str}`;
    }
    display() {
      const args = this.argTypes.map((arg) => arg.display()).join(", ");
      const rets = this.retTypes.map((arg) => arg.display()).join(", ");
      const annon = " " + this.annotations.join(" ");
      return `(${args}) \u2192 (${rets})${annon}`;
    }
    encodeAnnotation(ann) {
      if (ann === "query") {
        return new Uint8Array([1]);
      } else if (ann === "oneway") {
        return new Uint8Array([2]);
      } else if (ann === "composite_query") {
        return new Uint8Array([3]);
      } else {
        throw new Error("Illegal function annotation");
      }
    }
  }
  exports.FuncClass = FuncClass2;

  class ServiceClass2 extends ConstructType2 {
    constructor(fields) {
      super();
      this._fields = Object.entries(fields).sort((a, b2) => (0, hash_1.idlLabelToId)(a[0]) - (0, hash_1.idlLabelToId)(b2[0]));
    }
    accept(v, d) {
      return v.visitService(this, d);
    }
    covariant(x2) {
      if (x2 && x2._isPrincipal)
        return true;
      throw new Error(`Invalid ${this.display()} argument: ${toReadableString2(x2)}`);
    }
    encodeValue(x2) {
      const buf = x2.toUint8Array();
      const len = (0, leb128_1.lebEncode)(buf.length);
      return (0, buffer_1.concat)(new Uint8Array([1]), len, buf);
    }
    _buildTypeTableImpl(T2) {
      this._fields.forEach(([_2, func]) => func.buildTypeTable(T2));
      const opCode = (0, leb128_1.slebEncode)(-23);
      const len = (0, leb128_1.lebEncode)(this._fields.length);
      const meths = this._fields.map(([label, func]) => {
        const labelBuf = new TextEncoder().encode(label);
        const labelLen = (0, leb128_1.lebEncode)(labelBuf.length);
        return (0, buffer_1.concat)(labelLen, labelBuf, func.encodeType(T2));
      });
      T2.add(this, (0, buffer_1.concat)(opCode, len, ...meths));
    }
    decodeValue(b2) {
      return decodePrincipalId2(b2);
    }
    get name() {
      const fields = this._fields.map(([key, value4]) => key + ":" + value4.name);
      return `service {${fields.join("; ")}}`;
    }
    valueToString(x2) {
      return `service "${x2.toText()}"`;
    }
  }
  exports.ServiceClass = ServiceClass2;
  exports.encode = encode4;
  exports.decode = decode5;
  exports.Empty = new EmptyClass2;
  exports.Reserved = new ReservedClass2;
  exports.Unknown = new UnknownClass2;
  exports.Bool = new BoolClass2;
  exports.Null = new NullClass2;
  exports.Text = new TextClass2;
  exports.Int = new IntClass2;
  exports.Nat = new NatClass2;
  exports.Float32 = new FloatClass2(32);
  exports.Float64 = new FloatClass2(64);
  exports.Int8 = new FixedIntClass2(8);
  exports.Int16 = new FixedIntClass2(16);
  exports.Int32 = new FixedIntClass2(32);
  exports.Int64 = new FixedIntClass2(64);
  exports.Nat8 = new FixedNatClass2(8);
  exports.Nat16 = new FixedNatClass2(16);
  exports.Nat32 = new FixedNatClass2(32);
  exports.Nat64 = new FixedNatClass2(64);
  exports.Principal = new PrincipalClass2;
  exports.Tuple = Tuple2;
  exports.Vec = Vec2;
  exports.Opt = Opt2;
  exports.Record = Record2;
  exports.Variant = Variant2;
  exports.Rec = Rec2;
  exports.Func = Func2;
  exports.Service = Service2;
});

// node_modules/@dfinity/candid/lib/cjs/candid-core.js
var require_candid_core = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VecForm = exports.OptionForm = exports.VariantForm = exports.TupleForm = exports.RecordForm = exports.InputForm = exports.InputBox = undefined;

  class InputBox2 {
    constructor(idl, ui) {
      this.idl = idl;
      this.ui = ui;
      this.label = null;
      this.value = undefined;
      const status = document.createElement("span");
      status.className = "status";
      this.status = status;
      if (ui.input) {
        ui.input.addEventListener("blur", () => {
          if (ui.input.value === "") {
            return;
          }
          this.parse();
        });
        ui.input.addEventListener("input", () => {
          status.style.display = "none";
          ui.input.classList.remove("reject");
        });
      }
    }
    isRejected() {
      return this.value === undefined;
    }
    parse(config = {}) {
      if (this.ui.form) {
        const value4 = this.ui.form.parse(config);
        this.value = value4;
        return value4;
      }
      if (this.ui.input) {
        const input = this.ui.input;
        try {
          const value4 = this.ui.parse(this.idl, config, input.value);
          if (!this.idl.covariant(value4)) {
            throw new Error(`${input.value} is not of type ${this.idl.display()}`);
          }
          this.status.style.display = "none";
          this.value = value4;
          return value4;
        } catch (err) {
          input.classList.add("reject");
          this.status.style.display = "block";
          this.status.innerHTML = "InputError: " + err.message;
          this.value = undefined;
          return;
        }
      }
      return null;
    }
    render(dom) {
      const container = document.createElement("span");
      if (this.label) {
        const label = document.createElement("label");
        label.innerText = this.label;
        container.appendChild(label);
      }
      if (this.ui.input) {
        container.appendChild(this.ui.input);
        container.appendChild(this.status);
      }
      if (this.ui.form) {
        this.ui.form.render(container);
      }
      dom.appendChild(container);
    }
  }
  exports.InputBox = InputBox2;

  class InputForm {
    constructor(ui) {
      this.ui = ui;
      this.form = [];
    }
    renderForm(dom) {
      if (this.ui.container) {
        this.form.forEach((e) => e.render(this.ui.container));
        dom.appendChild(this.ui.container);
      } else {
        this.form.forEach((e) => e.render(dom));
      }
    }
    render(dom) {
      if (this.ui.open && this.ui.event) {
        dom.appendChild(this.ui.open);
        const form = this;
        form.ui.open.addEventListener(form.ui.event, () => {
          if (form.ui.container) {
            form.ui.container.innerHTML = "";
          } else {
            const oldContainer = form.ui.open.nextElementSibling;
            if (oldContainer) {
              oldContainer.parentNode.removeChild(oldContainer);
            }
          }
          form.generateForm();
          form.renderForm(dom);
        });
      } else {
        this.generateForm();
        this.renderForm(dom);
      }
    }
  }
  exports.InputForm = InputForm;

  class RecordForm2 extends InputForm {
    constructor(fields, ui) {
      super(ui);
      this.fields = fields;
      this.ui = ui;
    }
    generateForm() {
      this.form = this.fields.map(([key, type]) => {
        const input = this.ui.render(type);
        if (this.ui.labelMap && this.ui.labelMap.hasOwnProperty(key)) {
          input.label = this.ui.labelMap[key] + " ";
        } else {
          input.label = key + " ";
        }
        return input;
      });
    }
    parse(config) {
      const v = {};
      this.fields.forEach(([key, _2], i) => {
        const value4 = this.form[i].parse(config);
        v[key] = value4;
      });
      if (this.form.some((input) => input.isRejected())) {
        return;
      }
      return v;
    }
  }
  exports.RecordForm = RecordForm2;

  class TupleForm2 extends InputForm {
    constructor(components, ui) {
      super(ui);
      this.components = components;
      this.ui = ui;
    }
    generateForm() {
      this.form = this.components.map((type) => {
        const input = this.ui.render(type);
        return input;
      });
    }
    parse(config) {
      const v = [];
      this.components.forEach((_2, i) => {
        const value4 = this.form[i].parse(config);
        v.push(value4);
      });
      if (this.form.some((input) => input.isRejected())) {
        return;
      }
      return v;
    }
  }
  exports.TupleForm = TupleForm2;

  class VariantForm2 extends InputForm {
    constructor(fields, ui) {
      super(ui);
      this.fields = fields;
      this.ui = ui;
    }
    generateForm() {
      const index = this.ui.open.selectedIndex;
      const [_2, type] = this.fields[index];
      const variant = this.ui.render(type);
      this.form = [variant];
    }
    parse(config) {
      const select = this.ui.open;
      const selected = select.options[select.selectedIndex].value;
      const value4 = this.form[0].parse(config);
      if (value4 === undefined) {
        return;
      }
      const v = {};
      v[selected] = value4;
      return v;
    }
  }
  exports.VariantForm = VariantForm2;

  class OptionForm2 extends InputForm {
    constructor(ty, ui) {
      super(ui);
      this.ty = ty;
      this.ui = ui;
    }
    generateForm() {
      if (this.ui.open.checked) {
        const opt = this.ui.render(this.ty);
        this.form = [opt];
      } else {
        this.form = [];
      }
    }
    parse(config) {
      if (this.form.length === 0) {
        return [];
      } else {
        const value4 = this.form[0].parse(config);
        if (value4 === undefined) {
          return;
        }
        return [value4];
      }
    }
  }
  exports.OptionForm = OptionForm2;

  class VecForm2 extends InputForm {
    constructor(ty, ui) {
      super(ui);
      this.ty = ty;
      this.ui = ui;
    }
    generateForm() {
      const len = +this.ui.open.value;
      this.form = [];
      for (let i = 0;i < len; i++) {
        const t2 = this.ui.render(this.ty);
        this.form.push(t2);
      }
    }
    parse(config) {
      const value4 = this.form.map((input) => {
        return input.parse(config);
      });
      if (this.form.some((input) => input.isRejected())) {
        return;
      }
      return value4;
    }
  }
  exports.VecForm = VecForm2;
});

// node_modules/@dfinity/candid/lib/cjs/candid-ui.js
var require_candid_ui = __commonJS((exports) => {
  var parsePrimitive = function(t2, config, d) {
    if (config.random && d === "") {
      return t2.accept(new Random, d);
    } else {
      return t2.accept(new Parse, d);
    }
  };
  var renderInput = function(t2) {
    return t2.accept(new Render, null);
  };
  var renderValue = function(t2, input, value4) {
    return t2.accept(new RenderValue, { input, value: value4 });
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.renderValue = exports.renderInput = exports.Render = exports.vecForm = exports.optForm = exports.variantForm = exports.tupleForm = exports.recordForm = exports.inputBox = undefined;
  var IDL = __importStar(require_idl());
  var principal_1 = require_cjs2();
  var UI = __importStar(require_candid_core());
  var InputConfig = { parse: parsePrimitive };
  var FormConfig = { render: renderInput };
  var inputBox = (t2, config) => {
    return new UI.InputBox(t2, Object.assign(Object.assign({}, InputConfig), config));
  };
  exports.inputBox = inputBox;
  var recordForm = (fields, config) => {
    return new UI.RecordForm(fields, Object.assign(Object.assign({}, FormConfig), config));
  };
  exports.recordForm = recordForm;
  var tupleForm = (components, config) => {
    return new UI.TupleForm(components, Object.assign(Object.assign({}, FormConfig), config));
  };
  exports.tupleForm = tupleForm;
  var variantForm = (fields, config) => {
    return new UI.VariantForm(fields, Object.assign(Object.assign({}, FormConfig), config));
  };
  exports.variantForm = variantForm;
  var optForm = (ty, config) => {
    return new UI.OptionForm(ty, Object.assign(Object.assign({}, FormConfig), config));
  };
  exports.optForm = optForm;
  var vecForm = (ty, config) => {
    return new UI.VecForm(ty, Object.assign(Object.assign({}, FormConfig), config));
  };
  exports.vecForm = vecForm;

  class Render extends IDL.Visitor {
    visitType(t2, d) {
      const input = document.createElement("input");
      input.classList.add("argument");
      input.placeholder = t2.display();
      return (0, exports.inputBox)(t2, { input });
    }
    visitNull(t2, d) {
      return (0, exports.inputBox)(t2, {});
    }
    visitRecord(t2, fields, d) {
      let config = {};
      if (fields.length > 1) {
        const container = document.createElement("div");
        container.classList.add("popup-form");
        config = { container };
      }
      const form = (0, exports.recordForm)(fields, config);
      return (0, exports.inputBox)(t2, { form });
    }
    visitTuple(t2, components, d) {
      let config = {};
      if (components.length > 1) {
        const container = document.createElement("div");
        container.classList.add("popup-form");
        config = { container };
      }
      const form = (0, exports.tupleForm)(components, config);
      return (0, exports.inputBox)(t2, { form });
    }
    visitVariant(t2, fields, d) {
      const select = document.createElement("select");
      for (const [key, type] of fields) {
        const option = new Option(key);
        select.add(option);
      }
      select.selectedIndex = -1;
      select.classList.add("open");
      const config = { open: select, event: "change" };
      const form = (0, exports.variantForm)(fields, config);
      return (0, exports.inputBox)(t2, { form });
    }
    visitOpt(t2, ty, d) {
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.classList.add("open");
      const form = (0, exports.optForm)(ty, { open: checkbox, event: "change" });
      return (0, exports.inputBox)(t2, { form });
    }
    visitVec(t2, ty, d) {
      const len = document.createElement("input");
      len.type = "number";
      len.min = "0";
      len.max = "100";
      len.style.width = "8rem";
      len.placeholder = "len";
      len.classList.add("open");
      const container = document.createElement("div");
      container.classList.add("popup-form");
      const form = (0, exports.vecForm)(ty, { open: len, event: "change", container });
      return (0, exports.inputBox)(t2, { form });
    }
    visitRec(t2, ty, d) {
      return renderInput(ty);
    }
  }
  exports.Render = Render;

  class Parse extends IDL.Visitor {
    visitNull(t2, v) {
      return null;
    }
    visitBool(t2, v) {
      if (v === "true") {
        return true;
      }
      if (v === "false") {
        return false;
      }
      throw new Error(`Cannot parse ${v} as boolean`);
    }
    visitText(t2, v) {
      return v;
    }
    visitFloat(t2, v) {
      return parseFloat(v);
    }
    visitFixedInt(t2, v) {
      if (t2._bits <= 32) {
        return parseInt(v, 10);
      } else {
        return BigInt(v);
      }
    }
    visitFixedNat(t2, v) {
      if (t2._bits <= 32) {
        return parseInt(v, 10);
      } else {
        return BigInt(v);
      }
    }
    visitNumber(t2, v) {
      return BigInt(v);
    }
    visitPrincipal(t2, v) {
      return principal_1.Principal.fromText(v);
    }
    visitService(t2, v) {
      return principal_1.Principal.fromText(v);
    }
    visitFunc(t2, v) {
      const x2 = v.split(".", 2);
      return [principal_1.Principal.fromText(x2[0]), x2[1]];
    }
  }

  class Random extends IDL.Visitor {
    visitNull(t2, v) {
      return null;
    }
    visitBool(t2, v) {
      return Math.random() < 0.5;
    }
    visitText(t2, v) {
      return Math.random().toString(36).substring(6);
    }
    visitFloat(t2, v) {
      return Math.random();
    }
    visitInt(t2, v) {
      return BigInt(this.generateNumber(true));
    }
    visitNat(t2, v) {
      return BigInt(this.generateNumber(false));
    }
    visitFixedInt(t2, v) {
      const x2 = this.generateNumber(true);
      if (t2._bits <= 32) {
        return x2;
      } else {
        return BigInt(v);
      }
    }
    visitFixedNat(t2, v) {
      const x2 = this.generateNumber(false);
      if (t2._bits <= 32) {
        return x2;
      } else {
        return BigInt(v);
      }
    }
    generateNumber(signed) {
      const num = Math.floor(Math.random() * 100);
      if (signed && Math.random() < 0.5) {
        return -num;
      } else {
        return num;
      }
    }
  }
  exports.renderInput = renderInput;
  exports.renderValue = renderValue;

  class RenderValue extends IDL.Visitor {
    visitType(t2, d) {
      d.input.ui.input.value = t2.valueToString(d.value);
    }
    visitNull(t2, d) {
    }
    visitText(t2, d) {
      d.input.ui.input.value = d.value;
    }
    visitRec(t2, ty, d) {
      renderValue(ty, d.input, d.value);
    }
    visitOpt(t2, ty, d) {
      if (d.value.length === 0) {
        return;
      } else {
        const form = d.input.ui.form;
        const open = form.ui.open;
        open.checked = true;
        open.dispatchEvent(new Event(form.ui.event));
        renderValue(ty, form.form[0], d.value[0]);
      }
    }
    visitRecord(t2, fields, d) {
      const form = d.input.ui.form;
      fields.forEach(([key, type], i) => {
        renderValue(type, form.form[i], d.value[key]);
      });
    }
    visitTuple(t2, components, d) {
      const form = d.input.ui.form;
      components.forEach((type, i) => {
        renderValue(type, form.form[i], d.value[i]);
      });
    }
    visitVariant(t2, fields, d) {
      const form = d.input.ui.form;
      const selected = Object.entries(d.value)[0];
      fields.forEach(([key, type], i) => {
        if (key === selected[0]) {
          const open = form.ui.open;
          open.selectedIndex = i;
          open.dispatchEvent(new Event(form.ui.event));
          renderValue(type, form.form[0], selected[1]);
        }
      });
    }
    visitVec(t2, ty, d) {
      const form = d.input.ui.form;
      const len = d.value.length;
      const open = form.ui.open;
      open.value = len;
      open.dispatchEvent(new Event(form.ui.event));
      d.value.forEach((v, i) => {
        renderValue(ty, form.form[i], v);
      });
    }
  }
});

// node_modules/@dfinity/candid/lib/cjs/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@dfinity/candid/lib/cjs/index.js
var require_cjs3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IDL = undefined;
  __exportStar(require_candid_ui(), exports);
  __exportStar(require_candid_core(), exports);
  exports.IDL = __importStar(require_idl());
  __exportStar(require_hash(), exports);
  __exportStar(require_leb128(), exports);
  __exportStar(require_buffer2(), exports);
  __exportStar(require_types2(), exports);
});

// node_modules/@dfinity/agent/lib/cjs/utils/buffer.js
var require_buffer3 = __commonJS((exports) => {
  var concat4 = function(...buffers) {
    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));
    let index = 0;
    for (const b2 of buffers) {
      result.set(new Uint8Array(b2), index);
      index += b2.byteLength;
    }
    return result.buffer;
  };
  var toHex2 = function(buffer17) {
    return [...new Uint8Array(buffer17)].map((x2) => x2.toString(16).padStart(2, "0")).join("");
  };
  var fromHex2 = function(hex) {
    if (!hexRe2.test(hex)) {
      throw new Error("Invalid hexadecimal string.");
    }
    const buffer17 = [...hex].reduce((acc, curr, i) => {
      acc[i / 2 | 0] = (acc[i / 2 | 0] || "") + curr;
      return acc;
    }, []).map((x2) => Number.parseInt(x2, 16));
    return new Uint8Array(buffer17).buffer;
  };
  var compare4 = function(b1, b2) {
    if (b1.byteLength !== b2.byteLength) {
      return b1.byteLength - b2.byteLength;
    }
    const u1 = new Uint8Array(b1);
    const u2 = new Uint8Array(b2);
    for (let i = 0;i < u1.length; i++) {
      if (u1[i] !== u2[i]) {
        return u1[i] - u2[i];
      }
    }
    return 0;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compare = exports.fromHex = exports.toHex = exports.concat = undefined;
  exports.concat = concat4;
  exports.toHex = toHex2;
  var hexRe2 = new RegExp(/^([0-9A-F]{2})*$/i);
  exports.fromHex = fromHex2;
  exports.compare = compare4;
});

// node_modules/@dfinity/agent/lib/cjs/request_id.js
var require_request_id = __commonJS((exports) => {
  var hash4 = function(data) {
    return js_sha256_1.sha256.create().update(new Uint8Array(data)).arrayBuffer();
  };
  var hashValue2 = function(value4) {
    if (value4 instanceof borc_1.default.Tagged) {
      return hashValue2(value4.value);
    } else if (typeof value4 === "string") {
      return hashString2(value4);
    } else if (typeof value4 === "number") {
      return hash4((0, candid_1.lebEncode)(value4));
    } else if (value4 instanceof ArrayBuffer || ArrayBuffer.isView(value4)) {
      return hash4(value4);
    } else if (Array.isArray(value4)) {
      const vals = value4.map(hashValue2);
      return hash4((0, buffer_1.concat)(...vals));
    } else if (value4 && typeof value4 === "object" && value4._isPrincipal) {
      return hash4(value4.toUint8Array());
    } else if (typeof value4 === "object" && value4 !== null && typeof value4.toHash === "function") {
      return hashValue2(value4.toHash());
    } else if (typeof value4 === "bigint") {
      return hash4((0, candid_1.lebEncode)(value4));
    }
    throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value4}`), {
      value: value4
    });
  };
  var requestIdOf2 = function(request2) {
    const hashed = Object.entries(request2).filter(([, value4]) => value4 !== undefined).map(([key, value4]) => {
      const hashedKey = hashString2(key);
      const hashedValue = hashValue2(value4);
      return [hashedKey, hashedValue];
    });
    const traversed = hashed;
    const sorted = traversed.sort(([k1], [k2]) => {
      return (0, buffer_1.compare)(k1, k2);
    });
    const concatenated = (0, buffer_1.concat)(...sorted.map((x2) => (0, buffer_1.concat)(...x2)));
    const requestId = hash4(concatenated);
    return requestId;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.requestIdOf = exports.hashValue = exports.hash = undefined;
  var candid_1 = require_cjs3();
  var borc_1 = __importDefault(require_src());
  var js_sha256_1 = require_sha256();
  var buffer_1 = require_buffer3();
  exports.hash = hash4;
  exports.hashValue = hashValue2;
  var hashString2 = (value4) => {
    const encoded = new TextEncoder().encode(value4);
    return hash4(encoded);
  };
  exports.requestIdOf = requestIdOf2;
});

// node_modules/@dfinity/agent/lib/cjs/auth.js
var require_auth = __commonJS((exports) => {
  var createIdentityDescriptor = function(identity2) {
    const identityIndicator = "getPublicKey" in identity2 ? { type: "PublicKeyIdentity", publicKey: (0, buffer_1.toHex)(identity2.getPublicKey().toDer()) } : { type: "AnonymousIdentity" };
    return identityIndicator;
  };
  var __rest2 = exports && exports.__rest || function(s2, e) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s2);i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
          t2[p[i]] = s2[p[i]];
      }
    return t2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createIdentityDescriptor = exports.AnonymousIdentity = exports.SignIdentity = undefined;
  var principal_1 = require_cjs2();
  var request_id_1 = require_request_id();
  var buffer_1 = require_buffer3();
  var domainSeparator3 = new TextEncoder().encode(`
ic-request`);

  class SignIdentity2 {
    getPrincipal() {
      if (!this._principal) {
        this._principal = principal_1.Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));
      }
      return this._principal;
    }
    async transformRequest(request2) {
      const { body } = request2, fields = __rest2(request2, ["body"]);
      const requestId = await (0, request_id_1.requestIdOf)(body);
      return Object.assign(Object.assign({}, fields), { body: {
        content: body,
        sender_pubkey: this.getPublicKey().toDer(),
        sender_sig: await this.sign((0, buffer_1.concat)(domainSeparator3, requestId))
      } });
    }
  }
  exports.SignIdentity = SignIdentity2;

  class AnonymousIdentity2 {
    getPrincipal() {
      return principal_1.Principal.anonymous();
    }
    async transformRequest(request2) {
      return Object.assign(Object.assign({}, request2), { body: { content: request2.body } });
    }
  }
  exports.AnonymousIdentity = AnonymousIdentity2;
  exports.createIdentityDescriptor = createIdentityDescriptor;
});

// node_modules/@dfinity/agent/lib/cjs/cbor.js
var require_cbor = __commonJS((exports) => {
  var encode4 = function(value4) {
    return serializer2.serialize(value4);
  };
  var decodePositiveBigInt2 = function(buf) {
    const len = buf.byteLength;
    let res = BigInt(0);
    for (let i = 0;i < len; i++) {
      res = res * BigInt(256) + BigInt(buf[i]);
    }
    return res;
  };
  var decode5 = function(input) {
    const buffer17 = new Uint8Array(input);
    const decoder = new Uint8ArrayDecoder2({
      size: buffer17.byteLength,
      tags: {
        2: (val) => decodePositiveBigInt2(val),
        3: (val) => -decodePositiveBigInt2(val),
        [CborTag2.Semantic]: (value4) => value4
      }
    });
    return decoder.decodeFirst(buffer17);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decode = exports.encode = exports.CborTag = undefined;
  var borc_1 = __importDefault(require_src());
  var cbor4 = __importStar(require_src2());
  var simple_cbor_1 = require_src2();
  var buffer_1 = require_buffer3();

  class PrincipalEncoder2 {
    get name() {
      return "Principal";
    }
    get priority() {
      return 0;
    }
    match(value4) {
      return value4 && value4._isPrincipal === true;
    }
    encode(v) {
      return cbor4.value.bytes(v.toUint8Array());
    }
  }

  class BufferEncoder2 {
    get name() {
      return "Buffer";
    }
    get priority() {
      return 1;
    }
    match(value4) {
      return value4 instanceof ArrayBuffer || ArrayBuffer.isView(value4);
    }
    encode(v) {
      return cbor4.value.bytes(new Uint8Array(v));
    }
  }

  class BigIntEncoder2 {
    get name() {
      return "BigInt";
    }
    get priority() {
      return 1;
    }
    match(value4) {
      return typeof value4 === `bigint`;
    }
    encode(v) {
      if (v > BigInt(0)) {
        return cbor4.value.tagged(2, cbor4.value.bytes((0, buffer_1.fromHex)(v.toString(16))));
      } else {
        return cbor4.value.tagged(3, cbor4.value.bytes((0, buffer_1.fromHex)((BigInt("-1") * v).toString(16))));
      }
    }
  }
  var serializer2 = simple_cbor_1.SelfDescribeCborSerializer.withDefaultEncoders(true);
  serializer2.addEncoder(new PrincipalEncoder2);
  serializer2.addEncoder(new BufferEncoder2);
  serializer2.addEncoder(new BigIntEncoder2);
  var CborTag2;
  (function(CborTag3) {
    CborTag3[CborTag3["Uint64LittleEndian"] = 71] = "Uint64LittleEndian";
    CborTag3[CborTag3["Semantic"] = 55799] = "Semantic";
  })(CborTag2 = exports.CborTag || (exports.CborTag = {}));
  exports.encode = encode4;

  class Uint8ArrayDecoder2 extends borc_1.default.Decoder {
    createByteString(raw) {
      return (0, buffer_1.concat)(...raw);
    }
    createByteStringFromHeap(start, end) {
      if (start === end) {
        return new ArrayBuffer(0);
      }
      return new Uint8Array(this._heap.slice(start, end));
    }
  }
  exports.decode = decode5;
});

// node_modules/@dfinity/agent/lib/cjs/agent/http/types.js
var require_types3 = __commonJS((exports) => {
  var makeNonce2 = function() {
    const buffer17 = new ArrayBuffer(16);
    const view = new DataView(buffer17);
    const now = BigInt(+Date.now());
    const randHi = Math.floor(Math.random() * 4294967295);
    const randLo = Math.floor(Math.random() * 4294967295);
    if (typeof view.setBigUint64 === "function") {
      view.setBigUint64(0, now);
    } else {
      const TWO_TO_THE_32 = BigInt(1) << BigInt(32);
      view.setUint32(0, Number(now >> BigInt(32)));
      view.setUint32(4, Number(now % TWO_TO_THE_32));
    }
    view.setUint32(8, randHi);
    view.setUint32(12, randLo);
    return buffer17;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeNonce = exports.SubmitRequestType = undefined;
  var SubmitRequestType2;
  (function(SubmitRequestType3) {
    SubmitRequestType3["Call"] = "call";
  })(SubmitRequestType2 = exports.SubmitRequestType || (exports.SubmitRequestType = {}));
  exports.makeNonce = makeNonce2;
});

// node_modules/@dfinity/agent/lib/cjs/agent/http/transforms.js
var require_transforms = __commonJS((exports) => {
  var makeNonceTransform2 = function(nonceFn = types_1.makeNonce) {
    return async (request2) => {
      const nonce = nonceFn();
      const headers = request2.request.headers;
      request2.request.headers = headers;
      if (request2.endpoint === "call") {
        request2.body.nonce = nonceFn();
      }
    };
  };
  var makeExpiryTransform = function(delayInMilliseconds) {
    return async (request2) => {
      request2.body.ingress_expiry = new Expiry2(delayInMilliseconds);
    };
  };
  var httpHeadersTransform2 = function(headers) {
    const headerFields = [];
    headers.forEach((value4, key) => {
      headerFields.push([key, value4]);
    });
    return headerFields;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.httpHeadersTransform = exports.makeExpiryTransform = exports.makeNonceTransform = exports.Expiry = undefined;
  var candid_1 = require_cjs3();
  var cbor4 = __importStar(require_src2());
  var types_1 = require_types3();
  var NANOSECONDS_PER_MILLISECONDS2 = BigInt(1e6);
  var REPLICA_PERMITTED_DRIFT_MILLISECONDS2 = BigInt(60 * 1000);

  class Expiry2 {
    constructor(deltaInMSec) {
      this._value = (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS2) * NANOSECONDS_PER_MILLISECONDS2;
    }
    toCBOR() {
      return cbor4.value.u64(this._value.toString(16), 16);
    }
    toHash() {
      return (0, candid_1.lebEncode)(this._value);
    }
  }
  exports.Expiry = Expiry2;
  exports.makeNonceTransform = makeNonceTransform2;
  exports.makeExpiryTransform = makeExpiryTransform;
  exports.httpHeadersTransform = httpHeadersTransform2;
});

// node_modules/@dfinity/agent/lib/cjs/agent/http/errors.js
var require_errors2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AgentHTTPResponseError = undefined;

  class AgentHTTPResponseError2 extends Error {
    constructor(message, response) {
      super(message);
      this.response = response;
      this.name = this.constructor.name;
      Object.setPrototypeOf(this, new.target.prototype);
    }
  }
  exports.AgentHTTPResponseError = AgentHTTPResponseError2;
});

// node_modules/@dfinity/agent/lib/cjs/vendor/bls/wasm.js
var require_wasm = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wasmBytesBase64 = undefined;
  exports.wasmBytesBase64 = `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akE4ENABGiACQbgDakEBNgIAIAJBwANqQTgQ0AEaIAJB+ANqQQE2AgAgAkGABGpBOBDQARogAkEBNgK4BCACQcAEakE4ENABGiACQfgEakEBNgIAIAJBgAVqQTgQ0AEaIAJBuAVqQQE2AgAgAkHABWpBOBDQARogAkH4BWpBATYCACACQYAGakE4ENABGiACQQE2ArgGIAJBwAZqQTgQ0AEaIAJB+AZqQQE2AgAgAkGAB2pBOBDQARogAkG4B2pBATYCACACQcAHakE4ENABGiACQfgHakEBNgIAIAIgARAYAkAgASgCgAZBBEYNACAAKAKABkEERg0AIAJBgARqIgMgAEGAAmoQlgEgAyABQYACahAYDAYLIAJBwAxqIgdBOBDQARogAkEBNgL4DCACQYANakE4ENABGiACQbgNakEBNgIAIAJBgAhqIgRBOBDQARogAkEBNgK4CCACQcAIakE4ENABGiACQfgIakEBNgIAIAJBgApqIgMgAEGAA2oiBRBeIAQgAxCZASADIAFBgANqIgYQXiAEIAMQESAHELYBIAEoAoAGQQRHDQMMBAsgACABEAMMBgsgAkHADGoiAyABQYAFahBeIAJBgAxqIgQgA0HAABDRARogAkGABmogBBCnAQsgAkGABmoQZCACQYAIaiIDIAIQlgEgAxArIAJBgAJqIgQgAxCXASAGIAQQlgEgAkGABGoiByADEJYBIAMgABCWASADIAUQlwEgAxCwASACQYAKaiIEIAEQlgEgBCABQYAEahCXASAEELABIAMgBBAYIAcgAxCXASADIAUQlgECQCABKAKABkECRwRAIAJBwAxqIgMgAUGABWoQXiACQYAIaiADEKYBDAELIAJBwAxqIgMgAUGABWoQXiACQYAMaiIBIANBwAAQ0QEaIAJBgAhqIAEQpwELIAJBgAhqIgEQZCACQYAKaiIDIAEQlgEgAxArIAUgAkGABGoQlgEgBSADEJcBIAJBgAZqIgQgAxCXASABEGQgBiABEJcBIAQQsAEgBBBkIAAgAhCWASAAIAQQlwEMAwsgAkGACmoiAyAFEF4gAkHADGoiBCADEJkBIAMgAUGAAmoQXiAEIAMQEQsgACgCgAZBBEcEQCACQYAKaiIDIABBgAJqEF4gAkHADGoiBCADEJkBIAMgBhBeIAQgAxARCyACQYAEaiIDIAJB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AEHcu8AAKAIAQX4gA0EDdndxNgIACyAAIAEQoAEgAEH0vsAAKAIARw0BQey+wAAgATYCAAsPCyABQYACTwRAIAAgARAWDwsgAUEDdiICQQN0QeS7wABqIQECf0Hcu8AAKAIAIgNBASACdCICcQRAIAEoAggMAQtB3LvAACACIANyNgIAIAELIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIC+UDAQN/IwBB0CJrIgMkACADQcAWaiIEQcitwAAQSSADQcgcaiIFQYCuwAAQSSADQQhqIAQgBRBLIANBiAFqQTgQ0AEaIANBwAFqQTgQ0AEaIANB+AFqED0CQCACEIYBBEAgABBVDAELIANB+ARqIgQQPSAEIAEQfSAEEEcgA0H4B2oiARBnIAEgAhB4IAEQRiADQcgcaiICIAEQkAEgA0G4CWogAhCQASACIANBuAhqEJABIANB+AlqIAIQkAEgA0G4CmoiARA9IANBuA1qEFUgASAEEH0gA0HAE2oiARA9IAEgBBB9IAEQogEgA0HAAWogA0GIAWoQUEECayECA0AgAkEBakEBTQRAIANBuA1qIgEQngEgACABQYgGENEBGgUgA0G4DWoQGiADQcAWaiADQbgKaiADQbgJaiADQfgJahALAkACQAJAIANBwAFqIAIQUyADQYgBaiACEFNrQQFqDgMBAgACCyADQcgcaiIBIANBuApqIANB+ARqIANBuAlqIANB+AlqEAogA0HAFmogARADDAELIANByBxqIgEgA0G4CmogA0HAE2ogA0G4CWogA0H4CWoQCiADQcAWaiABEAMLIAJBAWshAiADQbgNaiADQcAWahABDAELCwsgA0HQImokAAvBAwEVfwNAIANBwAFGBEACQCAAQShqIQsgAEEUaigCACIMIQggAEEQaigCACINIQIgAEEMaigCACIOIQEgACgCCCIPIQMgAEEYaigCACIQIQogAEEcaigCACIRIQQgAEEgaigCACISIQcgAEEkaigCACITIQYDQCAHIQkgBCEHIAohBCAFQYACRg0BIAEgAnEhFCABIAJzIRUgBSALaigCACAFQcCiwABqKAIAIAkgBEF/c3EgBCAHcXIgBmogBEEadyAEQRV3cyAEQQd3c2pqaiIGIAhqIQogBUEEaiEFIAIhCCABIQIgAyIBQR53IAFBE3dzIAFBCndzIBQgASAVcXNqIAZqIQMgCSEGDAALAAsFIAAgA2oiAkHoAGogAkEoaigCACACQcwAaigCACACQeAAaigCACIBQQ93IAFBDXdzIAFBCnZzamogAkEsaigCACIBQRl3IAFBDndzIAFBA3ZzajYCACADQQRqIQMMAQsLIAAgBiATajYCJCAAIAkgEmo2AiAgACAHIBFqNgIcIAAgBCAQajYCGCAAIAggDGo2AhQgACACIA1qNgIQIAAgASAOajYCDCAAIAMgD2o2AggL5AEBAn8jAEGAA2siAyQAIAMQPSAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbyAAIAFBgANqIAJBAXNBAWtBH3YQbyAAIAFBgAZqIAJBAnNBAWtBH3YQbyAAIAFBgAlqIAJBA3NBAWtBH3YQbyAAIAFBgAxqIAJBBHNBAWtBH3YQbyAAIAFBgA9qIAJBBXNBAWtBH3YQbyAAIAFBgBJqIAJBBnNBAWtBH3YQbyAAIAFBgBVqIAJBB3NBAWtBH3YQbyADIAAQfSADEKIBIAAgAyAEQQFxEG8gA0GAA2okAAvlAwEIfyMAQZAGayICJAAgAEFAayEIAkAgAUH4AGooAgAgASgCOGqsIABB+ABqKAIAIgcgACgCOCIEaqx+Qv///w9XDQAgBEEBSgR/IAAQHiAAKAJ4BSAHC0EBTA0AIAgQHgsgAkHYpMAAEEkgAkE4aiIHQfAAENABGiACIQNBACECA0AgAkE4RgRAAkAgB0E4aiEEQQAhAgNAIAJBOEYNASACIARqIAIgA2opAwA3AwAgAkEIaiECDAALAAsFIAIgB2pCADcDACACQQhqIQIMAQsLIANBqAFqIgYgABBdIANB4AFqIgUgARBdIANBmAJqIgIgACABEAUgA0GIA2oiBCAIIAFBQGsiARAFIAYgCBBgIAYQQiAFIAEQYCAFEEIgA0H4A2oiCSAGIAUQBUEAIQEgA0HoBGoiBkHwABDQASEFA0AgAUHwAEcEQCABIAVqIAEgAmopAwA3AwAgAUEIaiEBDAELCyAGIAQQYkEAIQEDQCABQfAARwRAIAEgBGoiBSABIAdqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAiAEEGIgAhBIIAkgBhBjIAkQSCADQdgFaiIBIAIQayAAIAEQaiAAQQM2AjggASAJEGsgCCABEGogAEECNgJ4IANBkAZqJAALowIBCH8jAEGABmsiAiQAIAIgAEGAAWoiBxBeIAJBgAFqIgQgBxBeIAQQLSACQYACaiIFIAIQXiAFIABBgAJqIgMQESACQYADaiIBIAMQXiABEC0gAyAEEJkBIAMgBBCaASADEKkBIAMQuAEgAxC4ASADEKkBIAFBDBCrASABEHwgARCpASACQYAEaiIIIAEQXiAIIAMQESACQYAFaiIGIAQQXiAGIAEQmgEgBhCpASADIAUQESAFIAEQmQEgBSABEJoBIAEgBRCaASABEKkBIAQgARB7IAQQqQEgBiAEEBEgBiAIEJoBIAUgABCZASAFIAIQESAAIAQQmQEgABCpASAAIAUQESAAELgBIAAQqQEgByAGEJkBIAcQqQEgAkGABmokAAu8AgEGfyMAQYAIayIBJAAgASAAEIwBIAFBgAJqIgMgAEGABGoiBRCMASABQYAEaiIEIABBgAJqIgYQjAEgAUGABmoiAkE4ENABGiABQQE2ArgGIAFBwAZqQTgQ0AEaIAFB+AZqQQE2AgAgAUGAB2pBOBDQARogAUG4B2pBATYCACABQcAHakE4ENABGiABQfgHakEBNgIAIAAQISACIAAQlgEgAiAAEJcBIAAgAhCXASAAELABIAEQyQEgARCzASAAIAEQlwEgAxAhIAMQZCACIAMQlgEgAiADEJcBIAMgAhCXASADELABIAQQISACIAQQlgEgAiAEEJcBIAQgAhCXASAEELABIAYQsgEgBhCzASAFEMkBIAUQswEgBiADEJcBIAUgBBCXASAAQQU2AoAGIAAQnAEgAUGACGokAAv/AQEHfyMAQcACayIBJAAgASAAQUBrIgYQkAEgARBMIAFBQGsiAyAGEJABIAMgAEGAAWoiAhBKIAFBgAFqIgQgAhCQASAEEEwgAiABEK4BIAIgARB3IAIQQiACEIIBIAIQggEgAhBCIARBDBA0IAFBwAFqIgcgBBCQASAHIAIQSiABQYACaiIFIAEQkAEgBSAEEHcgBRBCIAIgAxBKIAMgBBCuASADIAQQdyAEIAMQdyABIAQQfiABEEIgBSABEEogBSAHEHcgAyAAEK4BIAMgBhBKIAAgARCuASAAEEIgACADEEogABCCASAAEEIgBiAFEK4BIAYQQiABQcACaiQAC84CAgd/An4CQAJAAkBBDSABQTpuIgJrIgRBDU0EQEEMIAJrIgNBDk8NASAAIAAgA0EDdGopAwBBOiABIAJBOmxrIgNrrSIKhyAAIARBA3RqKQMAIAOtIgmGhDcDaCAEQQ1rIQUgAEHgAGohBCACQQFqIQZBACACQQN0ayEHQQshAwNAAkAgA0ECaiAGTQRAIAFBrAZPDQEgACACQQN0aiAAKQMAIAmGQv//////////A4M3AwADQCACRQ0HIABCADcDACACQQFrIQIgAEEIaiEADAALAAsgAyAFakEOTw0EIAQgBCAHaiIIQQhrKQMAIAqHIAgpAwAgCYZC//////////8Dg4Q3AwAgA0EBayEDIARBCGshBAwBCwsgAkEOQYCywAAQOwALIARBDkHQscAAEDsACyADQQ5B4LHAABA7AAtBf0EOQfCxwAAQOwALC6cCAQR/IABCADcCECAAAn9BACABQYACSQ0AGkEfIAFB////B0sNABogAUEGIAFBCHZnIgNrdkEBcSADQQF0a0E+agsiBDYCHCAEQQJ0Qey9wABqIQMgACECAkACQAJAAkBB4LvAACgCACIAQQEgBHQiBXEEQCADKAIAIQMgBBCfASEAIAMQywEgAUcNASADIQAMAgtB4LvAACAAIAVyNgIAIAMgAjYCAAwDCyABIAB0IQQDQCADIARBHXZBBHFqQRBqIgUoAgAiAEUNAiAEQQF0IQQgACIDEMsBIAFHDQALCyAAKAIIIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCCACQQA2AhgPCyAFIAI2AgALIAIgAzYCGCACIAI2AgggAiACNgIMC7YCAQV/IAAoAhghBAJAAkAgACAAKAIMRgRAIABBFEEQIABBFGoiASgCACIDG2ooAgAiAg0BQQAhAQwCCyAAKAIIIgIgACgCDCIBNgIMIAEgAjYCCAwBCyABIABBEGogAxshAwNAIAMhBSACIgFBFGoiAygCACICRQRAIAFBEGohAyABKAIQIQILIAINAAsgBUEANgIACwJAIARFDQACQCAAIAAoAhxBAnRB7L3AAGoiAigCAEcEQCAEQRBBFCAEKAIQIABGG2ogATYCACABDQEMAgsgAiABNgIAIAENAEHgu8AAQeC7wAAoAgBBfiAAKAIcd3E2AgAPCyABIAQ2AhggACgCECICBEAgASACNgIQIAIgATYCGAsgAEEUaigCACIARQ0AIAFBFGogADYCACAAIAE2AhgLC+UBAQZ/IwBBgARrIgIkACACIAAQXiACQYABaiIFIABBgAFqIgYQXiACQYACaiIDQTgQ0AEaIAJBATYCuAIgAkHAAmpBOBDQARogAkH4AmpBATYCACACQYADaiIEIAYQXiACIAEQESAFIAFBgAFqIgcQESADIAcQmQEgAyABEJoBIAQgABCaASADEKkBIAQQqQEgBCADEBEgAyACEJkBIAMQNiAEIAMQmgEgBBCpASADIAUQmQEgAxA2IAYgBBCZASAGIAMQmgEgBRB8IAAgBRCZASAAIAIQmgEgABCwASACQYAEaiQAC28BDH9BjL/AACgCACICRQRAQZy/wABB/x82AgBBAA8LQYS/wAAhBgNAIAIiASgCCCECIAEoAgQhAyABKAIAIQQgAUEMaigCABogASEGIAVBAWohBSACDQALQZy/wAAgBUH/HyAFQf8fSxs2AgBBAAuAAgEGfyMAQYAIayIBJAAgACgCgAZBAUcEQCABIAAQjAEgAUGAAmoiAiAAQYACaiIEEIwBIAFBgARqIgUgAEGABGoiAxCMASABQYAGaiIGIAAQjAEgARAhIAIgAxAYIAIQswEgAhCwASAFECEgBiAEEBggBhCzASADIAAQlwEgAyAEEJcBIAMQsAEgAxAhIAAgARCWASABIAIQlwEgARCwASABIAUQlwEgASAGEJcBIAEQsAEgARArIAIQZCAFEGQgACACEJcBIAQgBRCWASAEIAYQlwEgAyABEJcBIABBBEEFIAAoAoAGQX5xQQJGGzYCgAYgABCdAQsgAUGACGokAAuZAgEBfyMAQYANayIDJAAgAyABEGkgAxCdASADQYgGaiIBIAIQXSABEEIgA0HABmoiAiABEF0gAkEDECkaIAIQQiADQfgGaiADEGkCQCACEFdFBEAgA0HABmoQKkECayECA0AgAkEBakEBTQRAIANB+AZqIgEQnAEMAwUgA0H4BmoQEwJAAkACQCADQcAGaiACEFMgA0GIBmogAhBTa0EBag4DAQIAAgsgA0H4BmogAxAHDAELIAMQngEgA0H4BmogAxAHIAMQngELIAJBAWshAgwBCwALAAsgA0H4BmoiARC3ASABQYABahC2ASABQYACahCxASABQYAEahCxASABQQE2AoAGCyAAIAFBiAYQ0QEaIANBgA1qJAALhgICBH8BfiMAQTBrIgIkACABQQRqIQQgASgCBEUEQCABKAIAIQMgAkEQaiIFQQA2AgAgAkIBNwMIIAIgAkEIajYCFCACQShqIANBEGopAgA3AwAgAkEgaiADQQhqKQIANwMAIAIgAykCADcDGCACQRRqIAJBGGoQDBogBEEIaiAFKAIANgIAIAQgAikDCDcCAAsgAkEgaiIDIARBCGooAgA2AgAgAUEMakEANgIAIAQpAgAhBiABQgE3AgQgAiAGNwMYQQxBBBC5ASIBRQRAQQxBBBDPAQALIAEgAikDGDcCACABQQhqIAMoAgA2AgAgAEGEt8AANgIEIAAgATYCACACQTBqJAAL5AEBAn8jAEHAAWsiAyQAIAMQZyAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbiAAIAFBwAFqIAJBAXNBAWtBH3YQbiAAIAFBgANqIAJBAnNBAWtBH3YQbiAAIAFBwARqIAJBA3NBAWtBH3YQbiAAIAFBgAZqIAJBBHNBAWtBH3YQbiAAIAFBwAdqIAJBBXNBAWtBH3YQbiAAIAFBgAlqIAJBBnNBAWtBH3YQbiAAIAFBwApqIAJBB3NBAWtBH3YQbiADIAAQeCADEKQBIAAgAyAEQQFxEG4gA0HAAWokAAvDAwIGfwN+IwBB8ABrIgEkACABQcCywAAQSSABQThqIAEQXSAAEEICQAJAAkAgAQJ/IAAoAjgiAkEQTARAIAJBAWsQNQwBCyABKQMwIghCAXwiByAIVA0BIAApAzAiCEKAgICAgICAgIB/USAHQn9RcQ0CIAFBOGoiAiAIIAd/pxApIQcgASABKQNoIAdCOoZ8NwNoIAAgAhBhIAAQQkECCyIEECgDQCAERQ0DQQAhAyABIAEpAwgiCEI5hkKAgICAgICAgAKDIAEpAwBCAYeEIgc3AwAgACkDACAHfSEHIABBCGohBSAAIAFBOGoiAkEBA38gAiADaiAHQv//////////A4M3AwAgB0I6hyEHIANBKEYEfyABIAEpAzBCAYciCDcDMCACIAApAzAgCH0gB3wiBzcDMCAHQj+IpwUgASADaiIGQQhqIAhCAYcgBkEQaikDACIIQjmGQoCAgICAgICAAoOEIgk3AwAgAyAFaikDACAHfCAJfSEHIANBCGohAwwBCwtrEDAgBEEBayEEDAALAAtB4LPAAEEZQcSzwAAQWQALQYC0wABBH0HEs8AAEFkACyAAQQE2AjggAUHwAGokAAvuAQECfyMAQbABayIDJAAgA0EwENABIQMCQAJAA0AgAkEwRgRAIANBMGogAxBwIAFBMGohAUEAIQIDQCACQTBGDQMgAkEwRg0EIAIgA2ogASACai0AADoAACACQQFqIQIMAAsACyACQeAARwRAIAIgA2ogASACai0AADoAACACQQFqIQIMAQsLQeAAQeAAQYCmwAAQOwALIANB8ABqIgEgAxBwIABBOBDQASIAQQE2AjggAEFAa0E4ENABIABB+ABqQQE2AgAgACABEK4BIANBMGoQrgEgA0GwAWokAA8LIAJBMGpB4ABBkKbAABA7AAuPAgEDfyMAQSBrIgUkAEEBIQZB2LvAAEHYu8AAKAIAIgdBAWo2AgACQEGgv8AALQAABEBBpL/AACgCAEEBaiEGDAELQaC/wABBAToAAAtBpL/AACAGNgIAAkACQCAHQQBIIAZBAktyDQAgBSAEOgAYIAUgAzYCFCAFIAI2AhBBzLvAACgCACICQQBIDQBBzLvAACACQQFqIgI2AgBBzLvAAEHUu8AAKAIAIgMEf0HQu8AAKAIAIAUgACABKAIQEQAAIAUgBSkDADcDCCAFQQhqIAMoAhQRAABBzLvAACgCAAUgAgtBAWs2AgAgBkEBSw0AIAQNAQsACyMAQRBrIgIkACACIAE2AgwgAiAANgIIAAucAQEEfyMAQYADayICJAAgAiAAEF4gAkGAAWoiASAAQYABaiIEEF4gAkGAAmoiAyAAEF4gAyAEEBEgAiAEEJoBIAEQfCABIAAQmgEgAhCpASABEKkBIAAgAhCZASAAIAEQESABIAMQmQEgARB8IAEgAxCaASABEKkBIAEQNiAAIAEQmgEgAxC4ASAEIAMQmQEgABCwASACQYADaiQAC7kBAQJ/IwBBIGsiAyQAAkAgASABIAJqIgFLDQAgAEEEaigCACICQQF0IgQgASABIARJGyIBQQggAUEISxshAQJAIAIEQCADQRhqQQE2AgAgAyACNgIUIAMgACgCADYCEAwBCyADQQA2AhALIAMgASADQRBqECYgAygCAARAIANBCGooAgAiAEUNASADKAIEIAAQzwEACyADKAIEIQIgAEEEaiABNgIAIAAgAjYCACADQSBqJAAPCxBlAAusAQECfyMAQYADayIDJAAgA0EIaiABEJABAkAgAgRAIANBCGogAhCuAQwBCyADQQhqEDoLIANByABqIgJB8LTAABBJIANBgAFqIAIQjgEgA0HAAWoiAiADQQhqIgQQkAEgAhBMIAIgARBKIAAgARCQASAAIAQQSiADQYACaiACEJABIAAQViEBIANBwAJqIgIgABCQASACEEMgAhBCIAAgAiABEHIgA0GAA2okAAueAQEFfyMAQYABayICJAAgAkE4ENABIgJBATYCOCACQUBrIgNBOBDQARogAkEBNgJ4IAIgABCuASACIAFBgAFqIgUQSiADIAEQrgEgAyAAQYABaiIGEEoCQCACIAMQWEUNACACIABBQGsQrgEgAiAFEEogAkFAayIAIAFBQGsQrgEgACAGEEogAiAAEFhFDQBBASEECyACQYABaiQAIAQLpwEBA38jAEEwayICJAAgAUEEaiEDIAEoAgRFBEAgASgCACEBIAJBEGoiBEEANgIAIAJCATcDCCACIAJBCGo2AhQgAkEoaiABQRBqKQIANwMAIAJBIGogAUEIaikCADcDACACIAEpAgA3AxggAkEUaiACQRhqEAwaIANBCGogBCgCADYCACADIAIpAwg3AgALIABBhLfAADYCBCAAIAM2AgAgAkEwaiQAC5UBAQJ/AkACQAJAAkACfwJAAkACf0EBIgMgAUEASA0AGiACKAIAIgRFDQEgAigCBCICDQQgAQ0CQQEMAwshA0EAIQEMBgsgAQ0AQQEMAQsgAUEBELkBCyICRQ0BDAILIAQgARCsASICDQELIAAgATYCBEEBIQEMAQsgACACNgIEQQAhAwsgACADNgIAIABBCGogATYCAAvvMwISfwV+IwBBMGsiDiQAIA5BEGogACABEFsgDiAOKAIUIgA2AhwgDiAOKAIQIgg2AhggDkEIaiACIAMQWyAOIA4oAgwiATYCJCAOIA4oAggiAzYCICAOIAQgBRBbIA4gDigCBCIFNgIsIA4gDigCACINNgIoIAAhBCMAQZAVayICJAAjAEGwBmsiCiQAIApBEGpBOBDQARogCkHQAGpBOBDQASEVIApBiAFqQQE2AgAgCkEBNgJIIApBkAFqIgBB2KTAABBJIAAQKiEPIApByAFqIhNBgAIQ0AEaIApByANqQYABENABGiMAQdAAayIRJAAgEUEQakHAABDQARogASEJQQAhACMAQYAEayIHJAAgB0EvakGBAhDQARogB0GwAmpBwAAQ0AEaIAdB8AJqQcAAENABGiAHQbADakHAABDQARogByAPQf8AakEDdkEBaiISQQF0IgFBCHQgAUGA/gNxQQh2cjsALCABQQFrQQV2QQFqIQsCQANAIAYgB2pBLmogADoAACAGQStGBEAgB0EsaiIGQS5qQSs6AAAgB0EgaiAGQS8QX0EAIQAgB0GwAmpBwAAgAyAJIAcoAiAgBygCJBAGIAdBADoA+AMgByALNgL0A0EAIAFrIRQgB0EBNgLwAyAGQSxqIRYMAgsgBkGBAkcEQCAGQcClwABqLQAAIQAgBkEBaiEGDAELCyAGQQNqQYQCQfCrwAAQOwALA0ACQCAHQRhqIQlBACEGQQAhCwJAIAdB8ANqIgMtAAgNACADKAIAIgsgAygCBCIXSw0AIAsgF08EQEEBIQYgA0EBOgAIDAELQQEhBiADIAtBAWo2AgALIAkgCzYCBCAJIAY2AgACQCAHKAIYBEAgBygCHCEDQQAhBgNAIAZBIEYEQCAHIAM6ACxBACEGAkACQANAIAZBK0YEQCAWQSs6AAAjAEEQayIDJAAgA0EIaiAHQbADakHAAEEgEIEBIAMoAgwhCSAHQRBqIgYgAygCCDYCACAGIAk2AgQgA0EQaiQAIAcoAhQhAyAHKAIQIQkgB0EIaiAHQSxqQS0QX0EAIQYgB0HwAmpBACAJIAMgBygCCCAHKAIMEAZBAEGAAiAAayIDIANBgAJLGyEDIAAgE2ohCSAAIBRqIQsDQCAGQSBGDQggBkHAAEYNBCADIAZGDQMgBiAJaiAHQfACaiAGai0AADoAACAGQQFqIgYgC2oNAAsgASEADAkLIAZBgwJHBEAgBiAHakEtaiAGQcClwABqLQAAOgAAIAZBAWohBgwBCwsgBkEBakGEAkGwrMAAEDsACyAAIAZqQYACQYCtwAAQOwALQcAAQcAAQfCswAAQOwALIAZBwABHBEAgB0HwAmogBmoiCSAJLQAAIAdBsAJqIAZqLQAAcyIJOgAAIAdBsANqIAZqIAk6AAAgBkEBaiEGDAELC0HAAEHAAEGgrMAAEDsACyAHQYAEaiQADAELIAAgBmohAAwBCwsgEUHQAGokACASQQN0IA9rIQlBACEAAkACQANAIABBAkcEQCAAQQFqIApByAFqIBBqIQZBACEDAkADQCADIBJGDQEgAyAQaiIHQf8BSw0EIANBgAFHBEAgCkHIA2ogA2ogAyAGai0AADoAACADQQFqIQMMAQsLQYABQYABQaClwAAQOwALIwBBEGsiAyQAIANBCGogCkHIA2pBgAEgEhCBASADKAIMIQYgCkEIaiIHIAMoAgg2AgAgByAGNgIEIANBEGokACAKKAIIIQMgCigCDCELIApBwAVqIg9B8AAQ0AEhBgNAIAsEQCAGQQgQFSAGIAYpAwAgAzEAAHw3AwAgC0EBayELIANBAWohAwwBCwsgCkGIBWohEyMAQeABayILJAAgDxBIIAsgCkGQAWoQLiALQfAAakHwABDQARogCyAJIgMQFQNAIAtB8ABqIQZBACEHA0AgB0HwAEcEQCAGIAdqIAcgD2opAwA3AwAgB0EIaiEHDAELCyAGIAsQYyAGEEhBACEHQgAhGCAGKQMIIA8pAwCFIhlCAYZCAYchG0F/IAspA9gBQj+Hp2usIRwDfiAHQfAARgR+IBgFIAcgD2oiESARKQMAIhogGYUgBiAHaikDACAahSAcg4UiGiAbhTcDACAYIBqFIRggB0EIaiEHDAELCxogAwRAQQAhBkEAIQdBACERAkACQANAIAZB6ABGBEAgC0HoAGogCykDaEIBhzcDACALQfAAaiEGA0AgB0UNBCAGQgA3AwAgB0EBayEHIAZBCGohBgwACwALIAZB8ABGDQEgBkHwAEcEQCAGIAtqIhQgFEEIaikDAEI5hkL//////////wODIBQpAwBCAYeENwMAIBFBAWohESAGQQhqIQYMAQsLQQ5BDkGgssAAEDsACyARQQ5BkLLAABA7AAsgA0EBayEDDAEFIBMgDxBdIAtB4AFqJAALCyAKQcgEaiIDIBMQjgEgCkEQaiAAQQZ0aiADQcAAENEBGiAQIBJqIRAhAAwBCwsgAiAKQRBqEAIgCkHIAWoiACAVEAIgAiAAEAkjAEGAAmsiACQAIABBCGoiAUHYgcAAEEkgAEFAayIDIAIgARC9ASACIAMQeCAAQYACaiQAIAIQRiAKQbAGaiQADAELIAdBgAJBkKXAABA7AAsgAkHAAWohASMAQeACayIAJAAgAEEwENABIgBBMGpB0IDAABBJAkACQAJAAkADQAJAIAxBMEYEQCAAIAAtAABBH3E6AAAgAEHoAGogABC+ASAEDQFBAEEAQZiBwAAQOwALIAQgDEYNAiAAIAxqIAggDGotAAA6AAAgDEEBaiEMDAELC0EAIQwgCCwAACIJQQBIDQIgCEEwaiEDIARBMCAEQTBLG0EwayEIA0AgDEEwRgRAIABBoAFqIgQgABC+ASMAQYABayIDJAAgARBnIAEgAEHoAGoQwAEgAUFAayIIIAQQwAEgAUGAAWoQygEgARBCIAMgARBPIANBQGsiBCAIEJABIAQQTCAEIAMQWEUEQCABEJIBCyADQYABaiQADAULIAggDEYNAiAAIAxqIAMgDGotAAA6AAAgDEEBaiEMDAALAAsgBCAEQYiBwAAQOwALIAxBMGogBEGogcAAEDsACyMAQcABayIDJAAgAEGgAWoiBBBnIANBOBDQASIDQQE2AjggBCAAQegAahDAASAEEEIgBEGAAWoQygEgA0FAayIIIAQQTwJAAkACQCAIIAMQWkEBRgRAIANBgAFqIgggA0FAayADECMgCBBWDQEMAgsgBBCSAQwCCyADQYABaiIIEEMgCBBCCyAEQUBrIANBgAFqEK4BCyADQcABaiQAIAlBIHEiA0EAIABB4AFqEE0iBEEBRxtBASADIARBAUdyGwRAIABBoAFqEKQBCyABIABBoAFqQcABENEBGgsgAEHgAmokAAJ/QQAhAyMAQcAFayIAJAACQCABEIYBDQAgAEEIaiIIQZCtwAAQSSAAQYAEaiIEQbiuwAAQSSAAQUBrIgkgBBCOASAAQYABaiIEEGcgBCABEHggBCAJEEogAEHAAmoiBCABIAgQvQEgASAEECQNACAAQYAEaiIEIABBwAJqIgEgAEEIahC9ASABIARBwAEQ0QEaIAEQpAEgAEGAAWogARAkRQ0AQQEhAwsgAEHABWokAEF/IANFDQAaIAJBwAFqEKQBIAJBgANqIQhBACEAIwBB4ARrIgEkACABQeAAENABIQECQCAFBEADQCAAQeAARgRAIAEgAS0AAEEfcToAACABQeAAaiABEB9BACEAAkAgDSwAACILQQBOBEAgDUHgAGohAyAFQeAAIAVB4ABLG0HgAGshBANAIABB4ABGBEAgAUHgAWoiACABEB8gCCABQeAAaiAAED8MAwsgACAERwRA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AWoQmQEgACAEEBEgAEGAAWoiASAFQYABahCZASABIAgQESAAIAEQeg0BC0EADAELQQELIQEgAEGAAmokACANQcAHaiQAQX8gAUUNABojAEHgA2siACQAIABBgAFqIgFBwKjAABBJIABBuAFqIgNB+KjAABBJIAAgASADEEsgAEHwAmoiAUGwqcAAEEkgAEGoA2oiA0HoqcAAEEkgAEHwAWoiBCABIAMQSyACQYAGaiIBIAAgBBA/IABB4ANqJAAgAkGACWohByACQYADaiEIIwBBkDRrIgAkACAAQYAoaiIDQcitwAAQSSAAQYguaiIEQYCuwAAQSSAAIAMgBBBLIABBgAFqQTgQ0AEaIABBuAFqQTgQ0AEaIABB8AFqED0CQCACQcABaiIEEIYBRQRAIAIQhgEEQCAHIAEgBBAODAILIABB8ARqIgMQPSADIAEQfSADEEcgAEHwB2oiBRBnIAUgBBB4IAUQRiAAQbAJaiIEED0gBCAIEH0gBBBHIABBsAxqIggQZyAIIAIQeCAIEEYgAEGILmoiASAFEJABIABB8A1qIAEQkAEgASAAQbAIahCQASAAQbAOaiABEJABIAEgCBCQASAAQfAOaiABEJABIAEgAEHwDGoQkAEgAEGwD2ogARCQASAAQfAPaiIBED0gAEHwEmoiBRA9IABB8BVqEFUgASADEH0gBSAEEH0gAEH4G2oiARA9IAEgAxB9IAEQogEgAEH4HmoiARA9IAEgBBB9IAEQogEgAEG4AWogAEGAAWoQUEECayEBA0AgAUEBakEBTQRAIABB8BVqIgEQngEgByABQYgGENEBGgwDBSAAQfAVaiIEEBogAEH4IWoiAyAAQfAPaiAAQfANaiAAQbAOahALIABBgChqIgUgAEHwEmogAEHwDmogAEGwD2oQCyADIAUQAyAEIAMQAQJAAkACQCAAQbgBaiABEFMgAEGAAWogARBTa0EBag4DAQIAAgsgAEGILmoiAyAAQfAPaiAAQfAEaiAAQfANaiAAQbAOahAKIABB+CFqIgQgA0GIBhDRARogAyAAQfASaiAAQbAJaiAAQfAOaiAAQbAPahAKIAQgAxADIABB8BVqIAQQAQwBCyAAQYguaiIDIABB8A9qIABB+BtqIABB8A1qIABBsA5qEAogAEH4IWoiBCADQYgGENEBGiADIABB8BJqIABB+B5qIABB8A5qIABBsA9qEAogBCADEAMgAEHwFWogBBABCyABQQFrIQEMAQsACwALIAcgCCACEA4LIABBkDRqJAAjAEHgH2siCCQAIAhB0BNqIgFByK3AABBJIAhB2BlqIg1BgK7AABBJIAggASANEEsgCEGAAWoiC0GQrcAAEEkgAkGID2oiACAHEGkgCEG4AWoiBSAAEGkjAEGACGsiAyQAIAMgBRCMASADQYACaiIJIAVBgAJqIg8QjAEgA0GABGoiCiAFEIwBIANBgAZqIgRBOBDQARogA0EBNgK4BiADQcAGakE4ENABGiADQfgGakEBNgIAIANBgAdqQTgQ0AEaIANBuAdqQQE2AgAgA0HAB2pBOBDQARogA0H4B2pBATYCACAFEJ0BIAMQISAJIAVBgARqIgwQGCAJEGQgAyAJEHkgAxCwASAJIAwQlgEgCRAhIAkQZCAKIA8QGCAJIAoQeSAJELABIAogDxCWASAKECEgBCAFEJYBIAQgDBAYIAogBBB5IAoQsAEgBCAPEJYBIAQgChAYIAQQZCAFIAMQGCAEIAUQlwEgDCAJEBggDBBkIAQgDBCXASAEELABIwBBgAJrIgYkACAGIAQQXiAGQYABaiIQIARBgAFqIhIQXiAGEC0gEBAtIBAQfCAQEKkBIAYgEBB7IAYQPiAEIAYQESAGEDYgBhCpASASIAYQESAGQYACaiQAIAUgAxCWASAFIAQQGCAPIAkQlgEgDyAEEBggDCAKEJYBIAwgBBAYIAVBBTYCgAYgA0GACGokACAAEJ4BIAAgBRAHIAUgABBtIAAgCBAyIAAgCBAyIAAgBRAHIAhBwAdqIgQgABBpIAQQEyAEIAAQByANIAAgCxAbIAhByA1qIgMgDRBpIAMQngEgASAAEGkgARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gASAIEDIgACADEG0gACABEAcgDSAAIAsQGyADIA0QbSANIAMgCxAbIAMgDRBtIAEgABBtIAEgCBAyIAEgCBAyIAMgARAHIAEgABBtIAEQngEgACADEG0gACABEAcgACAEEAcgABCcASAIQeAfaiQAIAcgAEGIBhDRARpBACEAIwBBgAJrIgEkACABEGwCQCAHIAEQegR/IAdBgAFqIAFBgAFqEHoFQQALRQ0AIAdBgAJqEIcBRQ0AIAdBgARqEIcBIQALIAFBgAJqJABBACAADQAaQX8LIAJBkBVqJAAgDkEoahC0ASAOQSBqELQBIA5BGGoQtAEgDkEwaiQAC58BAgJ/BX4gAEEwaiICKQMAIAFBP3GtIgSGIQUgACkDKCIGQTogAWtBP3GtIgiHIQdBBiEBA38gAiAFIAeENwMAIAFBAU0EfyAAIAApAwAgBIZC//////////8DgzcDACAAKQMwQiSHpwUgAUEBayEBIAJBEGsiA0EIaiECIAYgBIZC//////////8DgyEHIAMpAwAiBiAIhyEFDAELCxoLiAECA34DfyMAQRBrIgUkAAN+IAZBOEYEfiAFQRBqJAAgAwUgBSAAIAZqIgcpAwAiAiACQj+HIAGsIgIgAkI/hxAvIAcgBSkDACIEIAN8IgJC//////////8DgzcDACACIARUrSAFQQhqKQMAIANCP4d8fEIGhiACQjqIhCEDIAZBCGohBgwBCwsLigECA38BfiMAQUBqIgIkACACQQhqIgEgABBdIAEQQiACQThqIQFBBiEDQdwCIQACQAJAA0AgA0EATgRAIAEpAwAiBEIAUg0CIAFBCGshASAAQTprIQAgA0EBayEDDAELC0EAIQAMAQsDQCAEUA0BIABBAWohACAEQgJ/IQQMAAsACyACQUBrJAAgAAuHAQEDfyMAQYACayIBJAAgABCwASABIAAQXiABQYABaiICQTgQ0AEaIAFBATYCuAEgAUHAAWpBOBDQARogAUH4AWpBATYCACABIABBgAFqIgMQmgEgARA2IAIgARCZASACIAMQmgEgAyABEJkBIAMgABCaASAAIAIQmQEgABCwASABQYACaiQAC30CBH4BfyABQT9xrSECQTogAWtBP3GtIQRBACEBIAApAwAiBSEDA38gAUEwRgR/IAAgACkDMCAChzcDMCAFQn8gAoZCf4WDpwUgACABaiIGIAMgAocgBkEIaikDACIDIASGQv//////////A4OENwMAIAFBCGohAQwBCwsaC2kBBH8jAEHAAWsiASQAIAEgABCQASABQUBrIgIgABCQASABQYABaiIDIABBQGsiBBCQASABIAQQdyACIAAQdyACEEIgBCACEEogAxBDIAAgAxB3IAEQQiAAEEIgACABEEogAUHAAWokAAuCAQIBfwF+IABB8AAQ0AEhAANAIAJBOEYEQAJAIAAgASkDMCIDQjqHNwM4IAAgA0L//////////wODNwMwIABBQGshAEEAIQIDQCACQTBGDQEgACACakIANwMAIAJBCGohAgwACwALBSAAIAJqIAEgAmopAwA3AwAgAkEIaiECDAELCwtuAQZ+IAAgA0L/////D4MiBSABQv////8PgyIGfiIHIAUgAUIgiCIIfiIJIAYgA0IgiCIGfnwiBUIghnwiCjcDACAAIAcgClatIAYgCH4gBSAJVK1CIIYgBUIgiIR8fCABIAR+IAIgA358fDcDCAtqAgF/BX4gASkDCCAAKQMAhSIGQgGGQgGHIQdBACACa6whCAN+IANBOEYEfiAFBSAAIANqIgIgAikDACIEIAaFIAEgA2opAwAgBIUgCIOFIgQgB4U3AwAgBCAFhSEFIANBCGohAwwBCwsaC18CAX8EfkIBIQNBMCECA38gAkF4RgR/IARCAYYgA3ynQQFrBSABIAJqKQMAIgUgACACaikDACIGfUI6hyADgyAEhCEEIAJBCGshAiAFIAaFQgF9QjqHIAODIQMMAQsLC2kBBH8jAEGAAmsiAiQAIAIgARBeIAJBgAFqIgMgARBeIAIQLSADIAIQESAAIAMQmAEgAEGAAmoiBCADEJgBIABBgARqIgUgAxCYASAEIAEQpgEgBSACEKYBIABBBTYCgAYgAkGAAmokAAtiAQJ/IwBBQGoiAiQAIAAQQiACIAAQkAECQCABBEAgACABEK4BDAELIAAQOgtBACEBA0AgA0UEQCAAEExBASABQQFqIAFBAUYiAxshAQwBCwsgACACEEogABAeIAJBQGskAAtnAQJ/IwBBQGoiAyQAAkAgASABQR91IgJqIAJzIgIgACgCOGxBgICAEE4EQCADIAIQOSAAIAMQSgwBCyAAIAIQKRogACAAKAI4IAJsNgI4CyABQQBIBEAgABBDIAAQQgsgA0FAayQAC2cAIABBAXYgAHIiAEECdiAAciIAQQR2IAByIgBBCHYgAHIiAEEQdiAAciIAIABBAXZB1arVqgVxayIAQQJ2QbPmzJkDcSAAQbPmzJkDcWoiAEEEdiAAakGPnrz4AHFBgYKECGxBGHYLYQEDfyMAQYABayIBJAAgASAAEJABIAFBQGsiAkE4ENABGiABQQE2AnggASAAQUBrIgMQdyABEEMgAiABEK4BIAIgAxB3IAMgARCuASADIAAQdyAAIAIQrgEgAUGAAWokAAtVAgJ/AX4jAEHwAGsiASQAIAFBwLLAABBJIAApAwAhAyABQThqIgIgABBdIABBARAsIAIgARBgIAIQQiACQQEQLCAAIAIgA0ICgacQMCABQfAAaiQAC5gBAQZ/IwBBwAFrIgMkACAAIAEQXiAAEC0gA0GIAWoiBkHop8AAEEkjAEFAaiIEJAAgA0EIaiICQTgQ0AEiBUEBNgI4IAVBQGtBOBDQASAFQfgAakEBNgIAIAQgBhCOASAFIAQQrgEQwQEgBEFAayQAIAIQqQEgAhB8IAIQqQEgACABEBEgACACEJoBIAAQtQEgA0HAAWokAAtZAQJ/IwBBQGoiAyQAIABBOBDQASIAQQE2AjgCQCABQQBOBEAgACABEJMBDAELIANBCGoiAkHAssAAEEkgAiABEJMBIAIQQiAAIAIQagsgABBUIANBQGskAAu9CAEKfyMAQYABayIHJAAgB0EIaiIDQcCywAAQSSADQQEQlAECQAJAA0AgAUEwRgRAIANBMGogAykDMEIBhzcDACADQThqIQEDQCACRQ0EIAFCADcDACACQQFrIQIgAUEIaiEBDAALAAsgAUE4Rg0BIAFBOEcEQCABIANqIAEgA2oiBEEIaikDAEI5hkL//////////wODIAQpAwBCAYeENwMAIAVBAWohBSABQQhqIQEMAQsLQQdBB0GEm8AAEDsACyAFQQdB9JrAABA7AAsgA0EBEJQBIANBARAsIAdBQGshBUEAIQIjAEGgCmsiASQAIAFBOBDQASIBQUBrQTgQ0AEhBiABQYABakE4ENABGiABQcABakE4ENABGiABQYACakE4ENABGiABQcACakE4ENABGiABQYADakE4ENABGiABQcADakE4ENABGiABQYAEakE4ENABGiABQcAEakE4ENABGiABQYAFakE4ENABGiABQcAFakE4ENABGiABQYAGakE4ENABGiABQcAGakE4ENABGiABQYAHakE4ENABGiABQcAHakE4ENABGiABQfgHakEBNgIAIAFBuAdqQQE2AgAgAUH4BmpBATYCACABQbgGakEBNgIAIAFB+AVqQQE2AgAgAUG4BWpBATYCACABQfgEakEBNgIAIAFBuARqQQE2AgAgAUH4A2pBATYCACABQbgDakEBNgIAIAFB+AJqQQE2AgAgAUG4AmpBATYCACABQfgBakEBNgIAIAFBuAFqQQE2AgAgAUH4AGpBATYCACABQQE2AjggAUGBCGpB5wAQ0AEaIAFB6AhqIgQgABCQASAEEEIgAUGoCWoiBCADEF0gBBBCIAQQKkEDaiIIQQJ2IgNBAWohCQJAA0AgAiAJRgRAIAEQygEgBiABQegIahCuASABQeAJakE4ENABGiABQQE2ApgKQYB5IQIMAgsgAUGoCWoiBCAEQQQQjwEiChCUASAEEEIgAkHnAEcEQCABQYEIaiACaiAKOgAAIAFBqAlqQQQQLCACQQFqIQIMAQsLQecAQecAQaC0wAAQOwALA0AgAgRAIAFB4AlqIgQgASACaiIGQcAHahCuASAGQYAIaiIGIAQQrgEgBiABQegIahBKIAJBQGshAgwBCwsCQAJAAkACQCAIQZwDSQRAIAFBgQhqIANqLAAAIgJBEE8NASAFIAEgAkEGdGoQkAEgA0EBayICQeYASyEEA0AgAkF/Rg0DIAUQTCAFEEwgBRBMIAUQTCAEDQQgAUGBCGogAmotAAAiA0EQSQRAIAUgASADQQZ0ahBKIAJBAWshAgwBCwsgA0EYdEEYdUEQQeC0wAAQOwALIANB5wBBsLTAABA7AAsgAkEQQcC0wAAQOwALIAUQHiABQaAKaiQADAELIAJB5wBB0LTAABA7AAsgACAFEK4BIAdBgAFqJAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQE2AgAgA0ICNwIMIANB2LjAADYCCCADQQE2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEGYAC2UBAn8gACAAKAIAIgJBCGoiAzYCACAAIAJBA3ZBPHFqQShqIgIgAUH/AXEgAigCAEEIdHI2AgACQAJAIANFBEAgAEEANgIAIAAgACgCBEEBajYCBAwBCyADQf8DcQ0BCyAAEA8LC1wAIABBOBDQASIAQQE2AjggAEFAa0E4ENABGiAAQfgAakEBNgIAIABBgAFqEFEgAEGAAmpBOBDQARogAEG4AmpBATYCACAAQcACakE4ENABGiAAQfgCakEBNgIAC1sBA38jAEGAAWsiASQAIAAQqQEgASAAEJABIAFBQGsiAiAAQUBrIgMQkAEgARBMIAIQTCABIAIQdyABQQAQMyAAIAEQSiABEEMgARBCIAMgARBKIAFBgAFqJAALYQEBfyMAQYACayIDJAAgABA9IAAgARCZASAAQYABaiIBIAIQmQEgAEGAAmoQtwEgABCpASADIAAQOCADQYABaiICIAEQXiACEC0gAiADEHpFBEAgABCbAQsgA0GAAmokAAtUAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqIAJBCGoQDCACQSBqJAALZwAjAEEwayIBJABBpLvAAC0AAARAIAFBHGpBATYCACABQgI3AgwgAUGQtsAANgIIIAFBATYCJCABIAA2AiwgASABQSBqNgIYIAEgAUEsajYCICABQQhqQbi2wAAQZgALIAFBMGokAAtiAgF+An8gACkDACEBA34gACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkEoRgR+IAAgACkDMCABfCIBNwMwIAFCJIcFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLGgt8AQV/IwBBQGoiAyQAIANBCGoiAkHAssAAEEkgAiAAKAI4QQFrEDUiBBAoA0AgAUE4RwRAIAAgAWoiBSABIAJqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAEEBIARBAWp0IgI2AjggAkH///8PSgRAIAAQHgsgA0FAayQAC3sBAn8gAEEoaiECA0AgAUGAAkYEQCAAQufMp9DW0Ouzu383AgggAEIANwIAIABBIGpCq7OP/JGjs/DbADcCACAAQRhqQv+kuYjFkdqCm383AgAgAEEQakLy5rvjo6f9p6V/NwIABSABIAJqQQA2AgAgAUEEaiEBDAELCwtUACAAQTgQ0AEiAEEBNgI4IABBQGtBOBDQARogAEH4AGpBATYCACAAQYABakE4ENABGiAAQbgBakEBNgIAIABBwAFqQTgQ0AEaIABB+AFqQQE2AgALWAECfyMAQUBqIgEkAAJAIAAQhgENACABQQEQOSAAQYABaiICIAEQWA0AIAJBABAzIAAgAhBKIAAQHiAAQUBrIgAgAhBKIAAQHiACIAEQrgELIAFBQGskAAtZAQJ/IwBBgAFrIgEkAAJAIAAQigENACABEFEgAEGAAmoiAiABEHoNACACED4gACACEBEgABC1ASAAQYABaiIAIAIQESAAELUBIAIgARCZAQsgAUGAAWokAAtbAgF+An8gACkDACEBA0AgACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkHgAEYEQCAAIAApA2ggAXw3A2gFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLC08BAX8gAEE4ENABGgJAA0AgAkEHRwRAIAJBB0YNAiAAIAEpAwA3AwAgAEEIaiEAIAFBCGohASACQQFqIQIMAQsLDwtBB0EHQeSawAAQOwALVAECfyMAQbABayICJAAgATQCOCAANAI4fkL///8PVQRAIAAQHgsgAkEIaiIDIAAgARAFIAJB+ABqIgEgAxBrIAAgARBqIABBAjYCOCACQbABaiQAC1EBAn8jAEFAaiIDJAAgAEE4ENABIgBBATYCOCAAQUBrQTgQ0AEgAEH4AGpBATYCACADIAEQjgEgACADEK4BIAMgAhCOASADEK4BIANBQGskAAvwDAIRfwh+IwBBsAFrIg8kACAANAI4IhIgEn5C////D1YEQCAAEB4LIwBB0AFrIgEkACAPQQhqIgZBCGpB0AAQ0AEaIAFBwAFqIAApAwAiFyAXQj+HIhYgFyAWEC8gBiABKQPAASISQv//////////A4M3AwAgAUHIAWopAwAiFUIGhiASQjqIhCETIBVCOoghGCAAQQhqIgwhDSAAIQlBASEKQQEhBwJAA0AgCkEERgRAIABBGGohCiAAQRBqIQkgAEEoaiEMIAApAzAhF0EHIQUgAUHIAGohCwNAIAVBC0kEQCABQUBrIAVBA3QiCCAAakEwaykDACISIBJCP4cgFyAXQj+HIhYQLyAFQQFqIg1BAXYhByALKQMAIRUgASkDQCESIAkhAiAMIQQgBUEFayIOIQMDQCADIAdJBEAgASACKQMAIhQgFEI/hyAEKQMAIhQgFEI/hxAvIAEpAwAiFCASfCISIBRUrSABQQhqKQMAIBV8fCEVIAJBCGohAiAEQQhrIQQgA0EBaiEDDAELCyAGIAhqIBJCAYYiFCATfCITQv//////////A4M3AwAgAUEwaiAAIA5BA3RqKQMAIhkgGUI/hyAXIBYQLyATIBRU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aikDADcDACACQQhqIQIMAQsLC4QJAg1/Cn4jAEFAaiILJAAgC0EIaiIJQcCywAAQSSMAQZACayICJAAgAEEwENABIQogAkHoAGpB8AAQ0AEaIAJB4AFqQTAQ0AEaIAoQcSACIAEiDCkDACIQQv3/8//P///5AX5C//////////8DgyISNwPYASACQdgAaiASQgAgCSkDACIXIBdCP4ciGBAvIBAgAikDWCIPfCITIA9UrSACQeAAaikDACAQQj+HfHwiEEI6hyABKQMIIg9CP4d8IA8gEEIGhiATQjqIhCITfCIQIBNUrXwhD0EBIQBCACETAkACQANAAkAgAEEHRgRAQQYhB0EAIQhBByEADAELIABBAXYiAUEBaiEGIAggAWshAyABQQN0IgFBCGohBCAHIAFrIQUgAkHIAGogCSAAQQN0Ig1qKQMAIhUgFUI/hyIWIBJCABAvIAJB0ABqKQMAIBAgECATfCIRVq0gDyAUfHx8IBEgAikDSHwiDyARVK18IRAgAEEBaiEBA0AgACAGTQRAIAJB2AFqIA1qIA9C/f/z/8////kBfkL//////////wODIhE3AwAgAkE4aiARQgAgFyAYEC8gAkEoaiARQgAgFSAWEC8gAkHoAGogAEEEdGoiACACQTBqKQMAIhE3AwggACACKQMoIhU3AwAgDyACKQM4IhZ8Ig8gFlStIAJBQGspAwAgEHx8IhBCOocgDCABQQN0aikDACIWQj+HfCAWIBBCBoYgD0I6iIQiD3wiECAPVK18IQ8gEyAVfCITIBVUrSARIBR8fCEUIAdBCGohByAIQQFqIQggASEADAMLIANBB08NAyACQRhqIAQgCWopAwAgBSAJaikDAH0iESARQj+HIAJB2AFqIg4gBWopAwAgBCAOaikDAH0iESARQj+HEC8gAikDGCIRIA98Ig8gEVStIAJBIGopAwAgEHx8IRAgBkEBaiEGIARBCGohBCAFQQhrIQUgA0EBayEDDAALAAsLA0ACQAJAIABBDUcEQCAHIABBAXYiBmshAyAIIAZBA3QiAWshBCABQQhqIQUgDyAUfCAQIBN8Ig8gEFStfCEQIABBAWohAQNAIAZBBUsNAyADQQdPDQIgAkEIaiAFIAlqKQMAIAQgCWpBMGopAwB9IhIgEkI/hyACIARqQYgCaikDACACQdgBaiAFaikDAH0iEiASQj+HEC8gAikDCCISIA98Ig8gElStIAJBEGopAwAgEHx8IRAgBkEBaiEGIARBCGshBCADQQFrIQMgBUEIaiEFDAALAAsgCiAQQv//////////A4M3AzAgAkGQAmokAAwECyADQQdBpJzAABA7AAsgAEEDdCAKakE4ayAPQv//////////A4M3AwAgEEI6hyAMIAFBA3RqKQMAIhJCP4d8IBIgEEIGhiAPQjqIhCIPfCIQIA9UrXwhDyAUIABBBHQgAmpBCGoiAEEIaikDAH0gEyAAKQMAIhJUrX0hFCAIQQhqIQggB0EBaiEHIBMgEn0hEyABIQAMAAsACyADQQdBlJzAABA7AAsgC0FAayQACy4BAX8jAEGAAWsiASQAIAAQRSABEFEgACABEJkBIABBgAFqELYBIAFBgAFqJAALMwAgACABEJYBIABBgAJqIAFBgAJqEJYBIABBgARqIAFBgARqEJYBIAAgASgCgAY2AoAGCygAIAAgASACEHIgAEFAayABQUBrIAIQciAAQYABaiABQYABaiACEHILLQAgACABIAIQjQEgAEGAAWogAUGAAWogAhCNASAAQYACaiABQYACaiACEI0BCycBAn8jAEFAaiICJAAgAkEIaiIDIAEQvgEgACADEI4BIAJBQGskAAsiAQF/A0AgAUE4RwRAIAAgAWpCADcDACABQQhqIQEMAQsLCyUAIAAgASACEDAgAEEAIAJrIAAoAjgiACABKAI4c3EgAHM2AjgLJwAgACAAKAIEQQFxIAFyQQJyNgIEIAAgAWoiACAAKAIEQQFyNgIECyMAA0AgAgRAIAAgAS0AABA8IAJBAWshAiABQQFqIQEMAQsLCywAIAAQiwEgACABEJYBIABBgAJqIAIQlgEgAEGABGogAxCWASAAQQU2AoAGCyMBAX8jAEFAaiIBJAAgASAAEJABIAEQHiABEFcgAUFAayQACykAIAAgARBgIAAgACgCOCABKAI4aiIBNgI4IAFB////D0oEQCAAEB4LCyUAIAAgARCuASAAQUBrIAFBQGsQrgEgAEGAAWogAUGAAWoQrgELKAEBfyMAQYACayICJAAgAiABEIwBIAIQKyAAIAIQlwEgAkGAAmokAAscAQF/IAAgARBYBH8gAEFAayABQUBrEFgFQQALCycBAX8jAEGAAWsiAiQAIAIg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DCELDQALCyAMpyICQeMASwRAIABBAmsiACAGQQlqaiAMpyICIAJB//8DcUHkAG4iAkHkAGxrQf//A3FBAXRB6LjAAGovAAA7AAALAkAgAkEKTwRAIABBAmsiACAGQQlqaiACQQF0Qei4wABqLwAAOwAADAELIABBAWsiACAGQQlqaiACQTBqOgAACwJ/IAZBCWogAGohCEErQYCAxAAgASgCACIDQQFxIgIbIQQgAkEnIABrIglqIQJBlLjAAEEAIANBBHEbIQUCQAJAIAEoAghFBEBBASEAIAEgBCAFEFINAQwCCwJAAkACQAJAIAIgAUEMaigCACIDSQRAIAEtAABBCHENBEEAIQAgAyACayICIQNBASABLQAgIgcgB0EDRhtBA3FBAWsOAgECAwtBASEAIAEgBCAFEFINBAwFC0EAIQMgAiEADAELIAJBAXYhACACQQFqQQF2IQMLIABBAWohACABQRxqKAIAIQcgASgCBCECIAEoAhghCgJAA0AgAEEBayIARQ0BIAogAiAHKAIQEQQARQ0AC0EBDAQLQQEhACACQYCAxABGDQEgASAEIAUQUg0BIAEoAhggCCAJIAEoAhwoAgwRBQANASABKAIcIQQgASgCGCEBQQAhAAJ/A0AgAyAAIANGDQEaIABBAWohACABIAIgBCgCEBEEAEUNAAsgAEEBawsgA0khAAwBCyABKAIEIQcgAUEwNgIEIAEtACAhCkEBIQAgAUEBOgAgIAEgBCAFEFINAEEAIQAgAyACayICIQMCQAJAAkBBASABLQAgIgQgBEEDRhtBA3FBAWsOAgABAgtBACEDIAIhAAwBCyACQQF2IQAgAkEBakEBdiEDCyAAQQFqIQAgAUEcaigCACECIAEoAgQhBCABKAIYIQUCQANAIABBAWsiAEUNASAFIAQgAigCEBEEAEUNAAtBAQwDC0EBIQAgBEGAgMQARg0AIAEoAhggCCAJIAEoAhwoAgwRBQANACABKAIcIQAgASgCGCEFQQAhAgJAA0AgAiADRg0BIAJBAWohAiAFIAQgACgCEBEEAEUNAAtBASEAIAJBAWsgA0kNAQsgASAKOgAgIAEgBzYCBEEADAILIAAMAQsgASgCGCAIIAkgAUEcaigCACgCDBEFAAsgBkEwaiQACwsAIAAQNiAAELABCysCAX8BfkIBIQIDQCAAIAFq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AAANAEHgs8AAC8EHYXR0ZW1wdCB0byBkaXZpZGUgYnkgemVybwAAAAAAAABhdHRlbXB0IHRvIGRpdmlkZSB3aXRoIG92ZXJmbG93ALAZEAASAAAADAIAAA0AAACwGRAAEgAAABgCAAAmAAAAsBkQABIAAAAYAgAAIwAAALAZEAASAAAAHgIAABcAAACwGRAAEgAAAB4CAAAUAAAAqqr//////gHu//9UrP//AupBYg9rDyoBw5z9ShTOEwJLd2TXrEtDAu3pxpKm+V8Cox4RoAEAAAADAAAABAAAAAQAAAAEAAAABQAAAAYAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAoAAOsaEAAVAAAAABsQAA4AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnMgGxAAGAAAAEkBAAAJAAAAbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5yc0gbEAAcAAAARgIAAB8AAABIGxAAHAAAAEcCAAAeAAAABwAAAAwAAAAEAAAACAAAAAMAAAAIAAAABAAAAAkAAAAKAAAAEAAAAAQAAAALAAAADAAAAAMAAAAIAAAABAAAAA0AAAAOAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAA6BsQABEAAADMGxAAHAAAAAUCAAAFAAAAEAAAAAAAAAABAAAAEQAAAGluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAAkHBAAIAAAAEQcEAASAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5yc3JhbmdlIGVuZCBpbmRleCAAAABxHRAAEAAAADAdEAAiAAAAUh0QAB8AAABJAAAABQB7CXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS42MS4wIChmZTViMTNkNjggMjAyMi0wNS0xOCkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4SMC4yLjgxICgwNjJhYTVmNzAp`;
});

// node_modules/@dfinity/agent/lib/cjs/vendor/bls/bls.js
var require_bls = __commonJS((exports) => {
  var bls_init2 = function() {
    let ret2 = wasm3.bls_init();
    return ret2;
  };
  var getUint8Memory02 = function() {
    if (cachegetUint8Memory02 === null || cachegetUint8Memory02.buffer !== wasm3.memory.buffer) {
      cachegetUint8Memory02 = new Uint8Array(wasm3.memory.buffer);
    }
    return cachegetUint8Memory02;
  };
  var passArray8ToWasm02 = function(arg, malloc) {
    const ptr = malloc(arg.length * 1);
    getUint8Memory02().set(arg, ptr / 1);
    return [ptr, arg.length];
  };
  var bls_verify2 = function(sig, m, w) {
    const [ptr0, len0] = passArray8ToWasm02(sig, wasm3.__wbindgen_malloc);
    const [ptr1, len1] = passArray8ToWasm02(m, wasm3.__wbindgen_malloc);
    const [ptr2, len2] = passArray8ToWasm02(w, wasm3.__wbindgen_malloc);
    const ret2 = wasm3.bls_verify(ptr0, len0, ptr1, len1, ptr2, len2);
    return ret2;
  };
  async function load2(module2, imports) {
    if (typeof Response === "function" && module2 instanceof Response) {
      const bytes = await module2.arrayBuffer();
      return await WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = await WebAssembly.instantiate(module2, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module: module2 };
      } else {
        return instance;
      }
    }
  }
  async function init2() {
    const imports = {};
    const { instance, module: module2 } = await load2(wasmBytes2, imports);
    wasm3 = instance.exports;
    init2.__wbindgen_wasm_module = module2;
    return wasm3;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bls_verify = exports.bls_init = undefined;
  var base64Arraybuffer2 = __importStar(require_base64_arraybuffer());
  var wasm_1 = require_wasm();
  var wasm3;
  var wasmBytes2 = base64Arraybuffer2.decode(wasm_1.wasmBytesBase64);
  exports.bls_init = bls_init2;
  var cachegetUint8Memory02 = null;
  exports.bls_verify = bls_verify2;
  exports.default = init2;
});

// node_modules/@dfinity/agent/lib/cjs/utils/bls.js
var require_bls2 = __commonJS((exports) => {
  async function blsVerify2(pk, sig, msg) {
    if (!exports.verify) {
      await (0, bls_1.default)();
      if ((0, bls_1.bls_init)() !== 0) {
        throw new Error("Cannot initialize BLS");
      }
      exports.verify = (pk1, sig1, msg1) => {
        return (0, bls_1.bls_verify)(sig1, msg1, pk1) === 0;
      };
    }
    return (0, exports.verify)(pk, sig, msg);
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.blsVerify = exports.verify = undefined;
  var bls_1 = __importStar(require_bls());
  exports.blsVerify = blsVerify2;
});

// node_modules/@dfinity/agent/lib/cjs/certificate.js
var require_certificate = __commonJS((exports) => {
  var hashTreeToString = function(tree) {
    const indent = (s2) => s2.split("\n").map((x2) => "  " + x2).join("\n");
    function labelToString(label) {
      const decoder = new TextDecoder(undefined, { fatal: true });
      try {
        return JSON.stringify(decoder.decode(label));
      } catch (e) {
        return `data(...${label.byteLength} bytes)`;
      }
    }
    switch (tree[0]) {
      case 0:
        return "()";
      case 1: {
        const left = hashTreeToString(tree[1]);
        const right = hashTreeToString(tree[2]);
        return `sub(\n left:\n${indent(left)}\n---\n right:\n${indent(right)}\n)`;
      }
      case 2: {
        const label = labelToString(tree[1]);
        const sub = hashTreeToString(tree[2]);
        return `label(\n label:\n${indent(label)}\n sub:\n${indent(sub)}\n)`;
      }
      case 3: {
        return `leaf(...${tree[1].byteLength} bytes)`;
      }
      case 4: {
        return `pruned(${(0, buffer_1.toHex)(new Uint8Array(tree[1]))}`;
      }
      default: {
        return `unknown(${JSON.stringify(tree[0])})`;
      }
    }
  };
  var isBufferEqual2 = function(a, b2) {
    if (a.byteLength !== b2.byteLength) {
      return false;
    }
    const a8 = new Uint8Array(a);
    const b8 = new Uint8Array(b2);
    for (let i = 0;i < a8.length; i++) {
      if (a8[i] !== b8[i]) {
        return false;
      }
    }
    return true;
  };
  var extractDER2 = function(buf) {
    const expectedLength = DER_PREFIX2.byteLength + KEY_LENGTH2;
    if (buf.byteLength !== expectedLength) {
      throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);
    }
    const prefix = buf.slice(0, DER_PREFIX2.byteLength);
    if (!isBufferEqual2(prefix, DER_PREFIX2)) {
      throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX2}, but get ${prefix}`);
    }
    return buf.slice(DER_PREFIX2.byteLength);
  };
  async function reconstruct2(t2) {
    switch (t2[0]) {
      case 0:
        return (0, request_id_1.hash)(domain_sep2("ic-hashtree-empty"));
      case 4:
        return t2[1];
      case 3:
        return (0, request_id_1.hash)((0, buffer_1.concat)(domain_sep2("ic-hashtree-leaf"), t2[1]));
      case 2:
        return (0, request_id_1.hash)((0, buffer_1.concat)(domain_sep2("ic-hashtree-labeled"), t2[1], await reconstruct2(t2[2])));
      case 1:
        return (0, request_id_1.hash)((0, buffer_1.concat)(domain_sep2("ic-hashtree-fork"), await reconstruct2(t2[1]), await reconstruct2(t2[2])));
      default:
        throw new Error("unreachable");
    }
  }
  var domain_sep2 = function(s2) {
    const len = new Uint8Array([s2.length]);
    const str = new TextEncoder().encode(s2);
    return (0, buffer_1.concat)(len, str);
  };
  var lookup_path2 = function(path, tree) {
    if (path.length === 0) {
      switch (tree[0]) {
        case 3: {
          return new Uint8Array(tree[1]).buffer;
        }
        default: {
          return;
        }
      }
    }
    const label = typeof path[0] === "string" ? new TextEncoder().encode(path[0]) : path[0];
    const t2 = find_label2(label, flatten_forks2(tree));
    if (t2) {
      return lookup_path2(path.slice(1), t2);
    }
  };
  var flatten_forks2 = function(t2) {
    switch (t2[0]) {
      case 0:
        return [];
      case 1:
        return flatten_forks2(t2[1]).concat(flatten_forks2(t2[2]));
      default:
        return [t2];
    }
  };
  var find_label2 = function(l, trees) {
    if (trees.length === 0) {
      return;
    }
    for (const t2 of trees) {
      if (t2[0] === 2) {
        const p = t2[1];
        if (isBufferEqual2(l, p)) {
          return t2[2];
        }
      }
    }
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lookup_path = exports.reconstruct = exports.Certificate = exports.hashTreeToString = exports.CertificateVerificationError = undefined;
  var cbor4 = __importStar(require_cbor());
  var errors_1 = require_errors();
  var request_id_1 = require_request_id();
  var buffer_1 = require_buffer3();
  var principal_1 = require_cjs2();
  var bls3 = __importStar(require_bls2());

  class CertificateVerificationError2 extends errors_1.AgentError {
    constructor(reason) {
      super(`Invalid certificate: ${reason}`);
    }
  }
  exports.CertificateVerificationError = CertificateVerificationError2;
  exports.hashTreeToString = hashTreeToString;

  class Certificate2 {
    constructor(certificate4, _rootKey, _canisterId, _blsVerify) {
      this._rootKey = _rootKey;
      this._canisterId = _canisterId;
      this._blsVerify = _blsVerify;
      this.cert = cbor4.decode(new Uint8Array(certificate4));
    }
    static async create(options) {
      let blsVerify2 = options.blsVerify;
      if (!blsVerify2) {
        blsVerify2 = bls3.blsVerify;
      }
      const cert = new Certificate2(options.certificate, options.rootKey, options.canisterId, blsVerify2);
      await cert.verify();
      return cert;
    }
    lookup(path) {
      return lookup_path2(path, this.cert.tree);
    }
    async verify() {
      const rootHash = await reconstruct2(this.cert.tree);
      const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);
      const sig = this.cert.signature;
      const key = extractDER2(derKey);
      const msg = (0, buffer_1.concat)(domain_sep2("ic-state-root"), rootHash);
      let sigVer = false;
      try {
        sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));
      } catch (err) {
        sigVer = false;
      }
      if (!sigVer) {
        throw new CertificateVerificationError2("Signature verification failed");
      }
    }
    async _checkDelegationAndGetKey(d) {
      if (!d) {
        return this._rootKey;
      }
      const cert = await Certificate2.create({
        certificate: d.certificate,
        rootKey: this._rootKey,
        canisterId: this._canisterId
      });
      const rangeLookup = cert.lookup(["subnet", d.subnet_id, "canister_ranges"]);
      if (!rangeLookup) {
        throw new CertificateVerificationError2(`Could not find canister ranges for subnet 0x${(0, buffer_1.toHex)(d.subnet_id)}`);
      }
      const ranges_arr = cbor4.decode(rangeLookup);
      const ranges = ranges_arr.map((v) => [
        principal_1.Principal.fromUint8Array(v[0]),
        principal_1.Principal.fromUint8Array(v[1])
      ]);
      const canisterInRange = ranges.some((r) => r[0].ltEq(this._canisterId) && r[1].gtEq(this._canisterId));
      if (!canisterInRange) {
        throw new CertificateVerificationError2(`Canister ${this._canisterId} not in range of delegations for subnet 0x${(0, buffer_1.toHex)(d.subnet_id)}`);
      }
      const publicKeyLookup = cert.lookup(["subnet", d.subnet_id, "public_key"]);
      if (!publicKeyLookup) {
        throw new Error(`Could not find subnet key for subnet 0x${(0, buffer_1.toHex)(d.subnet_id)}`);
      }
      return publicKeyLookup;
    }
  }
  exports.Certificate = Certificate2;
  var DER_PREFIX2 = (0, buffer_1.fromHex)("308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100");
  var KEY_LENGTH2 = 96;
  exports.reconstruct = reconstruct2;
  exports.lookup_path = lookup_path2;
});

// node_modules/@dfinity/agent/lib/cjs/canisterStatus/index.js
var require_canisterStatus = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodePath = exports.request = undefined;
  var candid_1 = require_cjs3();
  var principal_1 = require_cjs2();
  var errors_1 = require_errors();
  var certificate_1 = require_certificate();
  var buffer_1 = require_buffer3();
  var Cbor = __importStar(require_cbor());
  var request2 = async (options) => {
    const { canisterId, agent: agent14, paths } = options;
    const uniquePaths = [...new Set(paths)];
    const encodedPaths = uniquePaths.map((path) => {
      return (0, exports.encodePath)(path, canisterId);
    });
    const status = new Map;
    const promises2 = uniquePaths.map((path, index) => {
      return (async () => {
        var _a;
        try {
          const response = await agent14.readState(canisterId, {
            paths: [encodedPaths[index]]
          });
          const cert = await certificate_1.Certificate.create({
            certificate: response.certificate,
            rootKey: agent14.rootKey,
            canisterId
          });
          const data = cert.lookup((0, exports.encodePath)(uniquePaths[index], canisterId));
          if (!data) {
            console.warn(`Expected to find result for path ${path}, but instead found nothing.`);
            if (typeof path === "string") {
              status.set(path, null);
            } else {
              status.set(path.key, null);
            }
          } else {
            switch (path) {
              case "time": {
                status.set(path, decodeTime2(data));
                break;
              }
              case "controllers": {
                status.set(path, decodeControllers2(data));
                break;
              }
              case "module_hash": {
                status.set(path, decodeHex2(data));
                break;
              }
              case "candid": {
                status.set(path, new TextDecoder().decode(data));
                break;
              }
              default: {
                if (typeof path !== "string" && ("key" in path) && ("path" in path)) {
                  switch (path.decodeStrategy) {
                    case "raw":
                      status.set(path.key, data);
                      break;
                    case "leb128": {
                      status.set(path.key, decodeLeb1282(data));
                      break;
                    }
                    case "cbor": {
                      status.set(path.key, decodeCbor2(data));
                      break;
                    }
                    case "hex": {
                      status.set(path.key, decodeHex2(data));
                      break;
                    }
                    case "utf-8": {
                      status.set(path.key, decodeUtf82(data));
                    }
                  }
                }
              }
            }
          }
        } catch (error) {
          if ((_a = error === null || error === undefined ? undefined : error.message) === null || _a === undefined ? undefined : _a.includes("Invalid certificate")) {
            throw new errors_1.AgentError(error.message);
          }
          if (typeof path !== "string" && ("key" in path) && ("path" in path)) {
            status.set(path.key, null);
          } else {
            status.set(path, null);
          }
          console.group();
          console.warn(`Expected to find result for path ${path}, but instead found nothing.`);
          console.warn(error);
          console.groupEnd();
        }
      })();
    });
    await Promise.all(promises2);
    return status;
  };
  exports.request = request2;
  var encodePath2 = (path, canisterId) => {
    const encoder = new TextEncoder;
    const encode4 = (arg) => {
      return new DataView(encoder.encode(arg).buffer).buffer;
    };
    const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;
    switch (path) {
      case "time":
        return [encode4("time")];
      case "controllers":
        return [encode4("canister"), canisterBuffer, encode4("controllers")];
      case "module_hash":
        return [encode4("canister"), canisterBuffer, encode4("module_hash")];
      case "subnet":
        return [encode4("subnet")];
      case "candid":
        return [encode4("canister"), canisterBuffer, encode4("metadata"), encode4("candid:service")];
      default: {
        if (("key" in path) && ("path" in path)) {
          if (typeof path["path"] === "string" || path["path"] instanceof ArrayBuffer) {
            const metaPath = path.path;
            const encoded = typeof metaPath === "string" ? encode4(metaPath) : metaPath;
            return [encode4("canister"), canisterBuffer, encode4("metadata"), encoded];
          } else {
            return path["path"];
          }
        }
      }
    }
    throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`);
  };
  exports.encodePath = encodePath2;
  var decodeHex2 = (buf) => {
    return (0, buffer_1.toHex)(buf);
  };
  var decodeLeb1282 = (buf) => {
    return (0, candid_1.lebDecode)(new candid_1.PipeArrayBuffer(buf));
  };
  var decodeCbor2 = (buf) => {
    return Cbor.decode(buf);
  };
  var decodeUtf82 = (buf) => {
    return new TextDecoder().decode(buf);
  };
  var decodeTime2 = (buf) => {
    const decoded = decodeLeb1282(buf);
    return new Date(Number(decoded / BigInt(1e6)));
  };
  var decodeControllers2 = (buf) => {
    const [tag, ...controllersRaw] = decodeCbor2(buf);
    return controllersRaw.map((buf2) => {
      return principal_1.Principal.fromUint8Array(new Uint8Array(buf2));
    });
  };
});

// node_modules/@dfinity/agent/lib/cjs/agent/http/index.js
var require_http = __commonJS((exports) => {
  var getDefaultFetch2 = function() {
    let defaultFetch;
    if (typeof window !== "undefined") {
      if (window.fetch) {
        defaultFetch = window.fetch.bind(window);
      } else {
        throw new HttpDefaultFetchError2("Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.");
      }
    } else if (typeof global !== "undefined") {
      if (global.fetch) {
        defaultFetch = global.fetch.bind(global);
      } else {
        throw new HttpDefaultFetchError2("Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.");
      }
    } else if (typeof self !== "undefined") {
      if (self.fetch) {
        defaultFetch = self.fetch.bind(self);
      }
    }
    if (defaultFetch) {
      return defaultFetch;
    }
    throw new HttpDefaultFetchError2("Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.");
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpAgent = exports.IdentityInvalidError = exports.RequestStatusResponseStatus = exports.makeNonce = undefined;
  var principal_1 = require_cjs2();
  var errors_1 = require_errors();
  var auth_1 = require_auth();
  var cbor4 = __importStar(require_cbor());
  var request_id_1 = require_request_id();
  var buffer_1 = require_buffer3();
  var transforms_1 = require_transforms();
  var types_1 = require_types3();
  var errors_2 = require_errors2();
  __exportStar(require_transforms(), exports);
  var types_2 = require_types3();
  Object.defineProperty(exports, "makeNonce", { enumerable: true, get: function() {
    return types_2.makeNonce;
  } });
  var RequestStatusResponseStatus2;
  (function(RequestStatusResponseStatus3) {
    RequestStatusResponseStatus3["Received"] = "received";
    RequestStatusResponseStatus3["Processing"] = "processing";
    RequestStatusResponseStatus3["Replied"] = "replied";
    RequestStatusResponseStatus3["Rejected"] = "rejected";
    RequestStatusResponseStatus3["Unknown"] = "unknown";
    RequestStatusResponseStatus3["Done"] = "done";
  })(RequestStatusResponseStatus2 = exports.RequestStatusResponseStatus || (exports.RequestStatusResponseStatus = {}));
  var DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS2 = 5 * 60 * 1000;
  var IC_ROOT_KEY2 = "308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d9685f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484b01291091c5f87b98883463f98091a0baaae";
  var IC0_DOMAIN2 = "ic0.app";
  var IC0_SUB_DOMAIN2 = ".ic0.app";
  var ICP0_DOMAIN2 = "icp0.io";
  var ICP0_SUB_DOMAIN2 = ".icp0.io";
  var ICP_API_DOMAIN2 = "icp-api.io";
  var ICP_API_SUB_DOMAIN2 = ".icp-api.io";

  class HttpDefaultFetchError2 extends errors_1.AgentError {
    constructor(message) {
      super(message);
      this.message = message;
    }
  }

  class IdentityInvalidError2 extends errors_1.AgentError {
    constructor(message) {
      super(message);
      this.message = message;
    }
  }
  exports.IdentityInvalidError = IdentityInvalidError2;

  class HttpAgent2 {
    constructor(options = {}) {
      this.rootKey = (0, buffer_1.fromHex)(IC_ROOT_KEY2);
      this._pipeline = [];
      this._timeDiffMsecs = 0;
      this._rootKeyFetched = false;
      this._isAgent = true;
      if (options.source) {
        if (!(options.source instanceof HttpAgent2)) {
          throw new Error("An Agent's source can only be another HttpAgent");
        }
        this._pipeline = [...options.source._pipeline];
        this._identity = options.source._identity;
        this._fetch = options.source._fetch;
        this._host = options.source._host;
        this._credentials = options.source._credentials;
      } else {
        this._fetch = options.fetch || getDefaultFetch2() || fetch.bind(global);
        this._fetchOptions = options.fetchOptions;
        this._callOptions = options.callOptions;
      }
      if (options.host !== undefined) {
        if (!options.host.match(/^[a-z]+:/) && typeof window !== "undefined") {
          this._host = new URL(window.location.protocol + "//" + options.host);
        } else {
          this._host = new URL(options.host);
        }
      } else if (options.source !== undefined) {
        this._host = options.source._host;
      } else {
        const location = typeof window !== "undefined" ? window.location : undefined;
        if (!location) {
          throw new Error("Must specify a host to connect to.");
        }
        this._host = new URL(location + "");
      }
      this._retryTimes = options.retryTimes !== undefined && options.retryTimes >= 0 ? options.retryTimes : 3;
      if (this._host.hostname.endsWith(IC0_SUB_DOMAIN2)) {
        this._host.hostname = IC0_DOMAIN2;
      } else if (this._host.hostname.endsWith(ICP0_SUB_DOMAIN2)) {
        this._host.hostname = ICP0_DOMAIN2;
      } else if (this._host.hostname.endsWith(ICP_API_SUB_DOMAIN2)) {
        this._host.hostname = ICP_API_DOMAIN2;
      }
      if (options.credentials) {
        const { name, password } = options.credentials;
        this._credentials = `${name}${password ? ":" + password : ""}`;
      }
      this._identity = Promise.resolve(options.identity || new auth_1.AnonymousIdentity);
      if (!options.disableNonce) {
        this.addTransform((0, transforms_1.makeNonceTransform)(types_1.makeNonce));
      }
    }
    isLocal() {
      const hostname = this._host.hostname;
      return hostname === "127.0.0.1" || hostname.endsWith("localhost");
    }
    addTransform(fn, priority = fn.priority || 0) {
      const i = this._pipeline.findIndex((x2) => (x2.priority || 0) < priority);
      this._pipeline.splice(i >= 0 ? i : this._pipeline.length, 0, Object.assign(fn, { priority }));
    }
    async getPrincipal() {
      if (!this._identity) {
        throw new IdentityInvalidError2("This identity has expired due this application's security policy. Please refresh your authentication.");
      }
      return (await this._identity).getPrincipal();
    }
    async call(canisterId, options, identity2) {
      const id = await (identity2 !== undefined ? await identity2 : await this._identity);
      if (!id) {
        throw new IdentityInvalidError2("This identity has expired due this application's security policy. Please refresh your authentication.");
      }
      const canister = principal_1.Principal.from(canisterId);
      const ecid = options.effectiveCanisterId ? principal_1.Principal.from(options.effectiveCanisterId) : canister;
      const sender = id.getPrincipal() || principal_1.Principal.anonymous();
      let ingress_expiry = new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS2);
      if (Math.abs(this._timeDiffMsecs) > 1000 * 30) {
        ingress_expiry = new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS2 + this._timeDiffMsecs);
      }
      const submit = {
        request_type: types_1.SubmitRequestType.Call,
        canister_id: canister,
        method_name: options.methodName,
        arg: options.arg,
        sender,
        ingress_expiry
      };
      let transformedRequest = await this._transform({
        request: {
          body: null,
          method: "POST",
          headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
        },
        endpoint: "call",
        body: submit
      });
      transformedRequest = await id.transformRequest(transformedRequest);
      const body = cbor4.encode(transformedRequest.body);
      const request2 = this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign(Object.assign({}, this._callOptions), transformedRequest.request), { body })));
      const [response, requestId] = await Promise.all([request2, (0, request_id_1.requestIdOf)(submit)]);
      const responseBuffer = await response.arrayBuffer();
      const responseBody = response.status === 200 && responseBuffer.byteLength > 0 ? cbor4.decode(responseBuffer) : null;
      return {
        requestId,
        response: {
          ok: response.ok,
          status: response.status,
          statusText: response.statusText,
          body: responseBody,
          headers: (0, transforms_1.httpHeadersTransform)(response.headers)
        }
      };
    }
    async _requestAndRetry(request2, tries = 0) {
      const response = await request2();
      if (response.ok) {
        return response;
      }
      const responseText = await response.clone().text();
      const errorMessage = `Server returned an error:\n` + `  Code: ${response.status} (${response.statusText})\n` + `  Body: ${responseText}\n`;
      if (this._retryTimes > tries) {
        console.warn(errorMessage + `  Retrying request.`);
        return await this._requestAndRetry(request2, tries + 1);
      }
      throw new errors_2.AgentHTTPResponseError(errorMessage, {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
        headers: (0, transforms_1.httpHeadersTransform)(response.headers)
      });
    }
    async query(canisterId, fields, identity2) {
      const id = await (identity2 !== undefined ? await identity2 : await this._identity);
      if (!id) {
        throw new IdentityInvalidError2("This identity has expired due this application's security policy. Please refresh your authentication.");
      }
      const canister = typeof canisterId === "string" ? principal_1.Principal.fromText(canisterId) : canisterId;
      const sender = (id === null || id === undefined ? undefined : id.getPrincipal()) || principal_1.Principal.anonymous();
      const request2 = {
        request_type: "query",
        canister_id: canister,
        method_name: fields.methodName,
        arg: fields.arg,
        sender,
        ingress_expiry: new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS2)
      };
      let transformedRequest = await this._transform({
        request: {
          method: "POST",
          headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
        },
        endpoint: "read",
        body: request2
      });
      transformedRequest = await (id === null || id === undefined ? undefined : id.transformRequest(transformedRequest));
      const body = cbor4.encode(transformedRequest.body);
      const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
      const queryResponse = cbor4.decode(await response.arrayBuffer());
      return Object.assign(Object.assign({}, queryResponse), { httpDetails: {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
        headers: (0, transforms_1.httpHeadersTransform)(response.headers)
      } });
    }
    async createReadStateRequest(fields, identity2) {
      const id = await (identity2 !== undefined ? await identity2 : await this._identity);
      if (!id) {
        throw new IdentityInvalidError2("This identity has expired due this application's security policy. Please refresh your authentication.");
      }
      const sender = (id === null || id === undefined ? undefined : id.getPrincipal()) || principal_1.Principal.anonymous();
      const transformedRequest = await this._transform({
        request: {
          method: "POST",
          headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
        },
        endpoint: "read_state",
        body: {
          request_type: "read_state",
          paths: fields.paths,
          sender,
          ingress_expiry: new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS2)
        }
      });
      return id === null || id === undefined ? undefined : id.transformRequest(transformedRequest);
    }
    async readState(canisterId, fields, identity2, request2) {
      const canister = typeof canisterId === "string" ? principal_1.Principal.fromText(canisterId) : canisterId;
      const transformedRequest = request2 !== null && request2 !== undefined ? request2 : await this.createReadStateRequest(fields, identity2);
      const body = cbor4.encode(transformedRequest.body);
      const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
      if (!response.ok) {
        throw new Error(`Server returned an error:\n` + `  Code: ${response.status} (${response.statusText})\n` + `  Body: ${await response.text()}\n`);
      }
      return cbor4.decode(await response.arrayBuffer());
    }
    async syncTime(canisterId) {
      const CanisterStatus = await Promise.resolve().then(() => __importStar(require_canisterStatus()));
      const callTime = Date.now();
      try {
        if (!canisterId) {
          console.log("Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai");
        }
        const status = await CanisterStatus.request({
          canisterId: canisterId !== null && canisterId !== undefined ? canisterId : principal_1.Principal.from("ryjl3-tyaaa-aaaaa-aaaba-cai"),
          agent: this,
          paths: ["time"]
        });
        const replicaTime = status.get("time");
        if (replicaTime) {
          this._timeDiffMsecs = Number(replicaTime) - Number(callTime);
        }
      } catch (error) {
        console.error("Caught exception while attempting to sync time:", error);
      }
    }
    async status() {
      const headers = this._credentials ? {
        Authorization: "Basic " + btoa(this._credentials)
      } : {};
      const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/status`, this._host), Object.assign({ headers }, this._fetchOptions)));
      return cbor4.decode(await response.arrayBuffer());
    }
    async fetchRootKey() {
      if (!this._rootKeyFetched) {
        this.rootKey = (await this.status()).root_key;
        this._rootKeyFetched = true;
      }
      return this.rootKey;
    }
    invalidateIdentity() {
      this._identity = null;
    }
    replaceIdentity(identity2) {
      this._identity = Promise.resolve(identity2);
    }
    _transform(request2) {
      let p = Promise.resolve(request2);
      for (const fn of this._pipeline) {
        p = p.then((r) => fn(r).then((r2) => r2 || r));
      }
      return p;
    }
  }
  exports.HttpAgent = HttpAgent2;
});

// node_modules/@dfinity/agent/lib/cjs/agent/proxy.js
var require_proxy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyAgent = exports.ProxyStubAgent = exports.ProxyMessageKind = undefined;
  var principal_1 = require_cjs2();
  var ProxyMessageKind2;
  (function(ProxyMessageKind3) {
    ProxyMessageKind3["Error"] = "err";
    ProxyMessageKind3["GetPrincipal"] = "gp";
    ProxyMessageKind3["GetPrincipalResponse"] = "gpr";
    ProxyMessageKind3["Query"] = "q";
    ProxyMessageKind3["QueryResponse"] = "qr";
    ProxyMessageKind3["Call"] = "c";
    ProxyMessageKind3["CallResponse"] = "cr";
    ProxyMessageKind3["ReadState"] = "rs";
    ProxyMessageKind3["ReadStateResponse"] = "rsr";
    ProxyMessageKind3["Status"] = "s";
    ProxyMessageKind3["StatusResponse"] = "sr";
  })(ProxyMessageKind2 = exports.ProxyMessageKind || (exports.ProxyMessageKind = {}));

  class ProxyStubAgent {
    constructor(_frontend, _agent) {
      this._frontend = _frontend;
      this._agent = _agent;
    }
    onmessage(msg) {
      switch (msg.type) {
        case ProxyMessageKind2.GetPrincipal:
          this._agent.getPrincipal().then((response) => {
            this._frontend({
              id: msg.id,
              type: ProxyMessageKind2.GetPrincipalResponse,
              response: response.toText()
            });
          });
          break;
        case ProxyMessageKind2.Query:
          this._agent.query(...msg.args).then((response) => {
            this._frontend({
              id: msg.id,
              type: ProxyMessageKind2.QueryResponse,
              response
            });
          });
          break;
        case ProxyMessageKind2.Call:
          this._agent.call(...msg.args).then((response) => {
            this._frontend({
              id: msg.id,
              type: ProxyMessageKind2.CallResponse,
              response
            });
          });
          break;
        case ProxyMessageKind2.ReadState:
          this._agent.readState(...msg.args).then((response) => {
            this._frontend({
              id: msg.id,
              type: ProxyMessageKind2.ReadStateResponse,
              response
            });
          });
          break;
        case ProxyMessageKind2.Status:
          this._agent.status().then((response) => {
            this._frontend({
              id: msg.id,
              type: ProxyMessageKind2.StatusResponse,
              response
            });
          });
          break;
        default:
          throw new Error(`Invalid message received: ${JSON.stringify(msg)}`);
      }
    }
  }
  exports.ProxyStubAgent = ProxyStubAgent;

  class ProxyAgent {
    constructor(_backend) {
      this._backend = _backend;
      this._nextId = 0;
      this._pendingCalls = new Map;
      this.rootKey = null;
    }
    onmessage(msg) {
      const id = msg.id;
      const maybePromise = this._pendingCalls.get(id);
      if (!maybePromise) {
        throw new Error("A proxy get the same message twice...");
      }
      this._pendingCalls.delete(id);
      const [resolve, reject] = maybePromise;
      switch (msg.type) {
        case ProxyMessageKind2.Error:
          return reject(msg.error);
        case ProxyMessageKind2.GetPrincipalResponse:
        case ProxyMessageKind2.CallResponse:
        case ProxyMessageKind2.QueryResponse:
        case ProxyMessageKind2.ReadStateResponse:
        case ProxyMessageKind2.StatusResponse:
          return resolve(msg.response);
        default:
          throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`);
      }
    }
    async getPrincipal() {
      return this._sendAndWait({
        id: this._nextId++,
        type: ProxyMessageKind2.GetPrincipal
      }).then((principal15) => {
        if (typeof principal15 !== "string") {
          throw new Error("Invalid principal received.");
        }
        return principal_1.Principal.fromText(principal15);
      });
    }
    readState(canisterId, fields) {
      return this._sendAndWait({
        id: this._nextId++,
        type: ProxyMessageKind2.ReadState,
        args: [canisterId.toString(), fields]
      });
    }
    call(canisterId, fields) {
      return this._sendAndWait({
        id: this._nextId++,
        type: ProxyMessageKind2.Call,
        args: [canisterId.toString(), fields]
      });
    }
    status() {
      return this._sendAndWait({
        id: this._nextId++,
        type: ProxyMessageKind2.Status
      });
    }
    query(canisterId, fields) {
      return this._sendAndWait({
        id: this._nextId++,
        type: ProxyMessageKind2.Query,
        args: [canisterId.toString(), fields]
      });
    }
    async _sendAndWait(msg) {
      return new Promise((resolve, reject) => {
        this._pendingCalls.set(msg.id, [resolve, reject]);
        this._backend(msg);
      });
    }
    async fetchRootKey() {
      const rootKey = (await this.status()).root_key;
      this.rootKey = rootKey;
      return rootKey;
    }
  }
  exports.ProxyAgent = ProxyAgent;
});

// node_modules/@dfinity/agent/lib/cjs/agent/index.js
var require_agent = __commonJS((exports) => {
  var getDefaultAgent2 = function() {
    const agent14 = typeof window === "undefined" ? typeof global === "undefined" ? typeof self === "undefined" ? undefined : self.ic.agent : global.ic.agent : window.ic.agent;
    if (!agent14) {
      throw new Error("No Agent could be found.");
    }
    return agent14;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getDefaultAgent = undefined;
  __exportStar(require_api(), exports);
  __exportStar(require_http(), exports);
  __exportStar(require_proxy(), exports);
  exports.getDefaultAgent = getDefaultAgent2;
});

// node_modules/@dfinity/agent/lib/cjs/polling/strategy.js
var require_strategy = __commonJS((exports) => {
  var defaultStrategy2 = function() {
    return chain2(conditionalDelay2(once2(), 1000), backoff2(1000, 1.2), timeout2(FIVE_MINUTES_IN_MSEC2));
  };
  var once2 = function() {
    let first = true;
    return async () => {
      if (first) {
        first = false;
        return true;
      }
      return false;
    };
  };
  var conditionalDelay2 = function(condition, timeInMsec) {
    return async (canisterId, requestId, status) => {
      if (await condition(canisterId, requestId, status)) {
        return new Promise((resolve) => setTimeout(resolve, timeInMsec));
      }
    };
  };
  var maxAttempts2 = function(count) {
    let attempts = count;
    return async (canisterId, requestId, status) => {
      if (--attempts <= 0) {
        throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\n` + `  Request ID: ${(0, buffer_1.toHex)(requestId)}\n` + `  Request status: ${status}\n`);
      }
    };
  };
  var throttle2 = function(throttleInMsec) {
    return () => new Promise((resolve) => setTimeout(resolve, throttleInMsec));
  };
  var timeout2 = function(timeInMsec) {
    const end = Date.now() + timeInMsec;
    return async (canisterId, requestId, status) => {
      if (Date.now() > end) {
        throw new Error(`Request timed out after ${timeInMsec} msec:\n` + `  Request ID: ${(0, buffer_1.toHex)(requestId)}\n` + `  Request status: ${status}\n`);
      }
    };
  };
  var backoff2 = function(startingThrottleInMsec, backoffFactor) {
    let currentThrottling = startingThrottleInMsec;
    return () => new Promise((resolve) => setTimeout(() => {
      currentThrottling *= backoffFactor;
      resolve();
    }, currentThrottling));
  };
  var chain2 = function(...strategies) {
    return async (canisterId, requestId, status) => {
      for (const a of strategies) {
        await a(canisterId, requestId, status);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chain = exports.backoff = exports.timeout = exports.throttle = exports.maxAttempts = exports.conditionalDelay = exports.once = exports.defaultStrategy = undefined;
  var buffer_1 = require_buffer3();
  var FIVE_MINUTES_IN_MSEC2 = 5 * 60 * 1000;
  exports.defaultStrategy = defaultStrategy2;
  exports.once = once2;
  exports.conditionalDelay = conditionalDelay2;
  exports.maxAttempts = maxAttempts2;
  exports.throttle = throttle2;
  exports.timeout = timeout2;
  exports.backoff = backoff2;
  exports.chain = chain2;
});

// node_modules/@dfinity/agent/lib/cjs/polling/index.js
var require_polling = __commonJS((exports) => {
  async function pollForResponse2(agent14, canisterId, requestId, strategy, request2, blsVerify2) {
    var _a;
    const path = [new TextEncoder().encode("request_status"), requestId];
    const currentRequest = request2 !== null && request2 !== undefined ? request2 : await ((_a = agent14.createReadStateRequest) === null || _a === undefined ? undefined : _a.call(agent14, { paths: [path] }));
    const state = await agent14.readState(canisterId, { paths: [path] }, undefined, currentRequest);
    if (agent14.rootKey == null)
      throw new Error("Agent root key not initialized before polling");
    const cert = await certificate_1.Certificate.create({
      certificate: state.certificate,
      rootKey: agent14.rootKey,
      canisterId,
      blsVerify: blsVerify2
    });
    const maybeBuf = cert.lookup([...path, new TextEncoder().encode("status")]);
    let status;
    if (typeof maybeBuf === "undefined") {
      status = agent_1.RequestStatusResponseStatus.Unknown;
    } else {
      status = new TextDecoder().decode(maybeBuf);
    }
    switch (status) {
      case agent_1.RequestStatusResponseStatus.Replied: {
        return cert.lookup([...path, "reply"]);
      }
      case agent_1.RequestStatusResponseStatus.Received:
      case agent_1.RequestStatusResponseStatus.Unknown:
      case agent_1.RequestStatusResponseStatus.Processing:
        await strategy(canisterId, requestId, status);
        return pollForResponse2(agent14, canisterId, requestId, strategy, currentRequest);
      case agent_1.RequestStatusResponseStatus.Rejected: {
        const rejectCode = new Uint8Array(cert.lookup([...path, "reject_code"]))[0];
        const rejectMessage = new TextDecoder().decode(cert.lookup([...path, "reject_message"]));
        throw new Error(`Call was rejected:\n` + `  Request ID: ${(0, buffer_1.toHex)(requestId)}\n` + `  Reject code: ${rejectCode}\n` + `  Reject text: ${rejectMessage}\n`);
      }
      case agent_1.RequestStatusResponseStatus.Done:
        throw new Error(`Call was marked as done but we never saw the reply:\n` + `  Request ID: ${(0, buffer_1.toHex)(requestId)}\n`);
    }
    throw new Error("unreachable");
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m, k2);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pollForResponse = exports.defaultStrategy = exports.strategy = undefined;
  var agent_1 = require_agent();
  var certificate_1 = require_certificate();
  var buffer_1 = require_buffer3();
  exports.strategy = __importStar(require_strategy());
  var strategy_1 = require_strategy();
  Object.defineProperty(exports, "defaultStrategy", { enumerable: true, get: function() {
    return strategy_1.defaultStrategy;
  } });
  exports.pollForResponse = pollForResponse2;
});

// node_modules/prom-client/lib/util.js
var require_util = __commonJS((exports) => {
  var hashObject = function(labels) {
    let keys = Object.keys(labels);
    if (keys.length === 0) {
      return "";
    }
    if (keys.length > 1) {
      keys = keys.sort();
    }
    let hash4 = "";
    let i = 0;
    const size = keys.length;
    for (;i < size - 1; i++) {
      hash4 += `${keys[i]}:${labels[keys[i]]},`;
    }
    hash4 += `${keys[i]}:${labels[keys[i]]}`;
    return hash4;
  };
  exports.getValueAsString = function getValueString(value4) {
    if (Number.isNaN(value4)) {
      return "Nan";
    } else if (!Number.isFinite(value4)) {
      if (value4 < 0) {
        return "-Inf";
      } else {
        return "+Inf";
      }
    } else {
      return `${value4}`;
    }
  };
  exports.removeLabels = function removeLabels(hashMap, labels) {
    const hash4 = hashObject(labels);
    delete hashMap[hash4];
  };
  exports.setValue = function setValue(hashMap, value4, labels) {
    const hash4 = hashObject(labels);
    hashMap[hash4] = {
      value: typeof value4 === "number" ? value4 : 0,
      labels: labels || {}
    };
    return hashMap;
  };
  exports.setValueDelta = function setValueDelta(hashMap, deltaValue, labels, hash4 = "") {
    const value4 = typeof deltaValue === "number" ? deltaValue : 0;
    if (hashMap[hash4]) {
      hashMap[hash4].value += value4;
    } else {
      hashMap[hash4] = { value: value4, labels };
    }
    return hashMap;
  };
  exports.getLabels = function(labelNames, args) {
    if (typeof args[0] === "object") {
      return args[0];
    }
    if (labelNames.length !== args.length) {
      throw new Error("Invalid number of arguments");
    }
    const acc = {};
    for (let i = 0;i < labelNames.length; i++) {
      acc[labelNames[i]] = args[i];
    }
    return acc;
  };
  exports.hashObject = hashObject;
  exports.isObject = function isObject(obj) {
    return obj === Object(obj);
  };
  exports.nowTimestamp = function nowTimestamp() {
    return Date.now() / 1000;
  };

  class Grouper extends Map {
    add(key, value4) {
      if (this.has(key)) {
        this.get(key).push(value4);
      } else {
        this.set(key, [value4]);
      }
    }
  }
  exports.Grouper = Grouper;
});

// node_modules/prom-client/lib/registry.js
var require_registry = __commonJS((exports, module) => {
  var formatLabels = function(labels, exclude) {
    const { hasOwnProperty } = Object.prototype;
    const formatted = [];
    for (const [name, value4] of Object.entries(labels)) {
      if (!exclude || !hasOwnProperty.call(exclude, name)) {
        formatted.push(`${name}="${escapeLabelValue(value4)}"`);
      }
    }
    return formatted;
  };
  var flattenSharedLabels = function(labels) {
    const cached = sharedLabelCache.get(labels);
    if (cached) {
      return cached;
    }
    const formattedLabels = formatLabels(labels);
    const flattened = formattedLabels.join(",");
    sharedLabelCache.set(labels, flattened);
    return flattened;
  };
  var escapeLabelValue = function(str) {
    if (typeof str !== "string") {
      return str;
    }
    return escapeString(str).replace(/"/g, '\\"');
  };
  var escapeString = function(str) {
    return str.replace(/\\/g, "\\\\").replace(/\n/g, "\\n");
  };
  var standardizeCounterName = function(name) {
    return name.replace(/_total$/, "");
  };
  var { getValueAsString } = require_util();

  class Registry {
    static get PROMETHEUS_CONTENT_TYPE() {
      return "text/plain; version=0.0.4; charset=utf-8";
    }
    static get OPENMETRICS_CONTENT_TYPE() {
      return "application/openmetrics-text; version=1.0.0; charset=utf-8";
    }
    constructor(regContentType = Registry.PROMETHEUS_CONTENT_TYPE) {
      this._metrics = {};
      this._collectors = [];
      this._defaultLabels = {};
      if (regContentType !== Registry.PROMETHEUS_CONTENT_TYPE && regContentType !== Registry.OPENMETRICS_CONTENT_TYPE) {
        throw new TypeError(`Content type ${regContentType} is unsupported`);
      }
      this._contentType = regContentType;
    }
    getMetricsAsArray() {
      return Object.values(this._metrics);
    }
    async getMetricsAsString(metrics) {
      const metric = typeof metrics.getForPromString === "function" ? await metrics.getForPromString() : await metrics.get();
      const name = escapeString(metric.name);
      const help = `# HELP ${name} ${escapeString(metric.help)}`;
      const type = `# TYPE ${name} ${metric.type}`;
      const values = [help, type];
      const defaultLabels = Object.keys(this._defaultLabels).length > 0 ? this._defaultLabels : null;
      const isOpenMetrics = this.contentType === Registry.OPENMETRICS_CONTENT_TYPE;
      for (const val of metric.values || []) {
        let { metricName = name, labels = {} } = val;
        const { sharedLabels = {} } = val;
        if (isOpenMetrics && metric.type === "counter") {
          metricName = `${metricName}_total`;
        }
        if (defaultLabels) {
          labels = { ...labels, ...defaultLabels, ...labels };
        }
        const formattedLabels = formatLabels(labels, sharedLabels);
        const flattenedShared = flattenSharedLabels(sharedLabels);
        const labelParts = [...formattedLabels, flattenedShared].filter(Boolean);
        const labelsString = labelParts.length ? `{${labelParts.join(",")}}` : "";
        let fullMetricLine = `${metricName}${labelsString} ${getValueAsString(val.value)}`;
        const { exemplar } = val;
        if (exemplar && isOpenMetrics) {
          const formattedExemplars = formatLabels(exemplar.labelSet);
          fullMetricLine += ` # {${formattedExemplars.join(",")}} ${getValueAsString(exemplar.value)} ${exemplar.timestamp}`;
        }
        values.push(fullMetricLine);
      }
      return values.join("\n");
    }
    async metrics() {
      const isOpenMetrics = this.contentType === Registry.OPENMETRICS_CONTENT_TYPE;
      const promises2 = this.getMetricsAsArray().map((metric) => {
        if (isOpenMetrics && metric.type === "counter") {
          metric.name = standardizeCounterName(metric.name);
        }
        return this.getMetricsAsString(metric);
      });
      const resolves = await Promise.all(promises2);
      return isOpenMetrics ? `${resolves.join("\n")}\n# EOF\n` : `${resolves.join("\n\n")}\n`;
    }
    registerMetric(metric) {
      if (this._metrics[metric.name] && this._metrics[metric.name] !== metric) {
        throw new Error(`A metric with the name ${metric.name} has already been registered.`);
      }
      this._metrics[metric.name] = metric;
    }
    clear() {
      this._metrics = {};
      this._defaultLabels = {};
    }
    async getMetricsAsJSON() {
      const metrics = [];
      const defaultLabelNames = Object.keys(this._defaultLabels);
      const promises2 = [];
      for (const metric of this.getMetricsAsArray()) {
        promises2.push(metric.get());
      }
      const resolves = await Promise.all(promises2);
      for (const item of resolves) {
        if (item.values && defaultLabelNames.length > 0) {
          for (const val of item.values) {
            val.labels = Object.assign({}, val.labels);
            for (const labelName of defaultLabelNames) {
              val.labels[labelName] = val.labels[labelName] || this._defaultLabels[labelName];
            }
          }
        }
        metrics.push(item);
      }
      return metrics;
    }
    removeSingleMetric(name) {
      delete this._metrics[name];
    }
    getSingleMetricAsString(name) {
      return this.getMetricsAsString(this._metrics[name]);
    }
    getSingleMetric(name) {
      return this._metrics[name];
    }
    setDefaultLabels(labels) {
      this._defaultLabels = labels;
    }
    resetMetrics() {
      for (const metric in this._metrics) {
        this._metrics[metric].reset();
      }
    }
    get contentType() {
      return this._contentType;
    }
    setContentType(metricsContentType) {
      if (metricsContentType === Registry.OPENMETRICS_CONTENT_TYPE || metricsContentType === Registry.PROMETHEUS_CONTENT_TYPE) {
        this._contentType = metricsContentType;
      } else {
        throw new Error(`Content type ${metricsContentType} is unsupported`);
      }
    }
    static merge(registers) {
      const regType = registers[0].contentType;
      for (const reg of registers) {
        if (reg.contentType !== regType) {
          throw new Error("Registers can only be merged if they have the same content type");
        }
      }
      const mergedRegistry = new Registry(regType);
      const metricsToMerge = registers.reduce((acc, reg) => acc.concat(reg.getMetricsAsArray()), []);
      metricsToMerge.forEach(mergedRegistry.registerMetric, mergedRegistry);
      return mergedRegistry;
    }
  }
  var sharedLabelCache = new WeakMap;
  module.exports = Registry;
  module.exports.globalRegistry = new Registry;
});

// node_modules/prom-client/lib/validation.js
var require_validation = __commonJS((exports) => {
  var util = import.meta.require("util");
  var metricRegexp = /^[a-zA-Z_:][a-zA-Z0-9_:]*$/;
  var labelRegexp = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
  exports.validateMetricName = function(name) {
    return metricRegexp.test(name);
  };
  exports.validateLabelName = function(names = []) {
    return names.every((name) => labelRegexp.test(name));
  };
  exports.validateLabel = function validateLabel(savedLabels, labels) {
    for (const label in labels) {
      if (!savedLabels.includes(label)) {
        throw new Error(`Added label "${label}" is not included in initial labelset: ${util.inspect(savedLabels)}`);
      }
    }
  };
});

// node_modules/prom-client/lib/metric.js
var require_metric = __commonJS((exports, module) => {
  var Registry = require_registry();
  var { isObject } = require_util();
  var { validateMetricName, validateLabelName } = require_validation();

  class Metric {
    constructor(config, defaults = {}) {
      if (!isObject(config)) {
        throw new TypeError("constructor expected a config object");
      }
      Object.assign(this, {
        labelNames: [],
        registers: [Registry.globalRegistry],
        aggregator: "sum",
        enableExemplars: false
      }, defaults, config);
      if (!this.registers) {
        this.registers = [Registry.globalRegistry];
      }
      if (!this.help) {
        throw new Error("Missing mandatory help parameter");
      }
      if (!this.name) {
        throw new Error("Missing mandatory name parameter");
      }
      if (!validateMetricName(this.name)) {
        throw new Error("Invalid metric name");
      }
      if (!validateLabelName(this.labelNames)) {
        throw new Error("Invalid label name");
      }
      if (this.collect && typeof this.collect !== "function") {
        throw new Error('Optional "collect" parameter must be a function');
      }
      this.reset();
      for (const register of this.registers) {
        if (this.enableExemplars && register.contentType === Registry.PROMETHEUS_CONTENT_TYPE) {
          throw new TypeError("Exemplars are supported only on OpenMetrics registries");
        }
        register.registerMetric(this);
      }
    }
    reset() {
    }
  }
  module.exports = { Metric };
});

// node_modules/prom-client/lib/exemplar.js
var require_exemplar = __commonJS((exports, module) => {
  class Exemplar {
    constructor(labelSet = {}, value4 = null) {
      this.labelSet = labelSet;
      this.value = value4;
    }
    validateExemplarLabelSet(labelSet) {
      let res = "";
      for (const [labelName, labelValue] of Object.entries(labelSet)) {
        res += `${labelName}${labelValue}`;
      }
      if (res.length > 128) {
        throw new RangeError("Label set size must be smaller than 128 UTF-8 chars");
      }
    }
  }
  module.exports = Exemplar;
});

// node_modules/prom-client/lib/counter.js
var require_counter = __commonJS((exports, module) => {
  var setValue = function(hashMap, value4, labels = {}, hash4 = "") {
    if (hashMap[hash4]) {
      hashMap[hash4].value += value4;
    } else {
      hashMap[hash4] = { value: value4, labels };
    }
    return hashMap;
  };
  var util = import.meta.require("util");
  var {
    hashObject,
    isObject,
    getLabels,
    removeLabels,
    nowTimestamp
  } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();
  var Exemplar = require_exemplar();

  class Counter extends Metric {
    constructor(config) {
      super(config);
      this.type = "counter";
      this.defaultLabels = {};
      this.defaultValue = 1;
      this.defaultExemplarLabelSet = {};
      if (config.enableExemplars) {
        this.enableExemplars = true;
        this.inc = this.incWithExemplar;
      } else {
        this.inc = this.incWithoutExemplar;
      }
    }
    incWithoutExemplar(labels, value4) {
      let hash4 = "";
      if (isObject(labels)) {
        hash4 = hashObject(labels);
        validateLabel(this.labelNames, labels);
      } else {
        value4 = labels;
        labels = {};
      }
      if (value4 && !Number.isFinite(value4)) {
        throw new TypeError(`Value is not a valid number: ${util.format(value4)}`);
      }
      if (value4 < 0) {
        throw new Error("It is not possible to decrease a counter");
      }
      if (value4 === null || value4 === undefined)
        value4 = 1;
      setValue(this.hashMap, value4, labels, hash4);
      return { labelHash: hash4 };
    }
    incWithExemplar({
      labels = this.defaultLabels,
      value: value4 = this.defaultValue,
      exemplarLabels = this.defaultExemplarLabelSet
    } = {}) {
      const res = this.incWithoutExemplar(labels, value4);
      this.updateExemplar(exemplarLabels, value4, res.labelHash);
    }
    updateExemplar(exemplarLabels, value4, hash4) {
      if (!isObject(this.hashMap[hash4].exemplar)) {
        this.hashMap[hash4].exemplar = new Exemplar;
      }
      this.hashMap[hash4].exemplar.validateExemplarLabelSet(exemplarLabels);
      this.hashMap[hash4].exemplar.labelSet = exemplarLabels;
      this.hashMap[hash4].exemplar.value = value4 ? value4 : 1;
      this.hashMap[hash4].exemplar.timestamp = nowTimestamp();
    }
    reset() {
      this.hashMap = {};
      if (this.labelNames.length === 0) {
        setValue(this.hashMap, 0);
      }
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      return {
        help: this.help,
        name: this.name,
        type: this.type,
        values: Object.values(this.hashMap),
        aggregator: this.aggregator
      };
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args) || {};
      return {
        inc: this.inc.bind(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args) || {};
      validateLabel(this.labelNames, labels);
      return removeLabels.call(this, this.hashMap, labels);
    }
  }
  module.exports = Counter;
});

// node_modules/prom-client/lib/gauge.js
var require_gauge = __commonJS((exports, module) => {
  var set = function(gauge, labels, value4) {
    if (typeof value4 !== "number") {
      throw new TypeError(`Value is not a valid number: ${util.format(value4)}`);
    }
    validateLabel(gauge.labelNames, labels);
    setValue(gauge.hashMap, value4, labels);
  };
  var setDelta = function(gauge, labels, delta) {
    if (typeof delta !== "number") {
      throw new TypeError(`Delta is not a valid number: ${util.format(delta)}`);
    }
    validateLabel(gauge.labelNames, labels);
    const hash4 = hashObject(labels);
    setValueDelta(gauge.hashMap, delta, labels, hash4);
  };
  var getLabelArg = function(labels) {
    return isObject(labels) ? labels : {};
  };
  var getValueArg = function(labels, value4) {
    return isObject(labels) ? value4 : labels;
  };
  var util = import.meta.require("util");
  var {
    setValue,
    setValueDelta,
    getLabels,
    hashObject,
    isObject,
    removeLabels
  } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();

  class Gauge extends Metric {
    constructor(config) {
      super(config);
      this.type = "gauge";
    }
    set(labels, value4) {
      value4 = getValueArg(labels, value4);
      labels = getLabelArg(labels);
      set(this, labels, value4);
    }
    reset() {
      this.hashMap = {};
      if (this.labelNames.length === 0) {
        setValue(this.hashMap, 0, {});
      }
    }
    inc(labels, value4) {
      value4 = getValueArg(labels, value4);
      labels = getLabelArg(labels);
      if (value4 === undefined)
        value4 = 1;
      setDelta(this, labels, value4);
    }
    dec(labels, value4) {
      value4 = getValueArg(labels, value4);
      labels = getLabelArg(labels);
      if (value4 === undefined)
        value4 = 1;
      setDelta(this, labels, -value4);
    }
    setToCurrentTime(labels) {
      const now = Date.now() / 1000;
      if (labels === undefined) {
        this.set(now);
      } else {
        this.set(labels, now);
      }
    }
    startTimer(labels) {
      const start = process.hrtime();
      return (endLabels) => {
        const delta = process.hrtime(start);
        const value4 = delta[0] + delta[1] / 1e9;
        this.set(Object.assign({}, labels, endLabels), value4);
        return value4;
      };
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      return {
        help: this.help,
        name: this.name,
        type: this.type,
        values: Object.values(this.hashMap),
        aggregator: this.aggregator
      };
    }
    _getValue(labels) {
      const hash4 = hashObject(labels || {});
      return this.hashMap[hash4] ? this.hashMap[hash4].value : 0;
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      return {
        inc: this.inc.bind(this, labels),
        dec: this.dec.bind(this, labels),
        set: this.set.bind(this, labels),
        setToCurrentTime: this.setToCurrentTime.bind(this, labels),
        startTimer: this.startTimer.bind(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      removeLabels.call(this, this.hashMap, labels);
    }
  }
  module.exports = Gauge;
});

// node_modules/prom-client/lib/histogram.js
var require_histogram = __commonJS((exports, module) => {
  var startTimer = function(startLabels) {
    return () => {
      const start = process.hrtime();
      return (endLabels) => {
        const delta = process.hrtime(start);
        const value4 = delta[0] + delta[1] / 1e9;
        this.observe(Object.assign({}, startLabels, endLabels), value4);
        return value4;
      };
    };
  };
  var setValuePair = function(labels, value4, metricName, exemplar, sharedLabels = {}) {
    return {
      labels,
      sharedLabels,
      value: value4,
      metricName,
      exemplar
    };
  };
  var findBound = function(upperBounds, value4) {
    for (let i = 0;i < upperBounds.length; i++) {
      const bound = upperBounds[i];
      if (value4 <= bound) {
        return bound;
      }
    }
    return -1;
  };
  var observe = function(labels) {
    return (value4) => {
      const labelValuePair = convertLabelsAndValues(labels, value4);
      validateLabel(this.labelNames, labelValuePair.labels);
      if (!Number.isFinite(labelValuePair.value)) {
        throw new TypeError(`Value is not a valid number: ${util.format(labelValuePair.value)}`);
      }
      const hash4 = hashObject(labelValuePair.labels);
      let valueFromMap = this.hashMap[hash4];
      if (!valueFromMap) {
        valueFromMap = createBaseValues(labelValuePair.labels, this.bucketValues, this.bucketExemplars);
      }
      const b2 = findBound(this.upperBounds, labelValuePair.value);
      valueFromMap.sum += labelValuePair.value;
      valueFromMap.count += 1;
      if (Object.prototype.hasOwnProperty.call(valueFromMap.bucketValues, b2)) {
        valueFromMap.bucketValues[b2] += 1;
      }
      this.hashMap[hash4] = valueFromMap;
    };
  };
  var createBaseValues = function(labels, bucketValues, bucketExemplars) {
    return {
      labels,
      bucketValues: { ...bucketValues },
      bucketExemplars: { ...bucketExemplars },
      sum: 0,
      count: 0
    };
  };
  var convertLabelsAndValues = function(labels, value4) {
    return isObject(labels) ? {
      labels,
      value: value4
    } : {
      value: labels,
      labels: {}
    };
  };
  var extractBucketValuesForExport = function(histogram) {
    const name = `${histogram.name}_bucket`;
    return (bucketData) => {
      let acc = 0;
      const buckets = histogram.upperBounds.map((upperBound) => {
        acc += bucketData.bucketValues[upperBound];
        return setValuePair({ le: upperBound }, acc, name, bucketData.bucketExemplars[upperBound], bucketData.labels);
      });
      return { buckets, data: bucketData };
    };
  };
  var addSumAndCountForExport = function(histogram) {
    return (acc, d) => {
      acc.push(...d.buckets);
      const infLabel = { le: "+Inf" };
      acc.push(setValuePair(infLabel, d.data.count, `${histogram.name}_bucket`, d.data.bucketExemplars["-1"], d.data.labels), setValuePair({}, d.data.sum, `${histogram.name}_sum`, undefined, d.data.labels), setValuePair({}, d.data.count, `${histogram.name}_count`, undefined, d.data.labels));
      return acc;
    };
  };
  var splayLabels = function(bucket) {
    const { sharedLabels, labels, ...newBucket } = bucket;
    for (const label of Object.keys(sharedLabels)) {
      labels[label] = sharedLabels[label];
    }
    newBucket.labels = labels;
    return newBucket;
  };
  var util = import.meta.require("util");
  var {
    getLabels,
    hashObject,
    isObject,
    removeLabels,
    nowTimestamp
  } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();
  var Exemplar = require_exemplar();

  class Histogram extends Metric {
    constructor(config) {
      super(config, {
        buckets: [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]
      });
      this.type = "histogram";
      this.defaultLabels = {};
      this.defaultExemplarLabelSet = {};
      if (config.enableExemplars) {
        this.observe = this.observeWithExemplar;
      } else {
        this.observe = this.observeWithoutExemplar;
      }
      for (const label of this.labelNames) {
        if (label === "le") {
          throw new Error("le is a reserved label keyword");
        }
      }
      this.upperBounds = this.buckets;
      this.bucketValues = this.upperBounds.reduce((acc, upperBound) => {
        acc[upperBound] = 0;
        return acc;
      }, {});
      this.bucketExemplars = this.upperBounds.reduce((acc, upperBound) => {
        acc[upperBound] = null;
        return acc;
      }, {});
      Object.freeze(this.bucketValues);
      Object.freeze(this.bucketExemplars);
      Object.freeze(this.upperBounds);
      if (this.labelNames.length === 0) {
        this.hashMap = {
          [hashObject({})]: createBaseValues({}, this.bucketValues, this.bucketExemplars)
        };
      }
    }
    observeWithoutExemplar(labels, value4) {
      observe.call(this, labels === 0 ? 0 : labels || {})(value4);
    }
    observeWithExemplar({
      labels = this.defaultLabels,
      value: value4,
      exemplarLabels = this.defaultExemplarLabelSet
    } = {}) {
      observe.call(this, labels === 0 ? 0 : labels || {})(value4);
      this.updateExemplar(labels, value4, exemplarLabels);
    }
    updateExemplar(labels, value4, exemplarLabels) {
      const hash4 = hashObject(labels);
      const bound = findBound(this.upperBounds, value4);
      const { bucketExemplars } = this.hashMap[hash4];
      let exemplar = bucketExemplars[bound];
      if (!isObject(exemplar)) {
        exemplar = new Exemplar;
        bucketExemplars[bound] = exemplar;
      }
      exemplar.validateExemplarLabelSet(exemplarLabels);
      exemplar.labelSet = exemplarLabels;
      exemplar.value = value4;
      exemplar.timestamp = nowTimestamp();
    }
    async get() {
      const data = await this.getForPromString();
      data.values = data.values.map(splayLabels);
      return data;
    }
    async getForPromString() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      const data = Object.values(this.hashMap);
      const values = data.map(extractBucketValuesForExport(this)).reduce(addSumAndCountForExport(this), []);
      return {
        name: this.name,
        help: this.help,
        type: this.type,
        values,
        aggregator: this.aggregator
      };
    }
    reset() {
      this.hashMap = {};
    }
    zero(labels) {
      const hash4 = hashObject(labels);
      this.hashMap[hash4] = createBaseValues(labels, this.bucketValues, this.bucketExemplars);
    }
    startTimer(labels) {
      return startTimer.call(this, labels)();
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      return {
        observe: observe.call(this, labels),
        startTimer: startTimer.call(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      removeLabels.call(this, this.hashMap, labels);
    }
  }
  module.exports = Histogram;
});

// node_modules/bintrees/lib/treebase.js
var require_treebase = __commonJS((exports, module) => {
  var TreeBase = function() {
  };
  var Iterator = function(tree) {
    this._tree = tree;
    this._ancestors = [];
    this._cursor = null;
  };
  TreeBase.prototype.clear = function() {
    this._root = null;
    this.size = 0;
  };
  TreeBase.prototype.find = function(data) {
    var res = this._root;
    while (res !== null) {
      var c2 = this._comparator(data, res.data);
      if (c2 === 0) {
        return res.data;
      } else {
        res = res.get_child(c2 > 0);
      }
    }
    return null;
  };
  TreeBase.prototype.findIter = function(data) {
    var res = this._root;
    var iter = this.iterator();
    while (res !== null) {
      var c2 = this._comparator(data, res.data);
      if (c2 === 0) {
        iter._cursor = res;
        return iter;
      } else {
        iter._ancestors.push(res);
        res = res.get_child(c2 > 0);
      }
    }
    return null;
  };
  TreeBase.prototype.lowerBound = function(item) {
    var cur = this._root;
    var iter = this.iterator();
    var cmp = this._comparator;
    while (cur !== null) {
      var c2 = cmp(item, cur.data);
      if (c2 === 0) {
        iter._cursor = cur;
        return iter;
      }
      iter._ancestors.push(cur);
      cur = cur.get_child(c2 > 0);
    }
    for (var i = iter._ancestors.length - 1;i >= 0; --i) {
      cur = iter._ancestors[i];
      if (cmp(item, cur.data) < 0) {
        iter._cursor = cur;
        iter._ancestors.length = i;
        return iter;
      }
    }
    iter._ancestors.length = 0;
    return iter;
  };
  TreeBase.prototype.upperBound = function(item) {
    var iter = this.lowerBound(item);
    var cmp = this._comparator;
    while (iter.data() !== null && cmp(iter.data(), item) === 0) {
      iter.next();
    }
    return iter;
  };
  TreeBase.prototype.min = function() {
    var res = this._root;
    if (res === null) {
      return null;
    }
    while (res.left !== null) {
      res = res.left;
    }
    return res.data;
  };
  TreeBase.prototype.max = function() {
    var res = this._root;
    if (res === null) {
      return null;
    }
    while (res.right !== null) {
      res = res.right;
    }
    return res.data;
  };
  TreeBase.prototype.iterator = function() {
    return new Iterator(this);
  };
  TreeBase.prototype.each = function(cb) {
    var it2 = this.iterator(), data;
    while ((data = it2.next()) !== null) {
      if (cb(data) === false) {
        return;
      }
    }
  };
  TreeBase.prototype.reach = function(cb) {
    var it2 = this.iterator(), data;
    while ((data = it2.prev()) !== null) {
      if (cb(data) === false) {
        return;
      }
    }
  };
  Iterator.prototype.data = function() {
    return this._cursor !== null ? this._cursor.data : null;
  };
  Iterator.prototype.next = function() {
    if (this._cursor === null) {
      var root = this._tree._root;
      if (root !== null) {
        this._minNode(root);
      }
    } else {
      if (this._cursor.right === null) {
        var save;
        do {
          save = this._cursor;
          if (this._ancestors.length) {
            this._cursor = this._ancestors.pop();
          } else {
            this._cursor = null;
            break;
          }
        } while (this._cursor.right === save);
      } else {
        this._ancestors.push(this._cursor);
        this._minNode(this._cursor.right);
      }
    }
    return this._cursor !== null ? this._cursor.data : null;
  };
  Iterator.prototype.prev = function() {
    if (this._cursor === null) {
      var root = this._tree._root;
      if (root !== null) {
        this._maxNode(root);
      }
    } else {
      if (this._cursor.left === null) {
        var save;
        do {
          save = this._cursor;
          if (this._ancestors.length) {
            this._cursor = this._ancestors.pop();
          } else {
            this._cursor = null;
            break;
          }
        } while (this._cursor.left === save);
      } else {
        this._ancestors.push(this._cursor);
        this._maxNode(this._cursor.left);
      }
    }
    return this._cursor !== null ? this._cursor.data : null;
  };
  Iterator.prototype._minNode = function(start) {
    while (start.left !== null) {
      this._ancestors.push(start);
      start = start.left;
    }
    this._cursor = start;
  };
  Iterator.prototype._maxNode = function(start) {
    while (start.right !== null) {
      this._ancestors.push(start);
      start = start.right;
    }
    this._cursor = start;
  };
  module.exports = TreeBase;
});

// node_modules/bintrees/lib/rbtree.js
var require_rbtree = __commonJS((exports, module) => {
  var Node = function(data) {
    this.data = data;
    this.left = null;
    this.right = null;
    this.red = true;
  };
  var RBTree = function(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
  };
  var is_red = function(node) {
    return node !== null && node.red;
  };
  var single_rotate = function(root, dir) {
    var save = root.get_child(!dir);
    root.set_child(!dir, save.get_child(dir));
    save.set_child(dir, root);
    root.red = true;
    save.red = false;
    return save;
  };
  var double_rotate = function(root, dir) {
    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));
    return single_rotate(root, dir);
  };
  var TreeBase = require_treebase();
  Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
  };
  Node.prototype.set_child = function(dir, val) {
    if (dir) {
      this.right = val;
    } else {
      this.left = val;
    }
  };
  RBTree.prototype = new TreeBase;
  RBTree.prototype.insert = function(data) {
    var ret2 = false;
    if (this._root === null) {
      this._root = new Node(data);
      ret2 = true;
      this.size++;
    } else {
      var head = new Node(undefined);
      var dir = 0;
      var last = 0;
      var gp = null;
      var ggp = head;
      var p = null;
      var node = this._root;
      ggp.right = this._root;
      while (true) {
        if (node === null) {
          node = new Node(data);
          p.set_child(dir, node);
          ret2 = true;
          this.size++;
        } else if (is_red(node.left) && is_red(node.right)) {
          node.red = true;
          node.left.red = false;
          node.right.red = false;
        }
        if (is_red(node) && is_red(p)) {
          var dir2 = ggp.right === gp;
          if (node === p.get_child(last)) {
            ggp.set_child(dir2, single_rotate(gp, !last));
          } else {
            ggp.set_child(dir2, double_rotate(gp, !last));
          }
        }
        var cmp = this._comparator(node.data, data);
        if (cmp === 0) {
          break;
        }
        last = dir;
        dir = cmp < 0;
        if (gp !== null) {
          ggp = gp;
        }
        gp = p;
        p = node;
        node = node.get_child(dir);
      }
      this._root = head.right;
    }
    this._root.red = false;
    return ret2;
  };
  RBTree.prototype.remove = function(data) {
    if (this._root === null) {
      return false;
    }
    var head = new Node(undefined);
    var node = head;
    node.right = this._root;
    var p = null;
    var gp = null;
    var found = null;
    var dir = 1;
    while (node.get_child(dir) !== null) {
      var last = dir;
      gp = p;
      p = node;
      node = node.get_child(dir);
      var cmp = this._comparator(data, node.data);
      dir = cmp > 0;
      if (cmp === 0) {
        found = node;
      }
      if (!is_red(node) && !is_red(node.get_child(dir))) {
        if (is_red(node.get_child(!dir))) {
          var sr = single_rotate(node, dir);
          p.set_child(last, sr);
          p = sr;
        } else if (!is_red(node.get_child(!dir))) {
          var sibling = p.get_child(!last);
          if (sibling !== null) {
            if (!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {
              p.red = false;
              sibling.red = true;
              node.red = true;
            } else {
              var dir2 = gp.right === p;
              if (is_red(sibling.get_child(last))) {
                gp.set_child(dir2, double_rotate(p, last));
              } else if (is_red(sibling.get_child(!last))) {
                gp.set_child(dir2, single_rotate(p, last));
              }
              var gpc = gp.get_child(dir2);
              gpc.red = true;
              node.red = true;
              gpc.left.red = false;
              gpc.right.red = false;
            }
          }
        }
      }
    }
    if (found !== null) {
      found.data = node.data;
      p.set_child(p.right === node, node.get_child(node.left === null));
      this.size--;
    }
    this._root = head.right;
    if (this._root !== null) {
      this._root.red = false;
    }
    return found !== null;
  };
  module.exports = RBTree;
});

// node_modules/bintrees/lib/bintree.js
var require_bintree = __commonJS((exports, module) => {
  var Node = function(data) {
    this.data = data;
    this.left = null;
    this.right = null;
  };
  var BinTree = function(comparator) {
    this._root = null;
    this._comparator = comparator;
    this.size = 0;
  };
  var TreeBase = require_treebase();
  Node.prototype.get_child = function(dir) {
    return dir ? this.right : this.left;
  };
  Node.prototype.set_child = function(dir, val) {
    if (dir) {
      this.right = val;
    } else {
      this.left = val;
    }
  };
  BinTree.prototype = new TreeBase;
  BinTree.prototype.insert = function(data) {
    if (this._root === null) {
      this._root = new Node(data);
      this.size++;
      return true;
    }
    var dir = 0;
    var p = null;
    var node = this._root;
    while (true) {
      if (node === null) {
        node = new Node(data);
        p.set_child(dir, node);
        ret = true;
        this.size++;
        return true;
      }
      if (this._comparator(node.data, data) === 0) {
        return false;
      }
      dir = this._comparator(node.data, data) < 0;
      p = node;
      node = node.get_child(dir);
    }
  };
  BinTree.prototype.remove = function(data) {
    if (this._root === null) {
      return false;
    }
    var head = new Node(undefined);
    var node = head;
    node.right = this._root;
    var p = null;
    var found = null;
    var dir = 1;
    while (node.get_child(dir) !== null) {
      p = node;
      node = node.get_child(dir);
      var cmp = this._comparator(data, node.data);
      dir = cmp > 0;
      if (cmp === 0) {
        found = node;
      }
    }
    if (found !== null) {
      found.data = node.data;
      p.set_child(p.right === node, node.get_child(node.left === null));
      this._root = head.right;
      this.size--;
      return true;
    } else {
      return false;
    }
  };
  module.exports = BinTree;
});

// node_modules/bintrees/index.js
var require_bintrees = __commonJS((exports, module) => {
  module.exports = {
    RBTree: require_rbtree(),
    BinTree: require_bintree()
  };
});

// node_modules/tdigest/tdigest.js
var require_tdigest = __commonJS((exports, module) => {
  var TDigest = function(delta, K2, CX) {
    this.discrete = delta === false;
    this.delta = delta || 0.01;
    this.K = K2 === undefined ? 25 : K2;
    this.CX = CX === undefined ? 1.1 : CX;
    this.centroids = new RBTree(compare_centroid_means);
    this.nreset = 0;
    this.reset();
  };
  var compare_centroid_means = function(a, b2) {
    return a.mean > b2.mean ? 1 : a.mean < b2.mean ? -1 : 0;
  };
  var compare_centroid_mean_cumns = function(a, b2) {
    return a.mean_cumn - b2.mean_cumn;
  };
  var pop_random = function(choices) {
    var idx = Math.floor(Math.random() * choices.length);
    return choices.splice(idx, 1)[0];
  };
  var Digest = function(config) {
    this.config = config || {};
    this.mode = this.config.mode || "auto";
    TDigest.call(this, this.mode === "cont" ? config.delta : false);
    this.digest_ratio = this.config.ratio || 0.9;
    this.digest_thresh = this.config.thresh || 1000;
    this.n_unique = 0;
  };
  var RBTree = require_bintrees().RBTree;
  TDigest.prototype.reset = function() {
    this.centroids.clear();
    this.n = 0;
    this.nreset += 1;
    this.last_cumulate = 0;
  };
  TDigest.prototype.size = function() {
    return this.centroids.size;
  };
  TDigest.prototype.toArray = function(everything) {
    var result = [];
    if (everything) {
      this._cumulate(true);
      this.centroids.each(function(c2) {
        result.push(c2);
      });
    } else {
      this.centroids.each(function(c2) {
        result.push({ mean: c2.mean, n: c2.n });
      });
    }
    return result;
  };
  TDigest.prototype.summary = function() {
    var approx = this.discrete ? "exact " : "approximating ";
    var s2 = [
      approx + this.n + " samples using " + this.size() + " centroids",
      "min = " + this.percentile(0),
      "Q1  = " + this.percentile(0.25),
      "Q2  = " + this.percentile(0.5),
      "Q3  = " + this.percentile(0.75),
      "max = " + this.percentile(1)
    ];
    return s2.join("\n");
  };
  TDigest.prototype.push = function(x2, n) {
    n = n || 1;
    x2 = Array.isArray(x2) ? x2 : [x2];
    for (var i = 0;i < x2.length; i++) {
      this._digest(x2[i], n);
    }
  };
  TDigest.prototype.push_centroid = function(c2) {
    c2 = Array.isArray(c2) ? c2 : [c2];
    for (var i = 0;i < c2.length; i++) {
      this._digest(c2[i].mean, c2[i].n);
    }
  };
  TDigest.prototype._cumulate = function(exact) {
    if (this.n === this.last_cumulate || !exact && this.CX && this.CX > this.n / this.last_cumulate) {
      return;
    }
    var cumn = 0;
    this.centroids.each(function(c2) {
      c2.mean_cumn = cumn + c2.n / 2;
      cumn = c2.cumn = cumn + c2.n;
    });
    this.n = this.last_cumulate = cumn;
  };
  TDigest.prototype.find_nearest = function(x2) {
    if (this.size() === 0) {
      return null;
    }
    var iter = this.centroids.lowerBound({ mean: x2 });
    var c2 = iter.data() === null ? iter.prev() : iter.data();
    if (c2.mean === x2 || this.discrete) {
      return c2;
    }
    var prev = iter.prev();
    if (prev && Math.abs(prev.mean - x2) < Math.abs(c2.mean - x2)) {
      return prev;
    } else {
      return c2;
    }
  };
  TDigest.prototype._new_centroid = function(x2, n, cumn) {
    var c2 = { mean: x2, n, cumn };
    this.centroids.insert(c2);
    this.n += n;
    return c2;
  };
  TDigest.prototype._addweight = function(nearest, x2, n) {
    if (x2 !== nearest.mean) {
      nearest.mean += n * (x2 - nearest.mean) / (nearest.n + n);
    }
    nearest.cumn += n;
    nearest.mean_cumn += n / 2;
    nearest.n += n;
    this.n += n;
  };
  TDigest.prototype._digest = function(x2, n) {
    var min = this.centroids.min();
    var max = this.centroids.max();
    var nearest = this.find_nearest(x2);
    if (nearest && nearest.mean === x2) {
      this._addweight(nearest, x2, n);
    } else if (nearest === min) {
      this._new_centroid(x2, n, 0);
    } else if (nearest === max) {
      this._new_centroid(x2, n, this.n);
    } else if (this.discrete) {
      this._new_centroid(x2, n, nearest.cumn);
    } else {
      var p = nearest.mean_cumn / this.n;
      var max_n = Math.floor(4 * this.n * this.delta * p * (1 - p));
      if (max_n - nearest.n >= n) {
        this._addweight(nearest, x2, n);
      } else {
        this._new_centroid(x2, n, nearest.cumn);
      }
    }
    this._cumulate(false);
    if (!this.discrete && this.K && this.size() > this.K / this.delta) {
      this.compress();
    }
  };
  TDigest.prototype.bound_mean = function(x2) {
    var iter = this.centroids.upperBound({ mean: x2 });
    var lower = iter.prev();
    var upper = lower.mean === x2 ? lower : iter.next();
    return [lower, upper];
  };
  TDigest.prototype.p_rank = function(x_or_xlist) {
    var xs = Array.isArray(x_or_xlist) ? x_or_xlist : [x_or_xlist];
    var ps = xs.map(this._p_rank, this);
    return Array.isArray(x_or_xlist) ? ps : ps[0];
  };
  TDigest.prototype._p_rank = function(x2) {
    if (this.size() === 0) {
      return;
    } else if (x2 < this.centroids.min().mean) {
      return 0;
    } else if (x2 > this.centroids.max().mean) {
      return 1;
    }
    this._cumulate(true);
    var bound = this.bound_mean(x2);
    var lower = bound[0], upper = bound[1];
    if (this.discrete) {
      return lower.cumn / this.n;
    } else {
      var cumn = lower.mean_cumn;
      if (lower !== upper) {
        cumn += (x2 - lower.mean) * (upper.mean_cumn - lower.mean_cumn) / (upper.mean - lower.mean);
      }
      return cumn / this.n;
    }
  };
  TDigest.prototype.bound_mean_cumn = function(cumn) {
    this.centroids._comparator = compare_centroid_mean_cumns;
    var iter = this.centroids.upperBound({ mean_cumn: cumn });
    this.centroids._comparator = compare_centroid_means;
    var lower = iter.prev();
    var upper = lower && lower.mean_cumn === cumn ? lower : iter.next();
    return [lower, upper];
  };
  TDigest.prototype.percentile = function(p_or_plist) {
    var ps = Array.isArray(p_or_plist) ? p_or_plist : [p_or_plist];
    var qs = ps.map(this._percentile, this);
    return Array.isArray(p_or_plist) ? qs : qs[0];
  };
  TDigest.prototype._percentile = function(p) {
    if (this.size() === 0) {
      return;
    }
    this._cumulate(true);
    var h2 = this.n * p;
    var bound = this.bound_mean_cumn(h2);
    var lower = bound[0], upper = bound[1];
    if (upper === lower || lower === null || upper === null) {
      return (lower || upper).mean;
    } else if (!this.discrete) {
      return lower.mean + (h2 - lower.mean_cumn) * (upper.mean - lower.mean) / (upper.mean_cumn - lower.mean_cumn);
    } else if (h2 <= lower.cumn) {
      return lower.mean;
    } else {
      return upper.mean;
    }
  };
  TDigest.prototype.compress = function() {
    if (this.compressing) {
      return;
    }
    var points = this.toArray();
    this.reset();
    this.compressing = true;
    while (points.length > 0) {
      this.push_centroid(pop_random(points));
    }
    this._cumulate(true);
    this.compressing = false;
  };
  Digest.prototype = Object.create(TDigest.prototype);
  Digest.prototype.constructor = Digest;
  Digest.prototype.push = function(x_or_xlist) {
    TDigest.prototype.push.call(this, x_or_xlist);
    this.check_continuous();
  };
  Digest.prototype._new_centroid = function(x2, n, cumn) {
    this.n_unique += 1;
    TDigest.prototype._new_centroid.call(this, x2, n, cumn);
  };
  Digest.prototype._addweight = function(nearest, x2, n) {
    if (nearest.n === 1) {
      this.n_unique -= 1;
    }
    TDigest.prototype._addweight.call(this, nearest, x2, n);
  };
  Digest.prototype.check_continuous = function() {
    if (this.mode !== "auto" || this.size() < this.digest_thresh) {
      return false;
    }
    if (this.n_unique / this.size() > this.digest_ratio) {
      this.mode = "cont";
      this.discrete = false;
      this.delta = this.config.delta || 0.01;
      this.compress();
      return true;
    }
    return false;
  };
  module.exports = {
    TDigest,
    Digest
  };
});

// node_modules/prom-client/lib/timeWindowQuantiles.js
var require_timeWindowQuantiles = __commonJS((exports, module) => {
  var rotate = function() {
    let timeSinceLastRotateMillis = Date.now() - this.lastRotateTimestampMillis;
    while (timeSinceLastRotateMillis > this.durationBetweenRotatesMillis && this.shouldRotate) {
      this.ringBuffer[this.currentBuffer] = new TDigest;
      if (++this.currentBuffer >= this.ringBuffer.length) {
        this.currentBuffer = 0;
      }
      timeSinceLastRotateMillis -= this.durationBetweenRotatesMillis;
      this.lastRotateTimestampMillis += this.durationBetweenRotatesMillis;
    }
    return this.ringBuffer[this.currentBuffer];
  };
  var { TDigest } = require_tdigest();

  class TimeWindowQuantiles {
    constructor(maxAgeSeconds, ageBuckets) {
      this.maxAgeSeconds = maxAgeSeconds || 0;
      this.ageBuckets = ageBuckets || 0;
      this.shouldRotate = maxAgeSeconds && ageBuckets;
      this.ringBuffer = Array(ageBuckets).fill(new TDigest);
      this.currentBuffer = 0;
      this.lastRotateTimestampMillis = Date.now();
      this.durationBetweenRotatesMillis = maxAgeSeconds * 1000 / ageBuckets || Infinity;
    }
    size() {
      const bucket = rotate.call(this);
      return bucket.size();
    }
    percentile(quantile) {
      const bucket = rotate.call(this);
      return bucket.percentile(quantile);
    }
    push(value4) {
      rotate.call(this);
      this.ringBuffer.forEach((bucket) => {
        bucket.push(value4);
      });
    }
    reset() {
      this.ringBuffer.forEach((bucket) => {
        bucket.reset();
      });
    }
    compress() {
      this.ringBuffer.forEach((bucket) => {
        bucket.compress();
      });
    }
  }
  module.exports = TimeWindowQuantiles;
});

// node_modules/prom-client/lib/summary.js
var require_summary = __commonJS((exports, module) => {
  var extractSummariesForExport = function(summaryOfLabels, percentiles) {
    summaryOfLabels.td.compress();
    return percentiles.map((percentile) => {
      const percentileValue = summaryOfLabels.td.percentile(percentile);
      return {
        labels: Object.assign({ quantile: percentile }, summaryOfLabels.labels),
        value: percentileValue ? percentileValue : 0
      };
    });
  };
  var getCountForExport = function(value4, summary) {
    return {
      metricName: `${summary.name}_count`,
      labels: value4.labels,
      value: value4.count
    };
  };
  var getSumForExport = function(value4, summary) {
    return {
      metricName: `${summary.name}_sum`,
      labels: value4.labels,
      value: value4.sum
    };
  };
  var startTimer = function(startLabels) {
    return () => {
      const start = process.hrtime();
      return (endLabels) => {
        const delta = process.hrtime(start);
        const value4 = delta[0] + delta[1] / 1e9;
        this.observe(Object.assign({}, startLabels, endLabels), value4);
        return value4;
      };
    };
  };
  var observe = function(labels) {
    return (value4) => {
      const labelValuePair = convertLabelsAndValues(labels, value4);
      validateLabel(this.labelNames, labels);
      if (!Number.isFinite(labelValuePair.value)) {
        throw new TypeError(`Value is not a valid number: ${util.format(labelValuePair.value)}`);
      }
      const hash4 = hashObject(labelValuePair.labels);
      let summaryOfLabel = this.hashMap[hash4];
      if (!summaryOfLabel) {
        summaryOfLabel = {
          labels: labelValuePair.labels,
          td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),
          count: 0,
          sum: 0
        };
      }
      summaryOfLabel.td.push(labelValuePair.value);
      summaryOfLabel.count++;
      if (summaryOfLabel.count % this.compressCount === 0) {
        summaryOfLabel.td.compress();
      }
      summaryOfLabel.sum += labelValuePair.value;
      this.hashMap[hash4] = summaryOfLabel;
    };
  };
  var convertLabelsAndValues = function(labels, value4) {
    if (value4 === undefined) {
      return {
        value: labels,
        labels: {}
      };
    }
    return {
      labels,
      value: value4
    };
  };
  var util = import.meta.require("util");
  var { getLabels, hashObject, removeLabels } = require_util();
  var { validateLabel } = require_validation();
  var { Metric } = require_metric();
  var timeWindowQuantiles = require_timeWindowQuantiles();
  var DEFAULT_COMPRESS_COUNT = 1000;

  class Summary extends Metric {
    constructor(config) {
      super(config, {
        percentiles: [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999],
        compressCount: DEFAULT_COMPRESS_COUNT,
        hashMap: {}
      });
      this.type = "summary";
      for (const label of this.labelNames) {
        if (label === "quantile")
          throw new Error("quantile is a reserved label keyword");
      }
      if (this.labelNames.length === 0) {
        this.hashMap = {
          [hashObject({})]: {
            labels: {},
            td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),
            count: 0,
            sum: 0
          }
        };
      }
    }
    observe(labels, value4) {
      observe.call(this, labels === 0 ? 0 : labels || {})(value4);
    }
    async get() {
      if (this.collect) {
        const v = this.collect();
        if (v instanceof Promise)
          await v;
      }
      const hashKeys = Object.keys(this.hashMap);
      const values = [];
      hashKeys.forEach((hashKey) => {
        const s2 = this.hashMap[hashKey];
        if (s2) {
          if (this.pruneAgedBuckets && s2.td.size() === 0) {
            delete this.hashMap[hashKey];
          } else {
            extractSummariesForExport(s2, this.percentiles).forEach((v) => {
              values.push(v);
            });
            values.push(getSumForExport(s2, this));
            values.push(getCountForExport(s2, this));
          }
        }
      });
      return {
        name: this.name,
        help: this.help,
        type: this.type,
        values,
        aggregator: this.aggregator
      };
    }
    reset() {
      const data = Object.values(this.hashMap);
      data.forEach((s2) => {
        s2.td.reset();
        s2.count = 0;
        s2.sum = 0;
      });
    }
    startTimer(labels) {
      return startTimer.call(this, labels)();
    }
    labels(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      return {
        observe: observe.call(this, labels),
        startTimer: startTimer.call(this, labels)
      };
    }
    remove(...args) {
      const labels = getLabels(this.labelNames, args);
      validateLabel(this.labelNames, labels);
      removeLabels.call(this, this.hashMap, labels);
    }
  }
  module.exports = Summary;
});

// node_modules/prom-client/lib/pushgateway.js
var require_pushgateway = __commonJS((exports, module) => {
  async function useGateway(method, job, groupings) {
    const gatewayUrlParsed = url.parse(this.gatewayUrl);
    const gatewayUrlPath = gatewayUrlParsed.pathname && gatewayUrlParsed.pathname !== "/" ? gatewayUrlParsed.pathname : "";
    const path = `${gatewayUrlPath}/metrics/job/${encodeURIComponent(job)}${generateGroupings(groupings)}`;
    const target = url.resolve(this.gatewayUrl, path);
    const requestParams = url.parse(target);
    const httpModule = isHttps(requestParams.href) ? https : http3;
    const options = Object.assign(requestParams, this.requestOptions, {
      method
    });
    return new Promise((resolve, reject) => {
      if (method === "DELETE" && options.headers) {
        delete options.headers["Content-Encoding"];
      }
      const req = httpModule.request(options, (resp) => {
        let body = "";
        resp.setEncoding("utf8");
        resp.on("data", (chunk) => {
          body += chunk;
        });
        resp.on("end", () => {
          if (resp.statusCode >= 400) {
            reject(new Error(`push failed with status ${resp.statusCode}, ${body}`));
          } else {
            resolve({ resp, body });
          }
        });
      });
      req.on("error", (err) => {
        reject(err);
      });
      req.on("timeout", () => {
        req.destroy(new Error("Pushgateway request timed out"));
      });
      if (method !== "DELETE") {
        this.registry.metrics().then((metrics) => {
          if (options.headers && options.headers["Content-Encoding"] === "gzip") {
            metrics = gzipSync(metrics);
          }
          req.write(metrics);
          req.end();
        }).catch((err) => {
          reject(err);
        });
      } else {
        req.end();
      }
    });
  }
  var generateGroupings = function(groupings) {
    if (!groupings) {
      return "";
    }
    return Object.keys(groupings).map((key) => `/${encodeURIComponent(key)}/${encodeURIComponent(groupings[key])}`).join("");
  };
  var isHttps = function(href) {
    return href.search(/^https/) !== -1;
  };
  var url = import.meta.require("url");
  var http3 = import.meta.require("http");
  var https = import.meta.require("https");
  var { gzipSync } = import.meta.require("zlib");
  var { globalRegistry } = require_registry();

  class Pushgateway {
    constructor(gatewayUrl, options, registry) {
      if (!registry) {
        registry = globalRegistry;
      }
      this.registry = registry;
      this.gatewayUrl = gatewayUrl;
      this.requestOptions = Object.assign({}, options);
    }
    pushAdd(params) {
      if (!params || !params.jobName) {
        throw new Error("Missing jobName parameter");
      }
      return useGateway.call(this, "POST", params.jobName, params.groupings);
    }
    push(params) {
      if (!params || !params.jobName) {
        throw new Error("Missing jobName parameter");
      }
      return useGateway.call(this, "PUT", params.jobName, params.groupings);
    }
    delete(params) {
      if (!params || !params.jobName) {
        throw new Error("Missing jobName parameter");
      }
      return useGateway.call(this, "DELETE", params.jobName, params.groupings);
    }
  }
  module.exports = Pushgateway;
});

// node_modules/prom-client/lib/bucketGenerators.js
var require_bucketGenerators = __commonJS((exports) => {
  exports.linearBuckets = (start, width, count) => {
    if (count < 1) {
      throw new Error("Linear buckets needs a positive count");
    }
    const buckets = new Array(count);
    for (let i = 0;i < count; i++) {
      buckets[i] = start + i * width;
    }
    return buckets;
  };
  exports.exponentialBuckets = (start, factor, count) => {
    if (start <= 0) {
      throw new Error("Exponential buckets needs a positive start");
    }
    if (count < 1) {
      throw new Error("Exponential buckets needs a positive count");
    }
    if (factor <= 1) {
      throw new Error("Exponential buckets needs a factor greater than 1");
    }
    const buckets = new Array(count);
    for (let i = 0;i < count; i++) {
      buckets[i] = start;
      start *= factor;
    }
    return buckets;
  };
});

// node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._globalThis = undefined;
  exports._globalThis = typeof globalThis === "object" ? globalThis : global;
});

// node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m[k2];
    } });
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_globalThis(), exports);
});

// node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m[k2];
    } });
  } : function(o, m, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o[k22] = m[k2];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_node(), exports);
});

// node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VERSION = undefined;
  exports.VERSION = "1.6.0";
});

// node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS((exports) => {
  var _makeCompatibilityCheck = function(ownVersion) {
    const acceptedVersions = new Set([ownVersion]);
    const rejectedVersions = new Set;
    const myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
      return () => false;
    }
    const ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
      return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
      };
    }
    function _reject(v) {
      rejectedVersions.add(v);
      return false;
    }
    function _accept(v) {
      acceptedVersions.add(v);
      return true;
    }
    return function isCompatible(globalVersion) {
      if (acceptedVersions.has(globalVersion)) {
        return true;
      }
      if (rejectedVersions.has(globalVersion)) {
        return false;
      }
      const globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) {
        return _reject(globalVersion);
      }
      const globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      if (globalVersionParsed.prerelease != null) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major !== globalVersionParsed.major) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major === 0) {
        if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }
      if (ownVersionParsed.minor <= globalVersionParsed.minor) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCompatible = exports._makeCompatibilityCheck = undefined;
  var version_1 = require_version();
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  exports._makeCompatibilityCheck = _makeCompatibilityCheck;
  exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
});

// node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS((exports) => {
  var registerGlobal = function(type, instance, diag, allowOverride = false) {
    var _a;
    const api2 = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== undefined ? _a : {
      version: version_1.VERSION
    };
    if (!allowOverride && api2[type]) {
      const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
      diag.error(err.stack || err.message);
      return false;
    }
    if (api2.version !== version_1.VERSION) {
      const err = new Error(`@opentelemetry/api: Registration of version v${api2.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
      diag.error(err.stack || err.message);
      return false;
    }
    api2[type] = instance;
    diag.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`);
    return true;
  };
  var getGlobal = function(type) {
    var _a, _b;
    const globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === undefined ? undefined : _a.version;
    if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
      return;
    }
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === undefined ? undefined : _b[type];
  };
  var unregisterGlobal = function(type, diag) {
    diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
    const api2 = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api2) {
      delete api2[type];
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = undefined;
  var platform_1 = require_platform();
  var version_1 = require_version();
  var semver_1 = require_semver();
  var major = version_1.VERSION.split(".")[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
  var _global = platform_1._globalThis;
  exports.registerGlobal = registerGlobal;
  exports.getGlobal = getGlobal;
  exports.unregisterGlobal = unregisterGlobal;
});

// node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS((exports) => {
  var logProxy = function(funcName, namespace, args) {
    const logger = (0, global_utils_1.getGlobal)("diag");
    if (!logger) {
      return;
    }
    args.unshift(namespace);
    return logger[funcName](...args);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagComponentLogger = undefined;
  var global_utils_1 = require_global_utils();

  class DiagComponentLogger {
    constructor(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    debug(...args) {
      return logProxy("debug", this._namespace, args);
    }
    error(...args) {
      return logProxy("error", this._namespace, args);
    }
    info(...args) {
      return logProxy("info", this._namespace, args);
    }
    warn(...args) {
      return logProxy("warn", this._namespace, args);
    }
    verbose(...args) {
      return logProxy("verbose", this._namespace, args);
    }
  }
  exports.DiagComponentLogger = DiagComponentLogger;
});

// node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagLogLevel = undefined;
  var DiagLogLevel;
  (function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
  })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
});

// node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS((exports) => {
  var createLogLevelDiagLogger = function(maxLevel, logger) {
    if (maxLevel < types_1.DiagLogLevel.NONE) {
      maxLevel = types_1.DiagLogLevel.NONE;
    } else if (maxLevel > types_1.DiagLogLevel.ALL) {
      maxLevel = types_1.DiagLogLevel.ALL;
    }
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
      const theFunc = logger[funcName];
      if (typeof theFunc === "function" && maxLevel >= theLevel) {
        return theFunc.bind(logger);
      }
      return function() {
      };
    }
    return {
      error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
      warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
      info: _filterFunc("info", types_1.DiagLogLevel.INFO),
      debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLogLevelDiagLogger = undefined;
  var types_1 = require_types4();
  exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
});

// node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagAPI = undefined;
  var ComponentLogger_1 = require_ComponentLogger();
  var logLevelLogger_1 = require_logLevelLogger();
  var types_1 = require_types4();
  var global_utils_1 = require_global_utils();
  var API_NAME = "diag";

  class DiagAPI {
    constructor() {
      function _logProxy(funcName) {
        return function(...args) {
          const logger = (0, global_utils_1.getGlobal)("diag");
          if (!logger)
            return;
          return logger[funcName](...args);
        };
      }
      const self2 = this;
      const setLogger = (logger, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
        var _a, _b, _c;
        if (logger === self2) {
          const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a = err.stack) !== null && _a !== undefined ? _a : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        const oldLogger = (0, global_utils_1.getGlobal)("diag");
        const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== undefined ? _b : types_1.DiagLogLevel.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          const stack = (_c = new Error().stack) !== null && _c !== undefined ? _c : "<failed to generate stacktrace>";
          oldLogger.warn(`Current logger will be overwritten from ${stack}`);
          newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
        }
        return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
      };
      self2.setLogger = setLogger;
      self2.disable = () => {
        (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
      };
      self2.createComponentLogger = (options) => {
        return new ComponentLogger_1.DiagComponentLogger(options);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    static instance() {
      if (!this._instance) {
        this._instance = new DiagAPI;
      }
      return this._instance;
    }
  }
  exports.DiagAPI = DiagAPI;
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaggageImpl = undefined;

  class BaggageImpl {
    constructor(entries) {
      this._entries = entries ? new Map(entries) : new Map;
    }
    getEntry(key) {
      const entry = this._entries.get(key);
      if (!entry) {
        return;
      }
      return Object.assign({}, entry);
    }
    getAllEntries() {
      return Array.from(this._entries.entries()).map(([k2, v]) => [k2, v]);
    }
    setEntry(key, entry) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    }
    removeEntry(key) {
      const newBaggage = new BaggageImpl(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    }
    removeEntries(...keys) {
      const newBaggage = new BaggageImpl(this._entries);
      for (const key of keys) {
        newBaggage._entries.delete(key);
      }
      return newBaggage;
    }
    clear() {
      return new BaggageImpl;
    }
  }
  exports.BaggageImpl = BaggageImpl;
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataSymbol = undefined;
  exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
});

// node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils2 = __commonJS((exports) => {
  var createBaggage = function(entries = {}) {
    return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
  };
  var baggageEntryMetadataFromString = function(str) {
    if (typeof str !== "string") {
      diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
      str = "";
    }
    return {
      __TYPE__: symbol_1.baggageEntryMetadataSymbol,
      toString() {
        return str;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.baggageEntryMetadataFromString = exports.createBaggage = undefined;
  var diag_1 = require_diag();
  var baggage_impl_1 = require_baggage_impl();
  var symbol_1 = require_symbol();
  var diag = diag_1.DiagAPI.instance();
  exports.createBaggage = createBaggage;
  exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
});

// node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS((exports) => {
  var createContextKey = function(description) {
    return Symbol.for(description);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ROOT_CONTEXT = exports.createContextKey = undefined;
  exports.createContextKey = createContextKey;

  class BaseContext {
    constructor(parentContext) {
      const self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : new Map;
      self2.getValue = (key) => self2._currentContext.get(key);
      self2.setValue = (key, value4) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.set(key, value4);
        return context;
      };
      self2.deleteValue = (key) => {
        const context = new BaseContext(self2._currentContext);
        context._currentContext.delete(key);
        return context;
      };
    }
  }
  exports.ROOT_CONTEXT = new BaseContext;
});

// node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagConsoleLogger = undefined;
  var consoleMap = [
    { n: "error", c: "error" },
    { n: "warn", c: "warn" },
    { n: "info", c: "info" },
    { n: "debug", c: "debug" },
    { n: "verbose", c: "trace" }
  ];

  class DiagConsoleLogger {
    constructor() {
      function _consoleFunc(funcName) {
        return function(...args) {
          if (console) {
            let theFunc = console[funcName];
            if (typeof theFunc !== "function") {
              theFunc = console.log;
            }
            if (typeof theFunc === "function") {
              return theFunc.apply(console, args);
            }
          }
        };
      }
      for (let i = 0;i < consoleMap.length; i++) {
        this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
    }
  }
  exports.DiagConsoleLogger = DiagConsoleLogger;
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS((exports) => {
  var createNoopMeter = function() {
    return exports.NOOP_METER;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = undefined;

  class NoopMeter {
    constructor() {
    }
    createHistogram(_name, _options) {
      return exports.NOOP_HISTOGRAM_METRIC;
    }
    createCounter(_name, _options) {
      return exports.NOOP_COUNTER_METRIC;
    }
    createUpDownCounter(_name, _options) {
      return exports.NOOP_UP_DOWN_COUNTER_METRIC;
    }
    createObservableGauge(_name, _options) {
      return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
    }
    createObservableCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
    }
    createObservableUpDownCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    }
    addBatchObservableCallback(_callback, _observables) {
    }
    removeBatchObservableCallback(_callback) {
    }
  }
  exports.NoopMeter = NoopMeter;

  class NoopMetric {
  }
  exports.NoopMetric = NoopMetric;

  class NoopCounterMetric extends NoopMetric {
    add(_value, _attributes) {
    }
  }
  exports.NoopCounterMetric = NoopCounterMetric;

  class NoopUpDownCounterMetric extends NoopMetric {
    add(_value, _attributes) {
    }
  }
  exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;

  class NoopHistogramMetric extends NoopMetric {
    record(_value, _attributes) {
    }
  }
  exports.NoopHistogramMetric = NoopHistogramMetric;

  class NoopObservableMetric {
    addCallback(_callback) {
    }
    removeCallback(_callback) {
    }
  }
  exports.NoopObservableMetric = NoopObservableMetric;

  class NoopObservableCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableCounterMetric = NoopObservableCounterMetric;

  class NoopObservableGaugeMetric extends NoopObservableMetric {
  }
  exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;

  class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
  }
  exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
  exports.NOOP_METER = new NoopMeter;
  exports.NOOP_COUNTER_METRIC = new NoopCounterMetric;
  exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric;
  exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric;
  exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric;
  exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric;
  exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric;
  exports.createNoopMeter = createNoopMeter;
});

// node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueType = undefined;
  var ValueType;
  (function(ValueType2) {
    ValueType2[ValueType2["INT"] = 0] = "INT";
    ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
  })(ValueType = exports.ValueType || (exports.ValueType = {}));
});

// node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultTextMapSetter = exports.defaultTextMapGetter = undefined;
  exports.defaultTextMapGetter = {
    get(carrier, key) {
      if (carrier == null) {
        return;
      }
      return carrier[key];
    },
    keys(carrier) {
      if (carrier == null) {
        return [];
      }
      return Object.keys(carrier);
    }
  };
  exports.defaultTextMapSetter = {
    set(carrier, key, value4) {
      if (carrier == null) {
        return;
      }
      carrier[key] = value4;
    }
  };
});

// node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopContextManager = undefined;
  var context_1 = require_context();

  class NoopContextManager {
    active() {
      return context_1.ROOT_CONTEXT;
    }
    with(_context, fn, thisArg, ...args) {
      return fn.call(thisArg, ...args);
    }
    bind(_context, target) {
      return target;
    }
    enable() {
      return this;
    }
    disable() {
      return this;
    }
  }
  exports.NoopContextManager = NoopContextManager;
});

// node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ContextAPI = undefined;
  var NoopContextManager_1 = require_NoopContextManager();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "context";
  var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager;

  class ContextAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new ContextAPI;
      }
      return this._instance;
    }
    setGlobalContextManager(contextManager) {
      return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
    }
    active() {
      return this._getContextManager().active();
    }
    with(context, fn, thisArg, ...args) {
      return this._getContextManager().with(context, fn, thisArg, ...args);
    }
    bind(context, target) {
      return this._getContextManager().bind(context, target);
    }
    _getContextManager() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
    }
    disable() {
      this._getContextManager().disable();
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.ContextAPI = ContextAPI;
});

// node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceFlags = undefined;
  var TraceFlags;
  (function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = undefined;
  var trace_flags_1 = require_trace_flags();
  exports.INVALID_SPANID = "0000000000000000";
  exports.INVALID_TRACEID = "00000000000000000000000000000000";
  exports.INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACEID,
    spanId: exports.INVALID_SPANID,
    traceFlags: trace_flags_1.TraceFlags.NONE
  };
});

// node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NonRecordingSpan = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();

  class NonRecordingSpan {
    constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
      this._spanContext = _spanContext;
    }
    spanContext() {
      return this._spanContext;
    }
    setAttribute(_key, _value) {
      return this;
    }
    setAttributes(_attributes) {
      return this;
    }
    addEvent(_name, _attributes) {
      return this;
    }
    setStatus(_status) {
      return this;
    }
    updateName(_name) {
      return this;
    }
    end(_endTime) {
    }
    isRecording() {
      return false;
    }
    recordException(_exception, _time) {
    }
  }
  exports.NonRecordingSpan = NonRecordingSpan;
});

// node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS((exports) => {
  var getSpan = function(context) {
    return context.getValue(SPAN_KEY) || undefined;
  };
  var getActiveSpan = function() {
    return getSpan(context_2.ContextAPI.getInstance().active());
  };
  var setSpan = function(context, span) {
    return context.setValue(SPAN_KEY, span);
  };
  var deleteSpan = function(context) {
    return context.deleteValue(SPAN_KEY);
  };
  var setSpanContext = function(context, spanContext) {
    return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
  };
  var getSpanContext = function(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === undefined ? undefined : _a.spanContext();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = undefined;
  var context_1 = require_context();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var context_2 = require_context2();
  var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
  exports.getSpan = getSpan;
  exports.getActiveSpan = getActiveSpan;
  exports.setSpan = setSpan;
  exports.deleteSpan = deleteSpan;
  exports.setSpanContext = setSpanContext;
  exports.getSpanContext = getSpanContext;
});

// node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS((exports) => {
  var isValidTraceId = function(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
  };
  var isValidSpanId = function(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
  };
  var isSpanContextValid = function(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  };
  var wrapSpanContext = function(spanContext) {
    return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = undefined;
  var invalid_span_constants_1 = require_invalid_span_constants();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  exports.isValidTraceId = isValidTraceId;
  exports.isValidSpanId = isValidSpanId;
  exports.isSpanContextValid = isSpanContextValid;
  exports.wrapSpanContext = wrapSpanContext;
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS((exports) => {
  var isSpanContext = function(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracer = undefined;
  var context_1 = require_context2();
  var context_utils_1 = require_context_utils();
  var NonRecordingSpan_1 = require_NonRecordingSpan();
  var spancontext_utils_1 = require_spancontext_utils();
  var contextApi = context_1.ContextAPI.getInstance();

  class NoopTracer {
    startSpan(name, options, context = contextApi.active()) {
      const root = Boolean(options === null || options === undefined ? undefined : options.root);
      if (root) {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
      const parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
      if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
        return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan_1.NonRecordingSpan;
      }
    }
    startActiveSpan(name, arg2, arg3, arg4) {
      let opts;
      let ctx;
      let fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      const parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
      const span = this.startSpan(name, opts, parentContext);
      const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, undefined, span);
    }
  }
  exports.NoopTracer = NoopTracer;
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracer = undefined;
  var NoopTracer_1 = require_NoopTracer();
  var NOOP_TRACER = new NoopTracer_1.NoopTracer;

  class ProxyTracer {
    constructor(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    startSpan(name, options, context) {
      return this._getTracer().startSpan(name, options, context);
    }
    startActiveSpan(_name, _options, _context, _fn) {
      const tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    }
    _getTracer() {
      if (this._delegate) {
        return this._delegate;
      }
      const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    }
  }
  exports.ProxyTracer = ProxyTracer;
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTracerProvider = undefined;
  var NoopTracer_1 = require_NoopTracer();

  class NoopTracerProvider {
    getTracer(_name, _version, _options) {
      return new NoopTracer_1.NoopTracer;
    }
  }
  exports.NoopTracerProvider = NoopTracerProvider;
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProxyTracerProvider = undefined;
  var ProxyTracer_1 = require_ProxyTracer();
  var NoopTracerProvider_1 = require_NoopTracerProvider();
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider;

  class ProxyTracerProvider {
    getTracer(name, version, options) {
      var _a;
      return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== undefined ? _a : new ProxyTracer_1.ProxyTracer(this, name, version, options);
    }
    getDelegate() {
      var _a;
      return (_a = this._delegate) !== null && _a !== undefined ? _a : NOOP_TRACER_PROVIDER;
    }
    setDelegate(delegate) {
      this._delegate = delegate;
    }
    getDelegateTracer(name, version, options) {
      var _a;
      return (_a = this._delegate) === null || _a === undefined ? undefined : _a.getTracer(name, version, options);
    }
  }
  exports.ProxyTracerProvider = ProxyTracerProvider;
});

// node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SamplingDecision = undefined;
  var SamplingDecision;
  (function(SamplingDecision2) {
    SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
    SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
    SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanKind = undefined;
  var SpanKind;
  (function(SpanKind2) {
    SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
    SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
    SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
    SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
    SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
  })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpanStatusCode = undefined;
  var SpanStatusCode;
  (function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS((exports) => {
  var validateKey = function(key) {
    return VALID_KEY_REGEX.test(key);
  };
  var validateValue = function(value4) {
    return VALID_VALUE_BASE_REGEX.test(value4) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value4);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateValue = exports.validateKey = undefined;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
  var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
  var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
  var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})\$`);
  var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
  var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  exports.validateKey = validateKey;
  exports.validateValue = validateValue;
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceStateImpl = undefined;
  var tracestate_validators_1 = require_tracestate_validators();
  var MAX_TRACE_STATE_ITEMS = 32;
  var MAX_TRACE_STATE_LEN = 512;
  var LIST_MEMBERS_SEPARATOR = ",";
  var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";

  class TraceStateImpl {
    constructor(rawTraceState) {
      this._internalState = new Map;
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    set(key, value4) {
      const traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value4);
      return traceState;
    }
    unset(key) {
      const traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    }
    get(key) {
      return this._internalState.get(key);
    }
    serialize() {
      return this._keys().reduce((agg, key) => {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
        const listMember = part.trim();
        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          const key = listMember.slice(0, i);
          const value4 = listMember.slice(i + 1, part.length);
          if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value4)) {
            agg.set(key, value4);
          } else {
          }
        }
        return agg;
      }, new Map);
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    }
    _keys() {
      return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
      const traceState = new TraceStateImpl;
      traceState._internalState = new Map(this._internalState);
      return traceState;
    }
  }
  exports.TraceStateImpl = TraceStateImpl;
});

// node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils3 = __commonJS((exports) => {
  var createTraceState = function(rawTraceState) {
    return new tracestate_impl_1.TraceStateImpl(rawTraceState);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTraceState = undefined;
  var tracestate_impl_1 = require_tracestate_impl();
  exports.createTraceState = createTraceState;
});

// node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.context = undefined;
  var context_1 = require_context2();
  exports.context = context_1.ContextAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.diag = undefined;
  var diag_1 = require_diag();
  exports.diag = diag_1.DiagAPI.instance();
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = undefined;
  var NoopMeter_1 = require_NoopMeter();

  class NoopMeterProvider {
    getMeter(_name, _version, _options) {
      return NoopMeter_1.NOOP_METER;
    }
  }
  exports.NoopMeterProvider = NoopMeterProvider;
  exports.NOOP_METER_PROVIDER = new NoopMeterProvider;
});

// node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MetricsAPI = undefined;
  var NoopMeterProvider_1 = require_NoopMeterProvider();
  var global_utils_1 = require_global_utils();
  var diag_1 = require_diag();
  var API_NAME = "metrics";

  class MetricsAPI {
    constructor() {
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new MetricsAPI;
      }
      return this._instance;
    }
    setGlobalMeterProvider(provider) {
      return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
    }
    getMeterProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
    }
    getMeter(name, version, options) {
      return this.getMeterProvider().getMeter(name, version, options);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
  }
  exports.MetricsAPI = MetricsAPI;
});

// node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metrics = undefined;
  var metrics_1 = require_metrics();
  exports.metrics = metrics_1.MetricsAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoopTextMapPropagator = undefined;

  class NoopTextMapPropagator {
    inject(_context, _carrier) {
    }
    extract(context, _carrier) {
      return context;
    }
    fields() {
      return [];
    }
  }
  exports.NoopTextMapPropagator = NoopTextMapPropagator;
});

// node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS((exports) => {
  var getBaggage = function(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
  };
  var getActiveBaggage = function() {
    return getBaggage(context_1.ContextAPI.getInstance().active());
  };
  var setBaggage = function(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
  };
  var deleteBaggage = function(context) {
    return context.deleteValue(BAGGAGE_KEY);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = undefined;
  var context_1 = require_context2();
  var context_2 = require_context();
  var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
  exports.getBaggage = getBaggage;
  exports.getActiveBaggage = getActiveBaggage;
  exports.setBaggage = setBaggage;
  exports.deleteBaggage = deleteBaggage;
});

// node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PropagationAPI = undefined;
  var global_utils_1 = require_global_utils();
  var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
  var TextMapPropagator_1 = require_TextMapPropagator();
  var context_helpers_1 = require_context_helpers();
  var utils_1 = require_utils2();
  var diag_1 = require_diag();
  var API_NAME = "propagation";
  var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator;

  class PropagationAPI {
    constructor() {
      this.createBaggage = utils_1.createBaggage;
      this.getBaggage = context_helpers_1.getBaggage;
      this.getActiveBaggage = context_helpers_1.getActiveBaggage;
      this.setBaggage = context_helpers_1.setBaggage;
      this.deleteBaggage = context_helpers_1.deleteBaggage;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new PropagationAPI;
      }
      return this._instance;
    }
    setGlobalPropagator(propagator) {
      return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
    }
    inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
      return this._getGlobalPropagator().inject(context, carrier, setter);
    }
    extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
      return this._getGlobalPropagator().extract(context, carrier, getter);
    }
    fields() {
      return this._getGlobalPropagator().fields();
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
    }
    _getGlobalPropagator() {
      return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    }
  }
  exports.PropagationAPI = PropagationAPI;
});

// node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.propagation = undefined;
  var propagation_1 = require_propagation();
  exports.propagation = propagation_1.PropagationAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TraceAPI = undefined;
  var global_utils_1 = require_global_utils();
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  var spancontext_utils_1 = require_spancontext_utils();
  var context_utils_1 = require_context_utils();
  var diag_1 = require_diag();
  var API_NAME = "trace";

  class TraceAPI {
    constructor() {
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
      this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
      this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
      this.deleteSpan = context_utils_1.deleteSpan;
      this.getSpan = context_utils_1.getSpan;
      this.getActiveSpan = context_utils_1.getActiveSpan;
      this.getSpanContext = context_utils_1.getSpanContext;
      this.setSpan = context_utils_1.setSpan;
      this.setSpanContext = context_utils_1.setSpanContext;
    }
    static getInstance() {
      if (!this._instance) {
        this._instance = new TraceAPI;
      }
      return this._instance;
    }
    setGlobalTracerProvider(provider) {
      const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    }
    getTracerProvider() {
      return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
    }
    getTracer(name, version) {
      return this.getTracerProvider().getTracer(name, version);
    }
    disable() {
      (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider;
    }
  }
  exports.TraceAPI = TraceAPI;
});

// node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = undefined;
  var trace_1 = require_trace();
  exports.trace = trace_1.TraceAPI.getInstance();
});

// node_modules/@opentelemetry/api/build/src/index.js
var require_src3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = undefined;
  var utils_1 = require_utils2();
  Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
    return utils_1.baggageEntryMetadataFromString;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "createContextKey", { enumerable: true, get: function() {
    return context_1.createContextKey;
  } });
  Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: function() {
    return context_1.ROOT_CONTEXT;
  } });
  var consoleLogger_1 = require_consoleLogger();
  Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: function() {
    return consoleLogger_1.DiagConsoleLogger;
  } });
  var types_1 = require_types4();
  Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: function() {
    return types_1.DiagLogLevel;
  } });
  var NoopMeter_1 = require_NoopMeter();
  Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: function() {
    return NoopMeter_1.createNoopMeter;
  } });
  var Metric_1 = require_Metric();
  Object.defineProperty(exports, "ValueType", { enumerable: true, get: function() {
    return Metric_1.ValueType;
  } });
  var TextMapPropagator_1 = require_TextMapPropagator();
  Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapGetter;
  } });
  Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: function() {
    return TextMapPropagator_1.defaultTextMapSetter;
  } });
  var ProxyTracer_1 = require_ProxyTracer();
  Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: function() {
    return ProxyTracer_1.ProxyTracer;
  } });
  var ProxyTracerProvider_1 = require_ProxyTracerProvider();
  Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: function() {
    return ProxyTracerProvider_1.ProxyTracerProvider;
  } });
  var SamplingResult_1 = require_SamplingResult();
  Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: function() {
    return SamplingResult_1.SamplingDecision;
  } });
  var span_kind_1 = require_span_kind();
  Object.defineProperty(exports, "SpanKind", { enumerable: true, get: function() {
    return span_kind_1.SpanKind;
  } });
  var status_1 = require_status();
  Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: function() {
    return status_1.SpanStatusCode;
  } });
  var trace_flags_1 = require_trace_flags();
  Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: function() {
    return trace_flags_1.TraceFlags;
  } });
  var utils_2 = require_utils3();
  Object.defineProperty(exports, "createTraceState", { enumerable: true, get: function() {
    return utils_2.createTraceState;
  } });
  var spancontext_utils_1 = require_spancontext_utils();
  Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: function() {
    return spancontext_utils_1.isSpanContextValid;
  } });
  Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidTraceId;
  } });
  Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: function() {
    return spancontext_utils_1.isValidSpanId;
  } });
  var invalid_span_constants_1 = require_invalid_span_constants();
  Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPANID;
  } });
  Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_TRACEID;
  } });
  Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
    return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
  } });
  var context_api_1 = require_context_api();
  Object.defineProperty(exports, "context", { enumerable: true, get: function() {
    return context_api_1.context;
  } });
  var diag_api_1 = require_diag_api();
  Object.defineProperty(exports, "diag", { enumerable: true, get: function() {
    return diag_api_1.diag;
  } });
  var metrics_api_1 = require_metrics_api();
  Object.defineProperty(exports, "metrics", { enumerable: true, get: function() {
    return metrics_api_1.metrics;
  } });
  var propagation_api_1 = require_propagation_api();
  Object.defineProperty(exports, "propagation", { enumerable: true, get: function() {
    return propagation_api_1.propagation;
  } });
  var trace_api_1 = require_trace_api();
  Object.defineProperty(exports, "trace", { enumerable: true, get: function() {
    return trace_api_1.trace;
  } });
  exports.default = {
    context: context_api_1.context,
    diag: diag_api_1.diag,
    metrics: metrics_api_1.metrics,
    propagation: propagation_api_1.propagation,
    trace: trace_api_1.trace
  };
});

// node_modules/prom-client/lib/metrics/processCpuTotal.js
var require_processCpuTotal = __commonJS((exports, module) => {
  var OtelApi = require_src3();
  var Counter = require_counter();
  var PROCESS_CPU_USER_SECONDS = "process_cpu_user_seconds_total";
  var PROCESS_CPU_SYSTEM_SECONDS = "process_cpu_system_seconds_total";
  var PROCESS_CPU_SECONDS = "process_cpu_seconds_total";
  module.exports = (registry, config = {}) => {
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const exemplars = config.enableExemplars ? config.enableExemplars : false;
    const labelNames = Object.keys(labels);
    let lastCpuUsage = process.cpuUsage();
    const cpuUserUsageCounter = new Counter({
      name: namePrefix + PROCESS_CPU_USER_SECONDS,
      help: "Total user CPU time spent in seconds.",
      enableExemplars: exemplars,
      registers,
      labelNames,
      collect() {
        const cpuUsage = process.cpuUsage();
        const userUsageMicros = cpuUsage.user - lastCpuUsage.user;
        const systemUsageMicros = cpuUsage.system - lastCpuUsage.system;
        lastCpuUsage = cpuUsage;
        if (this.enableExemplars) {
          let exemplarLabels = {};
          const currentSpan = OtelApi.trace.getSpan(OtelApi.context.active());
          if (currentSpan) {
            exemplarLabels = {
              traceId: currentSpan.spanContext().traceId,
              spanId: currentSpan.spanContext().spanId
            };
          }
          cpuUserUsageCounter.inc({
            labels,
            value: userUsageMicros / 1e6,
            exemplarLabels
          });
          cpuSystemUsageCounter.inc({
            labels,
            value: systemUsageMicros / 1e6,
            exemplarLabels
          });
          cpuUsageCounter.inc({
            labels,
            value: (userUsageMicros + systemUsageMicros) / 1e6,
            exemplarLabels
          });
        } else {
          cpuUserUsageCounter.inc(labels, userUsageMicros / 1e6);
          cpuSystemUsageCounter.inc(labels, systemUsageMicros / 1e6);
          cpuUsageCounter.inc(labels, (userUsageMicros + systemUsageMicros) / 1e6);
        }
      }
    });
    const cpuSystemUsageCounter = new Counter({
      name: namePrefix + PROCESS_CPU_SYSTEM_SECONDS,
      help: "Total system CPU time spent in seconds.",
      enableExemplars: exemplars,
      registers,
      labelNames
    });
    const cpuUsageCounter = new Counter({
      name: namePrefix + PROCESS_CPU_SECONDS,
      help: "Total user and system CPU time spent in seconds.",
      enableExemplars: exemplars,
      registers,
      labelNames
    });
  };
  module.exports.metricNames = [
    PROCESS_CPU_USER_SECONDS,
    PROCESS_CPU_SYSTEM_SECONDS,
    PROCESS_CPU_SECONDS
  ];
});

// node_modules/prom-client/lib/metrics/processStartTime.js
var require_processStartTime = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var startInSeconds = Math.round(Date.now() / 1000 - process.uptime());
  var PROCESS_START_TIME = "process_start_time_seconds";
  module.exports = (registry, config = {}) => {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_START_TIME,
      help: "Start time of the process since unix epoch in seconds.",
      registers: registry ? [registry] : undefined,
      labelNames,
      aggregator: "omit",
      collect() {
        this.set(labels, startInSeconds);
      }
    });
  };
  module.exports.metricNames = [PROCESS_START_TIME];
});

// node_modules/prom-client/lib/metrics/osMemoryHeapLinux.js
var require_osMemoryHeapLinux = __commonJS((exports, module) => {
  var structureOutput = function(input) {
    const returnValue = {};
    input.split("\n").filter((s2) => values.some((value4) => s2.indexOf(value4) === 0)).forEach((string) => {
      const split = string.split(":");
      let value4 = split[1].trim();
      value4 = value4.substr(0, value4.length - 3);
      value4 = Number(value4) * 1024;
      returnValue[split[0]] = value4;
    });
    return returnValue;
  };
  var Gauge = require_gauge();
  var fs = import.meta.require("fs");
  var values = ["VmSize", "VmRSS", "VmData"];
  var PROCESS_RESIDENT_MEMORY = "process_resident_memory_bytes";
  var PROCESS_VIRTUAL_MEMORY = "process_virtual_memory_bytes";
  var PROCESS_HEAP = "process_heap_bytes";
  module.exports = (registry, config = {}) => {
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const residentMemGauge = new Gauge({
      name: namePrefix + PROCESS_RESIDENT_MEMORY,
      help: "Resident memory size in bytes.",
      registers,
      labelNames,
      collect() {
        try {
          const stat = fs.readFileSync("/proc/self/status", "utf8");
          const structuredOutput = structureOutput(stat);
          residentMemGauge.set(labels, structuredOutput.VmRSS);
          virtualMemGauge.set(labels, structuredOutput.VmSize);
          heapSizeMemGauge.set(labels, structuredOutput.VmData);
        } catch {
        }
      }
    });
    const virtualMemGauge = new Gauge({
      name: namePrefix + PROCESS_VIRTUAL_MEMORY,
      help: "Virtual memory size in bytes.",
      registers,
      labelNames
    });
    const heapSizeMemGauge = new Gauge({
      name: namePrefix + PROCESS_HEAP,
      help: "Process heap size in bytes.",
      registers,
      labelNames
    });
  };
  module.exports.metricNames = [
    PROCESS_RESIDENT_MEMORY,
    PROCESS_VIRTUAL_MEMORY,
    PROCESS_HEAP
  ];
});

// node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js
var require_safeMemoryUsage = __commonJS((exports, module) => {
  var safeMemoryUsage = function() {
    try {
      return process.memoryUsage();
    } catch {
      return;
    }
  };
  module.exports = safeMemoryUsage;
});

// node_modules/prom-client/lib/metrics/osMemoryHeap.js
var require_osMemoryHeap = __commonJS((exports, module) => {
  var notLinuxVariant = function(registry, config = {}) {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_RESIDENT_MEMORY,
      help: "Resident memory size in bytes.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        const memUsage = safeMemoryUsage();
        if (memUsage) {
          this.set(labels, memUsage.rss);
        }
      }
    });
  };
  var Gauge = require_gauge();
  var linuxVariant = require_osMemoryHeapLinux();
  var safeMemoryUsage = require_safeMemoryUsage();
  var PROCESS_RESIDENT_MEMORY = "process_resident_memory_bytes";
  module.exports = (registry, config) => process.platform === "linux" ? linuxVariant(registry, config) : notLinuxVariant(registry, config);
  module.exports.metricNames = process.platform === "linux" ? linuxVariant.metricNames : [PROCESS_RESIDENT_MEMORY];
});

// node_modules/prom-client/lib/metrics/processOpenFileDescriptors.js
var require_processOpenFileDescriptors = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var fs = import.meta.require("fs");
  var process2 = import.meta.require("process");
  var PROCESS_OPEN_FDS = "process_open_fds";
  module.exports = (registry, config = {}) => {
    if (process2.platform !== "linux") {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_OPEN_FDS,
      help: "Number of open file descriptors.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        try {
          const fds = fs.readdirSync("/proc/self/fd");
          this.set(labels, fds.length - 1);
        } catch {
        }
      }
    });
  };
  module.exports.metricNames = [PROCESS_OPEN_FDS];
});

// node_modules/prom-client/lib/metrics/processMaxFileDescriptors.js
var require_processMaxFileDescriptors = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var fs = import.meta.require("fs");
  var PROCESS_MAX_FDS = "process_max_fds";
  var maxFds;
  module.exports = (registry, config = {}) => {
    if (maxFds === undefined) {
      try {
        const limits = fs.readFileSync("/proc/self/limits", "utf8");
        const lines = limits.split("\n");
        for (const line of lines) {
          if (line.startsWith("Max open files")) {
            const parts = line.split(/  +/);
            maxFds = Number(parts[1]);
            break;
          }
        }
      } catch {
        return;
      }
    }
    if (maxFds === undefined)
      return;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + PROCESS_MAX_FDS,
      help: "Maximum number of open file descriptors.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        if (maxFds !== undefined)
          this.set(labels, maxFds);
      }
    });
  };
  module.exports.metricNames = [PROCESS_MAX_FDS];
});

// node_modules/prom-client/lib/metrics/eventLoopLag.js
var require_eventLoopLag = __commonJS((exports, module) => {
  var reportEventloopLag = function(start, gauge, labels) {
    const delta = process.hrtime(start);
    const nanosec = delta[0] * 1e9 + delta[1];
    const seconds = nanosec / 1e9;
    gauge.set(labels, seconds);
  };
  var Gauge = require_gauge();
  var perf_hooks;
  try {
    perf_hooks = import.meta.require("perf_hooks");
  } catch {
  }
  var NODEJS_EVENTLOOP_LAG = "nodejs_eventloop_lag_seconds";
  var NODEJS_EVENTLOOP_LAG_MIN = "nodejs_eventloop_lag_min_seconds";
  var NODEJS_EVENTLOOP_LAG_MAX = "nodejs_eventloop_lag_max_seconds";
  var NODEJS_EVENTLOOP_LAG_MEAN = "nodejs_eventloop_lag_mean_seconds";
  var NODEJS_EVENTLOOP_LAG_STDDEV = "nodejs_eventloop_lag_stddev_seconds";
  var NODEJS_EVENTLOOP_LAG_P50 = "nodejs_eventloop_lag_p50_seconds";
  var NODEJS_EVENTLOOP_LAG_P90 = "nodejs_eventloop_lag_p90_seconds";
  var NODEJS_EVENTLOOP_LAG_P99 = "nodejs_eventloop_lag_p99_seconds";
  module.exports = (registry, config = {}) => {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const registers = registry ? [registry] : undefined;
    let collect;
    if (!perf_hooks || !perf_hooks.monitorEventLoopDelay) {
      collect = () => {
        const start = process.hrtime();
        setImmediate(reportEventloopLag, start, lag, labels);
      };
    } else {
      const histogram = perf_hooks.monitorEventLoopDelay({
        resolution: config.eventLoopMonitoringPrecision
      });
      histogram.enable();
      collect = () => {
        const start = process.hrtime();
        setImmediate(reportEventloopLag, start, lag, labels);
        lagMin.set(labels, histogram.min / 1e9);
        lagMax.set(labels, histogram.max / 1e9);
        lagMean.set(labels, histogram.mean / 1e9);
        lagStddev.set(labels, histogram.stddev / 1e9);
        lagP50.set(labels, histogram.percentile(50) / 1e9);
        lagP90.set(labels, histogram.percentile(90) / 1e9);
        lagP99.set(labels, histogram.percentile(99) / 1e9);
        histogram.reset();
      };
    }
    const lag = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG,
      help: "Lag of event loop in seconds.",
      registers,
      labelNames,
      aggregator: "average",
      collect
    });
    const lagMin = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_MIN,
      help: "The minimum recorded event loop delay.",
      registers,
      labelNames,
      aggregator: "min"
    });
    const lagMax = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_MAX,
      help: "The maximum recorded event loop delay.",
      registers,
      labelNames,
      aggregator: "max"
    });
    const lagMean = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_MEAN,
      help: "The mean of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagStddev = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_STDDEV,
      help: "The standard deviation of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagP50 = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_P50,
      help: "The 50th percentile of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagP90 = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_P90,
      help: "The 90th percentile of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
    const lagP99 = new Gauge({
      name: namePrefix + NODEJS_EVENTLOOP_LAG_P99,
      help: "The 99th percentile of the recorded event loop delays.",
      registers,
      labelNames,
      aggregator: "average"
    });
  };
  module.exports.metricNames = [
    NODEJS_EVENTLOOP_LAG,
    NODEJS_EVENTLOOP_LAG_MIN,
    NODEJS_EVENTLOOP_LAG_MAX,
    NODEJS_EVENTLOOP_LAG_MEAN,
    NODEJS_EVENTLOOP_LAG_STDDEV,
    NODEJS_EVENTLOOP_LAG_P50,
    NODEJS_EVENTLOOP_LAG_P90,
    NODEJS_EVENTLOOP_LAG_P99
  ];
});

// node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js
var require_processMetricsHelpers = __commonJS((exports, module) => {
  var aggregateByObjectName = function(list) {
    const data = {};
    for (let i = 0;i < list.length; i++) {
      const listElement = list[i];
      if (!listElement || typeof listElement.constructor === "undefined") {
        continue;
      }
      if (Object.hasOwnProperty.call(data, listElement.constructor.name)) {
        data[listElement.constructor.name] += 1;
      } else {
        data[listElement.constructor.name] = 1;
      }
    }
    return data;
  };
  var updateMetrics = function(gauge, data, labels) {
    gauge.reset();
    for (const key in data) {
      gauge.set(Object.assign({ type: key }, labels || {}), data[key]);
    }
  };
  module.exports = {
    aggregateByObjectName,
    updateMetrics
  };
});

// node_modules/prom-client/lib/metrics/processHandles.js
var require_processHandles = __commonJS((exports, module) => {
  var { aggregateByObjectName } = require_processMetricsHelpers();
  var { updateMetrics } = require_processMetricsHelpers();
  var Gauge = require_gauge();
  var NODEJS_ACTIVE_HANDLES = "nodejs_active_handles";
  var NODEJS_ACTIVE_HANDLES_TOTAL = "nodejs_active_handles_total";
  module.exports = (registry, config = {}) => {
    if (typeof process._getActiveHandles !== "function") {
      return;
    }
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_HANDLES,
      help: "Number of active libuv handles grouped by handle type. Every handle type is C++ class name.",
      labelNames: ["type", ...labelNames],
      registers,
      collect() {
        const handles = process._getActiveHandles();
        updateMetrics(this, aggregateByObjectName(handles), labels);
      }
    });
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_HANDLES_TOTAL,
      help: "Total number of active handles.",
      registers,
      labelNames,
      collect() {
        const handles = process._getActiveHandles();
        this.set(labels, handles.length);
      }
    });
  };
  module.exports.metricNames = [
    NODEJS_ACTIVE_HANDLES,
    NODEJS_ACTIVE_HANDLES_TOTAL
  ];
});

// node_modules/prom-client/lib/metrics/processRequests.js
var require_processRequests = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var { aggregateByObjectName } = require_processMetricsHelpers();
  var { updateMetrics } = require_processMetricsHelpers();
  var NODEJS_ACTIVE_REQUESTS = "nodejs_active_requests";
  var NODEJS_ACTIVE_REQUESTS_TOTAL = "nodejs_active_requests_total";
  module.exports = (registry, config = {}) => {
    if (typeof process._getActiveRequests !== "function") {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_REQUESTS,
      help: "Number of active libuv requests grouped by request type. Every request type is C++ class name.",
      labelNames: ["type", ...labelNames],
      registers: registry ? [registry] : undefined,
      collect() {
        const requests = process._getActiveRequests();
        updateMetrics(this, aggregateByObjectName(requests), labels);
      }
    });
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_REQUESTS_TOTAL,
      help: "Total number of active requests.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        const requests = process._getActiveRequests();
        this.set(labels, requests.length);
      }
    });
  };
  module.exports.metricNames = [
    NODEJS_ACTIVE_REQUESTS,
    NODEJS_ACTIVE_REQUESTS_TOTAL
  ];
});

// node_modules/prom-client/lib/metrics/processResources.js
var require_processResources = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var { updateMetrics } = require_processMetricsHelpers();
  var NODEJS_ACTIVE_RESOURCES = "nodejs_active_resources";
  var NODEJS_ACTIVE_RESOURCES_TOTAL = "nodejs_active_resources_total";
  module.exports = (registry, config = {}) => {
    if (typeof process.getActiveResourcesInfo !== "function") {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_RESOURCES,
      help: "Number of active resources that are currently keeping the event loop alive, grouped by async resource type.",
      labelNames: ["type", ...labelNames],
      registers: registry ? [registry] : undefined,
      collect() {
        const resources = process.getActiveResourcesInfo();
        const data = {};
        for (let i = 0;i < resources.length; i++) {
          const resource = resources[i];
          if (Object.hasOwn(data, resource)) {
            data[resource] += 1;
          } else {
            data[resource] = 1;
          }
        }
        updateMetrics(this, data, labels);
      }
    });
    new Gauge({
      name: namePrefix + NODEJS_ACTIVE_RESOURCES_TOTAL,
      help: "Total number of active resources.",
      registers: registry ? [registry] : undefined,
      labelNames,
      collect() {
        const resources = process.getActiveResourcesInfo();
        this.set(labels, resources.length);
      }
    });
  };
  module.exports.metricNames = [
    NODEJS_ACTIVE_RESOURCES,
    NODEJS_ACTIVE_RESOURCES_TOTAL
  ];
});

// node_modules/prom-client/lib/metrics/heapSizeAndUsed.js
var require_heapSizeAndUsed = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var safeMemoryUsage = require_safeMemoryUsage();
  var NODEJS_HEAP_SIZE_TOTAL = "nodejs_heap_size_total_bytes";
  var NODEJS_HEAP_SIZE_USED = "nodejs_heap_size_used_bytes";
  var NODEJS_EXTERNAL_MEMORY = "nodejs_external_memory_bytes";
  module.exports = (registry, config = {}) => {
    if (typeof process.memoryUsage !== "function") {
      return;
    }
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const collect = () => {
      const memUsage = safeMemoryUsage();
      if (memUsage) {
        heapSizeTotal.set(labels, memUsage.heapTotal);
        heapSizeUsed.set(labels, memUsage.heapUsed);
        if (memUsage.external !== undefined) {
          externalMemUsed.set(labels, memUsage.external);
        }
      }
    };
    const heapSizeTotal = new Gauge({
      name: namePrefix + NODEJS_HEAP_SIZE_TOTAL,
      help: "Process heap size from Node.js in bytes.",
      registers,
      labelNames,
      collect
    });
    const heapSizeUsed = new Gauge({
      name: namePrefix + NODEJS_HEAP_SIZE_USED,
      help: "Process heap size used from Node.js in bytes.",
      registers,
      labelNames
    });
    const externalMemUsed = new Gauge({
      name: namePrefix + NODEJS_EXTERNAL_MEMORY,
      help: "Node.js external memory size in bytes.",
      registers,
      labelNames
    });
  };
  module.exports.metricNames = [
    NODEJS_HEAP_SIZE_TOTAL,
    NODEJS_HEAP_SIZE_USED,
    NODEJS_EXTERNAL_MEMORY
  ];
});

// node_modules/prom-client/lib/metrics/heapSpacesSizeAndUsed.js
var require_heapSpacesSizeAndUsed = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var v8 = import.meta.require("v8");
  var METRICS = ["total", "used", "available"];
  var NODEJS_HEAP_SIZE = {};
  METRICS.forEach((metricType) => {
    NODEJS_HEAP_SIZE[metricType] = `nodejs_heap_space_size_${metricType}_bytes`;
  });
  module.exports = (registry, config = {}) => {
    const registers = registry ? [registry] : undefined;
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = ["space", ...Object.keys(labels)];
    const gauges = {};
    METRICS.forEach((metricType) => {
      gauges[metricType] = new Gauge({
        name: namePrefix + NODEJS_HEAP_SIZE[metricType],
        help: `Process heap space size ${metricType} from Node.js in bytes.`,
        labelNames,
        registers
      });
    });
    gauges.total.collect = () => {
      for (const space of v8.getHeapSpaceStatistics()) {
        const spaceName = space.space_name.substr(0, space.space_name.indexOf("_space"));
        gauges.total.set({ space: spaceName, ...labels }, space.space_size);
        gauges.used.set({ space: spaceName, ...labels }, space.space_used_size);
        gauges.available.set({ space: spaceName, ...labels }, space.space_available_size);
      }
    };
  };
  module.exports.metricNames = Object.values(NODEJS_HEAP_SIZE);
});

// node_modules/prom-client/lib/metrics/version.js
var require_version2 = __commonJS((exports, module) => {
  var Gauge = require_gauge();
  var version = process.version;
  var versionSegments = version.slice(1).split(".").map(Number);
  var NODE_VERSION_INFO = "nodejs_version_info";
  module.exports = (registry, config = {}) => {
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    new Gauge({
      name: namePrefix + NODE_VERSION_INFO,
      help: "Node.js version info.",
      labelNames: ["version", "major", "minor", "patch", ...labelNames],
      registers: registry ? [registry] : undefined,
      aggregator: "first",
      collect() {
        this.labels(version, versionSegments[0], versionSegments[1], versionSegments[2], ...Object.values(labels)).set(1);
      }
    });
  };
  module.exports.metricNames = [NODE_VERSION_INFO];
});

// node_modules/prom-client/lib/metrics/gc.js
var require_gc = __commonJS((exports, module) => {
  var Histogram = require_histogram();
  var perf_hooks;
  try {
    perf_hooks = import.meta.require("perf_hooks");
  } catch {
  }
  var NODEJS_GC_DURATION_SECONDS = "nodejs_gc_duration_seconds";
  var DEFAULT_GC_DURATION_BUCKETS = [0.001, 0.01, 0.1, 1, 2, 5];
  var kinds = [];
  if (perf_hooks && perf_hooks.constants) {
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MAJOR] = "major";
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MINOR] = "minor";
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_INCREMENTAL] = "incremental";
    kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_WEAKCB] = "weakcb";
  }
  module.exports = (registry, config = {}) => {
    if (!perf_hooks) {
      return;
    }
    const namePrefix = config.prefix ? config.prefix : "";
    const labels = config.labels ? config.labels : {};
    const labelNames = Object.keys(labels);
    const buckets = config.gcDurationBuckets ? config.gcDurationBuckets : DEFAULT_GC_DURATION_BUCKETS;
    const gcHistogram = new Histogram({
      name: namePrefix + NODEJS_GC_DURATION_SECONDS,
      help: "Garbage collection duration by kind, one of major, minor, incremental or weakcb.",
      labelNames: ["kind", ...labelNames],
      enableExemplars: false,
      buckets,
      registers: registry ? [registry] : undefined
    });
    const obs = new perf_hooks.PerformanceObserver((list) => {
      const entry = list.getEntries()[0];
      const kind = entry.detail ? kinds[entry.detail.kind] : kinds[entry.kind];
      gcHistogram.observe(Object.assign({ kind }, labels), entry.duration / 1000);
    });
    obs.observe({ entryTypes: ["gc"] });
  };
  module.exports.metricNames = [NODEJS_GC_DURATION_SECONDS];
});

// node_modules/prom-client/lib/defaultMetrics.js
var require_defaultMetrics = __commonJS((exports, module) => {
  var { isObject } = require_util();
  var processCpuTotal = require_processCpuTotal();
  var processStartTime = require_processStartTime();
  var osMemoryHeap = require_osMemoryHeap();
  var processOpenFileDescriptors = require_processOpenFileDescriptors();
  var processMaxFileDescriptors = require_processMaxFileDescriptors();
  var eventLoopLag = require_eventLoopLag();
  var processHandles = require_processHandles();
  var processRequests = require_processRequests();
  var processResources = require_processResources();
  var heapSizeAndUsed = require_heapSizeAndUsed();
  var heapSpacesSizeAndUsed = require_heapSpacesSizeAndUsed();
  var version = require_version2();
  var gc = require_gc();
  var metrics = {
    processCpuTotal,
    processStartTime,
    osMemoryHeap,
    processOpenFileDescriptors,
    processMaxFileDescriptors,
    eventLoopLag,
    ...typeof process.getActiveResourcesInfo === "function" ? { processResources } : {},
    processHandles,
    processRequests,
    heapSizeAndUsed,
    heapSpacesSizeAndUsed,
    version,
    gc
  };
  var metricsList = Object.keys(metrics);
  module.exports = function collectDefaultMetrics(config) {
    if (config !== null && config !== undefined && !isObject(config)) {
      throw new TypeError("config must be null, undefined, or an object");
    }
    config = { eventLoopMonitoringPrecision: 10, ...config };
    for (const metric of Object.values(metrics)) {
      metric(config.register, config);
    }
  };
  module.exports.metricsList = metricsList;
});

// node_modules/prom-client/lib/metricAggregators.js
var require_metricAggregators = __commonJS((exports) => {
  var AggregatorFactory = function(aggregatorFn) {
    return (metrics) => {
      if (metrics.length === 0)
        return;
      const result = {
        help: metrics[0].help,
        name: metrics[0].name,
        type: metrics[0].type,
        values: [],
        aggregator: metrics[0].aggregator
      };
      const byLabels = new Grouper;
      metrics.forEach((metric) => {
        metric.values.forEach((value4) => {
          const key = hashObject(value4.labels);
          byLabels.add(`${value4.metricName}_${key}`, value4);
        });
      });
      byLabels.forEach((values) => {
        if (values.length === 0)
          return;
        const valObj = {
          value: aggregatorFn(values),
          labels: values[0].labels
        };
        if (values[0].metricName) {
          valObj.metricName = values[0].metricName;
        }
        result.values.push(valObj);
      });
      return result;
    };
  };
  var { Grouper, hashObject } = require_util();
  exports.AggregatorFactory = AggregatorFactory;
  exports.aggregators = {
    sum: AggregatorFactory((v) => v.reduce((p, c2) => p + c2.value, 0)),
    first: AggregatorFactory((v) => v[0].value),
    omit: () => {
    },
    average: AggregatorFactory((v) => v.reduce((p, c2) => p + c2.value, 0) / v.length),
    min: AggregatorFactory((v) => v.reduce((p, c2) => Math.min(p, c2.value), Infinity)),
    max: AggregatorFactory((v) => v.reduce((p, c2) => Math.max(p, c2.value), (-Infinity)))
  };
});

// node_modules/prom-client/lib/cluster.js
var require_cluster = __commonJS((exports, module) => {
  var addListeners = function() {
    if (listenersAdded)
      return;
    listenersAdded = true;
    if (cluster().isMaster) {
      cluster().on("message", (worker, message) => {
        if (message.type === GET_METRICS_RES) {
          const request2 = requests.get(message.requestId);
          if (message.error) {
            request2.done(new Error(message.error));
            return;
          }
          message.metrics.forEach((registry) => request2.responses.push(registry));
          request2.pending--;
          if (request2.pending === 0) {
            requests.delete(message.requestId);
            clearTimeout(request2.errorTimeout);
            const registry = AggregatorRegistry.aggregate(request2.responses);
            const promString = registry.metrics();
            request2.done(null, promString);
          }
        }
      });
    }
    if (cluster().isWorker) {
      process.on("message", (message) => {
        if (message.type === GET_METRICS_REQ) {
          Promise.all(registries.map((r) => r.getMetricsAsJSON())).then((metrics) => {
            process.send({
              type: GET_METRICS_RES,
              requestId: message.requestId,
              metrics
            });
          }).catch((error) => {
            process.send({
              type: GET_METRICS_RES,
              requestId: message.requestId,
              error: error.message
            });
          });
        }
      });
    }
  };
  var Registry = require_registry();
  var { Grouper } = require_util();
  var { aggregators } = require_metricAggregators();
  var cluster = () => {
    const data = import.meta.require("cluster");
    cluster = () => data;
    return data;
  };
  var GET_METRICS_REQ = "prom-client:getMetricsReq";
  var GET_METRICS_RES = "prom-client:getMetricsRes";
  var registries = [Registry.globalRegistry];
  var requestCtr = 0;
  var listenersAdded = false;
  var requests = new Map;

  class AggregatorRegistry extends Registry {
    constructor(regContentType = Registry.PROMETHEUS_CONTENT_TYPE) {
      super(regContentType);
      addListeners();
    }
    clusterMetrics() {
      const requestId = requestCtr++;
      return new Promise((resolve, reject) => {
        let settled = false;
        function done(err, result) {
          if (settled)
            return;
          settled = true;
          if (err)
            reject(err);
          else
            resolve(result);
        }
        const request2 = {
          responses: [],
          pending: 0,
          done,
          errorTimeout: setTimeout(() => {
            const err = new Error("Operation timed out.");
            request2.done(err);
          }, 5000)
        };
        requests.set(requestId, request2);
        const message = {
          type: GET_METRICS_REQ,
          requestId
        };
        for (const id in cluster().workers) {
          if (cluster().workers[id].isConnected()) {
            cluster().workers[id].send(message);
            request2.pending++;
          }
        }
        if (request2.pending === 0) {
          clearTimeout(request2.errorTimeout);
          process.nextTick(() => done(null, ""));
        }
      });
    }
    get contentType() {
      return super.contentType;
    }
    static aggregate(metricsArr, registryType = Registry.PROMETHEUS_CONTENT_TYPE) {
      const aggregatedRegistry = new Registry;
      const metricsByName = new Grouper;
      aggregatedRegistry.setContentType(registryType);
      metricsArr.forEach((metrics) => {
        metrics.forEach((metric) => {
          metricsByName.add(metric.name, metric);
        });
      });
      metricsByName.forEach((metrics) => {
        const aggregatorName = metrics[0].aggregator;
        const aggregatorFn = aggregators[aggregatorName];
        if (typeof aggregatorFn !== "function") {
          throw new Error(`'${aggregatorName}' is not a defined aggregator.`);
        }
        const aggregatedMetric = aggregatorFn(metrics);
        if (aggregatedMetric) {
          const aggregatedMetricWrapper = Object.assign({
            get: () => aggregatedMetric
          }, aggregatedMetric);
          aggregatedRegistry.registerMetric(aggregatedMetricWrapper);
        }
      });
      return aggregatedRegistry;
    }
    static setRegistries(regs) {
      if (!Array.isArray(regs))
        regs = [regs];
      regs.forEach((reg) => {
        if (!(reg instanceof Registry)) {
          throw new TypeError(`Expected Registry, got ${typeof reg}`);
        }
      });
      registries = regs;
    }
  }
  module.exports = AggregatorRegistry;
});

// node_modules/prom-client/index.js
var require_prom_client = __commonJS((exports) => {
  exports.register = require_registry().globalRegistry;
  exports.Registry = require_registry();
  exports.contentType = require_registry().globalRegistry.contentType;
  exports.prometheusContentType = require_registry().PROMETHEUS_CONTENT_TYPE;
  exports.openMetricsContentType = require_registry().OPENMETRICS_CONTENT_TYPE;
  exports.validateMetricName = require_validation().validateMetricName;
  exports.Counter = require_counter();
  exports.Gauge = require_gauge();
  exports.Histogram = require_histogram();
  exports.Summary = require_summary();
  exports.Pushgateway = require_pushgateway();
  exports.linearBuckets = require_bucketGenerators().linearBuckets;
  exports.exponentialBuckets = require_bucketGenerators().exponentialBuckets;
  exports.collectDefaultMetrics = require_defaultMetrics();
  exports.aggregators = require_metricAggregators().aggregators;
  exports.AggregatorRegistry = require_cluster();
});

// node_modules/@research-ag/hpl-client/dist/esm/chunk-WFBVPRMZ.js
var s = (e) => {
  e instanceof Array && e.length == 1 && (e = e[0]);
  let r = Object.keys(e)[0];
  return [r, e[r]];
};
var t = (e, r) => typeof r == "bigint" ? `${r.toString()}n` : r;
var y = class extends Error {
  errorKey;
  errorPayload;
  constructor(r) {
    let [o, n] = s(r), i = "#" + o;
    n !== null && (i += ": " + JSON.stringify(n, t)), super(i), this.errorKey = o, this.errorPayload = n;
  }
  isTrapped() {
    return this.errorKey == "CanisterError";
  }
  isErrorRejectThrown() {
    return this.errorKey == "CanisterReject";
  }
  toString() {
    return `#${this.errorKey}(${JSON.stringify(this.errorPayload, t)})`;
  }
};

// node_modules/@research-ag/hpl-client/dist/esm/chunk-ZY472SXY.js
init_esm();
init_esm();
init_esm();
init_esm2();

// node_modules/buffer/index.js
var typedArraySupport = function() {
  try {
    var arr = new Uint8Array(1);
    var proto = { foo: function() {
      return 42;
    } };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
};
var createBuffer = function(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer2.prototype);
  return buf;
};
var Buffer2 = function(arg, encodingOrOffset, length) {
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
};
var from = function(value, encodingOrOffset, length) {
  if (typeof value === "string") {
    return fromString(value, encodingOrOffset);
  }
  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value);
  }
  if (value == null) {
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof value === "number") {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }
  var valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value) {
    return Buffer2.from(valueOf, encodingOrOffset, length);
  }
  var b = fromObject(value);
  if (b)
    return b;
  if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
    return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
  }
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
};
var assertSize = function(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
};
var alloc = function(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
};
var allocUnsafe = function(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
};
var fromString = function(string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError("Unknown encoding: " + encoding);
  }
  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
};
var fromArrayLike = function(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var i = 0;i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
};
var fromArrayView = function(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }
  return fromArrayLike(arrayView);
};
var fromArrayBuffer = function(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }
  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }
  Object.setPrototypeOf(buf, Buffer2.prototype);
  return buf;
};
var fromObject = function(obj) {
  if (Buffer2.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);
    if (buf.length === 0) {
      return buf;
    }
    obj.copy(buf, 0, 0, len);
    return buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }
    return fromArrayLike(obj);
  }
  if (obj.type === "Buffer" && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
};
var checked = function(length) {
  if (length >= K_MAX_LENGTH) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
  }
  return length | 0;
};
var byteLength = function(string, encoding) {
  if (Buffer2.isBuffer(string)) {
    return string.length;
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
  }
  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0)
    return 0;
  var loweredCase = false;
  for (;; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length;
        }
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
var slowToString = function(encoding, start, end) {
  var loweredCase = false;
  if (start === undefined || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
};
var swap = function(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
};
var bidirectionalIndexOf = function(buffer4, val, byteOffset, encoding, dir) {
  if (buffer4.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (numberIsNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer4.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer4.length + byteOffset;
  if (byteOffset >= buffer4.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer4.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (Buffer2.isBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer4, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer4, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer4, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer4, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
};
var arrayIndexOf = function(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset;i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset;i >= 0; i--) {
      var found = true;
      for (var j = 0;j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
};
var hexWrite = function(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0;i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
};
var utf8Write = function(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
};
var asciiWrite = function(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
};
var base64Write = function(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
};
var ucs2Write = function(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
};
var base64Slice = function(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
};
var utf8Slice = function(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
};
var decodeCodePointsArray = function(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
};
var asciiSlice = function(buf, start, end) {
  var ret2 = "";
  end = Math.min(buf.length, end);
  for (var i = start;i < end; ++i) {
    ret2 += String.fromCharCode(buf[i] & 127);
  }
  return ret2;
};
var latin1Slice = function(buf, start, end) {
  var ret2 = "";
  end = Math.min(buf.length, end);
  for (var i = start;i < end; ++i) {
    ret2 += String.fromCharCode(buf[i]);
  }
  return ret2;
};
var hexSlice = function(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start;i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }
  return out;
};
var utf16leSlice = function(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0;i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
};
var checkOffset = function(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
};
var checkInt = function(buf, value, offset, ext, max, min) {
  if (!Buffer2.isBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
};
var checkIEEE754 = function(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
};
var writeFloat = function(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
};
var writeDouble = function(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
};
var base64clean = function(str) {
  str = str.split("=")[0];
  str = str.trim().replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
};
var utf8ToBytes = function(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0;i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
};
var asciiToBytes = function(str) {
  var byteArray = [];
  for (var i = 0;i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
};
var utf16leToBytes = function(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0;i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
};
var base64ToBytes = function(str) {
  return base64.toByteArray(base64clean(str));
};
var blitBuffer = function(src, dst, offset, length) {
  for (var i = 0;i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
};
var isInstance = function(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
};
var numberIsNaN = function(obj) {
  return obj !== obj;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var base64 = require_base64_js();
var ieee754 = require_ieee754();
var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
var $Buffer = Buffer2;
var $INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 2147483647;
Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
  console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
}
Object.defineProperty(Buffer2.prototype, "parent", {
  enumerable: true,
  get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.buffer;
  }
});
Object.defineProperty(Buffer2.prototype, "offset", {
  enumerable: true,
  get: function() {
    if (!Buffer2.isBuffer(this))
      return;
    return this.byteOffset;
  }
});
Buffer2.poolSize = 8192;
Buffer2.from = function(value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer2, Uint8Array);
Buffer2.alloc = function(size, fill, encoding) {
  return alloc(size, fill, encoding);
};
Buffer2.allocUnsafe = function(size) {
  return allocUnsafe(size);
};
Buffer2.allocUnsafeSlow = function(size) {
  return allocUnsafe(size);
};
Buffer2.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer2.prototype;
};
Buffer2.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array))
    a = Buffer2.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array))
    b = Buffer2.from(b, b.offset, b.byteLength);
  if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b)
    return 0;
  var x = a.length;
  var y2 = b.length;
  for (var i = 0, len = Math.min(x, y2);i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y2 = b[i];
      break;
    }
  }
  if (x < y2)
    return -1;
  if (y2 < x)
    return 1;
  return 0;
};
Buffer2.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer2.concat = function concat2(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer2.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0;i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer4 = Buffer2.allocUnsafe(length);
  var pos = 0;
  for (i = 0;i < list.length; ++i) {
    var buf = list[i];
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer4.length) {
        Buffer2.from(buf).copy(buffer4, pos);
      } else {
        Uint8Array.prototype.set.call(buffer4, buf, pos);
      }
    } else if (!Buffer2.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    } else {
      buf.copy(buffer4, pos);
    }
    pos += buf.length;
  }
  return buffer4;
};
Buffer2.byteLength = byteLength;
Buffer2.prototype._isBuffer = true;
Buffer2.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0;i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer2.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0;i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer2.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0;i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer2.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
Buffer2.prototype.equals = function equals(b) {
  if (!Buffer2.isBuffer(b))
    throw new TypeError("Argument must be a Buffer");
  if (this === b)
    return true;
  return Buffer2.compare(this, b) === 0;
};
Buffer2.prototype.inspect = function inspect() {
  var str = "";
  var max = $INSPECT_MAX_BYTES;
  str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
  if (this.length > max)
    str += " ... ";
  return "<Buffer " + str + ">";
};
if (customInspectSymbol) {
  Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
}
Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer2.from(target, target.offset, target.byteLength);
  }
  if (!Buffer2.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x = thisEnd - thisStart;
  var y2 = end - start;
  var len = Math.min(x, y2);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0;i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y2 = targetCopy[i];
      break;
    }
  }
  if (x < y2)
    return -1;
  if (y2 < x)
    return 1;
  return 0;
};
Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer2.prototype.write = function write(string, offset, length, encoding) {
  if (offset === undefined) {
    encoding = "utf8";
    length = this.length;
    offset = 0;
  } else if (length === undefined && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined)
        encoding = "utf8";
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (;; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset, length);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset, length);
      case "ascii":
      case "latin1":
      case "binary":
        return asciiWrite(this, string, offset, length);
      case "base64":
        return base64Write(this, string, offset, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer2.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
var MAX_ARGUMENTS_LENGTH = 4096;
Buffer2.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer2.prototype);
  return newBuf;
};
Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE2(offset, byteLength2, noAssert) {
  offset = offset >>> 0;
  byteLength2 = byteLength2 >>> 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength2 && (mul *= 256)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
  offset = offset >>> 0;
  byteLength2 = byteLength2 >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength2, this.length);
  }
  var val = this[offset + --byteLength2];
  var mul = 1;
  while (byteLength2 > 0 && (mul *= 256)) {
    val += this[offset + --byteLength2] * mul;
  }
  return val;
};
Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer2.prototype.readIntLE = function readIntLE2(offset, byteLength2, noAssert) {
  offset = offset >>> 0;
  byteLength2 = byteLength2 >>> 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength2 && (mul *= 256)) {
    val += this[offset + i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
  offset = offset >>> 0;
  byteLength2 = byteLength2 >>> 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var i = byteLength2;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 256)) {
    val += this[offset + --i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  if (!(this[offset] & 128))
    return this[offset];
  return (255 - this[offset] + 1) * -1;
};
Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};
Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};
Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};
Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};
Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE2(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength2 = byteLength2 >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 255;
  while (++i < byteLength2 && (mul *= 256)) {
    this[offset + i] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength2 = byteLength2 >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var i = byteLength2 - 1;
  var mul = 1;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul *= 256)) {
    this[offset + i] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 255, 0);
  this[offset] = value & 255;
  return offset + 1;
};
Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  this[offset] = value & 255;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 255;
  return offset + 2;
};
Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 255;
  return offset + 4;
};
Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 255;
  return offset + 4;
};
Buffer2.prototype.writeIntLE = function writeIntLE2(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 255;
  while (++i < byteLength2 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i = byteLength2 - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 255;
  while (--i >= 0 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 127, -128);
  if (value < 0)
    value = 255 + value + 1;
  this[offset] = value & 255;
  return offset + 1;
};
Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  this[offset] = value & 255;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 255;
  return offset + 2;
};
Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  this[offset] = value & 255;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};
Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  if (value < 0)
    value = 4294967295 + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 255;
  return offset + 4;
};
Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};
Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer2.isBuffer(target))
    throw new TypeError("argument should be a Buffer");
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("Index out of range");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }
  return len;
};
Buffer2.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (encoding !== undefined && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (encoding === "utf8" && code < 128 || encoding === "latin1") {
        val = code;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  } else if (typeof val === "boolean") {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start;i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
    var len = bytes.length;
    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }
    for (i = 0;i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
var hexSliceLookupTable = function() {
  var alphabet2 = "0123456789abcdef";
  var table = new Array(256);
  for (var i = 0;i < 16; ++i) {
    var i16 = i * 16;
    for (var j = 0;j < 16; ++j) {
      table[i16 + j] = alphabet2[i] + alphabet2[j];
    }
  }
  return table;
}();

// node_modules/@dfinity/agent/lib/esm/agent/api.js
var ReplicaRejectCode;
(function(ReplicaRejectCode2) {
  ReplicaRejectCode2[ReplicaRejectCode2["SysFatal"] = 1] = "SysFatal";
  ReplicaRejectCode2[ReplicaRejectCode2["SysTransient"] = 2] = "SysTransient";
  ReplicaRejectCode2[ReplicaRejectCode2["DestinationInvalid"] = 3] = "DestinationInvalid";
  ReplicaRejectCode2[ReplicaRejectCode2["CanisterReject"] = 4] = "CanisterReject";
  ReplicaRejectCode2[ReplicaRejectCode2["CanisterError"] = 5] = "CanisterError";
})(ReplicaRejectCode || (ReplicaRejectCode = {}));
// node_modules/@dfinity/agent/lib/esm/agent/http/index.js
init_esm();
init_errors();

// node_modules/@dfinity/agent/lib/esm/auth.js
init_esm();
init_request_id();
init_buffer2();
var __rest = function(s2, e) {
  var t2 = {};
  for (var p in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
      t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s2);i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
        t2[p[i]] = s2[p[i]];
    }
  return t2;
};
var domainSeparator = new TextEncoder().encode(`
ic-request`);

class SignIdentity {
  getPrincipal() {
    if (!this._principal) {
      this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));
    }
    return this._principal;
  }
  async transformRequest(request) {
    const { body } = request, fields = __rest(request, ["body"]);
    const requestId = await requestIdOf(body);
    return Object.assign(Object.assign({}, fields), { body: {
      content: body,
      sender_pubkey: this.getPublicKey().toDer(),
      sender_sig: await this.sign(concat3(domainSeparator, requestId))
    } });
  }
}

class AnonymousIdentity {
  getPrincipal() {
    return Principal.anonymous();
  }
  async transformRequest(request) {
    return Object.assign(Object.assign({}, request), { body: { content: request.body } });
  }
}

// node_modules/@dfinity/agent/lib/esm/agent/http/index.js
init_cbor();
init_request_id();
init_buffer2();

// node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js
init_esm2();
var cbor2 = __toESM(require_src2(), 1);

// node_modules/@dfinity/agent/lib/esm/agent/http/types.js
function makeNonce() {
  const buffer7 = new ArrayBuffer(16);
  const view = new DataView(buffer7);
  const now = BigInt(+Date.now());
  const randHi = Math.floor(Math.random() * 4294967295);
  const randLo = Math.floor(Math.random() * 4294967295);
  if (typeof view.setBigUint64 === "function") {
    view.setBigUint64(0, now);
  } else {
    const TWO_TO_THE_32 = BigInt(1) << BigInt(32);
    view.setUint32(0, Number(now >> BigInt(32)));
    view.setUint32(4, Number(now % TWO_TO_THE_32));
  }
  view.setUint32(8, randHi);
  view.setUint32(12, randLo);
  return buffer7;
}
var SubmitRequestType;
(function(SubmitRequestType2) {
  SubmitRequestType2["Call"] = "call";
})(SubmitRequestType || (SubmitRequestType = {}));

// node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js
function makeNonceTransform(nonceFn = makeNonce) {
  return async (request) => {
    const nonce = nonceFn();
    const headers = request.request.headers;
    request.request.headers = headers;
    if (request.endpoint === "call") {
      request.body.nonce = nonceFn();
    }
  };
}
function httpHeadersTransform(headers) {
  const headerFields = [];
  headers.forEach((value3, key) => {
    headerFields.push([key, value3]);
  });
  return headerFields;
}
var NANOSECONDS_PER_MILLISECONDS = BigInt(1e6);
var REPLICA_PERMITTED_DRIFT_MILLISECONDS = BigInt(60 * 1000);

class Expiry {
  constructor(deltaInMSec) {
    this._value = (BigInt(Date.now()) + BigInt(deltaInMSec) - REPLICA_PERMITTED_DRIFT_MILLISECONDS) * NANOSECONDS_PER_MILLISECONDS;
  }
  toCBOR() {
    return cbor2.value.u64(this._value.toString(16), 16);
  }
  toHash() {
    return lebEncode(this._value);
  }
}

// node_modules/@dfinity/agent/lib/esm/agent/http/errors.js
class AgentHTTPResponseError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
    this.name = this.constructor.name;
    Object.setPrototypeOf(this, new.target.prototype);
  }
}

// node_modules/@dfinity/agent/lib/esm/agent/http/index.js
var getDefaultFetch = function() {
  let defaultFetch;
  if (typeof window !== "undefined") {
    if (window.fetch) {
      defaultFetch = window.fetch.bind(window);
    } else {
      throw new HttpDefaultFetchError("Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.");
    }
  } else if (typeof global !== "undefined") {
    if (global.fetch) {
      defaultFetch = global.fetch.bind(global);
    } else {
      throw new HttpDefaultFetchError("Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.");
    }
  } else if (typeof self !== "undefined") {
    if (self.fetch) {
      defaultFetch = self.fetch.bind(self);
    }
  }
  if (defaultFetch) {
    return defaultFetch;
  }
  throw new HttpDefaultFetchError("Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.");
};
var RequestStatusResponseStatus;
(function(RequestStatusResponseStatus2) {
  RequestStatusResponseStatus2["Received"] = "received";
  RequestStatusResponseStatus2["Processing"] = "processing";
  RequestStatusResponseStatus2["Replied"] = "replied";
  RequestStatusResponseStatus2["Rejected"] = "rejected";
  RequestStatusResponseStatus2["Unknown"] = "unknown";
  RequestStatusResponseStatus2["Done"] = "done";
})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));
var DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;
var IC_ROOT_KEY = "308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d9685f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484b01291091c5f87b98883463f98091a0baaae";
var IC0_DOMAIN = "ic0.app";
var IC0_SUB_DOMAIN = ".ic0.app";
var ICP0_DOMAIN = "icp0.io";
var ICP0_SUB_DOMAIN = ".icp0.io";
var ICP_API_DOMAIN = "icp-api.io";
var ICP_API_SUB_DOMAIN = ".icp-api.io";

class HttpDefaultFetchError extends AgentError {
  constructor(message) {
    super(message);
    this.message = message;
  }
}

class IdentityInvalidError extends AgentError {
  constructor(message) {
    super(message);
    this.message = message;
  }
}

class HttpAgent {
  constructor(options = {}) {
    this.rootKey = fromHex(IC_ROOT_KEY);
    this._pipeline = [];
    this._timeDiffMsecs = 0;
    this._rootKeyFetched = false;
    this._isAgent = true;
    if (options.source) {
      if (!(options.source instanceof HttpAgent)) {
        throw new Error("An Agent's source can only be another HttpAgent");
      }
      this._pipeline = [...options.source._pipeline];
      this._identity = options.source._identity;
      this._fetch = options.source._fetch;
      this._host = options.source._host;
      this._credentials = options.source._credentials;
    } else {
      this._fetch = options.fetch || getDefaultFetch() || fetch.bind(global);
      this._fetchOptions = options.fetchOptions;
      this._callOptions = options.callOptions;
    }
    if (options.host !== undefined) {
      if (!options.host.match(/^[a-z]+:/) && typeof window !== "undefined") {
        this._host = new URL(window.location.protocol + "//" + options.host);
      } else {
        this._host = new URL(options.host);
      }
    } else if (options.source !== undefined) {
      this._host = options.source._host;
    } else {
      const location = typeof window !== "undefined" ? window.location : undefined;
      if (!location) {
        throw new Error("Must specify a host to connect to.");
      }
      this._host = new URL(location + "");
    }
    this._retryTimes = options.retryTimes !== undefined && options.retryTimes >= 0 ? options.retryTimes : 3;
    if (this._host.hostname.endsWith(IC0_SUB_DOMAIN)) {
      this._host.hostname = IC0_DOMAIN;
    } else if (this._host.hostname.endsWith(ICP0_SUB_DOMAIN)) {
      this._host.hostname = ICP0_DOMAIN;
    } else if (this._host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {
      this._host.hostname = ICP_API_DOMAIN;
    }
    if (options.credentials) {
      const { name, password } = options.credentials;
      this._credentials = `${name}${password ? ":" + password : ""}`;
    }
    this._identity = Promise.resolve(options.identity || new AnonymousIdentity);
    if (!options.disableNonce) {
      this.addTransform(makeNonceTransform(makeNonce));
    }
  }
  isLocal() {
    const hostname = this._host.hostname;
    return hostname === "127.0.0.1" || hostname.endsWith("localhost");
  }
  addTransform(fn, priority = fn.priority || 0) {
    const i = this._pipeline.findIndex((x) => (x.priority || 0) < priority);
    this._pipeline.splice(i >= 0 ? i : this._pipeline.length, 0, Object.assign(fn, { priority }));
  }
  async getPrincipal() {
    if (!this._identity) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    return (await this._identity).getPrincipal();
  }
  async call(canisterId, options, identity) {
    const id = await (identity !== undefined ? await identity : await this._identity);
    if (!id) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    const canister = Principal.from(canisterId);
    const ecid = options.effectiveCanisterId ? Principal.from(options.effectiveCanisterId) : canister;
    const sender = id.getPrincipal() || Principal.anonymous();
    let ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);
    if (Math.abs(this._timeDiffMsecs) > 1000 * 30) {
      ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this._timeDiffMsecs);
    }
    const submit = {
      request_type: SubmitRequestType.Call,
      canister_id: canister,
      method_name: options.methodName,
      arg: options.arg,
      sender,
      ingress_expiry
    };
    let transformedRequest = await this._transform({
      request: {
        body: null,
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "call",
      body: submit
    });
    transformedRequest = await id.transformRequest(transformedRequest);
    const body = encode3(transformedRequest.body);
    const request2 = this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign(Object.assign({}, this._callOptions), transformedRequest.request), { body })));
    const [response, requestId] = await Promise.all([request2, requestIdOf(submit)]);
    const responseBuffer = await response.arrayBuffer();
    const responseBody = response.status === 200 && responseBuffer.byteLength > 0 ? decode3(responseBuffer) : null;
    return {
      requestId,
      response: {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
        body: responseBody,
        headers: httpHeadersTransform(response.headers)
      }
    };
  }
  async _requestAndRetry(request2, tries = 0) {
    const response = await request2();
    if (response.ok) {
      return response;
    }
    const responseText = await response.clone().text();
    const errorMessage = `Server returned an error:\n` + `  Code: ${response.status} (${response.statusText})\n` + `  Body: ${responseText}\n`;
    if (this._retryTimes > tries) {
      console.warn(errorMessage + `  Retrying request.`);
      return await this._requestAndRetry(request2, tries + 1);
    }
    throw new AgentHTTPResponseError(errorMessage, {
      ok: response.ok,
      status: response.status,
      statusText: response.statusText,
      headers: httpHeadersTransform(response.headers)
    });
  }
  async query(canisterId, fields, identity) {
    const id = await (identity !== undefined ? await identity : await this._identity);
    if (!id) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    const canister = typeof canisterId === "string" ? Principal.fromText(canisterId) : canisterId;
    const sender = (id === null || id === undefined ? undefined : id.getPrincipal()) || Principal.anonymous();
    const request2 = {
      request_type: "query",
      canister_id: canister,
      method_name: fields.methodName,
      arg: fields.arg,
      sender,
      ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)
    };
    let transformedRequest = await this._transform({
      request: {
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "read",
      body: request2
    });
    transformedRequest = await (id === null || id === undefined ? undefined : id.transformRequest(transformedRequest));
    const body = encode3(transformedRequest.body);
    const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
    const queryResponse = decode3(await response.arrayBuffer());
    return Object.assign(Object.assign({}, queryResponse), { httpDetails: {
      ok: response.ok,
      status: response.status,
      statusText: response.statusText,
      headers: httpHeadersTransform(response.headers)
    } });
  }
  async createReadStateRequest(fields, identity) {
    const id = await (identity !== undefined ? await identity : await this._identity);
    if (!id) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    const sender = (id === null || id === undefined ? undefined : id.getPrincipal()) || Principal.anonymous();
    const transformedRequest = await this._transform({
      request: {
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "read_state",
      body: {
        request_type: "read_state",
        paths: fields.paths,
        sender,
        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)
      }
    });
    return id === null || id === undefined ? undefined : id.transformRequest(transformedRequest);
  }
  async readState(canisterId, fields, identity, request2) {
    const canister = typeof canisterId === "string" ? Principal.fromText(canisterId) : canisterId;
    const transformedRequest = request2 !== null && request2 !== undefined ? request2 : await this.createReadStateRequest(fields, identity);
    const body = encode3(transformedRequest.body);
    const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
    if (!response.ok) {
      throw new Error(`Server returned an error:\n` + `  Code: ${response.status} (${response.statusText})\n` + `  Body: ${await response.text()}\n`);
    }
    return decode3(await response.arrayBuffer());
  }
  async syncTime(canisterId) {
    const CanisterStatus = await Promise.resolve().then(() => (init_canisterStatus(), exports_canisterStatus));
    const callTime = Date.now();
    try {
      if (!canisterId) {
        console.log("Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai");
      }
      const status = await CanisterStatus.request({
        canisterId: canisterId !== null && canisterId !== undefined ? canisterId : Principal.from("ryjl3-tyaaa-aaaaa-aaaba-cai"),
        agent: this,
        paths: ["time"]
      });
      const replicaTime = status.get("time");
      if (replicaTime) {
        this._timeDiffMsecs = Number(replicaTime) - Number(callTime);
      }
    } catch (error) {
      console.error("Caught exception while attempting to sync time:", error);
    }
  }
  async status() {
    const headers = this._credentials ? {
      Authorization: "Basic " + btoa(this._credentials)
    } : {};
    const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/status`, this._host), Object.assign({ headers }, this._fetchOptions)));
    return decode3(await response.arrayBuffer());
  }
  async fetchRootKey() {
    if (!this._rootKeyFetched) {
      this.rootKey = (await this.status()).root_key;
      this._rootKeyFetched = true;
    }
    return this.rootKey;
  }
  invalidateIdentity() {
    this._identity = null;
  }
  replaceIdentity(identity) {
    this._identity = Promise.resolve(identity);
  }
  _transform(request2) {
    let p = Promise.resolve(request2);
    for (const fn of this._pipeline) {
      p = p.then((r) => fn(r).then((r2) => r2 || r));
    }
    return p;
  }
}
// node_modules/@dfinity/agent/lib/esm/agent/proxy.js
init_esm();
var ProxyMessageKind;
(function(ProxyMessageKind2) {
  ProxyMessageKind2["Error"] = "err";
  ProxyMessageKind2["GetPrincipal"] = "gp";
  ProxyMessageKind2["GetPrincipalResponse"] = "gpr";
  ProxyMessageKind2["Query"] = "q";
  ProxyMessageKind2["QueryResponse"] = "qr";
  ProxyMessageKind2["Call"] = "c";
  ProxyMessageKind2["CallResponse"] = "cr";
  ProxyMessageKind2["ReadState"] = "rs";
  ProxyMessageKind2["ReadStateResponse"] = "rsr";
  ProxyMessageKind2["Status"] = "s";
  ProxyMessageKind2["StatusResponse"] = "sr";
})(ProxyMessageKind || (ProxyMessageKind = {}));

// node_modules/@dfinity/agent/lib/esm/agent/index.js
function getDefaultAgent() {
  const agent = typeof window === "undefined" ? typeof global === "undefined" ? typeof self === "undefined" ? undefined : self.ic.agent : global.ic.agent : window.ic.agent;
  if (!agent) {
    throw new Error("No Agent could be found.");
  }
  return agent;
}

// node_modules/@dfinity/agent/lib/esm/actor.js
init_errors();
init_esm2();

// node_modules/@dfinity/agent/lib/esm/polling/index.js
var exports_polling = {};
__export(exports_polling, {
  strategy: () => {
    {
      return exports_strategy;
    }
  },
  pollForResponse: () => {
    {
      return pollForResponse;
    }
  },
  defaultStrategy: () => {
    {
      return defaultStrategy;
    }
  }
});
init_certificate();
init_buffer2();

// node_modules/@dfinity/agent/lib/esm/polling/strategy.js
var exports_strategy = {};
__export(exports_strategy, {
  timeout: () => {
    {
      return timeout;
    }
  },
  throttle: () => {
    {
      return throttle;
    }
  },
  once: () => {
    {
      return once;
    }
  },
  maxAttempts: () => {
    {
      return maxAttempts;
    }
  },
  defaultStrategy: () => {
    {
      return defaultStrategy;
    }
  },
  conditionalDelay: () => {
    {
      return conditionalDelay;
    }
  },
  chain: () => {
    {
      return chain;
    }
  },
  backoff: () => {
    {
      return backoff;
    }
  }
});
init_buffer2();
function defaultStrategy() {
  return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));
}
function once() {
  let first = true;
  return async () => {
    if (first) {
      first = false;
      return true;
    }
    return false;
  };
}
function conditionalDelay(condition, timeInMsec) {
  return async (canisterId, requestId, status) => {
    if (await condition(canisterId, requestId, status)) {
      return new Promise((resolve) => setTimeout(resolve, timeInMsec));
    }
  };
}
function maxAttempts(count) {
  let attempts = count;
  return async (canisterId, requestId, status) => {
    if (--attempts <= 0) {
      throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\n` + `  Request ID: ${toHex(requestId)}\n` + `  Request status: ${status}\n`);
    }
  };
}
function throttle(throttleInMsec) {
  return () => new Promise((resolve) => setTimeout(resolve, throttleInMsec));
}
function timeout(timeInMsec) {
  const end = Date.now() + timeInMsec;
  return async (canisterId, requestId, status) => {
    if (Date.now() > end) {
      throw new Error(`Request timed out after ${timeInMsec} msec:\n` + `  Request ID: ${toHex(requestId)}\n` + `  Request status: ${status}\n`);
    }
  };
}
function backoff(startingThrottleInMsec, backoffFactor) {
  let currentThrottling = startingThrottleInMsec;
  return () => new Promise((resolve) => setTimeout(() => {
    currentThrottling *= backoffFactor;
    resolve();
  }, currentThrottling));
}
function chain(...strategies) {
  return async (canisterId, requestId, status) => {
    for (const a of strategies) {
      await a(canisterId, requestId, status);
    }
  };
}
var FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;

// node_modules/@dfinity/agent/lib/esm/polling/index.js
async function pollForResponse(agent2, canisterId, requestId, strategy, request2, blsVerify2) {
  var _a;
  const path = [new TextEncoder().encode("request_status"), requestId];
  const currentRequest = request2 !== null && request2 !== undefined ? request2 : await ((_a = agent2.createReadStateRequest) === null || _a === undefined ? undefined : _a.call(agent2, { paths: [path] }));
  const state = await agent2.readState(canisterId, { paths: [path] }, undefined, currentRequest);
  if (agent2.rootKey == null)
    throw new Error("Agent root key not initialized before polling");
  const cert = await Certificate.create({
    certificate: state.certificate,
    rootKey: agent2.rootKey,
    canisterId,
    blsVerify: blsVerify2
  });
  const maybeBuf = cert.lookup([...path, new TextEncoder().encode("status")]);
  let status;
  if (typeof maybeBuf === "undefined") {
    status = RequestStatusResponseStatus.Unknown;
  } else {
    status = new TextDecoder().decode(maybeBuf);
  }
  switch (status) {
    case RequestStatusResponseStatus.Replied: {
      return cert.lookup([...path, "reply"]);
    }
    case RequestStatusResponseStatus.Received:
    case RequestStatusResponseStatus.Unknown:
    case RequestStatusResponseStatus.Processing:
      await strategy(canisterId, requestId, status);
      return pollForResponse(agent2, canisterId, requestId, strategy, currentRequest);
    case RequestStatusResponseStatus.Rejected: {
      const rejectCode = new Uint8Array(cert.lookup([...path, "reject_code"]))[0];
      const rejectMessage = new TextDecoder().decode(cert.lookup([...path, "reject_message"]));
      throw new Error(`Call was rejected:\n` + `  Request ID: ${toHex(requestId)}\n` + `  Reject code: ${rejectCode}\n` + `  Reject text: ${rejectMessage}\n`);
    }
    case RequestStatusResponseStatus.Done:
      throw new Error(`Call was marked as done but we never saw the reply:\n` + `  Request ID: ${toHex(requestId)}\n`);
  }
  throw new Error("unreachable");
}

// node_modules/@dfinity/agent/lib/esm/actor.js
init_esm();
init_buffer2();

// node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js
var management_idl_default = ({ IDL }) => {
  const canister_id = IDL.Principal;
  const definite_canister_settings = IDL.Record({
    controllers: IDL.Vec(IDL.Principal),
    freezing_threshold: IDL.Nat,
    memory_allocation: IDL.Nat,
    compute_allocation: IDL.Nat
  });
  const canister_settings = IDL.Record({
    controllers: IDL.Opt(IDL.Vec(IDL.Principal)),
    freezing_threshold: IDL.Opt(IDL.Nat),
    memory_allocation: IDL.Opt(IDL.Nat),
    compute_allocation: IDL.Opt(IDL.Nat)
  });
  const wasm_module = IDL.Vec(IDL.Nat8);
  return IDL.Service({
    canister_status: IDL.Func([IDL.Record({ canister_id })], [
      IDL.Record({
        status: IDL.Variant({
          stopped: IDL.Null,
          stopping: IDL.Null,
          running: IDL.Null
        }),
        memory_size: IDL.Nat,
        cycles: IDL.Nat,
        settings: definite_canister_settings,
        module_hash: IDL.Opt(IDL.Vec(IDL.Nat8))
      })
    ], []),
    create_canister: IDL.Func([IDL.Record({ settings: IDL.Opt(canister_settings) })], [IDL.Record({ canister_id })], []),
    delete_canister: IDL.Func([IDL.Record({ canister_id })], [], []),
    deposit_cycles: IDL.Func([IDL.Record({ canister_id })], [], []),
    install_code: IDL.Func([
      IDL.Record({
        arg: IDL.Vec(IDL.Nat8),
        wasm_module,
        mode: IDL.Variant({
          reinstall: IDL.Null,
          upgrade: IDL.Null,
          install: IDL.Null
        }),
        canister_id
      })
    ], [], []),
    provisional_create_canister_with_cycles: IDL.Func([
      IDL.Record({
        settings: IDL.Opt(canister_settings),
        amount: IDL.Opt(IDL.Nat)
      })
    ], [IDL.Record({ canister_id })], []),
    provisional_top_up_canister: IDL.Func([IDL.Record({ canister_id, amount: IDL.Nat })], [], []),
    raw_rand: IDL.Func([], [IDL.Vec(IDL.Nat8)], []),
    start_canister: IDL.Func([IDL.Record({ canister_id })], [], []),
    stop_canister: IDL.Func([IDL.Record({ canister_id })], [], []),
    uninstall_code: IDL.Func([IDL.Record({ canister_id })], [], []),
    update_settings: IDL.Func([
      IDL.Record({
        canister_id: IDL.Principal,
        settings: canister_settings
      })
    ], [], [])
  });
};

// node_modules/@dfinity/agent/lib/esm/actor.js
var decodeReturnValue = function(types4, msg) {
  const returnValues = exports_idl.decode(types4, $Buffer.from(msg));
  switch (returnValues.length) {
    case 0:
      return;
    case 1:
      return returnValues[0];
    default:
      return returnValues;
  }
};
var _createActorMethod = function(actor, methodName, func, blsVerify2) {
  let caller;
  if (func.annotations.includes("query") || func.annotations.includes("composite_query")) {
    caller = async (options, ...args) => {
      var _a, _b;
      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === undefined ? undefined : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
      const agent3 = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();
      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);
      const arg = exports_idl.encode(func.argTypes, args);
      const result = await agent3.query(cid, { methodName, arg });
      switch (result.status) {
        case "rejected":
          throw new QueryCallRejectedError(cid, methodName, result);
        case "replied":
          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS) ? {
            httpDetails: result.httpDetails,
            result: decodeReturnValue(func.retTypes, result.reply.arg)
          } : decodeReturnValue(func.retTypes, result.reply.arg);
      }
    };
  } else {
    caller = async (options, ...args) => {
      var _a, _b;
      options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === undefined ? undefined : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
      const agent3 = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();
      const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);
      const cid = Principal.from(canisterId);
      const ecid = effectiveCanisterId !== undefined ? Principal.from(effectiveCanisterId) : cid;
      const arg = exports_idl.encode(func.argTypes, args);
      const { requestId, response } = await agent3.call(cid, {
        methodName,
        arg,
        effectiveCanisterId: ecid
      });
      if (!response.ok || response.body) {
        throw new UpdateCallRejectedError(cid, methodName, requestId, response);
      }
      const pollStrategy = pollingStrategyFactory();
      const responseBytes = await pollForResponse(agent3, ecid, requestId, pollStrategy, blsVerify2);
      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);
      if (responseBytes !== undefined) {
        return shouldIncludeHttpDetails ? {
          httpDetails: response,
          result: decodeReturnValue(func.retTypes, responseBytes)
        } : decodeReturnValue(func.retTypes, responseBytes);
      } else if (func.retTypes.length === 0) {
        return shouldIncludeHttpDetails ? {
          httpDetails: response,
          result: undefined
        } : undefined;
      } else {
        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(",")}].`);
      }
    };
  }
  const handler = (...args) => caller({}, ...args);
  handler.withOptions = (options) => (...args) => caller(options, ...args);
  return handler;
};
function getManagementCanister(config) {
  function transform(_methodName, args, _callConfig) {
    const first = args[0];
    let effectiveCanisterId = Principal.fromHex("");
    if (first && typeof first === "object" && first.canister_id) {
      effectiveCanisterId = Principal.from(first.canister_id);
    }
    return { effectiveCanisterId };
  }
  return Actor.createActor(management_idl_default, Object.assign(Object.assign(Object.assign({}, config), { canisterId: Principal.fromHex("") }), {
    callTransform: transform,
    queryTransform: transform
  }));
}

class ActorCallError extends AgentError {
  constructor(canisterId, methodName, type, props) {
    super([
      `Call failed:`,
      `  Canister: ${canisterId.toText()}`,
      `  Method: ${methodName} (${type})`,
      ...Object.getOwnPropertyNames(props).map((n) => `  "${n}": ${JSON.stringify(props[n])}`)
    ].join("\n"));
    this.canisterId = canisterId;
    this.methodName = methodName;
    this.type = type;
    this.props = props;
  }
}

class QueryCallRejectedError extends ActorCallError {
  constructor(canisterId, methodName, result) {
    var _a;
    super(canisterId, methodName, "query", {
      Status: result.status,
      Code: (_a = ReplicaRejectCode[result.reject_code]) !== null && _a !== undefined ? _a : `Unknown Code "${result.reject_code}"`,
      Message: result.reject_message
    });
    this.result = result;
  }
}

class UpdateCallRejectedError extends ActorCallError {
  constructor(canisterId, methodName, requestId, response) {
    super(canisterId, methodName, "update", Object.assign({ "Request ID": toHex(requestId) }, response.body ? Object.assign(Object.assign({}, response.body.error_code ? {
      "Error code": response.body.error_code
    } : {}), { "Reject code": String(response.body.reject_code), "Reject message": response.body.reject_message }) : {
      "HTTP status code": response.status.toString(),
      "HTTP status text": response.statusText
    }));
    this.requestId = requestId;
    this.response = response;
  }
}
var CanisterInstallMode;
(function(CanisterInstallMode2) {
  CanisterInstallMode2["Install"] = "install";
  CanisterInstallMode2["Reinstall"] = "reinstall";
  CanisterInstallMode2["Upgrade"] = "upgrade";
})(CanisterInstallMode || (CanisterInstallMode = {}));
var metadataSymbol = Symbol.for("ic-agent-metadata");

class Actor {
  constructor(metadata) {
    this[metadataSymbol] = Object.freeze(metadata);
  }
  static agentOf(actor) {
    return actor[metadataSymbol].config.agent;
  }
  static interfaceOf(actor) {
    return actor[metadataSymbol].service;
  }
  static canisterIdOf(actor) {
    return Principal.from(actor[metadataSymbol].config.canisterId);
  }
  static async install(fields, config) {
    const mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode;
    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];
    const wasmModule = [...new Uint8Array(fields.module)];
    const canisterId = typeof config.canisterId === "string" ? Principal.fromText(config.canisterId) : config.canisterId;
    await getManagementCanister(config).install_code({
      mode: { [mode]: null },
      arg,
      wasm_module: wasmModule,
      canister_id: canisterId
    });
  }
  static async createCanister(config) {
    const { canister_id: canisterId } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({ amount: [], settings: [] });
    return canisterId;
  }
  static async createAndInstallCanister(interfaceFactory, fields, config) {
    const canisterId = await this.createCanister(config);
    await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));
    return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));
  }
  static createActorClass(interfaceFactory, options) {
    const service = interfaceFactory({ IDL: exports_idl });

    class CanisterActor extends Actor {
      constructor(config) {
        const canisterId = typeof config.canisterId === "string" ? Principal.fromText(config.canisterId) : config.canisterId;
        super({
          config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId }),
          service
        });
        for (const [methodName, func] of service._fields) {
          if (options === null || options === undefined ? undefined : options.httpDetails) {
            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);
          }
          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);
        }
      }
    }
    return CanisterActor;
  }
  static createActor(interfaceFactory, configuration) {
    return new (this.createActorClass(interfaceFactory))(configuration);
  }
  static createActorWithHttpDetails(interfaceFactory, configuration) {
    return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(configuration);
  }
}
var DEFAULT_ACTOR_CONFIG = {
  pollingStrategyFactory: exports_strategy.defaultStrategy
};
var ACTOR_METHOD_WITH_HTTP_DETAILS = "http-details";

// node_modules/@dfinity/agent/lib/esm/index.js
init_certificate();

// node_modules/@dfinity/agent/lib/esm/fetch_candid.js
init_esm();
init_canisterStatus();

// node_modules/@dfinity/agent/lib/esm/index.js
init_request_id();
init_bls2();
init_buffer2();
init_canisterStatus();
init_cbor();

// node_modules/@research-ag/hpl-client/dist/esm/chunk-ZY472SXY.js
async function lt(t2, r) {
  let e = new HttpAgent({ host: t2 == "ic" ? "https://ic0.app" : "http://127.0.0.1:4943", ...r });
  return t2 === "local" && await e.fetchRootKey(), e;
}
init_esm();
var Qt = function(t2) {
  let r = 500, e = null, o = t2.message.split(`
`).map((i) => i.trim().toLowerCase()).find((i) => i.startsWith("code:") || i.startsWith("http status code:")), n = t2.message.split(`
`).map((i) => i.trim()).find((i) => i.startsWith('"Code": "'));
  if (o) {
    let i = o.split(":");
    if (i && i.length > 1) {
      let a = i[1].trim(), s2 = a.split(" ");
      s2 && s2.length > 1 && (a = s2[0].trim()), r = parseInt(a, 10), isNaN(r) && (r = 500);
    }
  }
  return n && (e = n.split('"')[3]), [r, e];
};
var Lt = function(t2) {
  let r = [];
  return t2.forEach((e, o) => {
    r.push([o, e]);
  }), r;
};
var At = function(t2, r) {
  let e = exports_idl.decode(t2, Buffer.from(r));
  switch (e.length) {
    case 0:
      return;
    case 1:
      return e[0];
    default:
      return e;
  }
};
var A = function(t2, r) {
  if (typeof r != "function" && r !== null)
    throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
  D(t2, r);
  function e() {
    this.constructor = t2;
  }
  t2.prototype = r === null ? Object.create(r) : (e.prototype = r.prototype, new e);
};
var F = function(t2) {
  var r = typeof Symbol == "function" && Symbol.iterator, e = r && t2[r], o = 0;
  if (e)
    return e.call(t2);
  if (t2 && typeof t2.length == "number")
    return { next: function() {
      return t2 && o >= t2.length && (t2 = undefined), { value: t2 && t2[o++], done: !t2 };
    } };
  throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var T = function(t2, r) {
  var e = typeof Symbol == "function" && t2[Symbol.iterator];
  if (!e)
    return t2;
  var o = e.call(t2), n, i = [], a;
  try {
    for (;(r === undefined || r-- > 0) && !(n = o.next()).done; )
      i.push(n.value);
  } catch (s2) {
    a = { error: s2 };
  } finally {
    try {
      n && !n.done && (e = o.return) && e.call(o);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return i;
};
var P = function(t2, r, e) {
  if (e || arguments.length === 2)
    for (var o = 0, n = r.length, i;o < n; o++)
      (i || !(o in r)) && (i || (i = Array.prototype.slice.call(r, 0, o)), i[o] = r[o]);
  return t2.concat(i || Array.prototype.slice.call(r));
};
var h = function(t2) {
  return typeof t2 == "function";
};
var G = function(t2) {
  var r = function(o) {
    Error.call(o), o.stack = new Error().stack;
  }, e = t2(r);
  return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e;
};
var N = function(t2, r) {
  if (t2) {
    var e = t2.indexOf(r);
    0 <= e && t2.splice(e, 1);
  }
};
var z = function(t2) {
  return t2 instanceof _ || t2 && ("closed" in t2) && h(t2.remove) && h(t2.add) && h(t2.unsubscribe);
};
var Pt = function(t2) {
  h(t2) ? t2() : t2.unsubscribe();
};
var _t = function(t2) {
  R.setTimeout(function() {
    var r = g.onUnhandledError;
    if (r)
      r(t2);
    else
      throw t2;
  });
};
var et = function() {
};
var Et = function(t2) {
  return rt("E", undefined, t2);
};
var Ot = function(t2) {
  return rt("N", t2, undefined);
};
var rt = function(t2, r, e) {
  return { kind: t2, value: r, error: e };
};
var E = function(t2) {
  if (g.useDeprecatedSynchronousErrorHandling) {
    var r = !S;
    if (r && (S = { errorThrown: false, error: null }), t2(), r) {
      var e = S, o = e.errorThrown, n = e.error;
      if (S = null, o)
        throw n;
    }
  } else
    t2();
};
var Vt = function(t2) {
  g.useDeprecatedSynchronousErrorHandling && S && (S.errorThrown = true, S.error = t2);
};
var ot = function(t2, r) {
  return oe.call(t2, r);
};
var Y = function(t2) {
  g.useDeprecatedSynchronousErrorHandling ? Vt(t2) : _t(t2);
};
var ie = function(t2) {
  throw t2;
};
var nt = function(t2, r) {
  var e = g.onStoppedNotification;
  e && R.setTimeout(function() {
    return e(t2, r);
  });
};
var Nt = function(t2) {
  return t2;
};
var qt = function(t2) {
  return t2.length === 0 ? Nt : t2.length === 1 ? t2[0] : function(e) {
    return t2.reduce(function(o, n) {
      return n(o);
    }, e);
  };
};
var Ct = function(t2) {
  var r;
  return (r = t2 ?? g.Promise) !== null && r !== undefined ? r : Promise;
};
var se = function(t2) {
  return t2 && h(t2.next) && h(t2.error) && h(t2.complete);
};
var ce = function(t2) {
  return t2 && t2 instanceof q || se(t2) && z(t2);
};
var ue = function(t2) {
  return h(t2?.lift);
};
var I = function(t2) {
  return function(r) {
    if (ue(r))
      return r.lift(function(e) {
        try {
          return t2(e, this);
        } catch (o) {
          this.error(o);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
};
var kt = function(t2, r, e, o, n) {
  return new pe(t2, r, e, o, n);
};
var at = function(t2) {
  return I(function(r, e) {
    try {
      r.subscribe(e);
    } finally {
      e.add(t2);
    }
  });
};
var st = function(t2, r) {
  return r === undefined && (r = false), I(function(e, o) {
    var n = 0;
    e.subscribe(kt(o, function(i) {
      var a = t2(i, n++);
      (a || r) && o.next(i), !a && o.complete();
    }));
  });
};
var pt = ({ IDL: t2 }) => {
  let r = t2.Tuple(t2.Nat, t2.Opt(t2.Nat)), e = t2.Variant({ id: t2.Nat, cat: t2.Vec(t2.Variant({ id: t2.Nat, idRange: r })), idRange: r }), o = t2.Nat, n = t2.Nat, i = t2.Variant({ ft: n }), a = t2.Nat, s2 = t2.Variant({ ft: t2.Nat }), c = t2.Nat64, u = t2.Tuple(t2.Principal, t2.Nat), p = t2.Variant({ id: u, cat: t2.Vec(t2.Variant({ id: u })) }), f = t2.Nat, l = t2.Tuple(t2.Nat, t2.Nat), m = t2.Variant({ DeletedVirtualAccount: t2.Null, InvalidArguments: t2.Text, InsufficientFunds: t2.Null }), y2 = t2.Variant({ ftTransfer: m }), d = t2.Variant({ ftTransfer: t2.Record({ fee: t2.Nat, amount: t2.Nat }) }), $ = t2.Variant({ failure: y2, success: d }), w = t2.Variant({ dropped: t2.Record({}), awaited: t2.Record({}), processed: t2.Tuple(t2.Opt($)) });
  return t2.Service({ accountInfo: t2.Func([e], [t2.Vec(t2.Tuple(o, i))], ["query"]), aggregatorPrincipal: t2.Func([t2.Nat], [t2.Variant({ ok: t2.Principal, err: t2.Variant({ NotFound: t2.Null }) })], ["query"]), aggregators: t2.Func([], [t2.Vec(t2.Tuple(t2.Principal, t2.Nat))], ["query"]), createFungibleToken: t2.Func([t2.Nat8, t2.Text], [t2.Variant({ ok: n, err: t2.Variant({ NoSpace: t2.Null, FeeError: t2.Null }) })], []), deleteVirtualAccount: t2.Func([a], [t2.Variant({ ok: t2.Variant({ ft: t2.Nat }), err: t2.Variant({ DeletedVirtualAccount: t2.Null, InvalidArguments: t2.Text }) })], []), ftInfo: t2.Func([e], [t2.Vec(t2.Tuple(n, t2.Record({ controller: t2.Principal, decimals: t2.Nat8, description: t2.Text })))], ["query"]), nAccounts: t2.Func([], [t2.Nat], ["query"]), nFtAssets: t2.Func([], [t2.Nat], ["query"]), nStreams: t2.Func([], [t2.Nat], ["query"]), nVirtualAccounts: t2.Func([], [t2.Nat], ["query"]), openAccounts: t2.Func([t2.Nat, i], [t2.Variant({ ok: t2.Record({ first: o }), err: t2.Variant({ InvalidArguments: t2.Text, NoSpaceForPrincipal: t2.Null, NoSpaceForSubaccount: t2.Null }) })], []), openVirtualAccount: t2.Func([i, t2.Principal, s2, o, c], [t2.Variant({ ok: t2.Record({ id: a }), err: t2.Variant({ InvalidArguments: t2.Text, NoSpaceForAccount: t2.Null }) })], []), ping: t2.Func([], [t2.Int], []), state: t2.Func([t2.Record({ ftSupplies: t2.Opt(e), virtualAccounts: t2.Opt(e), accounts: t2.Opt(e), remoteAccounts: t2.Opt(p) })], [t2.Record({ ftSupplies: t2.Vec(t2.Tuple(n, f)), virtualAccounts: t2.Vec(t2.Tuple(a, t2.Opt(t2.Tuple(s2, o, c)))), accounts: t2.Vec(t2.Tuple(o, s2)), remoteAccounts: t2.Vec(t2.Tuple(u, t2.Opt(t2.Tuple(s2, c)))) })], ["query"]), streamStatus: t2.Func([e], [t2.Vec(t2.Tuple(t2.Nat, t2.Record({ closed: t2.Bool, source: t2.Variant({ internal: t2.Null, aggregator: t2.Principal }), length: t2.Nat, lastActive: c })))], ["query"]), txStatus: t2.Func([t2.Vec(l)], [t2.Vec(w)], ["query"]), updateVirtualAccount: t2.Func([a, t2.Record({ backingAccount: t2.Opt(o), state: t2.Opt(t2.Variant({ ft_dec: t2.Nat, ft_inc: t2.Nat, ft_set: t2.Nat })), expiration: t2.Opt(c) })], [t2.Variant({ ok: t2.Variant({ ft: t2.Tuple(t2.Nat, t2.Int) }), err: t2.Variant({ DeletedVirtualAccount: t2.Null, InvalidArguments: t2.Text, InsufficientFunds: t2.Null }) })], []), virtualAccountInfo: t2.Func([e], [t2.Vec(t2.Tuple(a, t2.Opt(t2.Tuple(i, t2.Principal))))], ["query"]) });
};
var ft = async (t2, r, e) => {
  let o = await lt(e, { retryTimes: 5 });
  return Actor.createActor(r, { agent: o, canisterId: t2 });
};
var X = async (t2, ...r) => {
  try {
    return await t2(...r);
  } catch (e) {
    if (e.props?.Code) {
      let o = e.props.Message, n = null;
      throw e.props.Code == "CanisterError" && (n = /trapped explicitly:\s(.+)/gi.exec(o)), new y({ [e.props.Code]: n ? n[1] : o });
    } else if (e.message.startsWith("Call was rejected:")) {
      let o = /Reject\scode:\s(\d+)/gi.exec(e.message);
      if (o) {
        let n = ReplicaRejectCode[+o[1]], i = null;
        throw n == "CanisterError" && (i = /trapped explicitly:\s(.+)/gi.exec(e.message)), i || (i = /Reject text:\s(.+)/gi.exec(e.message)), new y({ [n]: i ? i[1] : e.message });
      }
    }
    throw e;
  }
};
var V = (t2) => new Promise((r) => setTimeout(r, t2));
var Kt = 100;
var It = 5;
var mt = async (t2, r, ...e) => {
  try {
    return await t2(...e);
  } catch (o) {
    let [n, i] = Qt(o);
    if (![401, 403].includes(n) && (!i || !["CanisterReject", "CanisterError"].includes(i)) && r < It) {
      let a = Kt * Math.pow(2, r);
      return await V(a), mt(t2, r + 1, ...e);
    } else
      throw o;
  }
};
var dt = async (t2, ...r) => mt(t2, 0, ...r);
var yt = async (t2) => b(await t2);
var b = (t2) => t2.length > 0 ? t2[0] : null;
var C = async (t2) => {
  let r = await t2;
  if (r.err)
    throw new y(r.err);
  return r.ok;
};
var bt = 5 * 60 * 1000;
var k = class extends HttpAgent {
  async prepareRequest(r, e, o) {
    let n = await (o !== undefined ? await o : await this._identity);
    if (!n)
      throw new Error("This identity has expired due this application's security policy. Please refresh your authentication.");
    let i = Principal.from(r), a = e.effectiveCanisterId ? Principal.from(e.effectiveCanisterId) : i, s2 = n.getPrincipal() || Principal.anonymous(), c = new Expiry(bt);
    Math.abs(this._timeDiffMsecs) > 1000 * 30 && (c = new Expiry(bt + this._timeDiffMsecs));
    let u = { request_type: SubmitRequestType.Call, canister_id: i, method_name: e.methodName, arg: e.arg, sender: s2, ingress_expiry: c }, p = await this._transform({ request: { body: null, method: "POST", headers: { "Content-Type": "application/cbor", ...this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {} } }, endpoint: "call", body: u });
    p = await n.transformRequest(p);
    let f = exports_cbor.encode(p.body), l = await requestIdOf(u);
    return { requestId: l, call: async () => {
      let m = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${a.toText()}/call`, this._host), { ...this._callOptions, ...p.request, body: f })), y2 = await m.arrayBuffer(), d = m.status === 200 && y2.byteLength > 0 ? exports_cbor.decode(y2) : null;
      return { requestId: l, response: { ok: m.ok, status: m.status, statusText: m.statusText, body: d, headers: Lt(m.headers) } };
    } };
  }
};
var x = class {
  constructor(r, e, o) {
    this.idl = r;
    this._canisterPrincipal = e;
    this.network = o;
    this._canisterPromise = ft(e, r, o).then((n) => (this._service = n, n));
  }
  get canisterPrincipal() {
    return this._canisterPrincipal instanceof Principal ? this._canisterPrincipal : Principal.fromText(this._canisterPrincipal);
  }
  _service = null;
  _canisterPromise;
  get service() {
    return this._service ? Promise.resolve(this._service) : this._canisterPromise;
  }
  get agent() {
    return this.service.then((r) => Actor.agentOf(r));
  }
  wrapCall(r, e, ...o) {
    return e.length ? e.pop()((...n) => this.wrapCall(r, e, ...o), ...o) : r(...o);
  }
  query(r, ...e) {
    return this.wrapCall(r, [dt, X], ...e);
  }
  optQuery(r, ...e) {
    return yt(this.query(r, ...e));
  }
  update(r, ...e) {
    return this.wrapCall(r, [X], ...e);
  }
  resUpdate(r, ...e) {
    return C(this.query(r, ...e));
  }
  async getFunction(r) {
    let e = await this.service, [o, n] = e[Symbol.for("ic-agent-metadata")].service._fields.find((i) => i[0] === r) || [];
    return n;
  }
  async parseResponse(r, e, o) {
    let n = await this.getFunction(r);
    if (!n)
      throw new Error(`Function "${r} not found!`);
    let i = n.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);
    if (e !== undefined)
      return i ? { httpDetails: o, result: At(n.retTypes, e) } : At(n.retTypes, e);
    if (n.retTypes.length === 0)
      return i ? { httpDetails: o, result: undefined } : undefined;
    throw new Error(`Call was returned undefined, but type [${n.retTypes.join(",")}].`);
  }
  async prepareUpdateRequest(r, ...e) {
    let o = await this.getFunction(r);
    if (!o)
      throw new Error(`Function "${r} not found!`);
    let i = (await this.service)[Symbol.for("ic-agent-metadata")].config, { canisterId: a, effectiveCanisterId: s2, pollingStrategyFactory: c, blsVerify: u } = i, p = Principal.from(a), f = s2 !== undefined ? Principal.from(s2) : p, l = exports_idl.encode(o.argTypes, e), m = await this.agent, y2 = new k({ host: this.network == "ic" ? "https://ic0.app" : "http://127.0.0.1:4943", identity: (m || {})._identity || new AnonymousIdentity });
    this.network === "local" && await y2.fetchRootKey();
    let { requestId: d, call: $ } = await y2.prepareRequest(p, { methodName: r, arg: l, effectiveCanisterId: f });
    return { requestId: d, call: async () => {
      let { response: w } = await $();
      if (!w.ok || w.body)
        throw new UpdateCallRejectedError(p, r, d, w);
      let ut = (c || exports_polling.defaultStrategy)(), Gt = await exports_polling.pollForResponse(y2, f, d, ut, null, u);
      return this.parseResponse(r, Gt, w);
    } };
  }
};
var L = (t2) => ({ type: "ft", balance: t2.ft });
var U = (t2) => ({ type: "ft", assetId: t2.ft });
var M = (t2) => ({ ftSupplies: t2.ftSupplies, virtualAccounts: t2.virtualAccounts.map(([r, e]) => [r, b(e) && { state: L(b(e)[0]), backingSubaccountId: b(e)[1], expiration: b(e)[2] }]), accounts: t2.accounts.map(([r, e]) => [r, L(e)]), remoteAccounts: t2.remoteAccounts.map(([r, e]) => [r, b(e) && { state: L(b(e)[0]), expiration: b(e)[1] }]) });
var B = class extends x {
  constructor(e, o) {
    super(pt, e, o);
    this._canisterPrincipal = e;
  }
  async accountInfo(e) {
    return (await this.query((await this.service).accountInfo, e)).map(([o, n]) => [o, U(n)]);
  }
  async nAccounts() {
    return this.query((await this.service).nAccounts);
  }
  async nVirtualAccounts() {
    return this.query((await this.service).nVirtualAccounts);
  }
  async virtualAccountInfo(e) {
    return (await this.query((await this.service).virtualAccountInfo, e)).map(([n, i]) => [n, i[0] ? { type: "ft", assetId: i[0][0].ft, accessPrincipal: i[0][1] } : null]);
  }
  async createFungibleToken(e, o) {
    return this.resUpdate((await this.service).createFungibleToken, e, o);
  }
  async openAccounts(e, o) {
    return this.resUpdate((await this.service).openAccounts, BigInt(o), e);
  }
  async openVirtualAccount(e, o, n, i, a) {
    return this.resUpdate((await this.service).openVirtualAccount, { [e.type]: e.assetId }, o instanceof Principal ? o : Principal.fromText(o), { [n.type]: n.balance }, i, BigInt(a || 0) * BigInt(1e6));
  }
  async updateVirtualAccount(e, o) {
    let n = await this.resUpdate((await this.service).updateVirtualAccount, e, { backingAccount: o.backingAccount || o.backingAccount === BigInt(0) ? [o.backingAccount] : [], state: o.state ? [o.state] : [], expiration: o.expiration || o.expiration === 0 ? [BigInt(o.expiration) * BigInt(1e6)] : [] });
    return { type: "ft", balance: n.ft[0], delta: n.ft[1] };
  }
  async deleteVirtualAccount(e) {
    return { type: "ft", balance: (await this.resUpdate((await this.service).deleteVirtualAccount, e)).ft };
  }
  async txStatus(e) {
    return (await this.query((await this.service).txStatus, e)).map((n) => {
      let [i, a] = s(n);
      return i === "awaited" ? { status: i, aggregator: a[0] } : i === "processed" ? { status: i, result: a[0] || null } : { status: i };
    });
  }
  async singleTxStatus(e) {
    return (await this.txStatus([e]))[0];
  }
  async nFtAssets() {
    return this.query((await this.service).nFtAssets);
  }
  async ftInfo(e) {
    return this.query((await this.service).ftInfo, e);
  }
  async aggregators() {
    return (await this.query((await this.service).aggregators)).map(([o, n]) => ({ principal: o, priority: Number(n) }));
  }
  async aggregatorPrincipal(e) {
    return C(this.query((await this.service).aggregatorPrincipal, e));
  }
  async nStreams() {
    return this.query((await this.service).nStreams);
  }
  async streamStatus(e) {
    return (await this.query((await this.service).streamStatus, e)).map(([n, i]) => {
      let [a, s2] = s(i.source), c = { type: a };
      return a === "aggregator" && (c.principal = s2), [n, { ...i, source: c }];
    });
  }
  async state(e) {
    return M(await this.query((await this.service).state, { ftSupplies: e.ftSupplies ? [e.ftSupplies] : [], virtualAccounts: e.virtualAccounts ? [e.virtualAccounts] : [], accounts: e.accounts ? [e.accounts] : [], remoteAccounts: e.remoteAccounts ? [e.remoteAccounts] : [] }));
  }
};
var wt = ({ IDL: t2 }) => {
  let r = t2.Tuple(t2.Nat, t2.Opt(t2.Nat)), e = t2.Variant({ id: t2.Nat, cat: t2.Vec(t2.Variant({ id: t2.Nat, idRange: r })), idRange: r }), o = t2.Nat, n = t2.Nat, i = t2.Variant({ ft: n }), a = t2.Tuple(t2.Principal, t2.Nat), s2 = t2.Variant({ id: a, cat: t2.Vec(t2.Variant({ id: a })) }), c = t2.Nat, u = t2.Nat, p = t2.Variant({ ft: t2.Nat }), f = t2.Nat64;
  return t2.Service({ adminAccountInfo: t2.Func([e], [t2.Vec(t2.Tuple(o, i))], ["query"]), adminState: t2.Func([t2.Record({ ftSupplies: t2.Opt(e), virtualAccounts: t2.Opt(e), accounts: t2.Opt(e), remoteAccounts: t2.Opt(s2) })], [t2.Record({ ftSupplies: t2.Vec(t2.Tuple(n, c)), virtualAccounts: t2.Vec(t2.Tuple(u, t2.Opt(t2.Tuple(p, o, f)))), accounts: t2.Vec(t2.Tuple(o, p)), remoteAccounts: t2.Vec(t2.Tuple(a, t2.Opt(t2.Tuple(p, f)))) })], ["query"]), nAdminAccounts: t2.Func([], [t2.Nat], ["query"]) });
};
var W = class extends x {
  constructor(e, o) {
    super(wt, e, o);
    this._canisterPrincipal = e;
  }
  async accountInfo(e) {
    return (await this.query((await this.service).adminAccountInfo, e)).map(([o, n]) => [o, U(n)]);
  }
  async nAccounts() {
    return this.query((await this.service).nAdminAccounts);
  }
  async state(e) {
    return M(await this.query((await this.service).adminState, { ftSupplies: e.ftSupplies ? [e.ftSupplies] : [], virtualAccounts: e.virtualAccounts ? [e.virtualAccounts] : [], accounts: e.accounts ? [e.accounts] : [], remoteAccounts: e.remoteAccounts ? [e.remoteAccounts] : [] }));
  }
};
var Tt = ({ IDL: t2 }) => {
  let r = t2.Record({ id: t2.Nat, sent: t2.Nat, length: t2.Nat, received: t2.Nat }), e = t2.Variant({ sub: t2.Nat, vir: t2.Tuple(t2.Principal, t2.Nat), mint: t2.Null }), o = t2.Nat, n = t2.Record({ to: e, asset: o, from: e, memo: t2.Vec(t2.Vec(t2.Nat8)), amount: t2.Variant({ max: t2.Null, amount: t2.Nat }) }), i = t2.Variant({ ftTransfer: n }), a = t2.Tuple(t2.Nat, t2.Nat), s2 = t2.Nat64, c = t2.Variant({ pending: t2.Record({}), other: t2.Tuple(s2, t2.Variant({ settled: t2.Null, settledIfIssuedHere: t2.Null })), queued: t2.Tuple(t2.Nat) });
  return t2.Service({ ping: t2.Func([], [t2.Int], []), streamStatus: t2.Func([], [t2.Vec(r)], ["query"]), submitAndExecute: t2.Func([t2.Vec(i)], [t2.Vec(a)], []), txStatus: t2.Func([t2.Vec(a)], [t2.Vec(c)], ["query"]) });
};
var H = class extends x {
  constructor(e, o) {
    super(Tt, e, o);
    this._canisterPrincipal = e;
  }
  async submitAndExecute(e) {
    return this.update((await this.service).submitAndExecute, e);
  }
  async singleSubmitAndExecute(e) {
    return (await this.update((await this.service).submitAndExecute, [e]))[0];
  }
  async txStatus(e) {
    return (await this.query((await this.service).txStatus, e)).map((n) => {
      let [i, a] = s(n);
      return i === "queued" ? { status: i, queueNumber: a[0] } : i === "other" ? { status: i, lastLedgerTimestamp: a[0] } : { status: i };
    });
  }
  async singleTxStatus(e) {
    return (await this.txStatus([e]))[0];
  }
  async streamStatus() {
    return (await this.service).streamStatus();
  }
};
var D = function(t2, r) {
  return D = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var n in o)
      Object.prototype.hasOwnProperty.call(o, n) && (e[n] = o[n]);
  }, D(t2, r);
};
var J = G(function(t2) {
  return function(e) {
    t2(this), this.message = e ? e.length + ` errors occurred during unsubscription:
` + e.map(function(o, n) {
      return n + 1 + ") " + o.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = e;
  };
});
var _ = function() {
  function t2(r) {
    this.initialTeardown = r, this.closed = false, this._parentage = null, this._finalizers = null;
  }
  return t2.prototype.unsubscribe = function() {
    var r, e, o, n, i;
    if (!this.closed) {
      this.closed = true;
      var a = this._parentage;
      if (a)
        if (this._parentage = null, Array.isArray(a))
          try {
            for (var s2 = F(a), c = s2.next();!c.done; c = s2.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (d) {
            r = { error: d };
          } finally {
            try {
              c && !c.done && (e = s2.return) && e.call(s2);
            } finally {
              if (r)
                throw r.error;
            }
          }
        else
          a.remove(this);
      var p = this.initialTeardown;
      if (h(p))
        try {
          p();
        } catch (d) {
          i = d instanceof J ? d.errors : [d];
        }
      var f = this._finalizers;
      if (f) {
        this._finalizers = null;
        try {
          for (var l = F(f), m = l.next();!m.done; m = l.next()) {
            var y2 = m.value;
            try {
              Pt(y2);
            } catch (d) {
              i = i ?? [], d instanceof J ? i = P(P([], T(i)), T(d.errors)) : i.push(d);
            }
          }
        } catch (d) {
          o = { error: d };
        } finally {
          try {
            m && !m.done && (n = l.return) && n.call(l);
          } finally {
            if (o)
              throw o.error;
          }
        }
      }
      if (i)
        throw new J(i);
    }
  }, t2.prototype.add = function(r) {
    var e;
    if (r && r !== this)
      if (this.closed)
        Pt(r);
      else {
        if (r instanceof t2) {
          if (r.closed || r._hasParent(this))
            return;
          r._addParent(this);
        }
        (this._finalizers = (e = this._finalizers) !== null && e !== undefined ? e : []).push(r);
      }
  }, t2.prototype._hasParent = function(r) {
    var e = this._parentage;
    return e === r || Array.isArray(e) && e.includes(r);
  }, t2.prototype._addParent = function(r) {
    var e = this._parentage;
    this._parentage = Array.isArray(e) ? (e.push(r), e) : e ? [e, r] : r;
  }, t2.prototype._removeParent = function(r) {
    var e = this._parentage;
    e === r ? this._parentage = null : Array.isArray(e) && N(e, r);
  }, t2.prototype.remove = function(r) {
    var e = this._finalizers;
    e && N(e, r), r instanceof t2 && r._removeParent(this);
  }, t2.EMPTY = function() {
    var r = new t2;
    return r.closed = true, r;
  }(), t2;
}();
var tt = _.EMPTY;
var g = { onUnhandledError: null, onStoppedNotification: null, Promise: undefined, useDeprecatedSynchronousErrorHandling: false, useDeprecatedNextContext: false };
var R = { setTimeout: function(t2, r) {
  for (var e = [], o = 2;o < arguments.length; o++)
    e[o - 2] = arguments[o];
  var n = R.delegate;
  return n?.setTimeout ? n.setTimeout.apply(n, P([t2, r], T(e))) : setTimeout.apply(undefined, P([t2, r], T(e)));
}, clearTimeout: function(t2) {
  var r = R.delegate;
  return (r?.clearTimeout || clearTimeout)(t2);
}, delegate: undefined };
var Rt = function() {
  return rt("C", undefined, undefined);
}();
var S = null;
var q = function(t2) {
  A(r, t2);
  function r(e) {
    var o = t2.call(this) || this;
    return o.isStopped = false, e ? (o.destination = e, z(e) && e.add(o)) : o.destination = ae, o;
  }
  return r.create = function(e, o, n) {
    return new K(e, o, n);
  }, r.prototype.next = function(e) {
    this.isStopped ? nt(Ot(e), this) : this._next(e);
  }, r.prototype.error = function(e) {
    this.isStopped ? nt(Et(e), this) : (this.isStopped = true, this._error(e));
  }, r.prototype.complete = function() {
    this.isStopped ? nt(Rt, this) : (this.isStopped = true, this._complete());
  }, r.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = true, t2.prototype.unsubscribe.call(this), this.destination = null);
  }, r.prototype._next = function(e) {
    this.destination.next(e);
  }, r.prototype._error = function(e) {
    try {
      this.destination.error(e);
    } finally {
      this.unsubscribe();
    }
  }, r.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, r;
}(_);
var oe = Function.prototype.bind;
var ne = function() {
  function t2(r) {
    this.partialObserver = r;
  }
  return t2.prototype.next = function(r) {
    var e = this.partialObserver;
    if (e.next)
      try {
        e.next(r);
      } catch (o) {
        Y(o);
      }
  }, t2.prototype.error = function(r) {
    var e = this.partialObserver;
    if (e.error)
      try {
        e.error(r);
      } catch (o) {
        Y(o);
      }
    else
      Y(r);
  }, t2.prototype.complete = function() {
    var r = this.partialObserver;
    if (r.complete)
      try {
        r.complete();
      } catch (e) {
        Y(e);
      }
  }, t2;
}();
var K = function(t2) {
  A(r, t2);
  function r(e, o, n) {
    var i = t2.call(this) || this, a;
    if (h(e) || !e)
      a = { next: e ?? undefined, error: o ?? undefined, complete: n ?? undefined };
    else {
      var s2;
      i && g.useDeprecatedNextContext ? (s2 = Object.create(e), s2.unsubscribe = function() {
        return i.unsubscribe();
      }, a = { next: e.next && ot(e.next, s2), error: e.error && ot(e.error, s2), complete: e.complete && ot(e.complete, s2) }) : a = e;
    }
    return i.destination = new ne(a), i;
  }
  return r;
}(q);
var ae = { closed: true, next: et, error: ie, complete: et };
var Ft = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
var it = function() {
  function t2(r) {
    r && (this._subscribe = r);
  }
  return t2.prototype.lift = function(r) {
    var e = new t2;
    return e.source = this, e.operator = r, e;
  }, t2.prototype.subscribe = function(r, e, o) {
    var n = this, i = ce(r) ? r : new K(r, e, o);
    return E(function() {
      var a = n, s2 = a.operator, c = a.source;
      i.add(s2 ? s2.call(i, c) : c ? n._subscribe(i) : n._trySubscribe(i));
    }), i;
  }, t2.prototype._trySubscribe = function(r) {
    try {
      return this._subscribe(r);
    } catch (e) {
      r.error(e);
    }
  }, t2.prototype.forEach = function(r, e) {
    var o = this;
    return e = Ct(e), new e(function(n, i) {
      var a = new K({ next: function(s2) {
        try {
          r(s2);
        } catch (c) {
          i(c), a.unsubscribe();
        }
      }, error: i, complete: n });
      o.subscribe(a);
    });
  }, t2.prototype._subscribe = function(r) {
    var e;
    return (e = this.source) === null || e === undefined ? undefined : e.subscribe(r);
  }, t2.prototype[Ft] = function() {
    return this;
  }, t2.prototype.pipe = function() {
    for (var r = [], e = 0;e < arguments.length; e++)
      r[e] = arguments[e];
    return qt(r)(this);
  }, t2.prototype.toPromise = function(r) {
    var e = this;
    return r = Ct(r), new r(function(o, n) {
      var i;
      e.subscribe(function(a) {
        return i = a;
      }, function(a) {
        return n(a);
      }, function() {
        return o(i);
      });
    });
  }, t2.create = function(r) {
    return new t2(r);
  }, t2;
}();
var pe = function(t2) {
  A(r, t2);
  function r(e, o, n, i, a, s2) {
    var c = t2.call(this, e) || this;
    return c.onFinalize = a, c.shouldUnsubscribe = s2, c._next = o ? function(u) {
      try {
        o(u);
      } catch (p) {
        e.error(p);
      }
    } : t2.prototype._next, c._error = i ? function(u) {
      try {
        i(u);
      } catch (p) {
        e.error(p);
      } finally {
        this.unsubscribe();
      }
    } : t2.prototype._error, c._complete = n ? function() {
      try {
        n();
      } catch (u) {
        e.error(u);
      } finally {
        this.unsubscribe();
      }
    } : t2.prototype._complete, c;
  }
  return r.prototype.unsubscribe = function() {
    var e;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var o = this.closed;
      t2.prototype.unsubscribe.call(this), !o && ((e = this.onFinalize) === null || e === undefined || e.call(this));
    }
  }, r;
}(q);
var jt = G(function(t2) {
  return function() {
    t2(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
});
var Q = function(t2) {
  A(r, t2);
  function r() {
    var e = t2.call(this) || this;
    return e.closed = false, e.currentObservers = null, e.observers = [], e.isStopped = false, e.hasError = false, e.thrownError = null, e;
  }
  return r.prototype.lift = function(e) {
    var o = new Ut(this, this);
    return o.operator = e, o;
  }, r.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new jt;
  }, r.prototype.next = function(e) {
    var o = this;
    E(function() {
      var n, i;
      if (o._throwIfClosed(), !o.isStopped) {
        o.currentObservers || (o.currentObservers = Array.from(o.observers));
        try {
          for (var a = F(o.currentObservers), s2 = a.next();!s2.done; s2 = a.next()) {
            var c = s2.value;
            c.next(e);
          }
        } catch (u) {
          n = { error: u };
        } finally {
          try {
            s2 && !s2.done && (i = a.return) && i.call(a);
          } finally {
            if (n)
              throw n.error;
          }
        }
      }
    });
  }, r.prototype.error = function(e) {
    var o = this;
    E(function() {
      if (o._throwIfClosed(), !o.isStopped) {
        o.hasError = o.isStopped = true, o.thrownError = e;
        for (var n = o.observers;n.length; )
          n.shift().error(e);
      }
    });
  }, r.prototype.complete = function() {
    var e = this;
    E(function() {
      if (e._throwIfClosed(), !e.isStopped) {
        e.isStopped = true;
        for (var o = e.observers;o.length; )
          o.shift().complete();
      }
    });
  }, r.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true, this.observers = this.currentObservers = null;
  }, Object.defineProperty(r.prototype, "observed", { get: function() {
    var e;
    return ((e = this.observers) === null || e === undefined ? undefined : e.length) > 0;
  }, enumerable: false, configurable: true }), r.prototype._trySubscribe = function(e) {
    return this._throwIfClosed(), t2.prototype._trySubscribe.call(this, e);
  }, r.prototype._subscribe = function(e) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e);
  }, r.prototype._innerSubscribe = function(e) {
    var o = this, n = this, i = n.hasError, a = n.isStopped, s2 = n.observers;
    return i || a ? tt : (this.currentObservers = null, s2.push(e), new _(function() {
      o.currentObservers = null, N(s2, e);
    }));
  }, r.prototype._checkFinalizedStatuses = function(e) {
    var o = this, n = o.hasError, i = o.thrownError, a = o.isStopped;
    n ? e.error(i) : a && e.complete();
  }, r.prototype.asObservable = function() {
    var e = new it;
    return e.source = this, e;
  }, r.create = function(e, o) {
    return new Ut(e, o);
  }, r;
}(it);
var Ut = function(t2) {
  A(r, t2);
  function r(e, o) {
    var n = t2.call(this) || this;
    return n.destination = e, n.source = o, n;
  }
  return r.prototype.next = function(e) {
    var o, n;
    (n = (o = this.destination) === null || o === undefined ? undefined : o.next) === null || n === undefined || n.call(o, e);
  }, r.prototype.error = function(e) {
    var o, n;
    (n = (o = this.destination) === null || o === undefined ? undefined : o.error) === null || n === undefined || n.call(o, e);
  }, r.prototype.complete = function() {
    var e, o;
    (o = (e = this.destination) === null || e === undefined ? undefined : e.complete) === null || o === undefined || o.call(e);
  }, r.prototype._subscribe = function(e) {
    var o, n;
    return (n = (o = this.source) === null || o === undefined ? undefined : o.subscribe(e)) !== null && n !== undefined ? n : tt;
  }, r;
}(Q);
var Wt = (t2) => {
  switch (t2.type) {
    case "mint":
      return { mint: null };
    case "sub":
      return { sub: t2.id };
    case "vir":
      return { vir: [t2.owner instanceof Principal ? t2.owner : Principal.fromText(t2.owner), t2.id] };
  }
};
var Ht = class {
  constructor(r, e) {
    this.ledgerPrincipal = r;
    this.network = e;
    this.ledger = new B(this.ledgerPrincipal, e), this.admin = new W(this.ledgerPrincipal, e);
  }
  ledger;
  admin;
  _externalIdentity = null;
  get externalIdentity() {
    return this._externalIdentity;
  }
  async setIdentity(r) {
    this._externalIdentity = r, r = r || new AnonymousIdentity, Actor.agentOf(await this.ledger.service).replaceIdentity(r), Actor.agentOf(await this.admin.service).replaceIdentity(r);
  }
  async getAggregators() {
    return Promise.all((await this.ledger.aggregators()).filter(({ priority: r }) => r > 0).map(({ principal: r }) => this.createAggregatorDelegate(r)));
  }
  async pickAggregator() {
    let r = await this.ledger.aggregators(), e = r.reduce((a, s2) => a + s2.priority, 0);
    if (e == 0)
      return null;
    let o = Math.random() * e, n = 0, i = null;
    for (let a = 0;a < r.length; a++)
      if (n += r[a].priority, o <= n) {
        i = r[a].principal;
        break;
      }
    return this.createAggregatorDelegate(i);
  }
  async createAggregatorDelegate(r) {
    let e = new H(r, this.network), o = this.externalIdentity || new AnonymousIdentity;
    return Actor.agentOf(await e.service).replaceIdentity(o), e;
  }
  simpleTransfer(r, e, o, n, i, a = []) {
    return r.singleSubmitAndExecute(this._txInputFromRawArgs(e, o, n, i, a));
  }
  async prepareSimpleTransfer(r, e, o, n, i, a = []) {
    let { requestId: s2, call: c } = await r.prepareUpdateRequest("submitAndExecute", [this._txInputFromRawArgs(e, o, n, i, a)]);
    return { requestId: s2, commit: async () => (await c())[0] };
  }
  pollTx(r, e) {
    let o = new Q, n = false, i;
    return o.pipe(st(() => !n)).subscribe((a) => {
      i = a;
    }), setTimeout(async () => {
      try {
        let a = "aggregator", s2 = 0, c = async () => {
          let f = await r.singleTxStatus(e), l = null;
          return f.status == "queued" ? (l = { status: "queued", txId: e, statusPayload: f.queueNumber }, a = "aggregator") : f.status == "pending" ? (l = { status: "forwarding", txId: e, statusPayload: { info: 'Aggregator responded with state "pending"' } }, a = "both") : (l = { status: "forwarded", txId: e }, a = "final"), l;
        }, u = async (f) => {
          let l = await this.ledger.singleTxStatus(e);
          if (l.status === "dropped")
            throw new Error('Ledger responded with "dropped" state');
          if (l.status === "processed")
            return o.next({ status: "processed", txId: e, statusPayload: l.result }), true;
          if (l.status === "awaited") {
            if (f)
              throw new Error('Ledger responded with "awaited" state, when aggregator already forwarded transaction');
            o.next({ status: i.status, txId: e, statusPayload: { info: 'Ledger responded with state "awaited"' } });
          }
          return false;
        }, p = 0;
        t:
          for (;; ) {
            switch (a) {
              case "aggregator":
                await V(250);
                try {
                  o.next(await c());
                } catch (y2) {
                  if (p < 10 && y2 instanceof y && y2.errorKey == "CanisterReject" && y2.errorPayload == "Not yet issued")
                    p++;
                  else
                    throw y2;
                }
                break;
              case "both":
                await V(250);
                let f = [u(false)];
                s2 % 3 == 0 && f.push(c());
                let [l, m] = await Promise.all(f);
                if (l)
                  break t;
                m && o.next(m);
                break;
              case "final":
                await u(true);
                break t;
            }
            s2++;
          }
      } catch (a) {
        o.error(a);
      }
      o.complete();
    }, 0), o.pipe(at(() => n = true));
  }
  _txInputFromRawArgs(r, e, o, n, i = []) {
    return { ftTransfer: { from: Wt(r), to: Wt(e), asset: o, amount: n === "max" ? { max: null } : { amount: typeof n == "bigint" ? n : BigInt(n) }, memo: i } };
  }
};

// node_modules/@dfinity/identity/lib/esm/identity/ed25519.js
var tweetnacl = __toESM(require_nacl_fast(), 1);

// node_modules/@dfinity/identity/lib/esm/buffer.js
function fromHexString2(hexString) {
  var _a;
  return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== undefined ? _a : []).map((byte) => parseInt(byte, 16))).buffer;
}
function toHexString2(bytes) {
  return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// node_modules/@dfinity/identity/lib/esm/identity/der.js
function wrapDER(payload, oid) {
  const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);
  const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;
  let offset = 0;
  const buf = new Uint8Array(1 + encodeLenBytes(len) + len);
  buf[offset++] = 48;
  offset += encodeLen(buf, offset, len);
  buf.set(oid, offset);
  offset += oid.byteLength;
  buf[offset++] = 3;
  offset += encodeLen(buf, offset, payload.byteLength + 1);
  buf[offset++] = 0;
  buf.set(new Uint8Array(payload), offset);
  return buf;
}
var bufEquals = (b1, b2) => {
  if (b1.byteLength !== b2.byteLength)
    return false;
  const u1 = new Uint8Array(b1);
  const u2 = new Uint8Array(b2);
  for (let i = 0;i < u1.length; i++) {
    if (u1[i] !== u2[i])
      return false;
  }
  return true;
};
var encodeLenBytes = (len) => {
  if (len <= 127) {
    return 1;
  } else if (len <= 255) {
    return 2;
  } else if (len <= 65535) {
    return 3;
  } else if (len <= 16777215) {
    return 4;
  } else {
    throw new Error("Length too long (> 4 bytes)");
  }
};
var encodeLen = (buf, offset, len) => {
  if (len <= 127) {
    buf[offset] = len;
    return 1;
  } else if (len <= 255) {
    buf[offset] = 129;
    buf[offset + 1] = len;
    return 2;
  } else if (len <= 65535) {
    buf[offset] = 130;
    buf[offset + 1] = len >> 8;
    buf[offset + 2] = len;
    return 3;
  } else if (len <= 16777215) {
    buf[offset] = 131;
    buf[offset + 1] = len >> 16;
    buf[offset + 2] = len >> 8;
    buf[offset + 3] = len;
    return 4;
  } else {
    throw new Error("Length too long (> 4 bytes)");
  }
};
var decodeLenBytes = (buf, offset) => {
  if (buf[offset] < 128)
    return 1;
  if (buf[offset] === 128)
    throw new Error("Invalid length 0");
  if (buf[offset] === 129)
    return 2;
  if (buf[offset] === 130)
    return 3;
  if (buf[offset] === 131)
    return 4;
  throw new Error("Length too long (> 4 bytes)");
};
var decodeLen = (buf, offset) => {
  const lenBytes = decodeLenBytes(buf, offset);
  if (lenBytes === 1)
    return buf[offset];
  else if (lenBytes === 2)
    return buf[offset + 1];
  else if (lenBytes === 3)
    return (buf[offset + 1] << 8) + buf[offset + 2];
  else if (lenBytes === 4)
    return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];
  throw new Error("Length too long (> 4 bytes)");
};
var DER_COSE_OID = Uint8Array.from([
  ...[48, 12],
  ...[6, 10],
  ...[43, 6, 1, 4, 1, 131, 184, 67, 1, 1]
]);
var ED25519_OID = Uint8Array.from([
  ...[48, 5],
  ...[6, 3],
  ...[43, 101, 112]
]);
var SECP256K1_OID = Uint8Array.from([
  ...[48, 16],
  ...[6, 7],
  ...[42, 134, 72, 206, 61, 2, 1],
  ...[6, 5],
  ...[43, 129, 4, 0, 10]
]);
var unwrapDER = (derEncoded, oid) => {
  let offset = 0;
  const expect = (n, msg) => {
    if (buf[offset++] !== n) {
      throw new Error("Expected: " + msg);
    }
  };
  const buf = new Uint8Array(derEncoded);
  expect(48, "sequence");
  offset += decodeLenBytes(buf, offset);
  if (!bufEquals(buf.slice(offset, offset + oid.byteLength), oid)) {
    throw new Error("Not the expected OID.");
  }
  offset += oid.byteLength;
  expect(3, "bit string");
  const payloadLen = decodeLen(buf, offset) - 1;
  offset += decodeLenBytes(buf, offset);
  expect(0, "0 padding");
  const result = buf.slice(offset);
  if (payloadLen !== result.length) {
    throw new Error(`DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`);
  }
  return result;
};

// node_modules/@dfinity/identity/lib/esm/identity/ed25519.js
class Ed25519PublicKey {
  constructor(key) {
    this.rawKey = key;
    this.derKey = Ed25519PublicKey.derEncode(key);
  }
  static from(key) {
    return this.fromDer(key.toDer());
  }
  static fromRaw(rawKey) {
    return new Ed25519PublicKey(rawKey);
  }
  static fromDer(derKey) {
    return new Ed25519PublicKey(this.derDecode(derKey));
  }
  static derEncode(publicKey) {
    return wrapDER(publicKey, ED25519_OID).buffer;
  }
  static derDecode(key) {
    const unwrapped = unwrapDER(key, ED25519_OID);
    if (unwrapped.length !== this.RAW_KEY_LENGTH) {
      throw new Error("An Ed25519 public key must be exactly 32bytes long");
    }
    return unwrapped;
  }
  toDer() {
    return this.derKey;
  }
  toRaw() {
    return this.rawKey;
  }
}
Ed25519PublicKey.RAW_KEY_LENGTH = 32;

class Ed25519KeyIdentity extends SignIdentity {
  constructor(publicKey, _privateKey) {
    super();
    this._privateKey = _privateKey;
    this._publicKey = Ed25519PublicKey.from(publicKey);
  }
  static generate(seed) {
    if (seed && seed.length !== 32) {
      throw new Error("Ed25519 Seed needs to be 32 bytes long.");
    }
    const { publicKey, secretKey } = seed === undefined ? tweetnacl.sign.keyPair() : tweetnacl.sign.keyPair.fromSeed(seed);
    return new this(Ed25519PublicKey.fromRaw(publicKey), secretKey);
  }
  static fromParsedJson(obj) {
    const [publicKeyDer, privateKeyRaw] = obj;
    return new Ed25519KeyIdentity(Ed25519PublicKey.fromDer(fromHexString2(publicKeyDer)), fromHexString2(privateKeyRaw));
  }
  static fromJSON(json) {
    const parsed = JSON.parse(json);
    if (Array.isArray(parsed)) {
      if (typeof parsed[0] === "string" && typeof parsed[1] === "string") {
        return this.fromParsedJson([parsed[0], parsed[1]]);
      } else {
        throw new Error("Deserialization error: JSON must have at least 2 items.");
      }
    }
    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);
  }
  static fromKeyPair(publicKey, privateKey) {
    return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);
  }
  static fromSecretKey(secretKey) {
    const keyPair = tweetnacl.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
    return Ed25519KeyIdentity.fromKeyPair(keyPair.publicKey, keyPair.secretKey);
  }
  toJSON() {
    return [toHexString2(this._publicKey.toDer()), toHexString2(this._privateKey)];
  }
  getKeyPair() {
    return {
      secretKey: this._privateKey,
      publicKey: this._publicKey
    };
  }
  getPublicKey() {
    return this._publicKey;
  }
  async sign(challenge) {
    const blob = new Uint8Array(challenge);
    const signature = tweetnacl.sign.detached(blob, new Uint8Array(this._privateKey)).buffer;
    return signature;
  }
}
// node_modules/@dfinity/identity/lib/esm/identity/delegation.js
init_esm();
var cbor3 = __toESM(require_src2(), 1);
var domainSeparator2 = new TextEncoder().encode("\x1Aic-request-auth-delegation");
var requestDomainSeparator = new TextEncoder().encode(`
ic-request`);
// node_modules/@dfinity/identity/lib/esm/identity/webauthn.js
var import_borc3 = __toESM(require_src(), 1);
var tweetnacl2 = __toESM(require_nacl_fast(), 1);
var PubKeyCoseAlgo;
(function(PubKeyCoseAlgo2) {
  PubKeyCoseAlgo2[PubKeyCoseAlgo2["ECDSA_WITH_SHA256"] = -7] = "ECDSA_WITH_SHA256";
})(PubKeyCoseAlgo || (PubKeyCoseAlgo = {}));
// utils.ts
import {appendFile} from "fs/promises";
function seedToIdentity(seed) {
  const seedBuf = new Uint8Array(new ArrayBuffer(32));
  if (seed.length && seed.length > 0 && seed.length <= 32) {
    seedBuf.set(new TextEncoder().encode(seed));
    return Ed25519KeyIdentity.generate(seedBuf);
  }
  return null;
}
async function log(requestLog) {
  const LOG_PATH = `logs/${getDate()}.log`;
  try {
    await appendFile(LOG_PATH, `\n ${new Date().toISOString() + " " + requestLog.join(" ")}`);
  } catch (e) {
    console.log("Log file doesn't exist", e);
  }
}
var getDate = function() {
  let objectDate = new Date;
  let day = objectDate.getDate();
  let month = objectDate.getMonth();
  let year = objectDate.getFullYear();
  let format1 = month + "-" + day + "-" + year;
  return format1;
};
function randomId(length = 6) {
  return Math.random().toString(36).substring(2, length + 2);
}

// src/scripts/transfer.ts
var import_rxjs = __toESM(require_cjs(), 1);
var polling2 = __toESM(require_polling(), 1);
var strategy = __toESM(require_strategy(), 1);
async function onTxStatusChanged(localId, entry, logCallback, latestStatusPayload = null, printRequestId = false) {
  global.transactions = [...global.transactions, JSON.stringify(entry, t)];
  let consoleEntry = `TxId: ${entry.txId}; status: ${entry.lastSeenStatus}; payload: ${JSON.stringify(latestStatusPayload, t)}`;
  if (printRequestId) {
    consoleEntry += `; submit request id: ${entry.submitRequestId}`;
  }
  log(["localId:", localId, "aggregator", entry.aggregatorPrincipal, "consoleEntry", consoleEntry]);
  logCallback(consoleEntry);
}
async function handleError(localId, e, logCallback, txId) {
  const errorMessage = e.errorKey !== undefined ? `Error: ${e.toString()}` : "Error: " + e.message;
  console.log("errorMessage", JSON.stringify(errorMessage));
  log(["localId:", localId, "TxId:", txId, "errorMessage", JSON.stringify(errorMessage)]);
  logCallback("errorMessage");
  global.transactions = [...global.transactions, JSON.stringify({ errorMessage }, t)];
}
var runOrPickupSimpleTransfer = async (localId, txArgs, client, logCallback, loggers, aggregatorPrincipal = null, submitRequestId = null, txId = null) => {
  let err = false;
  let aggregator = null;
  try {
    log(["localId:", localId, "aggregator: ", aggregatorPrincipal?.toString() || "all", "Started"]);
    if (!aggregatorPrincipal) {
      onTxStatusChanged(localId, { txArgs, lastSeenStatus: "pickAggregator", aggregatorPrincipal: null }, logCallback);
      aggregator = await client.pickAggregator();
    } else {
      aggregator = aggregatorPrincipal ? await client.createAggregatorDelegate(aggregatorPrincipal) : null;
    }
  } catch (error) {
    log(["pick aggregator error: ", aggregatorPrincipal?.toString() || "all", JSON.stringify(error)]);
  }
  if (!aggregator) {
    throw new Error("No available aggregator");
  }
  log(["localId:", localId, "aggregator: ", aggregatorPrincipal?.toString() || "all", "Submit request"]);
  try {
    if (!txId) {
      if (submitRequestId) {
        logCallback("Retrieving response by request id...");
        const requestId = new Uint8Array(submitRequestId.split(",")).buffer;
        const responseBytes = await polling2.pollForResponse(await aggregator.agent, aggregator.canisterPrincipal, requestId, strategy.maxAttempts(5));
        txId = (await aggregator.parseResponse("submitAndExecute", responseBytes, null))[0];
      } else {
        const { requestId, commit } = await client.prepareSimpleTransfer(aggregator, ...txArgs);
        submitRequestId = new Uint8Array(requestId).join(",");
        onTxStatusChanged(localId, {
          txArgs,
          lastSeenStatus: "submitting",
          aggregatorPrincipal: aggregator.canisterPrincipal.toText(),
          submitRequestId
        }, logCallback, { aggregatorPrincipal: aggregator.canisterPrincipal.toText() }, true);
        txId = await commit();
        onTxStatusChanged(localId, {
          txArgs,
          lastSeenStatus: "submitting",
          txId,
          aggregatorPrincipal: aggregator.canisterPrincipal.toText(),
          submitRequestId
        }, logCallback, { aggregatorPrincipal: aggregator.canisterPrincipal.toText() }, true);
      }
    }
  } catch (error) {
    log(["submit to aggregator error: ", aggregatorPrincipal?.toString() || "all", JSON.stringify(error)]);
  }
  log(["localId:", localId, "TxId:", txId, "aggregator: ", aggregatorPrincipal?.toString() || "all", "Start poll tx"]);
  try {
    await import_rxjs.lastValueFrom(client.pollTx(aggregator, txId).pipe(import_rxjs.map((x2) => {
      onTxStatusChanged(localId, {
        txArgs,
        aggregatorPrincipal: aggregator.canisterPrincipal.toText(),
        txId,
        submitRequestId,
        lastSeenStatus: x2.status
      }, logCallback, x2.statusPayload);
    }), import_rxjs.catchError(async (e) => {
      err = true;
      loggers.errors(aggregatorPrincipal?.toString() || "all");
      log(["localId:", localId, "TxId:", txId, "catch poll error: ", aggregatorPrincipal?.toString() || "all"]);
      await handleError(localId, e, logCallback, txId);
      return import_rxjs.of();
    })));
  } catch (e) {
    err = true;
    loggers.errors(aggregatorPrincipal?.toString() || "all");
    log(["localId:", localId, "TxId:", txId, "try catch error: ", aggregatorPrincipal?.toString() || "all"]);
    await handleError(localId, e, logCallback, txId);
  }
  return { txId, err };
};

// src/index.ts
var import_prom_client = __toESM(require_prom_client(), 1);

// node_modules/elysia/dist/bun/index.js
var aY = Object.create;
var { defineProperty: S8, getPrototypeOf: eY, getOwnPropertyNames: $X } = Object;
var WX = Object.prototype.hasOwnProperty;
var Q1 = ($, W2, Y2) => {
  Y2 = $ != null ? aY(eY($)) : {};
  const X2 = W2 || !$ || !$.__esModule ? S8(Y2, "default", { value: $, enumerable: true }) : Y2;
  for (let Z of $X($))
    if (!WX.call(X2, Z))
      S8(X2, Z, { get: () => $[Z], enumerable: true });
  return X2;
};
var H0 = ($, W2) => () => (W2 || $((W2 = { exports: {} }).exports, W2), W2.exports);
var b8 = H0((j7, r$) => {
  var s1 = function() {
  }, XX = function($, W2, Y2) {
    this.fn = $, this.context = W2, this.once = Y2 || false;
  }, I8 = function($, W2, Y2, X2, Z) {
    if (typeof Y2 !== "function")
      throw new TypeError("The listener must be a function");
    var Q2 = new XX(Y2, X2 || $, Z), J2 = x0 ? x0 + W2 : W2;
    if (!$._events[J2])
      $._events[J2] = Q2, $._eventsCount++;
    else if (!$._events[J2].fn)
      $._events[J2].push(Q2);
    else
      $._events[J2] = [$._events[J2], Q2];
    return $;
  }, K$ = function($, W2) {
    if (--$._eventsCount === 0)
      $._events = new s1;
    else
      delete $._events[W2];
  }, _0 = function() {
    this._events = new s1, this._eventsCount = 0;
  }, YX = Object.prototype.hasOwnProperty, x0 = "~";
  if (Object.create) {
    if (s1.prototype = Object.create(null), !new s1().__proto__)
      x0 = false;
  }
  _0.prototype.eventNames = function $() {
    var W2 = [], Y2, X2;
    if (this._eventsCount === 0)
      return W2;
    for (X2 in Y2 = this._events)
      if (YX.call(Y2, X2))
        W2.push(x0 ? X2.slice(1) : X2);
    if (Object.getOwnPropertySymbols)
      return W2.concat(Object.getOwnPropertySymbols(Y2));
    return W2;
  };
  _0.prototype.listeners = function $(W2) {
    var Y2 = x0 ? x0 + W2 : W2, X2 = this._events[Y2];
    if (!X2)
      return [];
    if (X2.fn)
      return [X2.fn];
    for (var Z = 0, Q2 = X2.length, J2 = new Array(Q2);Z < Q2; Z++)
      J2[Z] = X2[Z].fn;
    return J2;
  };
  _0.prototype.listenerCount = function $(W2) {
    var Y2 = x0 ? x0 + W2 : W2, X2 = this._events[Y2];
    if (!X2)
      return 0;
    if (X2.fn)
      return 1;
    return X2.length;
  };
  _0.prototype.emit = function $(W2, Y2, X2, Z, Q2, J2) {
    var z2 = x0 ? x0 + W2 : W2;
    if (!this._events[z2])
      return false;
    var F2 = this._events[z2], w = arguments.length, B2, S2;
    if (F2.fn) {
      if (F2.once)
        this.removeListener(W2, F2.fn, undefined, true);
      switch (w) {
        case 1:
          return F2.fn.call(F2.context), true;
        case 2:
          return F2.fn.call(F2.context, Y2), true;
        case 3:
          return F2.fn.call(F2.context, Y2, X2), true;
        case 4:
          return F2.fn.call(F2.context, Y2, X2, Z), true;
        case 5:
          return F2.fn.call(F2.context, Y2, X2, Z, Q2), true;
        case 6:
          return F2.fn.call(F2.context, Y2, X2, Z, Q2, J2), true;
      }
      for (S2 = 1, B2 = new Array(w - 1);S2 < w; S2++)
        B2[S2 - 1] = arguments[S2];
      F2.fn.apply(F2.context, B2);
    } else {
      var G2 = F2.length, j;
      for (S2 = 0;S2 < G2; S2++) {
        if (F2[S2].once)
          this.removeListener(W2, F2[S2].fn, undefined, true);
        switch (w) {
          case 1:
            F2[S2].fn.call(F2[S2].context);
            break;
          case 2:
            F2[S2].fn.call(F2[S2].context, Y2);
            break;
          case 3:
            F2[S2].fn.call(F2[S2].context, Y2, X2);
            break;
          case 4:
            F2[S2].fn.call(F2[S2].context, Y2, X2, Z);
            break;
          default:
            if (!B2)
              for (j = 1, B2 = new Array(w - 1);j < w; j++)
                B2[j - 1] = arguments[j];
            F2[S2].fn.apply(F2[S2].context, B2);
        }
      }
    }
    return true;
  };
  _0.prototype.on = function $(W2, Y2, X2) {
    return I8(this, W2, Y2, X2, false);
  };
  _0.prototype.once = function $(W2, Y2, X2) {
    return I8(this, W2, Y2, X2, true);
  };
  _0.prototype.removeListener = function $(W2, Y2, X2, Z) {
    var Q2 = x0 ? x0 + W2 : W2;
    if (!this._events[Q2])
      return this;
    if (!Y2)
      return K$(this, Q2), this;
    var J2 = this._events[Q2];
    if (J2.fn) {
      if (J2.fn === Y2 && (!Z || J2.once) && (!X2 || J2.context === X2))
        K$(this, Q2);
    } else {
      for (var z2 = 0, F2 = [], w = J2.length;z2 < w; z2++)
        if (J2[z2].fn !== Y2 || Z && !J2[z2].once || X2 && J2[z2].context !== X2)
          F2.push(J2[z2]);
      if (F2.length)
        this._events[Q2] = F2.length === 1 ? F2[0] : F2;
      else
        K$(this, Q2);
    }
    return this;
  };
  _0.prototype.removeAllListeners = function $(W2) {
    var Y2;
    if (W2) {
      if (Y2 = x0 ? x0 + W2 : W2, this._events[Y2])
        K$(this, Y2);
    } else
      this._events = new s1, this._eventsCount = 0;
    return this;
  };
  _0.prototype.off = _0.prototype.removeListener;
  _0.prototype.addListener = _0.prototype.on;
  _0.prefixed = x0;
  _0.EventEmitter = _0;
  if (typeof r$ !== "undefined")
    r$.exports = _0;
});
var k0 = H0((d8) => {
  var ZX = function($) {
    return j$($) && (Symbol.asyncIterator in $);
  }, QX = function($) {
    return j$($) && (Symbol.iterator in $);
  }, JX = function($) {
    return ArrayBuffer.isView($);
  }, zX = function($) {
    return $ instanceof Promise;
  }, HX = function($) {
    return $ instanceof Uint8Array;
  }, qX = function($) {
    return $ instanceof Date && Number.isFinite($.getTime());
  }, NX = function($, W2) {
    return W2 in $;
  }, MX = function($) {
    return j$($) && f8($.constructor) && $.constructor.name === "Object";
  }, j$ = function($) {
    return $ !== null && typeof $ === "object";
  }, AX = function($) {
    return Array.isArray($) && !ArrayBuffer.isView($);
  }, E8 = function($) {
    return $ === undefined;
  }, V8 = function($) {
    return $ === null;
  }, x8 = function($) {
    return typeof $ === "boolean";
  }, a$ = function($) {
    return typeof $ === "number";
  }, FX = function($) {
    return a$($) && Number.isInteger($);
  }, k8 = function($) {
    return typeof $ === "bigint";
  }, g8 = function($) {
    return typeof $ === "string";
  }, f8 = function($) {
    return typeof $ === "function";
  }, T8 = function($) {
    return typeof $ === "symbol";
  }, UX = function($) {
    return k8($) || x8($) || V8($) || a$($) || g8($) || T8($) || E8($);
  };
  Object.defineProperty(d8, "__esModule", { value: true });
  d8.IsValueType = d8.IsSymbol = d8.IsFunction = d8.IsString = d8.IsBigInt = d8.IsInteger = d8.IsNumber = d8.IsBoolean = d8.IsNull = d8.IsUndefined = d8.IsArray = d8.IsObject = d8.IsPlainObject = d8.HasPropertyKey = d8.IsDate = d8.IsUint8Array = d8.IsPromise = d8.IsTypedArray = d8.IsIterator = d8.IsAsyncIterator = undefined;
  d8.IsAsyncIterator = ZX;
  d8.IsIterator = QX;
  d8.IsTypedArray = JX;
  d8.IsPromise = zX;
  d8.IsUint8Array = HX;
  d8.IsDate = qX;
  d8.HasPropertyKey = NX;
  d8.IsPlainObject = MX;
  d8.IsObject = j$;
  d8.IsArray = AX;
  d8.IsUndefined = E8;
  d8.IsNull = V8;
  d8.IsBoolean = x8;
  d8.IsNumber = a$;
  d8.IsInteger = FX;
  d8.IsBigInt = k8;
  d8.IsString = g8;
  d8.IsFunction = f8;
  d8.IsSymbol = T8;
  d8.IsValueType = UX;
});
var f0 = H0((m8) => {
  Object.defineProperty(m8, "__esModule", { value: true });
  m8.Type = m8.JsonType = m8.JavaScriptTypeBuilder = m8.JsonTypeBuilder = m8.TypeBuilder = m8.TypeBuilderError = m8.TransformEncodeBuilder = m8.TransformDecodeBuilder = m8.TemplateLiteralDslParser = m8.TemplateLiteralGenerator = m8.TemplateLiteralGeneratorError = m8.TemplateLiteralFinite = m8.TemplateLiteralFiniteError = m8.TemplateLiteralParser = m8.TemplateLiteralParserError = m8.TemplateLiteralResolver = m8.TemplateLiteralPattern = m8.TemplateLiteralPatternError = m8.UnionResolver = m8.KeyArrayResolver = m8.KeyArrayResolverError = m8.KeyResolver = m8.ObjectMap = m8.Intrinsic = m8.IndexedAccessor = m8.TypeClone = m8.TypeExtends = m8.TypeExtendsResult = m8.TypeExtendsError = m8.ExtendsUndefined = m8.TypeGuard = m8.TypeGuardUnknownTypeError = m8.ValueGuard = m8.FormatRegistry = m8.TypeBoxError = m8.TypeRegistry = m8.PatternStringExact = m8.PatternNumberExact = m8.PatternBooleanExact = m8.PatternString = m8.PatternNumber = m8.PatternBoolean = m8.Kind = m8.Hint = m8.Optional = m8.Readonly = m8.Transform = undefined;
  m8.Transform = Symbol.for("TypeBox.Transform");
  m8.Readonly = Symbol.for("TypeBox.Readonly");
  m8.Optional = Symbol.for("TypeBox.Optional");
  m8.Hint = Symbol.for("TypeBox.Hint");
  m8.Kind = Symbol.for("TypeBox.Kind");
  m8.PatternBoolean = "(true|false)";
  m8.PatternNumber = "(0|[1-9][0-9]*)";
  m8.PatternString = "(.*)";
  m8.PatternBooleanExact = `^${m8.PatternBoolean}$`;
  m8.PatternNumberExact = `^${m8.PatternNumber}$`;
  m8.PatternStringExact = `^${m8.PatternString}$`;
  var e$;
  (function($) {
    const W2 = new Map;
    function Y2() {
      return new Map(W2);
    }
    $.Entries = Y2;
    function X2() {
      return W2.clear();
    }
    $.Clear = X2;
    function Z(F2) {
      return W2.delete(F2);
    }
    $.Delete = Z;
    function Q2(F2) {
      return W2.has(F2);
    }
    $.Has = Q2;
    function J2(F2, w) {
      W2.set(F2, w);
    }
    $.Set = J2;
    function z2(F2) {
      return W2.get(F2);
    }
    $.Get = z2;
  })(e$ || (m8.TypeRegistry = e$ = {}));

  class $1 extends Error {
    constructor($) {
      super($);
    }
  }
  m8.TypeBoxError = $1;
  var v8;
  (function($) {
    const W2 = new Map;
    function Y2() {
      return new Map(W2);
    }
    $.Entries = Y2;
    function X2() {
      return W2.clear();
    }
    $.Clear = X2;
    function Z(F2) {
      return W2.delete(F2);
    }
    $.Delete = Z;
    function Q2(F2) {
      return W2.has(F2);
    }
    $.Has = Q2;
    function J2(F2, w) {
      W2.set(F2, w);
    }
    $.Set = J2;
    function z2(F2) {
      return W2.get(F2);
    }
    $.Get = z2;
  })(v8 || (m8.FormatRegistry = v8 = {}));
  var x2;
  (function($) {
    function W2(w) {
      return Array.isArray(w);
    }
    $.IsArray = W2;
    function Y2(w) {
      return typeof w === "bigint";
    }
    $.IsBigInt = Y2;
    function X2(w) {
      return typeof w === "boolean";
    }
    $.IsBoolean = X2;
    function Z(w) {
      return w === null;
    }
    $.IsNull = Z;
    function Q2(w) {
      return typeof w === "number";
    }
    $.IsNumber = Q2;
    function J2(w) {
      return typeof w === "object" && w !== null;
    }
    $.IsObject = J2;
    function z2(w) {
      return typeof w === "string";
    }
    $.IsString = z2;
    function F2(w) {
      return w === undefined;
    }
    $.IsUndefined = F2;
  })(x2 || (m8.ValueGuard = x2 = {}));

  class i8 extends $1 {
  }
  m8.TypeGuardUnknownTypeError = i8;
  var U2;
  (function($) {
    function W2(N2) {
      try {
        return new RegExp(N2), true;
      } catch {
        return false;
      }
    }
    function Y2(N2) {
      if (!x2.IsString(N2))
        return false;
      for (let l = 0;l < N2.length; l++) {
        const I0 = N2.charCodeAt(l);
        if (I0 >= 7 && I0 <= 13 || I0 === 27 || I0 === 127)
          return false;
      }
      return true;
    }
    function X2(N2) {
      return J2(N2) || Q0(N2);
    }
    function Z(N2) {
      return x2.IsUndefined(N2) || x2.IsBigInt(N2);
    }
    function Q2(N2) {
      return x2.IsUndefined(N2) || x2.IsNumber(N2);
    }
    function J2(N2) {
      return x2.IsUndefined(N2) || x2.IsBoolean(N2);
    }
    function z2(N2) {
      return x2.IsUndefined(N2) || x2.IsString(N2);
    }
    function F2(N2) {
      return x2.IsUndefined(N2) || x2.IsString(N2) && Y2(N2) && W2(N2);
    }
    function w(N2) {
      return x2.IsUndefined(N2) || x2.IsString(N2) && Y2(N2);
    }
    function B2(N2) {
      return x2.IsUndefined(N2) || Q0(N2);
    }
    function S2(N2) {
      return _2(N2, "Any") && z2(N2.$id);
    }
    $.TAny = S2;
    function G2(N2) {
      return _2(N2, "Array") && N2.type === "array" && z2(N2.$id) && Q0(N2.items) && Q2(N2.minItems) && Q2(N2.maxItems) && J2(N2.uniqueItems) && B2(N2.contains) && Q2(N2.minContains) && Q2(N2.maxContains);
    }
    $.TArray = G2;
    function j(N2) {
      return _2(N2, "AsyncIterator") && N2.type === "AsyncIterator" && z2(N2.$id) && Q0(N2.items);
    }
    $.TAsyncIterator = j;
    function M2(N2) {
      return _2(N2, "BigInt") && N2.type === "bigint" && z2(N2.$id) && Z(N2.exclusiveMaximum) && Z(N2.exclusiveMinimum) && Z(N2.maximum) && Z(N2.minimum) && Z(N2.multipleOf);
    }
    $.TBigInt = M2;
    function O(N2) {
      return _2(N2, "Boolean") && N2.type === "boolean" && z2(N2.$id);
    }
    $.TBoolean = O;
    function K2(N2) {
      return _2(N2, "Constructor") && N2.type === "Constructor" && z2(N2.$id) && x2.IsArray(N2.parameters) && N2.parameters.every((l) => Q0(l)) && Q0(N2.returns);
    }
    $.TConstructor = K2;
    function A2(N2) {
      return _2(N2, "Date") && N2.type === "Date" && z2(N2.$id) && Q2(N2.exclusiveMaximumTimestamp) && Q2(N2.exclusiveMinimumTimestamp) && Q2(N2.maximumTimestamp) && Q2(N2.minimumTimestamp) && Q2(N2.multipleOfTimestamp);
    }
    $.TDate = A2;
    function D2(N2) {
      return _2(N2, "Function") && N2.type === "Function" && z2(N2.$id) && x2.IsArray(N2.parameters) && N2.parameters.every((l) => Q0(l)) && Q0(N2.returns);
    }
    $.TFunction = D2;
    function I2(N2) {
      return _2(N2, "Integer") && N2.type === "integer" && z2(N2.$id) && Q2(N2.exclusiveMaximum) && Q2(N2.exclusiveMinimum) && Q2(N2.maximum) && Q2(N2.minimum) && Q2(N2.multipleOf);
    }
    $.TInteger = I2;
    function b2(N2) {
      return _2(N2, "Intersect") && (x2.IsString(N2.type) && N2.type !== "object" ? false : true) && x2.IsArray(N2.allOf) && N2.allOf.every((l) => Q0(l) && !K0(l)) && z2(N2.type) && (J2(N2.unevaluatedProperties) || B2(N2.unevaluatedProperties)) && z2(N2.$id);
    }
    $.TIntersect = b2;
    function V2(N2) {
      return _2(N2, "Iterator") && N2.type === "Iterator" && z2(N2.$id) && Q0(N2.items);
    }
    $.TIterator = V2;
    function _2(N2, l) {
      return a(N2) && N2[m8.Kind] === l;
    }
    $.TKindOf = _2;
    function a(N2) {
      return x2.IsObject(N2) && (m8.Kind in N2) && x2.IsString(N2[m8.Kind]);
    }
    $.TKind = a;
    function e(N2) {
      return F0(N2) && x2.IsString(N2.const);
    }
    $.TLiteralString = e;
    function o(N2) {
      return F0(N2) && x2.IsNumber(N2.const);
    }
    $.TLiteralNumber = o;
    function P0(N2) {
      return F0(N2) && x2.IsBoolean(N2.const);
    }
    $.TLiteralBoolean = P0;
    function F0(N2) {
      return _2(N2, "Literal") && z2(N2.$id) && (x2.IsBoolean(N2.const) || x2.IsNumber(N2.const) || x2.IsString(N2.const));
    }
    $.TLiteral = F0;
    function C0(N2) {
      return _2(N2, "Never") && x2.IsObject(N2.not) && Object.getOwnPropertyNames(N2.not).length === 0;
    }
    $.TNever = C0;
    function Y0(N2) {
      return _2(N2, "Not") && Q0(N2.not);
    }
    $.TNot = Y0;
    function X0(N2) {
      return _2(N2, "Null") && N2.type === "null" && z2(N2.$id);
    }
    $.TNull = X0;
    function u0(N2) {
      return _2(N2, "Number") && N2.type === "number" && z2(N2.$id) && Q2(N2.exclusiveMaximum) && Q2(N2.exclusiveMinimum) && Q2(N2.maximum) && Q2(N2.minimum) && Q2(N2.multipleOf);
    }
    $.TNumber = u0;
    function a0(N2) {
      return _2(N2, "Object") && N2.type === "object" && z2(N2.$id) && x2.IsObject(N2.properties) && X2(N2.additionalProperties) && Q2(N2.minProperties) && Q2(N2.maxProperties) && Object.entries(N2.properties).every(([l, I0]) => Y2(l) && Q0(I0));
    }
    $.TObject = a0;
    function v0(N2) {
      return _2(N2, "Promise") && N2.type === "Promise" && z2(N2.$id) && Q0(N2.item);
    }
    $.TPromise = v0;
    function R2(N2) {
      return _2(N2, "Record") && N2.type === "object" && z2(N2.$id) && X2(N2.additionalProperties) && x2.IsObject(N2.patternProperties) && ((l) => {
        const I0 = Object.getOwnPropertyNames(l.patternProperties);
        return I0.length === 1 && W2(I0[0]) && x2.IsObject(l.patternProperties) && Q0(l.patternProperties[I0[0]]);
      })(N2);
    }
    $.TRecord = R2;
    function f(N2) {
      return x2.IsObject(N2) && (m8.Hint in N2) && N2[m8.Hint] === "Recursive";
    }
    $.TRecursive = f;
    function i(N2) {
      return _2(N2, "Ref") && z2(N2.$id) && x2.IsString(N2.$ref);
    }
    $.TRef = i;
    function u(N2) {
      return _2(N2, "String") && N2.type === "string" && z2(N2.$id) && Q2(N2.minLength) && Q2(N2.maxLength) && F2(N2.pattern) && w(N2.format);
    }
    $.TString = u;
    function q0(N2) {
      return _2(N2, "Symbol") && N2.type === "symbol" && z2(N2.$id);
    }
    $.TSymbol = q0;
    function D0(N2) {
      return _2(N2, "TemplateLiteral") && N2.type === "string" && x2.IsString(N2.pattern) && N2.pattern[0] === "^" && N2.pattern[N2.pattern.length - 1] === "$";
    }
    $.TTemplateLiteral = D0;
    function w0(N2) {
      return _2(N2, "This") && z2(N2.$id) && x2.IsString(N2.$ref);
    }
    $.TThis = w0;
    function K0(N2) {
      return x2.IsObject(N2) && (m8.Transform in N2);
    }
    $.TTransform = K0;
    function N0(N2) {
      return _2(N2, "Tuple") && N2.type === "array" && z2(N2.$id) && x2.IsNumber(N2.minItems) && x2.IsNumber(N2.maxItems) && N2.minItems === N2.maxItems && (x2.IsUndefined(N2.items) && x2.IsUndefined(N2.additionalItems) && N2.minItems === 0 || x2.IsArray(N2.items) && N2.items.every((l) => Q0(l)));
    }
    $.TTuple = N0;
    function B1(N2) {
      return _2(N2, "Undefined") && N2.type === "undefined" && z2(N2.$id);
    }
    $.TUndefined = B1;
    function P2(N2) {
      return E2(N2) && N2.anyOf.every((l) => e(l) || o(l));
    }
    $.TUnionLiteral = P2;
    function E2(N2) {
      return _2(N2, "Union") && z2(N2.$id) && x2.IsObject(N2) && x2.IsArray(N2.anyOf) && N2.anyOf.every((l) => Q0(l));
    }
    $.TUnion = E2;
    function L2(N2) {
      return _2(N2, "Uint8Array") && N2.type === "Uint8Array" && z2(N2.$id) && Q2(N2.minByteLength) && Q2(N2.maxByteLength);
    }
    $.TUint8Array = L2;
    function p(N2) {
      return _2(N2, "Unknown") && z2(N2.$id);
    }
    $.TUnknown = p;
    function T2(N2) {
      return _2(N2, "Unsafe");
    }
    $.TUnsafe = T2;
    function d(N2) {
      return _2(N2, "Void") && N2.type === "void" && z2(N2.$id);
    }
    $.TVoid = d;
    function Z0(N2) {
      return x2.IsObject(N2) && N2[m8.Readonly] === "Readonly";
    }
    $.TReadonly = Z0;
    function O0(N2) {
      return x2.IsObject(N2) && N2[m8.Optional] === "Optional";
    }
    $.TOptional = O0;
    function Q0(N2) {
      return x2.IsObject(N2) && (S2(N2) || G2(N2) || O(N2) || M2(N2) || j(N2) || K2(N2) || A2(N2) || D2(N2) || I2(N2) || b2(N2) || V2(N2) || F0(N2) || C0(N2) || Y0(N2) || X0(N2) || u0(N2) || a0(N2) || v0(N2) || R2(N2) || i(N2) || u(N2) || q0(N2) || D0(N2) || w0(N2) || N0(N2) || B1(N2) || E2(N2) || L2(N2) || p(N2) || T2(N2) || d(N2) || a(N2) && e$.Has(N2[m8.Kind]));
    }
    $.TSchema = Q0;
  })(U2 || (m8.TypeGuard = U2 = {}));
  var p8;
  (function($) {
    function W2(Y2) {
      return Y2[m8.Kind] === "Intersect" ? Y2.allOf.every((X2) => W2(X2)) : Y2[m8.Kind] === "Union" ? Y2.anyOf.some((X2) => W2(X2)) : Y2[m8.Kind] === "Undefined" ? true : Y2[m8.Kind] === "Not" ? !W2(Y2.not) : false;
    }
    $.Check = W2;
  })(p8 || (m8.ExtendsUndefined = p8 = {}));

  class X6 extends $1 {
  }
  m8.TypeExtendsError = X6;
  var C2;
  (function($) {
    $[$.Union = 0] = "Union", $[$.True = 1] = "True", $[$.False = 2] = "False";
  })(C2 || (m8.TypeExtendsResult = C2 = {}));
  var P1;
  (function($) {
    function W2(H2) {
      return H2 === C2.False ? H2 : C2.True;
    }
    function Y2(H2) {
      throw new X6(H2);
    }
    function X2(H2) {
      return U2.TNever(H2) || U2.TIntersect(H2) || U2.TUnion(H2) || U2.TUnknown(H2) || U2.TAny(H2);
    }
    function Z(H2, q2) {
      return U2.TNever(q2) ? _2(H2, q2) : U2.TIntersect(q2) ? D2(H2, q2) : U2.TUnion(q2) ? t$(H2, q2) : U2.TUnknown(q2) ? O8(H2, q2) : U2.TAny(q2) ? Q2(H2, q2) : Y2("StructuralRight");
    }
    function Q2(H2, q2) {
      return C2.True;
    }
    function J2(H2, q2) {
      return U2.TIntersect(q2) ? D2(H2, q2) : U2.TUnion(q2) && q2.anyOf.some(($0) => U2.TAny($0) || U2.TUnknown($0)) ? C2.True : U2.TUnion(q2) ? C2.Union : U2.TUnknown(q2) ? C2.True : U2.TAny(q2) ? C2.True : C2.Union;
    }
    function z2(H2, q2) {
      return U2.TUnknown(H2) ? C2.False : U2.TAny(H2) ? C2.Union : U2.TNever(H2) ? C2.True : C2.False;
    }
    function F2(H2, q2) {
      return U2.TObject(q2) && D0(q2) ? C2.True : X2(q2) ? Z(H2, q2) : !U2.TArray(q2) ? C2.False : W2(z0(H2.items, q2.items));
    }
    function w(H2, q2) {
      return X2(q2) ? Z(H2, q2) : !U2.TAsyncIterator(q2) ? C2.False : W2(z0(H2.items, q2.items));
    }
    function B2(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TRecord(q2) ? p(H2, q2) : U2.TBigInt(q2) ? C2.True : C2.False;
    }
    function S2(H2, q2) {
      return U2.TLiteral(H2) && x2.IsBoolean(H2.const) ? C2.True : U2.TBoolean(H2) ? C2.True : C2.False;
    }
    function G2(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TRecord(q2) ? p(H2, q2) : U2.TBoolean(q2) ? C2.True : C2.False;
    }
    function j(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : !U2.TConstructor(q2) ? C2.False : H2.parameters.length > q2.parameters.length ? C2.False : !H2.parameters.every(($0, h0) => W2(z0(q2.parameters[h0], $0)) === C2.True) ? C2.False : W2(z0(H2.returns, q2.returns));
    }
    function M2(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TRecord(q2) ? p(H2, q2) : U2.TDate(q2) ? C2.True : C2.False;
    }
    function O(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : !U2.TFunction(q2) ? C2.False : H2.parameters.length > q2.parameters.length ? C2.False : !H2.parameters.every(($0, h0) => W2(z0(q2.parameters[h0], $0)) === C2.True) ? C2.False : W2(z0(H2.returns, q2.returns));
    }
    function K2(H2, q2) {
      return U2.TLiteral(H2) && x2.IsNumber(H2.const) ? C2.True : U2.TNumber(H2) || U2.TInteger(H2) ? C2.True : C2.False;
    }
    function A2(H2, q2) {
      return U2.TInteger(q2) || U2.TNumber(q2) ? C2.True : X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TRecord(q2) ? p(H2, q2) : C2.False;
    }
    function D2(H2, q2) {
      return q2.allOf.every(($0) => z0(H2, $0) === C2.True) ? C2.True : C2.False;
    }
    function I2(H2, q2) {
      return H2.allOf.some(($0) => z0($0, q2) === C2.True) ? C2.True : C2.False;
    }
    function b2(H2, q2) {
      return X2(q2) ? Z(H2, q2) : !U2.TIterator(q2) ? C2.False : W2(z0(H2.items, q2.items));
    }
    function V2(H2, q2) {
      return U2.TLiteral(q2) && q2.const === H2.const ? C2.True : X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TRecord(q2) ? p(H2, q2) : U2.TString(q2) ? d(H2, q2) : U2.TNumber(q2) ? F0(H2, q2) : U2.TInteger(q2) ? K2(H2, q2) : U2.TBoolean(q2) ? S2(H2, q2) : C2.False;
    }
    function _2(H2, q2) {
      return C2.False;
    }
    function a(H2, q2) {
      return C2.True;
    }
    function e(H2) {
      let [q2, $0] = [H2, 0];
      while (true) {
        if (!U2.TNot(q2))
          break;
        q2 = q2.not, $0 += 1;
      }
      return $0 % 2 === 0 ? q2 : m8.Type.Unknown();
    }
    function o(H2, q2) {
      return U2.TNot(H2) ? z0(e(H2), q2) : U2.TNot(q2) ? z0(H2, e(q2)) : Y2("Invalid fallthrough for Not");
    }
    function P0(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TRecord(q2) ? p(H2, q2) : U2.TNull(q2) ? C2.True : C2.False;
    }
    function F0(H2, q2) {
      return U2.TLiteralNumber(H2) ? C2.True : U2.TNumber(H2) || U2.TInteger(H2) ? C2.True : C2.False;
    }
    function C0(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TRecord(q2) ? p(H2, q2) : U2.TInteger(q2) || U2.TNumber(q2) ? C2.True : C2.False;
    }
    function Y0(H2, q2) {
      return Object.getOwnPropertyNames(H2.properties).length === q2;
    }
    function X0(H2) {
      return D0(H2);
    }
    function u0(H2) {
      return Y0(H2, 0) || Y0(H2, 1) && ("description" in H2.properties) && U2.TUnion(H2.properties.description) && H2.properties.description.anyOf.length === 2 && (U2.TString(H2.properties.description.anyOf[0]) && U2.TUndefined(H2.properties.description.anyOf[1]) || U2.TString(H2.properties.description.anyOf[1]) && U2.TUndefined(H2.properties.description.anyOf[0]));
    }
    function a0(H2) {
      return Y0(H2, 0);
    }
    function v0(H2) {
      return Y0(H2, 0);
    }
    function R2(H2) {
      return Y0(H2, 0);
    }
    function f(H2) {
      return Y0(H2, 0);
    }
    function i(H2) {
      return D0(H2);
    }
    function u(H2) {
      const q2 = m8.Type.Number();
      return Y0(H2, 0) || Y0(H2, 1) && ("length" in H2.properties) && W2(z0(H2.properties.length, q2)) === C2.True;
    }
    function q0(H2) {
      return Y0(H2, 0);
    }
    function D0(H2) {
      const q2 = m8.Type.Number();
      return Y0(H2, 0) || Y0(H2, 1) && ("length" in H2.properties) && W2(z0(H2.properties.length, q2)) === C2.True;
    }
    function w0(H2) {
      const q2 = m8.Type.Function([m8.Type.Any()], m8.Type.Any());
      return Y0(H2, 0) || Y0(H2, 1) && ("then" in H2.properties) && W2(z0(H2.properties.then, q2)) === C2.True;
    }
    function K0(H2, q2) {
      return z0(H2, q2) === C2.False ? C2.False : U2.TOptional(H2) && !U2.TOptional(q2) ? C2.False : C2.True;
    }
    function N0(H2, q2) {
      return U2.TUnknown(H2) ? C2.False : U2.TAny(H2) ? C2.Union : U2.TNever(H2) || U2.TLiteralString(H2) && X0(q2) || U2.TLiteralNumber(H2) && a0(q2) || U2.TLiteralBoolean(H2) && v0(q2) || U2.TSymbol(H2) && u0(q2) || U2.TBigInt(H2) && R2(q2) || U2.TString(H2) && X0(q2) || U2.TSymbol(H2) && u0(q2) || U2.TNumber(H2) && a0(q2) || U2.TInteger(H2) && a0(q2) || U2.TBoolean(H2) && v0(q2) || U2.TUint8Array(H2) && i(q2) || U2.TDate(H2) && f(q2) || U2.TConstructor(H2) && q0(q2) || U2.TFunction(H2) && u(q2) ? C2.True : U2.TRecord(H2) && U2.TString(E2(H2)) ? (() => {
        return q2[m8.Hint] === "Record" ? C2.True : C2.False;
      })() : U2.TRecord(H2) && U2.TNumber(E2(H2)) ? (() => {
        return Y0(q2, 0) ? C2.True : C2.False;
      })() : C2.False;
    }
    function B1(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TRecord(q2) ? p(H2, q2) : !U2.TObject(q2) ? C2.False : (() => {
        for (let $0 of Object.getOwnPropertyNames(q2.properties)) {
          if (!($0 in H2.properties))
            return C2.False;
          if (K0(H2.properties[$0], q2.properties[$0]) === C2.False)
            return C2.False;
        }
        return C2.True;
      })();
    }
    function P2(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) && w0(q2) ? C2.True : !U2.TPromise(q2) ? C2.False : W2(z0(H2.item, q2.item));
    }
    function E2(H2) {
      return m8.PatternNumberExact in H2.patternProperties ? m8.Type.Number() : (m8.PatternStringExact in H2.patternProperties) ? m8.Type.String() : Y2("Unknown record key pattern");
    }
    function L2(H2) {
      return m8.PatternNumberExact in H2.patternProperties ? H2.patternProperties[m8.PatternNumberExact] : (m8.PatternStringExact in H2.patternProperties) ? H2.patternProperties[m8.PatternStringExact] : Y2("Unable to get record value schema");
    }
    function p(H2, q2) {
      const [$0, h0] = [E2(q2), L2(q2)];
      return U2.TLiteralString(H2) && U2.TNumber($0) && W2(z0(H2, h0)) === C2.True ? C2.True : U2.TUint8Array(H2) && U2.TNumber($0) ? z0(H2, h0) : U2.TString(H2) && U2.TNumber($0) ? z0(H2, h0) : U2.TArray(H2) && U2.TNumber($0) ? z0(H2, h0) : U2.TObject(H2) ? (() => {
        for (let rY of Object.getOwnPropertyNames(H2.properties))
          if (K0(h0, H2.properties[rY]) === C2.False)
            return C2.False;
        return C2.True;
      })() : C2.False;
    }
    function T2(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : !U2.TRecord(q2) ? C2.False : z0(L2(H2), L2(q2));
    }
    function d(H2, q2) {
      return U2.TLiteral(H2) && x2.IsString(H2.const) ? C2.True : U2.TString(H2) ? C2.True : C2.False;
    }
    function Z0(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TRecord(q2) ? p(H2, q2) : U2.TString(q2) ? C2.True : C2.False;
    }
    function O0(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TRecord(q2) ? p(H2, q2) : U2.TSymbol(q2) ? C2.True : C2.False;
    }
    function Q0(H2, q2) {
      return U2.TTemplateLiteral(H2) ? z0(J1.Resolve(H2), q2) : U2.TTemplateLiteral(q2) ? z0(H2, J1.Resolve(q2)) : Y2("Invalid fallthrough for TemplateLiteral");
    }
    function N2(H2, q2) {
      return U2.TArray(q2) && H2.items !== undefined && H2.items.every(($0) => z0($0, q2.items) === C2.True);
    }
    function l(H2, q2) {
      return U2.TNever(H2) ? C2.True : U2.TUnknown(H2) ? C2.False : U2.TAny(H2) ? C2.Union : C2.False;
    }
    function I0(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) && D0(q2) ? C2.True : U2.TArray(q2) && N2(H2, q2) ? C2.True : !U2.TTuple(q2) ? C2.False : x2.IsUndefined(H2.items) && !x2.IsUndefined(q2.items) || !x2.IsUndefined(H2.items) && x2.IsUndefined(q2.items) ? C2.False : x2.IsUndefined(H2.items) && !x2.IsUndefined(q2.items) ? C2.True : H2.items.every(($0, h0) => z0($0, q2.items[h0]) === C2.True) ? C2.True : C2.False;
    }
    function c$(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TRecord(q2) ? p(H2, q2) : U2.TUint8Array(q2) ? C2.True : C2.False;
    }
    function l$(H2, q2) {
      return X2(q2) ? Z(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TRecord(q2) ? p(H2, q2) : U2.TVoid(q2) ? lY(H2, q2) : U2.TUndefined(q2) ? C2.True : C2.False;
    }
    function t$(H2, q2) {
      return q2.anyOf.some(($0) => z0(H2, $0) === C2.True) ? C2.True : C2.False;
    }
    function oY(H2, q2) {
      return H2.anyOf.every(($0) => z0($0, q2) === C2.True) ? C2.True : C2.False;
    }
    function O8(H2, q2) {
      return C2.True;
    }
    function cY(H2, q2) {
      return U2.TNever(q2) ? _2(H2, q2) : U2.TIntersect(q2) ? D2(H2, q2) : U2.TUnion(q2) ? t$(H2, q2) : U2.TAny(q2) ? Q2(H2, q2) : U2.TString(q2) ? d(H2, q2) : U2.TNumber(q2) ? F0(H2, q2) : U2.TInteger(q2) ? K2(H2, q2) : U2.TBoolean(q2) ? S2(H2, q2) : U2.TArray(q2) ? z2(H2, q2) : U2.TTuple(q2) ? l(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TUnknown(q2) ? C2.True : C2.False;
    }
    function lY(H2, q2) {
      return U2.TUndefined(H2) ? C2.True : U2.TUndefined(H2) ? C2.True : C2.False;
    }
    function tY(H2, q2) {
      return U2.TIntersect(q2) ? D2(H2, q2) : U2.TUnion(q2) ? t$(H2, q2) : U2.TUnknown(q2) ? O8(H2, q2) : U2.TAny(q2) ? Q2(H2, q2) : U2.TObject(q2) ? N0(H2, q2) : U2.TVoid(q2) ? C2.True : C2.False;
    }
    function z0(H2, q2) {
      return U2.TTemplateLiteral(H2) || U2.TTemplateLiteral(q2) ? Q0(H2, q2) : U2.TNot(H2) || U2.TNot(q2) ? o(H2, q2) : U2.TAny(H2) ? J2(H2, q2) : U2.TArray(H2) ? F2(H2, q2) : U2.TBigInt(H2) ? B2(H2, q2) : U2.TBoolean(H2) ? G2(H2, q2) : U2.TAsyncIterator(H2) ? w(H2, q2) : U2.TConstructor(H2) ? j(H2, q2) : U2.TDate(H2) ? M2(H2, q2) : U2.TFunction(H2) ? O(H2, q2) : U2.TInteger(H2) ? A2(H2, q2) : U2.TIntersect(H2) ? I2(H2, q2) : U2.TIterator(H2) ? b2(H2, q2) : U2.TLiteral(H2) ? V2(H2, q2) : U2.TNever(H2) ? a(H2, q2) : U2.TNull(H2) ? P0(H2, q2) : U2.TNumber(H2) ? C0(H2, q2) : U2.TObject(H2) ? B1(H2, q2) : U2.TRecord(H2) ? T2(H2, q2) : U2.TString(H2) ? Z0(H2, q2) : U2.TSymbol(H2) ? O0(H2, q2) : U2.TTuple(H2) ? I0(H2, q2) : U2.TPromise(H2) ? P2(H2, q2) : U2.TUint8Array(H2) ? c$(H2, q2) : U2.TUndefined(H2) ? l$(H2, q2) : U2.TUnion(H2) ? oY(H2, q2) : U2.TUnknown(H2) ? cY(H2, q2) : U2.TVoid(H2) ? tY(H2, q2) : Y2(`Unknown left type operand '${H2[m8.Kind]}'`);
    }
    function sY(H2, q2) {
      return z0(H2, q2);
    }
    $.Extends = sY;
  })(P1 || (m8.TypeExtends = P1 = {}));
  var m;
  (function($) {
    function W2(J2) {
      const z2 = Object.getOwnPropertyNames(J2).reduce((w, B2) => ({ ...w, [B2]: X2(J2[B2]) }), {}), F2 = Object.getOwnPropertySymbols(J2).reduce((w, B2) => ({ ...w, [B2]: X2(J2[B2]) }), {});
      return { ...z2, ...F2 };
    }
    function Y2(J2) {
      return J2.map((z2) => X2(z2));
    }
    function X2(J2) {
      return x2.IsArray(J2) ? Y2(J2) : x2.IsObject(J2) ? W2(J2) : J2;
    }
    function Z(J2) {
      return J2.map((z2) => Q2(z2));
    }
    $.Rest = Z;
    function Q2(J2, z2 = {}) {
      return { ...X2(J2), ...z2 };
    }
    $.Type = Q2;
  })(m || (m8.TypeClone = m = {}));
  var $6;
  (function($) {
    function W2(j) {
      return j.map((M2) => {
        const { [m8.Optional]: O, ...K2 } = m.Type(M2);
        return K2;
      });
    }
    function Y2(j) {
      return j.every((M2) => U2.TOptional(M2));
    }
    function X2(j) {
      return j.some((M2) => U2.TOptional(M2));
    }
    function Z(j) {
      return Y2(j.allOf) ? m8.Type.Optional(m8.Type.Intersect(W2(j.allOf))) : j;
    }
    function Q2(j) {
      return X2(j.anyOf) ? m8.Type.Optional(m8.Type.Union(W2(j.anyOf))) : j;
    }
    function J2(j) {
      return j[m8.Kind] === "Intersect" ? Z(j) : j[m8.Kind] === "Union" ? Q2(j) : j;
    }
    function z2(j, M2) {
      const O = j.allOf.reduce((K2, A2) => {
        const D2 = S2(A2, M2);
        return D2[m8.Kind] === "Never" ? K2 : [...K2, D2];
      }, []);
      return J2(m8.Type.Intersect(O));
    }
    function F2(j, M2) {
      const O = j.anyOf.map((K2) => S2(K2, M2));
      return J2(m8.Type.Union(O));
    }
    function w(j, M2) {
      const O = j.properties[M2];
      return x2.IsUndefined(O) ? m8.Type.Never() : m8.Type.Union([O]);
    }
    function B2(j, M2) {
      const O = j.items;
      if (x2.IsUndefined(O))
        return m8.Type.Never();
      const K2 = O[M2];
      if (x2.IsUndefined(K2))
        return m8.Type.Never();
      return K2;
    }
    function S2(j, M2) {
      return j[m8.Kind] === "Intersect" ? z2(j, M2) : j[m8.Kind] === "Union" ? F2(j, M2) : j[m8.Kind] === "Object" ? w(j, M2) : j[m8.Kind] === "Tuple" ? B2(j, M2) : m8.Type.Never();
    }
    function G2(j, M2, O = {}) {
      const K2 = M2.map((A2) => S2(j, A2.toString()));
      return J2(m8.Type.Union(K2, O));
    }
    $.Resolve = G2;
  })($6 || (m8.IndexedAccessor = $6 = {}));
  var E1;
  (function($) {
    function W2(B2) {
      const [S2, G2] = [B2.slice(0, 1), B2.slice(1)];
      return `${S2.toLowerCase()}${G2}`;
    }
    function Y2(B2) {
      const [S2, G2] = [B2.slice(0, 1), B2.slice(1)];
      return `${S2.toUpperCase()}${G2}`;
    }
    function X2(B2) {
      return B2.toUpperCase();
    }
    function Z(B2) {
      return B2.toLowerCase();
    }
    function Q2(B2, S2) {
      const G2 = g1.ParseExact(B2.pattern);
      if (!f1.Check(G2))
        return { ...B2, pattern: J2(B2.pattern, S2) };
      const O = [...T1.Generate(G2)].map((D2) => m8.Type.Literal(D2)), K2 = z2(O, S2), A2 = m8.Type.Union(K2);
      return m8.Type.TemplateLiteral([A2]);
    }
    function J2(B2, S2) {
      return typeof B2 === "string" ? S2 === "Uncapitalize" ? W2(B2) : S2 === "Capitalize" ? Y2(B2) : S2 === "Uppercase" ? X2(B2) : S2 === "Lowercase" ? Z(B2) : B2 : B2.toString();
    }
    function z2(B2, S2) {
      if (B2.length === 0)
        return [];
      const [G2, ...j] = B2;
      return [w(G2, S2), ...z2(j, S2)];
    }
    function F2(B2, S2) {
      return U2.TTemplateLiteral(B2) ? Q2(B2, S2) : U2.TUnion(B2) ? m8.Type.Union(z2(B2.anyOf, S2)) : U2.TLiteral(B2) ? m8.Type.Literal(J2(B2.const, S2)) : B2;
    }
    function w(B2, S2) {
      return F2(B2, S2);
    }
    $.Map = w;
  })(E1 || (m8.Intrinsic = E1 = {}));
  var V1;
  (function($) {
    function W2(J2, z2) {
      return m8.Type.Intersect(J2.allOf.map((F2) => Z(F2, z2)), { ...J2 });
    }
    function Y2(J2, z2) {
      return m8.Type.Union(J2.anyOf.map((F2) => Z(F2, z2)), { ...J2 });
    }
    function X2(J2, z2) {
      return z2(J2);
    }
    function Z(J2, z2) {
      return J2[m8.Kind] === "Intersect" ? W2(J2, z2) : J2[m8.Kind] === "Union" ? Y2(J2, z2) : J2[m8.Kind] === "Object" ? X2(J2, z2) : J2;
    }
    function Q2(J2, z2, F2) {
      return { ...Z(m.Type(J2), z2), ...F2 };
    }
    $.Map = Q2;
  })(V1 || (m8.ObjectMap = V1 = {}));
  var P$;
  (function($) {
    function W2(w) {
      return w[0] === "^" && w[w.length - 1] === "$" ? w.slice(1, w.length - 1) : w;
    }
    function Y2(w, B2) {
      return w.allOf.reduce((S2, G2) => [...S2, ...J2(G2, B2)], []);
    }
    function X2(w, B2) {
      const S2 = w.anyOf.map((G2) => J2(G2, B2));
      return [...S2.reduce((G2, j) => j.map((M2) => S2.every((O) => O.includes(M2)) ? G2.add(M2) : G2)[0], new Set)];
    }
    function Z(w, B2) {
      return Object.getOwnPropertyNames(w.properties);
    }
    function Q2(w, B2) {
      return B2.includePatterns ? Object.getOwnPropertyNames(w.patternProperties) : [];
    }
    function J2(w, B2) {
      return U2.TIntersect(w) ? Y2(w, B2) : U2.TUnion(w) ? X2(w, B2) : U2.TObject(w) ? Z(w, B2) : U2.TRecord(w) ? Q2(w, B2) : [];
    }
    function z2(w, B2) {
      return [...new Set(J2(w, B2))];
    }
    $.ResolveKeys = z2;
    function F2(w) {
      return `^(${z2(w, { includePatterns: true }).map((G2) => `(${W2(G2)})`).join("|")})$`;
    }
    $.ResolvePattern = F2;
  })(P$ || (m8.KeyResolver = P$ = {}));

  class Z6 extends $1 {
  }
  m8.KeyArrayResolverError = Z6;
  var r1;
  (function($) {
    function W2(Y2) {
      return Array.isArray(Y2) ? Y2 : U2.TUnionLiteral(Y2) ? Y2.anyOf.map((X2) => X2.const.toString()) : U2.TLiteral(Y2) ? [Y2.const] : U2.TTemplateLiteral(Y2) ? (() => {
        const X2 = g1.ParseExact(Y2.pattern);
        if (!f1.Check(X2))
          throw new Z6("Cannot resolve keys from infinite template expression");
        return [...T1.Generate(X2)];
      })() : [];
    }
    $.Resolve = W2;
  })(r1 || (m8.KeyArrayResolver = r1 = {}));
  var W6;
  (function($) {
    function* W2(X2) {
      for (let Z of X2.anyOf)
        if (Z[m8.Kind] === "Union")
          yield* W2(Z);
        else
          yield Z;
    }
    function Y2(X2) {
      return m8.Type.Union([...W2(X2)], { ...X2 });
    }
    $.Resolve = Y2;
  })(W6 || (m8.UnionResolver = W6 = {}));

  class Q6 extends $1 {
  }
  m8.TemplateLiteralPatternError = Q6;
  var O$;
  (function($) {
    function W2(Q2) {
      throw new Q6(Q2);
    }
    function Y2(Q2) {
      return Q2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function X2(Q2, J2) {
      return U2.TTemplateLiteral(Q2) ? Q2.pattern.slice(1, Q2.pattern.length - 1) : U2.TUnion(Q2) ? `(${Q2.anyOf.map((z2) => X2(z2, J2)).join("|")})` : U2.TNumber(Q2) ? `${J2}${m8.PatternNumber}` : U2.TInteger(Q2) ? `${J2}${m8.PatternNumber}` : U2.TBigInt(Q2) ? `${J2}${m8.PatternNumber}` : U2.TString(Q2) ? `${J2}${m8.PatternString}` : U2.TLiteral(Q2) ? `${J2}${Y2(Q2.const.toString())}` : U2.TBoolean(Q2) ? `${J2}${m8.PatternBoolean}` : W2(`Unexpected Kind '${Q2[m8.Kind]}'`);
    }
    function Z(Q2) {
      return `^${Q2.map((J2) => X2(J2, "")).join("")}\$`;
    }
    $.Create = Z;
  })(O$ || (m8.TemplateLiteralPattern = O$ = {}));
  var J1;
  (function($) {
    function W2(Y2) {
      const X2 = g1.ParseExact(Y2.pattern);
      if (!f1.Check(X2))
        return m8.Type.String();
      const Z = [...T1.Generate(X2)].map((Q2) => m8.Type.Literal(Q2));
      return m8.Type.Union(Z);
    }
    $.Resolve = W2;
  })(J1 || (m8.TemplateLiteralResolver = J1 = {}));

  class S$ extends $1 {
  }
  m8.TemplateLiteralParserError = S$;
  var g1;
  (function($) {
    function W2(j, M2, O) {
      return j[M2] === O && j.charCodeAt(M2 - 1) !== 92;
    }
    function Y2(j, M2) {
      return W2(j, M2, "(");
    }
    function X2(j, M2) {
      return W2(j, M2, ")");
    }
    function Z(j, M2) {
      return W2(j, M2, "|");
    }
    function Q2(j) {
      if (!(Y2(j, 0) && X2(j, j.length - 1)))
        return false;
      let M2 = 0;
      for (let O = 0;O < j.length; O++) {
        if (Y2(j, O))
          M2 += 1;
        if (X2(j, O))
          M2 -= 1;
        if (M2 === 0 && O !== j.length - 1)
          return false;
      }
      return true;
    }
    function J2(j) {
      return j.slice(1, j.length - 1);
    }
    function z2(j) {
      let M2 = 0;
      for (let O = 0;O < j.length; O++) {
        if (Y2(j, O))
          M2 += 1;
        if (X2(j, O))
          M2 -= 1;
        if (Z(j, O) && M2 === 0)
          return true;
      }
      return false;
    }
    function F2(j) {
      for (let M2 = 0;M2 < j.length; M2++)
        if (Y2(j, M2))
          return true;
      return false;
    }
    function w(j) {
      let [M2, O] = [0, 0];
      const K2 = [];
      for (let D2 = 0;D2 < j.length; D2++) {
        if (Y2(j, D2))
          M2 += 1;
        if (X2(j, D2))
          M2 -= 1;
        if (Z(j, D2) && M2 === 0) {
          const I2 = j.slice(O, D2);
          if (I2.length > 0)
            K2.push(S2(I2));
          O = D2 + 1;
        }
      }
      const A2 = j.slice(O);
      if (A2.length > 0)
        K2.push(S2(A2));
      if (K2.length === 0)
        return { type: "const", const: "" };
      if (K2.length === 1)
        return K2[0];
      return { type: "or", expr: K2 };
    }
    function B2(j) {
      function M2(A2, D2) {
        if (!Y2(A2, D2))
          throw new S$("TemplateLiteralParser: Index must point to open parens");
        let I2 = 0;
        for (let b2 = D2;b2 < A2.length; b2++) {
          if (Y2(A2, b2))
            I2 += 1;
          if (X2(A2, b2))
            I2 -= 1;
          if (I2 === 0)
            return [D2, b2];
        }
        throw new S$("TemplateLiteralParser: Unclosed group parens in expression");
      }
      function O(A2, D2) {
        for (let I2 = D2;I2 < A2.length; I2++)
          if (Y2(A2, I2))
            return [D2, I2];
        return [D2, A2.length];
      }
      const K2 = [];
      for (let A2 = 0;A2 < j.length; A2++)
        if (Y2(j, A2)) {
          const [D2, I2] = M2(j, A2), b2 = j.slice(D2, I2 + 1);
          K2.push(S2(b2)), A2 = I2;
        } else {
          const [D2, I2] = O(j, A2), b2 = j.slice(D2, I2);
          if (b2.length > 0)
            K2.push(S2(b2));
          A2 = I2 - 1;
        }
      return K2.length === 0 ? { type: "const", const: "" } : K2.length === 1 ? K2[0] : { type: "and", expr: K2 };
    }
    function S2(j) {
      return Q2(j) ? S2(J2(j)) : z2(j) ? w(j) : F2(j) ? B2(j) : { type: "const", const: j };
    }
    $.Parse = S2;
    function G2(j) {
      return S2(j.slice(1, j.length - 1));
    }
    $.ParseExact = G2;
  })(g1 || (m8.TemplateLiteralParser = g1 = {}));

  class J6 extends $1 {
  }
  m8.TemplateLiteralFiniteError = J6;
  var f1;
  (function($) {
    function W2(J2) {
      throw new J6(J2);
    }
    function Y2(J2) {
      return J2.type === "or" && J2.expr.length === 2 && J2.expr[0].type === "const" && J2.expr[0].const === "0" && J2.expr[1].type === "const" && J2.expr[1].const === "[1-9][0-9]*";
    }
    function X2(J2) {
      return J2.type === "or" && J2.expr.length === 2 && J2.expr[0].type === "const" && J2.expr[0].const === "true" && J2.expr[1].type === "const" && J2.expr[1].const === "false";
    }
    function Z(J2) {
      return J2.type === "const" && J2.const === ".*";
    }
    function Q2(J2) {
      return X2(J2) ? true : Y2(J2) || Z(J2) ? false : J2.type === "and" ? J2.expr.every((z2) => Q2(z2)) : J2.type === "or" ? J2.expr.every((z2) => Q2(z2)) : J2.type === "const" ? true : W2("Unknown expression type");
    }
    $.Check = Q2;
  })(f1 || (m8.TemplateLiteralFinite = f1 = {}));

  class z6 extends $1 {
  }
  m8.TemplateLiteralGeneratorError = z6;
  var T1;
  (function($) {
    function* W2(J2) {
      if (J2.length === 1)
        return yield* J2[0];
      for (let z2 of J2[0])
        for (let F2 of W2(J2.slice(1)))
          yield `${z2}${F2}`;
    }
    function* Y2(J2) {
      return yield* W2(J2.expr.map((z2) => [...Q2(z2)]));
    }
    function* X2(J2) {
      for (let z2 of J2.expr)
        yield* Q2(z2);
    }
    function* Z(J2) {
      return yield J2.const;
    }
    function* Q2(J2) {
      return J2.type === "and" ? yield* Y2(J2) : J2.type === "or" ? yield* X2(J2) : J2.type === "const" ? yield* Z(J2) : (() => {
        throw new z6("Unknown expression");
      })();
    }
    $.Generate = Q2;
  })(T1 || (m8.TemplateLiteralGenerator = T1 = {}));
  var Y6;
  (function($) {
    function* W2(Q2) {
      const J2 = Q2.trim().replace(/"|'/g, "");
      return J2 === "boolean" ? yield m8.Type.Boolean() : J2 === "number" ? yield m8.Type.Number() : J2 === "bigint" ? yield m8.Type.BigInt() : J2 === "string" ? yield m8.Type.String() : yield (() => {
        const z2 = J2.split("|").map((F2) => m8.Type.Literal(F2.trim()));
        return z2.length === 0 ? m8.Type.Never() : z2.length === 1 ? z2[0] : m8.Type.Union(z2);
      })();
    }
    function* Y2(Q2) {
      if (Q2[1] !== "{") {
        const J2 = m8.Type.Literal("$"), z2 = X2(Q2.slice(1));
        return yield* [J2, ...z2];
      }
      for (let J2 = 2;J2 < Q2.length; J2++)
        if (Q2[J2] === "}") {
          const z2 = W2(Q2.slice(2, J2)), F2 = X2(Q2.slice(J2 + 1));
          return yield* [...z2, ...F2];
        }
      yield m8.Type.Literal(Q2);
    }
    function* X2(Q2) {
      for (let J2 = 0;J2 < Q2.length; J2++)
        if (Q2[J2] === "$") {
          const z2 = m8.Type.Literal(Q2.slice(0, J2)), F2 = Y2(Q2.slice(J2));
          return yield* [z2, ...F2];
        }
      yield m8.Type.Literal(Q2);
    }
    function Z(Q2) {
      return [...X2(Q2)];
    }
    $.Parse = Z;
  })(Y6 || (m8.TemplateLiteralDslParser = Y6 = {}));

  class H6 {
    constructor($) {
      this.schema = $;
    }
    Decode($) {
      return new q6(this.schema, $);
    }
  }
  m8.TransformDecodeBuilder = H6;

  class q6 {
    constructor($, W2) {
      this.schema = $, this.decode = W2;
    }
    Encode($) {
      const W2 = m.Type(this.schema);
      return U2.TTransform(W2) ? (() => {
        const Z = { Encode: (Q2) => W2[m8.Transform].Encode($(Q2)), Decode: (Q2) => this.decode(W2[m8.Transform].Decode(Q2)) };
        return { ...W2, [m8.Transform]: Z };
      })() : (() => {
        const Y2 = { Decode: this.decode, Encode: $ };
        return { ...W2, [m8.Transform]: Y2 };
      })();
    }
  }
  m8.TransformEncodeBuilder = q6;
  var gX = 0;

  class N6 extends $1 {
  }
  m8.TypeBuilderError = N6;

  class M6 {
    Create($) {
      return $;
    }
    Throw($) {
      throw new N6($);
    }
    Discard($, W2) {
      return W2.reduce((Y2, X2) => {
        const { [X2]: Z, ...Q2 } = Y2;
        return Q2;
      }, $);
    }
    Strict($) {
      return JSON.parse(JSON.stringify($));
    }
  }
  m8.TypeBuilder = M6;

  class L$ extends M6 {
    ReadonlyOptional($) {
      return this.Readonly(this.Optional($));
    }
    Readonly($) {
      return { ...m.Type($), [m8.Readonly]: "Readonly" };
    }
    Optional($) {
      return { ...m.Type($), [m8.Optional]: "Optional" };
    }
    Any($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Any" });
    }
    Array($, W2 = {}) {
      return this.Create({ ...W2, [m8.Kind]: "Array", type: "array", items: m.Type($) });
    }
    Boolean($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize($, W2 = {}) {
      return { ...E1.Map(m.Type($), "Capitalize"), ...W2 };
    }
    Composite($, W2) {
      const Y2 = m8.Type.Intersect($, {}), Z = P$.ResolveKeys(Y2, { includePatterns: false }).reduce((Q2, J2) => ({ ...Q2, [J2]: m8.Type.Index(Y2, [J2]) }), {});
      return m8.Type.Object(Z, W2);
    }
    Enum($, W2 = {}) {
      const Y2 = Object.getOwnPropertyNames($).filter((Q2) => isNaN(Q2)).map((Q2) => $[Q2]), Z = [...new Set(Y2)].map((Q2) => m8.Type.Literal(Q2));
      return this.Union(Z, { ...W2, [m8.Hint]: "Enum" });
    }
    Extends($, W2, Y2, X2, Z = {}) {
      switch (P1.Extends($, W2)) {
        case C2.Union:
          return this.Union([m.Type(Y2, Z), m.Type(X2, Z)]);
        case C2.True:
          return m.Type(Y2, Z);
        case C2.False:
          return m.Type(X2, Z);
      }
    }
    Exclude($, W2, Y2 = {}) {
      return U2.TTemplateLiteral($) ? this.Exclude(J1.Resolve($), W2, Y2) : U2.TTemplateLiteral(W2) ? this.Exclude($, J1.Resolve(W2), Y2) : U2.TUnion($) ? (() => {
        const X2 = $.anyOf.filter((Z) => P1.Extends(Z, W2) === C2.False);
        return X2.length === 1 ? m.Type(X2[0], Y2) : this.Union(X2, Y2);
      })() : P1.Extends($, W2) !== C2.False ? this.Never(Y2) : m.Type($, Y2);
    }
    Extract($, W2, Y2 = {}) {
      return U2.TTemplateLiteral($) ? this.Extract(J1.Resolve($), W2, Y2) : U2.TTemplateLiteral(W2) ? this.Extract($, J1.Resolve(W2), Y2) : U2.TUnion($) ? (() => {
        const X2 = $.anyOf.filter((Z) => P1.Extends(Z, W2) !== C2.False);
        return X2.length === 1 ? m.Type(X2[0], Y2) : this.Union(X2, Y2);
      })() : P1.Extends($, W2) !== C2.False ? m.Type($, Y2) : this.Never(Y2);
    }
    Index($, W2, Y2 = {}) {
      return U2.TArray($) && U2.TNumber(W2) ? (() => {
        return m.Type($.items, Y2);
      })() : U2.TTuple($) && U2.TNumber(W2) ? (() => {
        const Z = (x2.IsUndefined($.items) ? [] : $.items).map((Q2) => m.Type(Q2));
        return this.Union(Z, Y2);
      })() : (() => {
        const X2 = r1.Resolve(W2), Z = m.Type($);
        return $6.Resolve(Z, X2, Y2);
      })();
    }
    Integer($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Integer", type: "integer" });
    }
    Intersect($, W2 = {}) {
      if ($.length === 0)
        return m8.Type.Never();
      if ($.length === 1)
        return m.Type($[0], W2);
      if ($.some((Q2) => U2.TTransform(Q2)))
        this.Throw("Cannot intersect transform types");
      const Y2 = $.every((Q2) => U2.TObject(Q2)), X2 = m.Rest($), Z = U2.TSchema(W2.unevaluatedProperties) ? { unevaluatedProperties: m.Type(W2.unevaluatedProperties) } : {};
      return W2.unevaluatedProperties === false || U2.TSchema(W2.unevaluatedProperties) || Y2 ? this.Create({ ...W2, ...Z, [m8.Kind]: "Intersect", type: "object", allOf: X2 }) : this.Create({ ...W2, ...Z, [m8.Kind]: "Intersect", allOf: X2 });
    }
    KeyOf($, W2 = {}) {
      return U2.TRecord($) ? (() => {
        const Y2 = Object.getOwnPropertyNames($.patternProperties)[0];
        return Y2 === m8.PatternNumberExact ? this.Number(W2) : Y2 === m8.PatternStringExact ? this.String(W2) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : U2.TTuple($) ? (() => {
        const X2 = (x2.IsUndefined($.items) ? [] : $.items).map((Z, Q2) => m8.Type.Literal(Q2.toString()));
        return this.Union(X2, W2);
      })() : U2.TArray($) ? (() => {
        return this.Number(W2);
      })() : (() => {
        const Y2 = P$.ResolveKeys($, { includePatterns: false });
        if (Y2.length === 0)
          return this.Never(W2);
        const X2 = Y2.map((Z) => this.Literal(Z));
        return this.Union(X2, W2);
      })();
    }
    Literal($, W2 = {}) {
      return this.Create({ ...W2, [m8.Kind]: "Literal", const: $, type: typeof $ });
    }
    Lowercase($, W2 = {}) {
      return { ...E1.Map(m.Type($), "Lowercase"), ...W2 };
    }
    Never($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Never", not: {} });
    }
    Not($, W2) {
      return this.Create({ ...W2, [m8.Kind]: "Not", not: m.Type($) });
    }
    Null($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Null", type: "null" });
    }
    Number($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Number", type: "number" });
    }
    Object($, W2 = {}) {
      const Y2 = Object.getOwnPropertyNames($), X2 = Y2.filter((z2) => U2.TOptional($[z2])), Z = Y2.filter((z2) => !X2.includes(z2)), Q2 = U2.TSchema(W2.additionalProperties) ? { additionalProperties: m.Type(W2.additionalProperties) } : {}, J2 = Y2.reduce((z2, F2) => ({ ...z2, [F2]: m.Type($[F2]) }), {});
      return Z.length > 0 ? this.Create({ ...W2, ...Q2, [m8.Kind]: "Object", type: "object", properties: J2, required: Z }) : this.Create({ ...W2, ...Q2, [m8.Kind]: "Object", type: "object", properties: J2 });
    }
    Omit($, W2, Y2 = {}) {
      const X2 = r1.Resolve(W2);
      return V1.Map(this.Discard(m.Type($), ["$id", m8.Transform]), (Z) => {
        if (x2.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q2) => !X2.includes(Q2)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q2 of Object.getOwnPropertyNames(Z.properties))
          if (X2.includes(Q2))
            delete Z.properties[Q2];
        return this.Create(Z);
      }, Y2);
    }
    Partial($, W2 = {}) {
      return V1.Map(this.Discard(m.Type($), ["$id", m8.Transform]), (Y2) => {
        const X2 = Object.getOwnPropertyNames(Y2.properties).reduce((Z, Q2) => {
          return { ...Z, [Q2]: this.Optional(Y2.properties[Q2]) };
        }, {});
        return this.Object(X2, this.Discard(Y2, ["required"]));
      }, W2);
    }
    Pick($, W2, Y2 = {}) {
      const X2 = r1.Resolve(W2);
      return V1.Map(this.Discard(m.Type($), ["$id", m8.Transform]), (Z) => {
        if (x2.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q2) => X2.includes(Q2)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q2 of Object.getOwnPropertyNames(Z.properties))
          if (!X2.includes(Q2))
            delete Z.properties[Q2];
        return this.Create(Z);
      }, Y2);
    }
    Record($, W2, Y2 = {}) {
      return U2.TTemplateLiteral($) ? (() => {
        const X2 = g1.ParseExact($.pattern);
        return f1.Check(X2) ? this.Object([...T1.Generate(X2)].reduce((Z, Q2) => ({ ...Z, [Q2]: m.Type(W2) }), {}), Y2) : this.Create({ ...Y2, [m8.Kind]: "Record", type: "object", patternProperties: { [$.pattern]: m.Type(W2) } });
      })() : U2.TUnion($) ? (() => {
        const X2 = W6.Resolve($);
        if (U2.TUnionLiteral(X2)) {
          const Z = X2.anyOf.reduce((Q2, J2) => ({ ...Q2, [J2.const]: m.Type(W2) }), {});
          return this.Object(Z, { ...Y2, [m8.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : U2.TLiteral($) ? (() => {
        return x2.IsString($.const) || x2.IsNumber($.const) ? this.Object({ [$.const]: m.Type(W2) }, Y2) : this.Throw("Record key of type literal is not of type string or number");
      })() : U2.TInteger($) || U2.TNumber($) ? (() => {
        return this.Create({ ...Y2, [m8.Kind]: "Record", type: "object", patternProperties: { [m8.PatternNumberExact]: m.Type(W2) } });
      })() : U2.TString($) ? (() => {
        const X2 = x2.IsUndefined($.pattern) ? m8.PatternStringExact : $.pattern;
        return this.Create({ ...Y2, [m8.Kind]: "Record", type: "object", patternProperties: { [X2]: m.Type(W2) } });
      })() : this.Never();
    }
    Recursive($, W2 = {}) {
      if (x2.IsUndefined(W2.$id))
        W2.$id = `T${gX++}`;
      const Y2 = $({ [m8.Kind]: "This", $ref: `${W2.$id}` });
      return Y2.$id = W2.$id, this.Create({ ...W2, [m8.Hint]: "Recursive", ...Y2 });
    }
    Ref($, W2 = {}) {
      if (x2.IsString($))
        return this.Create({ ...W2, [m8.Kind]: "Ref", $ref: $ });
      if (x2.IsUndefined($.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...W2, [m8.Kind]: "Ref", $ref: $.$id });
    }
    Required($, W2 = {}) {
      return V1.Map(this.Discard(m.Type($), ["$id", m8.Transform]), (Y2) => {
        const X2 = Object.getOwnPropertyNames(Y2.properties).reduce((Z, Q2) => {
          return { ...Z, [Q2]: this.Discard(Y2.properties[Q2], [m8.Optional]) };
        }, {});
        return this.Object(X2, Y2);
      }, W2);
    }
    Rest($) {
      return U2.TTuple($) && !x2.IsUndefined($.items) ? m.Rest($.items) : U2.TIntersect($) ? m.Rest($.allOf) : U2.TUnion($) ? m.Rest($.anyOf) : [];
    }
    String($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "String", type: "string" });
    }
    TemplateLiteral($, W2 = {}) {
      const Y2 = x2.IsString($) ? O$.Create(Y6.Parse($)) : O$.Create($);
      return this.Create({ ...W2, [m8.Kind]: "TemplateLiteral", type: "string", pattern: Y2 });
    }
    Transform($) {
      return new H6($);
    }
    Tuple($, W2 = {}) {
      const [Y2, X2, Z] = [false, $.length, $.length], Q2 = m.Rest($), J2 = $.length > 0 ? { ...W2, [m8.Kind]: "Tuple", type: "array", items: Q2, additionalItems: Y2, minItems: X2, maxItems: Z } : { ...W2, [m8.Kind]: "Tuple", type: "array", minItems: X2, maxItems: Z };
      return this.Create(J2);
    }
    Uncapitalize($, W2 = {}) {
      return { ...E1.Map(m.Type($), "Uncapitalize"), ...W2 };
    }
    Union($, W2 = {}) {
      return U2.TTemplateLiteral($) ? J1.Resolve($) : (() => {
        const Y2 = $;
        if (Y2.length === 0)
          return this.Never(W2);
        if (Y2.length === 1)
          return this.Create(m.Type(Y2[0], W2));
        const X2 = m.Rest(Y2);
        return this.Create({ ...W2, [m8.Kind]: "Union", anyOf: X2 });
      })();
    }
    Unknown($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Unknown" });
    }
    Unsafe($ = {}) {
      return this.Create({ ...$, [m8.Kind]: $[m8.Kind] || "Unsafe" });
    }
    Uppercase($, W2 = {}) {
      return { ...E1.Map(m.Type($), "Uppercase"), ...W2 };
    }
  }
  m8.JsonTypeBuilder = L$;

  class A6 extends L$ {
    AsyncIterator($, W2 = {}) {
      return this.Create({ ...W2, [m8.Kind]: "AsyncIterator", type: "AsyncIterator", items: m.Type($) });
    }
    Awaited($, W2 = {}) {
      const Y2 = (X2) => X2.length > 0 ? (() => {
        const [Z, ...Q2] = X2;
        return [this.Awaited(Z), ...Y2(Q2)];
      })() : X2;
      return U2.TIntersect($) ? m8.Type.Intersect(Y2($.allOf)) : U2.TUnion($) ? m8.Type.Union(Y2($.anyOf)) : U2.TPromise($) ? this.Awaited($.item) : m.Type($, W2);
    }
    BigInt($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters($, W2 = {}) {
      return this.Tuple([...$.parameters], { ...W2 });
    }
    Constructor($, W2, Y2) {
      const [X2, Z] = [m.Rest($), m.Type(W2)];
      return this.Create({ ...Y2, [m8.Kind]: "Constructor", type: "Constructor", parameters: X2, returns: Z });
    }
    Date($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Date", type: "Date" });
    }
    Function($, W2, Y2) {
      const [X2, Z] = [m.Rest($), m.Type(W2)];
      return this.Create({ ...Y2, [m8.Kind]: "Function", type: "Function", parameters: X2, returns: Z });
    }
    InstanceType($, W2 = {}) {
      return m.Type($.returns, W2);
    }
    Iterator($, W2 = {}) {
      return this.Create({ ...W2, [m8.Kind]: "Iterator", type: "Iterator", items: m.Type($) });
    }
    Parameters($, W2 = {}) {
      return this.Tuple($.parameters, { ...W2 });
    }
    Promise($, W2 = {}) {
      return this.Create({ ...W2, [m8.Kind]: "Promise", type: "Promise", item: m.Type($) });
    }
    RegExp($, W2 = {}) {
      const Y2 = x2.IsString($) ? $ : $.source;
      return this.Create({ ...W2, [m8.Kind]: "String", type: "string", pattern: Y2 });
    }
    RegEx($, W2 = {}) {
      return this.RegExp($, W2);
    }
    ReturnType($, W2 = {}) {
      return m.Type($.returns, W2);
    }
    Symbol($) {
      return this.Create({ ...$, [m8.Kind]: "Symbol", type: "symbol" });
    }
    Undefined($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Void", type: "void" });
    }
  }
  m8.JavaScriptTypeBuilder = A6;
  m8.JsonType = new L$;
  m8.Type = new A6;
});
var j6 = H0((o8) => {
  var D6 = function($, W2) {
    switch (W2) {
      case y2.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case y2.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${$.maxContains} matching values`;
      case y2.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${$.minContains} matching values`;
      case y2.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${$.maxItems}`;
      case y2.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${$.minItems}`;
      case y2.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case y2.ValueErrorType.Array:
        return "Expected array";
      case y2.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case y2.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${$.exclusiveMaximum}`;
      case y2.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${$.exclusiveMinimum}`;
      case y2.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${$.maximum}`;
      case y2.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${$.minimum}`;
      case y2.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${$.multipleOf}`;
      case y2.ValueErrorType.BigInt:
        return "Expected bigint";
      case y2.ValueErrorType.Boolean:
        return "Expected boolean";
      case y2.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${$.exclusiveMinimumTimestamp}`;
      case y2.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${$.exclusiveMaximumTimestamp}`;
      case y2.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${$.minimumTimestamp}`;
      case y2.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${$.maximumTimestamp}`;
      case y2.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${$.multipleOfTimestamp}`;
      case y2.ValueErrorType.Date:
        return "Expected Date";
      case y2.ValueErrorType.Function:
        return "Expected function";
      case y2.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${$.exclusiveMaximum}`;
      case y2.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${$.exclusiveMinimum}`;
      case y2.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${$.maximum}`;
      case y2.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${$.minimum}`;
      case y2.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${$.multipleOf}`;
      case y2.ValueErrorType.Integer:
        return "Expected integer";
      case y2.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case y2.ValueErrorType.Intersect:
        return "Expected all values to match";
      case y2.ValueErrorType.Iterator:
        return "Expected Iterator";
      case y2.ValueErrorType.Literal:
        return `Expected ${typeof $.const === "string" ? `'${$.const}'` : $.const}`;
      case y2.ValueErrorType.Never:
        return "Never";
      case y2.ValueErrorType.Not:
        return "Value should not match";
      case y2.ValueErrorType.Null:
        return "Expected null";
      case y2.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${$.exclusiveMaximum}`;
      case y2.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${$.exclusiveMinimum}`;
      case y2.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${$.maximum}`;
      case y2.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${$.minimum}`;
      case y2.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${$.multipleOf}`;
      case y2.ValueErrorType.Number:
        return "Expected number";
      case y2.ValueErrorType.Object:
        return "Expected object";
      case y2.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case y2.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${$.maxProperties} properties`;
      case y2.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${$.minProperties} properties`;
      case y2.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case y2.ValueErrorType.Promise:
        return "Expected Promise";
      case y2.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${$.format}'`;
      case y2.ValueErrorType.StringFormat:
        return `Expected string to match '${$.format}' format`;
      case y2.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${$.maxLength}`;
      case y2.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${$.minLength}`;
      case y2.ValueErrorType.StringPattern:
        return `Expected string to match '${$.pattern}'`;
      case y2.ValueErrorType.String:
        return "Expected string";
      case y2.ValueErrorType.Symbol:
        return "Expected symbol";
      case y2.ValueErrorType.TupleLength:
        return `Expected tuple to have ${$.maxItems || 0} elements`;
      case y2.ValueErrorType.Tuple:
        return "Expected tuple";
      case y2.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${$.maxByteLength}`;
      case y2.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${$.minByteLength}`;
      case y2.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case y2.ValueErrorType.Undefined:
        return "Expected undefined";
      case y2.ValueErrorType.Union:
        return "Expected union value";
      case y2.ValueErrorType.Void:
        return "Expected void";
      case y2.ValueErrorType.Kind:
        return `Expected kind '${$[z1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  };
  Object.defineProperty(o8, "__esModule", { value: true });
  o8.DefaultErrorFunction = o8.TypeSystemPolicy = o8.TypeSystemErrorFunction = o8.TypeSystem = o8.TypeSystemDuplicateFormat = o8.TypeSystemDuplicateTypeKind = undefined;
  var C$ = k0(), y2 = $$(), z1 = f0();

  class w6 extends z1.TypeBoxError {
    constructor($) {
      super(`Duplicate type kind '${$}' detected`);
    }
  }
  o8.TypeSystemDuplicateTypeKind = w6;

  class K6 extends z1.TypeBoxError {
    constructor($) {
      super(`Duplicate string format '${$}' detected`);
    }
  }
  o8.TypeSystemDuplicateFormat = K6;
  var u8;
  (function($) {
    function W2(X2, Z) {
      if (z1.TypeRegistry.Has(X2))
        throw new w6(X2);
      return z1.TypeRegistry.Set(X2, Z), (Q2 = {}) => z1.Type.Unsafe({ ...Q2, [z1.Kind]: X2 });
    }
    $.Type = W2;
    function Y2(X2, Z) {
      if (z1.FormatRegistry.Has(X2))
        throw new K6(X2);
      return z1.FormatRegistry.Set(X2, Z), X2;
    }
    $.Format = Y2;
  })(u8 || (o8.TypeSystem = u8 = {}));
  var h8;
  (function($) {
    let W2 = D6;
    function Y2() {
      W2 = D6;
    }
    $.Reset = Y2;
    function X2(Q2) {
      W2 = Q2;
    }
    $.Set = X2;
    function Z() {
      return W2;
    }
    $.Get = Z;
  })(h8 || (o8.TypeSystemErrorFunction = h8 = {}));
  var n8;
  (function($) {
    $.ExactOptionalPropertyTypes = false, $.AllowArrayObject = false, $.AllowNaN = false, $.AllowNullVoid = false;
    function W2(J2, z2) {
      return $.ExactOptionalPropertyTypes ? z2 in J2 : J2[z2] !== undefined;
    }
    $.IsExactOptionalProperty = W2;
    function Y2(J2) {
      const z2 = (0, C$.IsObject)(J2);
      return $.AllowArrayObject ? z2 : z2 && !(0, C$.IsArray)(J2);
    }
    $.IsObjectLike = Y2;
    function X2(J2) {
      return Y2(J2) && !(J2 instanceof Date) && !(J2 instanceof Uint8Array);
    }
    $.IsRecordLike = X2;
    function Z(J2) {
      const z2 = (0, C$.IsNumber)(J2);
      return $.AllowNaN ? z2 : z2 && Number.isFinite(J2);
    }
    $.IsNumberLike = Z;
    function Q2(J2) {
      const z2 = (0, C$.IsUndefined)(J2);
      return $.AllowNullVoid ? z2 || J2 === null : z2;
    }
    $.IsVoidLike = Q2;
  })(n8 || (o8.TypeSystemPolicy = n8 = {}));
  o8.DefaultErrorFunction = D6;
});
var D1 = H0((l8) => {
  var LZ = function($, W2) {
    const Y2 = W2.findIndex((X2) => X2.$id === $.$ref);
    if (Y2 === -1)
      throw new P6($);
    return W2[Y2];
  };
  Object.defineProperty(l8, "__esModule", { value: true });
  l8.Deref = l8.TypeDereferenceError = undefined;
  var SZ = f0();

  class P6 extends SZ.TypeBoxError {
    constructor($) {
      super(`Unable to dereference schema with $id '${$.$id}'`);
      this.schema = $;
    }
  }
  l8.TypeDereferenceError = P6;
  l8.Deref = LZ;
});
var W$ = H0((e8) => {
  function* RZ($) {
    const W2 = $ === 0 ? 1 : Math.ceil(Math.floor(Math.log2($) + 1) / 8);
    for (let Y2 = 0;Y2 < W2; Y2++)
      yield $ >> 8 * (W2 - 1 - Y2) & 255;
  }
  var _Z = function($) {
    E0(T0.Array);
    for (let W2 of $)
      y1(W2);
  }, EZ = function($) {
    E0(T0.Boolean), E0($ ? 1 : 0);
  }, VZ = function($) {
    E0(T0.BigInt), r8.setBigInt64(0, $);
    for (let W2 of a8)
      E0(W2);
  }, xZ = function($) {
    E0(T0.Date), y1($.getTime());
  }, kZ = function($) {
    E0(T0.Null);
  }, gZ = function($) {
    E0(T0.Number), r8.setFloat64(0, $);
    for (let W2 of a8)
      E0(W2);
  }, fZ = function($) {
    E0(T0.Object);
    for (let W2 of globalThis.Object.keys($).sort())
      y1(W2), y1($[W2]);
  }, TZ = function($) {
    E0(T0.String);
    for (let W2 = 0;W2 < $.length; W2++)
      for (let Y2 of RZ($.charCodeAt(W2)))
        E0(Y2);
  }, dZ = function($) {
    E0(T0.Symbol), y1($.description);
  }, yZ = function($) {
    E0(T0.Uint8Array);
    for (let W2 = 0;W2 < $.length; W2++)
      E0($[W2]);
  }, vZ = function($) {
    return E0(T0.Undefined);
  }, y1 = function($) {
    if ((0, n0.IsArray)($))
      return _Z($);
    if ((0, n0.IsBoolean)($))
      return EZ($);
    if ((0, n0.IsBigInt)($))
      return VZ($);
    if ((0, n0.IsDate)($))
      return xZ($);
    if ((0, n0.IsNull)($))
      return kZ($);
    if ((0, n0.IsNumber)($))
      return gZ($);
    if ((0, n0.IsPlainObject)($))
      return fZ($);
    if ((0, n0.IsString)($))
      return TZ($);
    if ((0, n0.IsSymbol)($))
      return dZ($);
    if ((0, n0.IsUint8Array)($))
      return yZ($);
    if ((0, n0.IsUndefined)($))
      return vZ($);
    throw new O6($);
  }, E0 = function($) {
    d1 = d1 ^ GZ[$], d1 = d1 * IZ % bZ;
  }, pZ = function($) {
    return d1 = BigInt("14695981039346656037"), y1($), d1;
  };
  Object.defineProperty(e8, "__esModule", { value: true });
  e8.Hash = e8.ByteMarker = e8.ValueHashError = undefined;
  var n0 = k0();

  class O6 extends Error {
    constructor($) {
      super("Unable to hash value");
      this.value = $;
    }
  }
  e8.ValueHashError = O6;
  var T0;
  (function($) {
    $[$.Undefined = 0] = "Undefined", $[$.Null = 1] = "Null", $[$.Boolean = 2] = "Boolean", $[$.Number = 3] = "Number", $[$.String = 4] = "String", $[$.Object = 5] = "Object", $[$.Array = 6] = "Array", $[$.Date = 7] = "Date", $[$.Uint8Array = 8] = "Uint8Array", $[$.Symbol = 9] = "Symbol", $[$.BigInt = 10] = "BigInt";
  })(T0 || (e8.ByteMarker = T0 = {}));
  var d1 = BigInt("14695981039346656037"), [IZ, bZ] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")], GZ = Array.from({ length: 256 }).map(($, W2) => BigInt(W2)), s8 = new Float64Array(1), r8 = new DataView(s8.buffer), a8 = new Uint8Array(s8.buffer);
  e8.Hash = pZ;
});
var $$ = H0((YW) => {
  var t2 = function($) {
    return $ !== undefined;
  }, g2 = function($, W2, Y2, X2) {
    return { type: $, schema: W2, path: Y2, value: X2, message: v1.TypeSystemErrorFunction.Get()(W2, $) };
  };
  function* hZ($, W2, Y2, X2) {
  }
  function* nZ($, W2, Y2, X2) {
    if (!(0, U0.IsArray)(X2))
      return yield g2(k2.Array, $, Y2, X2);
    if (t2($.minItems) && !(X2.length >= $.minItems))
      yield g2(k2.ArrayMinItems, $, Y2, X2);
    if (t2($.maxItems) && !(X2.length <= $.maxItems))
      yield g2(k2.ArrayMaxItems, $, Y2, X2);
    for (let J2 = 0;J2 < X2.length; J2++)
      yield* b0($.items, W2, `${Y2}/${J2}`, X2[J2]);
    if ($.uniqueItems === true && !function() {
      const J2 = new Set;
      for (let z2 of X2) {
        const F2 = (0, uZ.Hash)(z2);
        if (J2.has(F2))
          return false;
        else
          J2.add(F2);
      }
      return true;
    }())
      yield g2(k2.ArrayUniqueItems, $, Y2, X2);
    if (!(t2($.contains) || t2($.minContains) || t2($.maxContains)))
      return;
    const Z = t2($.contains) ? $.contains : p0.Type.Never(), Q2 = X2.reduce((J2, z2, F2) => b0(Z, W2, `${Y2}${F2}`, z2).next().done === true ? J2 + 1 : J2, 0);
    if (Q2 === 0)
      yield g2(k2.ArrayContains, $, Y2, X2);
    if ((0, U0.IsNumber)($.minContains) && Q2 < $.minContains)
      yield g2(k2.ArrayMinContains, $, Y2, X2);
    if ((0, U0.IsNumber)($.maxContains) && Q2 > $.maxContains)
      yield g2(k2.ArrayMaxContains, $, Y2, X2);
  }
  function* oZ($, W2, Y2, X2) {
    if (!(0, U0.IsAsyncIterator)(X2))
      yield g2(k2.AsyncIterator, $, Y2, X2);
  }
  function* cZ($, W2, Y2, X2) {
    if (!(0, U0.IsBigInt)(X2))
      return yield g2(k2.BigInt, $, Y2, X2);
    if (t2($.exclusiveMaximum) && !(X2 < $.exclusiveMaximum))
      yield g2(k2.BigIntExclusiveMaximum, $, Y2, X2);
    if (t2($.exclusiveMinimum) && !(X2 > $.exclusiveMinimum))
      yield g2(k2.BigIntExclusiveMinimum, $, Y2, X2);
    if (t2($.maximum) && !(X2 <= $.maximum))
      yield g2(k2.BigIntMaximum, $, Y2, X2);
    if (t2($.minimum) && !(X2 >= $.minimum))
      yield g2(k2.BigIntMinimum, $, Y2, X2);
    if (t2($.multipleOf) && X2 % $.multipleOf !== BigInt(0))
      yield g2(k2.BigIntMultipleOf, $, Y2, X2);
  }
  function* lZ($, W2, Y2, X2) {
    if (!(0, U0.IsBoolean)(X2))
      yield g2(k2.Boolean, $, Y2, X2);
  }
  function* tZ($, W2, Y2, X2) {
    yield* b0($.returns, W2, Y2, X2.prototype);
  }
  function* sZ($, W2, Y2, X2) {
    if (!(0, U0.IsDate)(X2))
      return yield g2(k2.Date, $, Y2, X2);
    if (t2($.exclusiveMaximumTimestamp) && !(X2.getTime() < $.exclusiveMaximumTimestamp))
      yield g2(k2.DateExclusiveMaximumTimestamp, $, Y2, X2);
    if (t2($.exclusiveMinimumTimestamp) && !(X2.getTime() > $.exclusiveMinimumTimestamp))
      yield g2(k2.DateExclusiveMinimumTimestamp, $, Y2, X2);
    if (t2($.maximumTimestamp) && !(X2.getTime() <= $.maximumTimestamp))
      yield g2(k2.DateMaximumTimestamp, $, Y2, X2);
    if (t2($.minimumTimestamp) && !(X2.getTime() >= $.minimumTimestamp))
      yield g2(k2.DateMinimumTimestamp, $, Y2, X2);
    if (t2($.multipleOfTimestamp) && X2.getTime() % $.multipleOfTimestamp !== 0)
      yield g2(k2.DateMultipleOfTimestamp, $, Y2, X2);
  }
  function* rZ($, W2, Y2, X2) {
    if (!(0, U0.IsFunction)(X2))
      yield g2(k2.Function, $, Y2, X2);
  }
  function* aZ($, W2, Y2, X2) {
    if (!(0, U0.IsInteger)(X2))
      return yield g2(k2.Integer, $, Y2, X2);
    if (t2($.exclusiveMaximum) && !(X2 < $.exclusiveMaximum))
      yield g2(k2.IntegerExclusiveMaximum, $, Y2, X2);
    if (t2($.exclusiveMinimum) && !(X2 > $.exclusiveMinimum))
      yield g2(k2.IntegerExclusiveMinimum, $, Y2, X2);
    if (t2($.maximum) && !(X2 <= $.maximum))
      yield g2(k2.IntegerMaximum, $, Y2, X2);
    if (t2($.minimum) && !(X2 >= $.minimum))
      yield g2(k2.IntegerMinimum, $, Y2, X2);
    if (t2($.multipleOf) && X2 % $.multipleOf !== 0)
      yield g2(k2.IntegerMultipleOf, $, Y2, X2);
  }
  function* eZ($, W2, Y2, X2) {
    for (let Z of $.allOf) {
      const Q2 = b0(Z, W2, Y2, X2).next();
      if (!Q2.done)
        yield g2(k2.Intersect, $, Y2, X2), yield Q2.value;
    }
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(p0.KeyResolver.ResolvePattern($));
      for (let Q2 of Object.getOwnPropertyNames(X2))
        if (!Z.test(Q2))
          yield g2(k2.IntersectUnevaluatedProperties, $, `${Y2}/${Q2}`, X2);
    }
    if (typeof $.unevaluatedProperties === "object") {
      const Z = new RegExp(p0.KeyResolver.ResolvePattern($));
      for (let Q2 of Object.getOwnPropertyNames(X2))
        if (!Z.test(Q2)) {
          const J2 = b0($.unevaluatedProperties, W2, `${Y2}/${Q2}`, X2[Q2]).next();
          if (!J2.done)
            yield J2.value;
        }
    }
  }
  function* $Q($, W2, Y2, X2) {
    if (!(0, U0.IsIterator)(X2))
      yield g2(k2.Iterator, $, Y2, X2);
  }
  function* WQ($, W2, Y2, X2) {
    if (X2 !== $.const)
      yield g2(k2.Literal, $, Y2, X2);
  }
  function* YQ($, W2, Y2, X2) {
    yield g2(k2.Never, $, Y2, X2);
  }
  function* XQ($, W2, Y2, X2) {
    if (b0($.not, W2, Y2, X2).next().done === true)
      yield g2(k2.Not, $, Y2, X2);
  }
  function* ZQ($, W2, Y2, X2) {
    if (!(0, U0.IsNull)(X2))
      yield g2(k2.Null, $, Y2, X2);
  }
  function* QQ($, W2, Y2, X2) {
    if (!v1.TypeSystemPolicy.IsNumberLike(X2))
      return yield g2(k2.Number, $, Y2, X2);
    if (t2($.exclusiveMaximum) && !(X2 < $.exclusiveMaximum))
      yield g2(k2.NumberExclusiveMaximum, $, Y2, X2);
    if (t2($.exclusiveMinimum) && !(X2 > $.exclusiveMinimum))
      yield g2(k2.NumberExclusiveMinimum, $, Y2, X2);
    if (t2($.maximum) && !(X2 <= $.maximum))
      yield g2(k2.NumberMaximum, $, Y2, X2);
    if (t2($.minimum) && !(X2 >= $.minimum))
      yield g2(k2.NumberMinimum, $, Y2, X2);
    if (t2($.multipleOf) && X2 % $.multipleOf !== 0)
      yield g2(k2.NumberMultipleOf, $, Y2, X2);
  }
  function* JQ($, W2, Y2, X2) {
    if (!v1.TypeSystemPolicy.IsObjectLike(X2))
      return yield g2(k2.Object, $, Y2, X2);
    if (t2($.minProperties) && !(Object.getOwnPropertyNames(X2).length >= $.minProperties))
      yield g2(k2.ObjectMinProperties, $, Y2, X2);
    if (t2($.maxProperties) && !(Object.getOwnPropertyNames(X2).length <= $.maxProperties))
      yield g2(k2.ObjectMaxProperties, $, Y2, X2);
    const Z = Array.isArray($.required) ? $.required : [], Q2 = Object.getOwnPropertyNames($.properties), J2 = Object.getOwnPropertyNames(X2);
    for (let z2 of Z) {
      if (J2.includes(z2))
        continue;
      yield g2(k2.ObjectRequiredProperty, $.properties[z2], `${Y2}/${z2}`, undefined);
    }
    if ($.additionalProperties === false) {
      for (let z2 of J2)
        if (!Q2.includes(z2))
          yield g2(k2.ObjectAdditionalProperties, $, `${Y2}/${z2}`, X2[z2]);
    }
    if (typeof $.additionalProperties === "object")
      for (let z2 of J2) {
        if (Q2.includes(z2))
          continue;
        yield* b0($.additionalProperties, W2, `${Y2}/${z2}`, X2[z2]);
      }
    for (let z2 of Q2) {
      const F2 = $.properties[z2];
      if ($.required && $.required.includes(z2)) {
        if (yield* b0(F2, W2, `${Y2}/${z2}`, X2[z2]), p0.ExtendsUndefined.Check($) && !(z2 in X2))
          yield g2(k2.ObjectRequiredProperty, F2, `${Y2}/${z2}`, undefined);
      } else if (v1.TypeSystemPolicy.IsExactOptionalProperty(X2, z2))
        yield* b0(F2, W2, `${Y2}/${z2}`, X2[z2]);
    }
  }
  function* zQ($, W2, Y2, X2) {
    if (!(0, U0.IsPromise)(X2))
      yield g2(k2.Promise, $, Y2, X2);
  }
  function* HQ($, W2, Y2, X2) {
    if (!v1.TypeSystemPolicy.IsRecordLike(X2))
      return yield g2(k2.Object, $, Y2, X2);
    if (t2($.minProperties) && !(Object.getOwnPropertyNames(X2).length >= $.minProperties))
      yield g2(k2.ObjectMinProperties, $, Y2, X2);
    if (t2($.maxProperties) && !(Object.getOwnPropertyNames(X2).length <= $.maxProperties))
      yield g2(k2.ObjectMaxProperties, $, Y2, X2);
    const [Z, Q2] = Object.entries($.patternProperties)[0], J2 = new RegExp(Z);
    for (let [z2, F2] of Object.entries(X2))
      if (J2.test(z2))
        yield* b0(Q2, W2, `${Y2}/${z2}`, F2);
    if (typeof $.additionalProperties === "object") {
      for (let [z2, F2] of Object.entries(X2))
        if (!J2.test(z2))
          yield* b0($.additionalProperties, W2, `${Y2}/${z2}`, F2);
    }
    if ($.additionalProperties === false)
      for (let [z2, F2] of Object.entries(X2)) {
        if (J2.test(z2))
          continue;
        return yield g2(k2.ObjectAdditionalProperties, $, `${Y2}/${z2}`, F2);
      }
  }
  function* qQ($, W2, Y2, X2) {
    yield* b0((0, WW.Deref)($, W2), W2, Y2, X2);
  }
  function* NQ($, W2, Y2, X2) {
    if (!(0, U0.IsString)(X2))
      return yield g2(k2.String, $, Y2, X2);
    if (t2($.minLength) && !(X2.length >= $.minLength))
      yield g2(k2.StringMinLength, $, Y2, X2);
    if (t2($.maxLength) && !(X2.length <= $.maxLength))
      yield g2(k2.StringMaxLength, $, Y2, X2);
    if ((0, U0.IsString)($.pattern)) {
      if (!new RegExp($.pattern).test(X2))
        yield g2(k2.StringPattern, $, Y2, X2);
    }
    if ((0, U0.IsString)($.format)) {
      if (!p0.FormatRegistry.Has($.format))
        yield g2(k2.StringFormatUnknown, $, Y2, X2);
      else if (!p0.FormatRegistry.Get($.format)(X2))
        yield g2(k2.StringFormat, $, Y2, X2);
    }
  }
  function* MQ($, W2, Y2, X2) {
    if (!(0, U0.IsSymbol)(X2))
      yield g2(k2.Symbol, $, Y2, X2);
  }
  function* AQ($, W2, Y2, X2) {
    if (!(0, U0.IsString)(X2))
      return yield g2(k2.String, $, Y2, X2);
    if (!new RegExp($.pattern).test(X2))
      yield g2(k2.StringPattern, $, Y2, X2);
  }
  function* FQ($, W2, Y2, X2) {
    yield* b0((0, WW.Deref)($, W2), W2, Y2, X2);
  }
  function* UQ($, W2, Y2, X2) {
    if (!(0, U0.IsArray)(X2))
      return yield g2(k2.Tuple, $, Y2, X2);
    if ($.items === undefined && X2.length !== 0)
      return yield g2(k2.TupleLength, $, Y2, X2);
    if (X2.length !== $.maxItems)
      return yield g2(k2.TupleLength, $, Y2, X2);
    if (!$.items)
      return;
    for (let Z = 0;Z < $.items.length; Z++)
      yield* b0($.items[Z], W2, `${Y2}/${Z}`, X2[Z]);
  }
  function* BQ($, W2, Y2, X2) {
    if (!(0, U0.IsUndefined)(X2))
      yield g2(k2.Undefined, $, Y2, X2);
  }
  function* DQ($, W2, Y2, X2) {
    let Z = 0;
    for (let Q2 of $.anyOf) {
      const J2 = [...b0(Q2, W2, Y2, X2)];
      if (J2.length === 0)
        return;
      Z += J2.length;
    }
    if (Z > 0)
      yield g2(k2.Union, $, Y2, X2);
  }
  function* wQ($, W2, Y2, X2) {
    if (!(0, U0.IsUint8Array)(X2))
      return yield g2(k2.Uint8Array, $, Y2, X2);
    if (t2($.maxByteLength) && !(X2.length <= $.maxByteLength))
      yield g2(k2.Uint8ArrayMaxByteLength, $, Y2, X2);
    if (t2($.minByteLength) && !(X2.length >= $.minByteLength))
      yield g2(k2.Uint8ArrayMinByteLength, $, Y2, X2);
  }
  function* KQ($, W2, Y2, X2) {
  }
  function* jQ($, W2, Y2, X2) {
    if (!v1.TypeSystemPolicy.IsVoidLike(X2))
      yield g2(k2.Void, $, Y2, X2);
  }
  function* PQ($, W2, Y2, X2) {
    if (!p0.TypeRegistry.Get($[p0.Kind])($, X2))
      yield g2(k2.Kind, $, Y2, X2);
  }
  function* b0($, W2, Y2, X2) {
    const Z = t2($.$id) ? [...W2, $] : W2, Q2 = $;
    switch (Q2[p0.Kind]) {
      case "Any":
        return yield* hZ(Q2, Z, Y2, X2);
      case "Array":
        return yield* nZ(Q2, Z, Y2, X2);
      case "AsyncIterator":
        return yield* oZ(Q2, Z, Y2, X2);
      case "BigInt":
        return yield* cZ(Q2, Z, Y2, X2);
      case "Boolean":
        return yield* lZ(Q2, Z, Y2, X2);
      case "Constructor":
        return yield* tZ(Q2, Z, Y2, X2);
      case "Date":
        return yield* sZ(Q2, Z, Y2, X2);
      case "Function":
        return yield* rZ(Q2, Z, Y2, X2);
      case "Integer":
        return yield* aZ(Q2, Z, Y2, X2);
      case "Intersect":
        return yield* eZ(Q2, Z, Y2, X2);
      case "Iterator":
        return yield* $Q(Q2, Z, Y2, X2);
      case "Literal":
        return yield* WQ(Q2, Z, Y2, X2);
      case "Never":
        return yield* YQ(Q2, Z, Y2, X2);
      case "Not":
        return yield* XQ(Q2, Z, Y2, X2);
      case "Null":
        return yield* ZQ(Q2, Z, Y2, X2);
      case "Number":
        return yield* QQ(Q2, Z, Y2, X2);
      case "Object":
        return yield* JQ(Q2, Z, Y2, X2);
      case "Promise":
        return yield* zQ(Q2, Z, Y2, X2);
      case "Record":
        return yield* HQ(Q2, Z, Y2, X2);
      case "Ref":
        return yield* qQ(Q2, Z, Y2, X2);
      case "String":
        return yield* NQ(Q2, Z, Y2, X2);
      case "Symbol":
        return yield* MQ(Q2, Z, Y2, X2);
      case "TemplateLiteral":
        return yield* AQ(Q2, Z, Y2, X2);
      case "This":
        return yield* FQ(Q2, Z, Y2, X2);
      case "Tuple":
        return yield* UQ(Q2, Z, Y2, X2);
      case "Undefined":
        return yield* BQ(Q2, Z, Y2, X2);
      case "Union":
        return yield* DQ(Q2, Z, Y2, X2);
      case "Uint8Array":
        return yield* wQ(Q2, Z, Y2, X2);
      case "Unknown":
        return yield* KQ(Q2, Z, Y2, X2);
      case "Void":
        return yield* jQ(Q2, Z, Y2, X2);
      default:
        if (!p0.TypeRegistry.Has(Q2[p0.Kind]))
          throw new S6($);
        return yield* PQ(Q2, Z, Y2, X2);
    }
  }
  var OQ = function(...$) {
    const W2 = $.length === 3 ? b0($[0], $[1], "", $[2]) : b0($[0], [], "", $[1]);
    return new L6(W2);
  };
  Object.defineProperty(YW, "__esModule", { value: true });
  YW.Errors = YW.ValueErrorIterator = YW.ValueErrorsUnknownTypeError = YW.ValueErrorType = undefined;
  var U0 = k0(), v1 = j6(), WW = D1(), uZ = W$(), p0 = f0(), k2;
  (function($) {
    $[$.ArrayContains = 0] = "ArrayContains", $[$.ArrayMaxContains = 1] = "ArrayMaxContains", $[$.ArrayMaxItems = 2] = "ArrayMaxItems", $[$.ArrayMinContains = 3] = "ArrayMinContains", $[$.ArrayMinItems = 4] = "ArrayMinItems", $[$.ArrayUniqueItems = 5] = "ArrayUniqueItems", $[$.Array = 6] = "Array", $[$.AsyncIterator = 7] = "AsyncIterator", $[$.BigIntExclusiveMaximum = 8] = "BigIntExclusiveMaximum", $[$.BigIntExclusiveMinimum = 9] = "BigIntExclusiveMinimum", $[$.BigIntMaximum = 10] = "BigIntMaximum", $[$.BigIntMinimum = 11] = "BigIntMinimum", $[$.BigIntMultipleOf = 12] = "BigIntMultipleOf", $[$.BigInt = 13] = "BigInt", $[$.Boolean = 14] = "Boolean", $[$.DateExclusiveMaximumTimestamp = 15] = "DateExclusiveMaximumTimestamp", $[$.DateExclusiveMinimumTimestamp = 16] = "DateExclusiveMinimumTimestamp", $[$.DateMaximumTimestamp = 17] = "DateMaximumTimestamp", $[$.DateMinimumTimestamp = 18] = "DateMinimumTimestamp", $[$.DateMultipleOfTimestamp = 19] = "DateMultipleOfTimestamp", $[$.Date = 20] = "Date", $[$.Function = 21] = "Function", $[$.IntegerExclusiveMaximum = 22] = "IntegerExclusiveMaximum", $[$.IntegerExclusiveMinimum = 23] = "IntegerExclusiveMinimum", $[$.IntegerMaximum = 24] = "IntegerMaximum", $[$.IntegerMinimum = 25] = "IntegerMinimum", $[$.IntegerMultipleOf = 26] = "IntegerMultipleOf", $[$.Integer = 27] = "Integer", $[$.IntersectUnevaluatedProperties = 28] = "IntersectUnevaluatedProperties", $[$.Intersect = 29] = "Intersect", $[$.Iterator = 30] = "Iterator", $[$.Kind = 31] = "Kind", $[$.Literal = 32] = "Literal", $[$.Never = 33] = "Never", $[$.Not = 34] = "Not", $[$.Null = 35] = "Null", $[$.NumberExclusiveMaximum = 36] = "NumberExclusiveMaximum", $[$.NumberExclusiveMinimum = 37] = "NumberExclusiveMinimum", $[$.NumberMaximum = 38] = "NumberMaximum", $[$.NumberMinimum = 39] = "NumberMinimum", $[$.NumberMultipleOf = 40] = "NumberMultipleOf", $[$.Number = 41] = "Number", $[$.ObjectAdditionalProperties = 42] = "ObjectAdditionalProperties", $[$.ObjectMaxProperties = 43] = "ObjectMaxProperties", $[$.ObjectMinProperties = 44] = "ObjectMinProperties", $[$.ObjectRequiredProperty = 45] = "ObjectRequiredProperty", $[$.Object = 46] = "Object", $[$.Promise = 47] = "Promise", $[$.StringFormatUnknown = 48] = "StringFormatUnknown", $[$.StringFormat = 49] = "StringFormat", $[$.StringMaxLength = 50] = "StringMaxLength", $[$.StringMinLength = 51] = "StringMinLength", $[$.StringPattern = 52] = "StringPattern", $[$.String = 53] = "String", $[$.Symbol = 54] = "Symbol", $[$.TupleLength = 55] = "TupleLength", $[$.Tuple = 56] = "Tuple", $[$.Uint8ArrayMaxByteLength = 57] = "Uint8ArrayMaxByteLength", $[$.Uint8ArrayMinByteLength = 58] = "Uint8ArrayMinByteLength", $[$.Uint8Array = 59] = "Uint8Array", $[$.Undefined = 60] = "Undefined", $[$.Union = 61] = "Union", $[$.Void = 62] = "Void";
  })(k2 || (YW.ValueErrorType = k2 = {}));

  class S6 extends p0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  YW.ValueErrorsUnknownTypeError = S6;

  class L6 {
    constructor($) {
      this.iterator = $;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const $ = this.iterator.next();
      return $.done ? undefined : $.value;
    }
  }
  YW.ValueErrorIterator = L6;
  YW.Errors = OQ;
});
var I$ = H0((S1) => {
  var IQ = S1 && S1.__createBinding || (Object.create ? function($, W2, Y2, X2) {
    if (X2 === undefined)
      X2 = Y2;
    var Z = Object.getOwnPropertyDescriptor(W2, Y2);
    if (!Z || ("get" in Z ? !W2.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return W2[Y2];
      } };
    Object.defineProperty($, X2, Z);
  } : function($, W2, Y2, X2) {
    if (X2 === undefined)
      X2 = Y2;
    $[X2] = W2[Y2];
  }), bQ = S1 && S1.__exportStar || function($, W2) {
    for (var Y2 in $)
      if (Y2 !== "default" && !Object.prototype.hasOwnProperty.call(W2, Y2))
        IQ(W2, $, Y2);
  };
  Object.defineProperty(S1, "__esModule", { value: true });
  bQ($$(), S1);
});
var b$ = H0((QW) => {
  Object.defineProperty(QW, "__esModule", { value: true });
  QW.ValuePointer = QW.ValuePointerRootDeleteError = QW.ValuePointerRootSetError = undefined;

  class C6 extends Error {
    constructor($, W2, Y2) {
      super("Cannot set root value");
      this.value = $, this.path = W2, this.update = Y2;
    }
  }
  QW.ValuePointerRootSetError = C6;

  class I6 extends Error {
    constructor($, W2) {
      super("Cannot delete root value");
      this.value = $, this.path = W2;
    }
  }
  QW.ValuePointerRootDeleteError = I6;
  var ZW;
  (function($) {
    function W2(z2) {
      return z2.indexOf("~") === -1 ? z2 : z2.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* Y2(z2) {
      if (z2 === "")
        return;
      let [F2, w] = [0, 0];
      for (let B2 = 0;B2 < z2.length; B2++)
        if (z2.charAt(B2) === "/")
          if (B2 === 0)
            F2 = B2 + 1;
          else
            w = B2, yield W2(z2.slice(F2, w)), F2 = B2 + 1;
        else
          w = B2;
      yield W2(z2.slice(F2));
    }
    $.Format = Y2;
    function X2(z2, F2, w) {
      if (F2 === "")
        throw new C6(z2, F2, w);
      let [B2, S2, G2] = [null, z2, ""];
      for (let j of Y2(F2)) {
        if (S2[j] === undefined)
          S2[j] = {};
        B2 = S2, S2 = S2[j], G2 = j;
      }
      B2[G2] = w;
    }
    $.Set = X2;
    function Z(z2, F2) {
      if (F2 === "")
        throw new I6(z2, F2);
      let [w, B2, S2] = [null, z2, ""];
      for (let G2 of Y2(F2)) {
        if (B2[G2] === undefined || B2[G2] === null)
          return;
        w = B2, B2 = B2[G2], S2 = G2;
      }
      if (Array.isArray(w)) {
        const G2 = parseInt(S2);
        w.splice(G2, 1);
      } else
        delete w[S2];
    }
    $.Delete = Z;
    function Q2(z2, F2) {
      if (F2 === "")
        return true;
      let [w, B2, S2] = [null, z2, ""];
      for (let G2 of Y2(F2)) {
        if (B2[G2] === undefined)
          return false;
        w = B2, B2 = B2[G2], S2 = G2;
      }
      return Object.getOwnPropertyNames(w).includes(S2);
    }
    $.Has = Q2;
    function J2(z2, F2) {
      if (F2 === "")
        return z2;
      let w = z2;
      for (let B2 of Y2(F2)) {
        if (w[B2] === undefined)
          return;
        w = w[B2];
      }
      return w;
    }
    $.Get = J2;
  })(ZW || (QW.ValuePointer = ZW = {}));
});
var p1 = H0((zW) => {
  var _Q = function($) {
    return [...Object.getOwnPropertyNames($), ...Object.getOwnPropertySymbols($)].reduce((Y2, X2) => ({ ...Y2, [X2]: b6($[X2]) }), {});
  }, EQ = function($) {
    return $.map((W2) => b6(W2));
  }, VQ = function($) {
    return $.slice();
  }, xQ = function($) {
    return new Date($.toISOString());
  }, kQ = function($) {
    return $;
  }, b6 = function($) {
    if ((0, Y$.IsArray)($))
      return EQ($);
    if ((0, Y$.IsDate)($))
      return xQ($);
    if ((0, Y$.IsPlainObject)($))
      return _Q($);
    if ((0, Y$.IsTypedArray)($))
      return VQ($);
    if ((0, Y$.IsValueType)($))
      return kQ($);
    throw new Error("ValueClone: Unable to clone value");
  };
  Object.defineProperty(zW, "__esModule", { value: true });
  zW.Clone = undefined;
  var Y$ = k0();
  zW.Clone = b6;
});
var E6 = H0((MW) => {
  var X$ = function($, W2) {
    return { type: "update", path: $, value: W2 };
  }, qW = function($, W2) {
    return { type: "insert", path: $, value: W2 };
  }, NW = function($) {
    return { type: "delete", path: $ };
  };
  function* gQ($, W2, Y2) {
    if (!(0, V0.IsPlainObject)(Y2))
      return yield X$($, Y2);
    const X2 = [...Object.keys(W2), ...Object.getOwnPropertySymbols(W2)], Z = [...Object.keys(Y2), ...Object.getOwnPropertySymbols(Y2)];
    for (let Q2 of X2) {
      if ((0, V0.IsSymbol)(Q2))
        throw new i1(Q2);
      if ((0, V0.IsUndefined)(Y2[Q2]) && Z.includes(Q2))
        yield X$(`${$}/${String(Q2)}`, undefined);
    }
    for (let Q2 of Z) {
      if ((0, V0.IsUndefined)(W2[Q2]) || (0, V0.IsUndefined)(Y2[Q2]))
        continue;
      if ((0, V0.IsSymbol)(Q2))
        throw new i1(Q2);
      yield* G$(`${$}/${String(Q2)}`, W2[Q2], Y2[Q2]);
    }
    for (let Q2 of Z) {
      if ((0, V0.IsSymbol)(Q2))
        throw new i1(Q2);
      if ((0, V0.IsUndefined)(W2[Q2]))
        yield qW(`${$}/${String(Q2)}`, Y2[Q2]);
    }
    for (let Q2 of X2.reverse()) {
      if ((0, V0.IsSymbol)(Q2))
        throw new i1(Q2);
      if ((0, V0.IsUndefined)(Y2[Q2]) && !Z.includes(Q2))
        yield NW(`${$}/${String(Q2)}`);
    }
  }
  function* fQ($, W2, Y2) {
    if (!(0, V0.IsArray)(Y2))
      return yield X$($, Y2);
    for (let X2 = 0;X2 < Math.min(W2.length, Y2.length); X2++)
      yield* G$(`${$}/${X2}`, W2[X2], Y2[X2]);
    for (let X2 = 0;X2 < Y2.length; X2++) {
      if (X2 < W2.length)
        continue;
      yield qW(`${$}/${X2}`, Y2[X2]);
    }
    for (let X2 = W2.length - 1;X2 >= 0; X2--) {
      if (X2 < Y2.length)
        continue;
      yield NW(`${$}/${X2}`);
    }
  }
  function* TQ($, W2, Y2) {
    if (!(0, V0.IsTypedArray)(Y2) || W2.length !== Y2.length || Object.getPrototypeOf(W2).constructor.name !== Object.getPrototypeOf(Y2).constructor.name)
      return yield X$($, Y2);
    for (let X2 = 0;X2 < Math.min(W2.length, Y2.length); X2++)
      yield* G$(`${$}/${X2}`, W2[X2], Y2[X2]);
  }
  function* dQ($, W2, Y2) {
    if (W2 === Y2)
      return;
    yield X$($, Y2);
  }
  function* G$($, W2, Y2) {
    if ((0, V0.IsPlainObject)(W2))
      return yield* gQ($, W2, Y2);
    if ((0, V0.IsArray)(W2))
      return yield* fQ($, W2, Y2);
    if ((0, V0.IsTypedArray)(W2))
      return yield* TQ($, W2, Y2);
    if ((0, V0.IsValueType)(W2))
      return yield* dQ($, W2, Y2);
    throw new _6(W2);
  }
  var yQ = function($, W2) {
    return [...G$("", $, W2)];
  }, vQ = function($) {
    return $.length > 0 && $[0].path === "" && $[0].type === "update";
  }, pQ = function($) {
    return $.length === 0;
  }, iQ = function($, W2) {
    if (vQ(W2))
      return (0, R6.Clone)(W2[0].value);
    if (pQ(W2))
      return (0, R6.Clone)($);
    const Y2 = (0, R6.Clone)($);
    for (let X2 of W2)
      switch (X2.type) {
        case "insert": {
          G6.ValuePointer.Set(Y2, X2.path, X2.value);
          break;
        }
        case "update": {
          G6.ValuePointer.Set(Y2, X2.path, X2.value);
          break;
        }
        case "delete": {
          G6.ValuePointer.Delete(Y2, X2.path);
          break;
        }
      }
    return Y2;
  };
  Object.defineProperty(MW, "__esModule", { value: true });
  MW.Patch = MW.Diff = MW.ValueDeltaUnableToDiffUnknownValue = MW.ValueDeltaObjectWithSymbolKeyError = MW.Edit = MW.Delete = MW.Update = MW.Insert = undefined;
  var V0 = k0(), i0 = f0(), G6 = b$(), R6 = p1();
  MW.Insert = i0.Type.Object({ type: i0.Type.Literal("insert"), path: i0.Type.String(), value: i0.Type.Unknown() });
  MW.Update = i0.Type.Object({ type: i0.Type.Literal("update"), path: i0.Type.String(), value: i0.Type.Unknown() });
  MW.Delete = i0.Type.Object({ type: i0.Type.Literal("delete"), path: i0.Type.String() });
  MW.Edit = i0.Type.Union([MW.Insert, MW.Update, MW.Delete]);

  class i1 extends Error {
    constructor($) {
      super("Cannot diff objects with symbol keys");
      this.key = $;
    }
  }
  MW.ValueDeltaObjectWithSymbolKeyError = i1;

  class _6 extends Error {
    constructor($) {
      super("Unable to create diff edits for unknown value");
      this.value = $;
    }
  }
  MW.ValueDeltaUnableToDiffUnknownValue = _6;
  MW.Diff = yQ;
  MW.Patch = iQ;
});
var jW = H0((wW) => {
  var oQ = function($, W2, Y2, X2) {
    if (!(0, d0.IsPlainObject)(Y2))
      R$.ValuePointer.Set($, W2, (0, V6.Clone)(X2));
    else {
      const Z = Object.keys(Y2), Q2 = Object.keys(X2);
      for (let J2 of Z)
        if (!Q2.includes(J2))
          delete Y2[J2];
      for (let J2 of Q2)
        if (!Z.includes(J2))
          Y2[J2] = null;
      for (let J2 of Q2)
        g6($, `${W2}/${J2}`, Y2[J2], X2[J2]);
    }
  }, cQ = function($, W2, Y2, X2) {
    if (!(0, d0.IsArray)(Y2))
      R$.ValuePointer.Set($, W2, (0, V6.Clone)(X2));
    else {
      for (let Z = 0;Z < X2.length; Z++)
        g6($, `${W2}/${Z}`, Y2[Z], X2[Z]);
      Y2.splice(X2.length);
    }
  }, lQ = function($, W2, Y2, X2) {
    if ((0, d0.IsTypedArray)(Y2) && Y2.length === X2.length)
      for (let Z = 0;Z < Y2.length; Z++)
        Y2[Z] = X2[Z];
    else
      R$.ValuePointer.Set($, W2, (0, V6.Clone)(X2));
  }, tQ = function($, W2, Y2, X2) {
    if (Y2 === X2)
      return;
    R$.ValuePointer.Set($, W2, X2);
  }, g6 = function($, W2, Y2, X2) {
    if ((0, d0.IsArray)(X2))
      return cQ($, W2, Y2, X2);
    if ((0, d0.IsTypedArray)(X2))
      return lQ($, W2, Y2, X2);
    if ((0, d0.IsPlainObject)(X2))
      return oQ($, W2, Y2, X2);
    if ((0, d0.IsValueType)(X2))
      return tQ($, W2, Y2, X2);
  }, DW = function($) {
    return (0, d0.IsTypedArray)($) || (0, d0.IsValueType)($);
  }, sQ = function($, W2) {
    return (0, d0.IsPlainObject)($) && (0, d0.IsArray)(W2) || (0, d0.IsArray)($) && (0, d0.IsPlainObject)(W2);
  }, rQ = function($, W2) {
    if (DW($) || DW(W2))
      throw new k6;
    if (sQ($, W2))
      throw new x6;
    g6($, "", $, W2);
  };
  Object.defineProperty(wW, "__esModule", { value: true });
  wW.Mutate = wW.ValueMutateInvalidRootMutationError = wW.ValueMutateTypeMismatchError = undefined;
  var d0 = k0(), R$ = b$(), V6 = p1();

  class x6 extends Error {
    constructor() {
      super("Cannot assign due type mismatch of assignable values");
    }
  }
  wW.ValueMutateTypeMismatchError = x6;

  class k6 extends Error {
    constructor() {
      super("Only object and array types can be mutated at the root level");
    }
  }
  wW.ValueMutateInvalidRootMutationError = k6;
  wW.Mutate = rQ;
});
var SW = H0((PW) => {
  var $4 = function($, W2) {
    if (!(0, H1.IsPlainObject)(W2))
      return false;
    const Y2 = [...Object.keys($), ...Object.getOwnPropertySymbols($)], X2 = [...Object.keys(W2), ...Object.getOwnPropertySymbols(W2)];
    if (Y2.length !== X2.length)
      return false;
    return Y2.every((Z) => _$($[Z], W2[Z]));
  }, W4 = function($, W2) {
    return (0, H1.IsDate)(W2) && $.getTime() === W2.getTime();
  }, Y4 = function($, W2) {
    if (!(0, H1.IsArray)(W2) || $.length !== W2.length)
      return false;
    return $.every((Y2, X2) => _$(Y2, W2[X2]));
  }, X4 = function($, W2) {
    if (!(0, H1.IsTypedArray)(W2) || $.length !== W2.length || Object.getPrototypeOf($).constructor.name !== Object.getPrototypeOf(W2).constructor.name)
      return false;
    return $.every((Y2, X2) => _$(Y2, W2[X2]));
  }, Z4 = function($, W2) {
    return $ === W2;
  }, _$ = function($, W2) {
    if ((0, H1.IsPlainObject)($))
      return $4($, W2);
    if ((0, H1.IsDate)($))
      return W4($, W2);
    if ((0, H1.IsTypedArray)($))
      return X4($, W2);
    if ((0, H1.IsArray)($))
      return Y4($, W2);
    if ((0, H1.IsValueType)($))
      return Z4($, W2);
    throw new Error("ValueEquals: Unable to compare value");
  };
  Object.defineProperty(PW, "__esModule", { value: true });
  PW.Equal = undefined;
  var H1 = k0();
  PW.Equal = _$;
});
var E$ = H0((q1) => {
  var Q4 = q1 && q1.__createBinding || (Object.create ? function($, W2, Y2, X2) {
    if (X2 === undefined)
      X2 = Y2;
    var Z = Object.getOwnPropertyDescriptor(W2, Y2);
    if (!Z || ("get" in Z ? !W2.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return W2[Y2];
      } };
    Object.defineProperty($, X2, Z);
  } : function($, W2, Y2, X2) {
    if (X2 === undefined)
      X2 = Y2;
    $[X2] = W2[Y2];
  }), J4 = q1 && q1.__exportStar || function($, W2) {
    for (var Y2 in $)
      if (Y2 !== "default" && !Object.prototype.hasOwnProperty.call(W2, Y2))
        Q4(W2, $, Y2);
  };
  Object.defineProperty(q1, "__esModule", { value: true });
  q1.ValueErrorType = undefined;
  var z4 = $$();
  Object.defineProperty(q1, "ValueErrorType", { enumerable: true, get: function() {
    return z4.ValueErrorType;
  } });
  J4(j6(), q1);
});
var Q$ = H0((CW) => {
  var q4 = function($) {
    return $[G0.Kind] === "Any" || $[G0.Kind] === "Unknown";
  }, s2 = function($) {
    return $ !== undefined;
  }, N4 = function($, W2, Y2) {
    return true;
  }, M4 = function($, W2, Y2) {
    if (!(0, B0.IsArray)(Y2))
      return false;
    if (s2($.minItems) && !(Y2.length >= $.minItems))
      return false;
    if (s2($.maxItems) && !(Y2.length <= $.maxItems))
      return false;
    if (!Y2.every((Q2) => R0($.items, W2, Q2)))
      return false;
    if ($.uniqueItems === true && !function() {
      const Q2 = new Set;
      for (let J2 of Y2) {
        const z2 = (0, H4.Hash)(J2);
        if (Q2.has(z2))
          return false;
        else
          Q2.add(z2);
      }
      return true;
    }())
      return false;
    if (!(s2($.contains) || (0, B0.IsNumber)($.minContains) || (0, B0.IsNumber)($.maxContains)))
      return true;
    const X2 = s2($.contains) ? $.contains : G0.Type.Never(), Z = Y2.reduce((Q2, J2) => R0(X2, W2, J2) ? Q2 + 1 : Q2, 0);
    if (Z === 0)
      return false;
    if ((0, B0.IsNumber)($.minContains) && Z < $.minContains)
      return false;
    if ((0, B0.IsNumber)($.maxContains) && Z > $.maxContains)
      return false;
    return true;
  }, A4 = function($, W2, Y2) {
    return (0, B0.IsAsyncIterator)(Y2);
  }, F4 = function($, W2, Y2) {
    if (!(0, B0.IsBigInt)(Y2))
      return false;
    if (s2($.exclusiveMaximum) && !(Y2 < $.exclusiveMaximum))
      return false;
    if (s2($.exclusiveMinimum) && !(Y2 > $.exclusiveMinimum))
      return false;
    if (s2($.maximum) && !(Y2 <= $.maximum))
      return false;
    if (s2($.minimum) && !(Y2 >= $.minimum))
      return false;
    if (s2($.multipleOf) && Y2 % $.multipleOf !== BigInt(0))
      return false;
    return true;
  }, U4 = function($, W2, Y2) {
    return (0, B0.IsBoolean)(Y2);
  }, B4 = function($, W2, Y2) {
    return R0($.returns, W2, Y2.prototype);
  }, D4 = function($, W2, Y2) {
    if (!(0, B0.IsDate)(Y2))
      return false;
    if (s2($.exclusiveMaximumTimestamp) && !(Y2.getTime() < $.exclusiveMaximumTimestamp))
      return false;
    if (s2($.exclusiveMinimumTimestamp) && !(Y2.getTime() > $.exclusiveMinimumTimestamp))
      return false;
    if (s2($.maximumTimestamp) && !(Y2.getTime() <= $.maximumTimestamp))
      return false;
    if (s2($.minimumTimestamp) && !(Y2.getTime() >= $.minimumTimestamp))
      return false;
    if (s2($.multipleOfTimestamp) && Y2.getTime() % $.multipleOfTimestamp !== 0)
      return false;
    return true;
  }, w4 = function($, W2, Y2) {
    return (0, B0.IsFunction)(Y2);
  }, K4 = function($, W2, Y2) {
    if (!(0, B0.IsInteger)(Y2))
      return false;
    if (s2($.exclusiveMaximum) && !(Y2 < $.exclusiveMaximum))
      return false;
    if (s2($.exclusiveMinimum) && !(Y2 > $.exclusiveMinimum))
      return false;
    if (s2($.maximum) && !(Y2 <= $.maximum))
      return false;
    if (s2($.minimum) && !(Y2 >= $.minimum))
      return false;
    if (s2($.multipleOf) && Y2 % $.multipleOf !== 0)
      return false;
    return true;
  }, j4 = function($, W2, Y2) {
    const X2 = $.allOf.every((Z) => R0(Z, W2, Y2));
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(G0.KeyResolver.ResolvePattern($)), Q2 = Object.getOwnPropertyNames(Y2).every((J2) => Z.test(J2));
      return X2 && Q2;
    } else if (G0.TypeGuard.TSchema($.unevaluatedProperties)) {
      const Z = new RegExp(G0.KeyResolver.ResolvePattern($)), Q2 = Object.getOwnPropertyNames(Y2).every((J2) => Z.test(J2) || R0($.unevaluatedProperties, W2, Y2[J2]));
      return X2 && Q2;
    } else
      return X2;
  }, P4 = function($, W2, Y2) {
    return (0, B0.IsIterator)(Y2);
  }, O4 = function($, W2, Y2) {
    return Y2 === $.const;
  }, S4 = function($, W2, Y2) {
    return false;
  }, L4 = function($, W2, Y2) {
    return !R0($.not, W2, Y2);
  }, C4 = function($, W2, Y2) {
    return (0, B0.IsNull)(Y2);
  }, I4 = function($, W2, Y2) {
    if (!Z$.TypeSystemPolicy.IsNumberLike(Y2))
      return false;
    if (s2($.exclusiveMaximum) && !(Y2 < $.exclusiveMaximum))
      return false;
    if (s2($.exclusiveMinimum) && !(Y2 > $.exclusiveMinimum))
      return false;
    if (s2($.minimum) && !(Y2 >= $.minimum))
      return false;
    if (s2($.maximum) && !(Y2 <= $.maximum))
      return false;
    if (s2($.multipleOf) && Y2 % $.multipleOf !== 0)
      return false;
    return true;
  }, b4 = function($, W2, Y2) {
    if (!Z$.TypeSystemPolicy.IsObjectLike(Y2))
      return false;
    if (s2($.minProperties) && !(Object.getOwnPropertyNames(Y2).length >= $.minProperties))
      return false;
    if (s2($.maxProperties) && !(Object.getOwnPropertyNames(Y2).length <= $.maxProperties))
      return false;
    const X2 = Object.getOwnPropertyNames($.properties);
    for (let Z of X2) {
      const Q2 = $.properties[Z];
      if ($.required && $.required.includes(Z)) {
        if (!R0(Q2, W2, Y2[Z]))
          return false;
        if ((G0.ExtendsUndefined.Check(Q2) || q4(Q2)) && !(Z in Y2))
          return false;
      } else if (Z$.TypeSystemPolicy.IsExactOptionalProperty(Y2, Z) && !R0(Q2, W2, Y2[Z]))
        return false;
    }
    if ($.additionalProperties === false) {
      const Z = Object.getOwnPropertyNames(Y2);
      if ($.required && $.required.length === X2.length && Z.length === X2.length)
        return true;
      else
        return Z.every((Q2) => X2.includes(Q2));
    } else if (typeof $.additionalProperties === "object")
      return Object.getOwnPropertyNames(Y2).every((Q2) => X2.includes(Q2) || R0($.additionalProperties, W2, Y2[Q2]));
    else
      return true;
  }, G4 = function($, W2, Y2) {
    return (0, B0.IsPromise)(Y2);
  }, R4 = function($, W2, Y2) {
    if (!Z$.TypeSystemPolicy.IsRecordLike(Y2))
      return false;
    if (s2($.minProperties) && !(Object.getOwnPropertyNames(Y2).length >= $.minProperties))
      return false;
    if (s2($.maxProperties) && !(Object.getOwnPropertyNames(Y2).length <= $.maxProperties))
      return false;
    const [X2, Z] = Object.entries($.patternProperties)[0], Q2 = new RegExp(X2), J2 = Object.entries(Y2).every(([w, B2]) => {
      return Q2.test(w) ? R0(Z, W2, B2) : true;
    }), z2 = typeof $.additionalProperties === "object" ? Object.entries(Y2).every(([w, B2]) => {
      return !Q2.test(w) ? R0($.additionalProperties, W2, B2) : true;
    }) : true, F2 = $.additionalProperties === false ? Object.getOwnPropertyNames(Y2).every((w) => {
      return Q2.test(w);
    }) : true;
    return J2 && z2 && F2;
  }, _4 = function($, W2, Y2) {
    return R0((0, LW.Deref)($, W2), W2, Y2);
  }, E4 = function($, W2, Y2) {
    if (!(0, B0.IsString)(Y2))
      return false;
    if (s2($.minLength)) {
      if (!(Y2.length >= $.minLength))
        return false;
    }
    if (s2($.maxLength)) {
      if (!(Y2.length <= $.maxLength))
        return false;
    }
    if (s2($.pattern)) {
      if (!new RegExp($.pattern).test(Y2))
        return false;
    }
    if (s2($.format)) {
      if (!G0.FormatRegistry.Has($.format))
        return false;
      return G0.FormatRegistry.Get($.format)(Y2);
    }
    return true;
  }, V4 = function($, W2, Y2) {
    return (0, B0.IsSymbol)(Y2);
  }, x4 = function($, W2, Y2) {
    return (0, B0.IsString)(Y2) && new RegExp($.pattern).test(Y2);
  }, k4 = function($, W2, Y2) {
    return R0((0, LW.Deref)($, W2), W2, Y2);
  }, g4 = function($, W2, Y2) {
    if (!(0, B0.IsArray)(Y2))
      return false;
    if ($.items === undefined && Y2.length !== 0)
      return false;
    if (Y2.length !== $.maxItems)
      return false;
    if (!$.items)
      return true;
    for (let X2 = 0;X2 < $.items.length; X2++)
      if (!R0($.items[X2], W2, Y2[X2]))
        return false;
    return true;
  }, f4 = function($, W2, Y2) {
    return (0, B0.IsUndefined)(Y2);
  }, T4 = function($, W2, Y2) {
    return $.anyOf.some((X2) => R0(X2, W2, Y2));
  }, d4 = function($, W2, Y2) {
    if (!(0, B0.IsUint8Array)(Y2))
      return false;
    if (s2($.maxByteLength) && !(Y2.length <= $.maxByteLength))
      return false;
    if (s2($.minByteLength) && !(Y2.length >= $.minByteLength))
      return false;
    return true;
  }, y4 = function($, W2, Y2) {
    return true;
  }, v4 = function($, W2, Y2) {
    return Z$.TypeSystemPolicy.IsVoidLike(Y2);
  }, p4 = function($, W2, Y2) {
    if (!G0.TypeRegistry.Has($[G0.Kind]))
      return false;
    return G0.TypeRegistry.Get($[G0.Kind])($, Y2);
  }, R0 = function($, W2, Y2) {
    const X2 = s2($.$id) ? [...W2, $] : W2, Z = $;
    switch (Z[G0.Kind]) {
      case "Any":
        return N4(Z, X2, Y2);
      case "Array":
        return M4(Z, X2, Y2);
      case "AsyncIterator":
        return A4(Z, X2, Y2);
      case "BigInt":
        return F4(Z, X2, Y2);
      case "Boolean":
        return U4(Z, X2, Y2);
      case "Constructor":
        return B4(Z, X2, Y2);
      case "Date":
        return D4(Z, X2, Y2);
      case "Function":
        return w4(Z, X2, Y2);
      case "Integer":
        return K4(Z, X2, Y2);
      case "Intersect":
        return j4(Z, X2, Y2);
      case "Iterator":
        return P4(Z, X2, Y2);
      case "Literal":
        return O4(Z, X2, Y2);
      case "Never":
        return S4(Z, X2, Y2);
      case "Not":
        return L4(Z, X2, Y2);
      case "Null":
        return C4(Z, X2, Y2);
      case "Number":
        return I4(Z, X2, Y2);
      case "Object":
        return b4(Z, X2, Y2);
      case "Promise":
        return G4(Z, X2, Y2);
      case "Record":
        return R4(Z, X2, Y2);
      case "Ref":
        return _4(Z, X2, Y2);
      case "String":
        return E4(Z, X2, Y2);
      case "Symbol":
        return V4(Z, X2, Y2);
      case "TemplateLiteral":
        return x4(Z, X2, Y2);
      case "This":
        return k4(Z, X2, Y2);
      case "Tuple":
        return g4(Z, X2, Y2);
      case "Undefined":
        return f4(Z, X2, Y2);
      case "Union":
        return T4(Z, X2, Y2);
      case "Uint8Array":
        return d4(Z, X2, Y2);
      case "Unknown":
        return y4(Z, X2, Y2);
      case "Void":
        return v4(Z, X2, Y2);
      default:
        if (!G0.TypeRegistry.Has(Z[G0.Kind]))
          throw new f6(Z);
        return p4(Z, X2, Y2);
    }
  }, i4 = function(...$) {
    return $.length === 3 ? R0($[0], $[1], $[2]) : R0($[0], [], $[1]);
  };
  Object.defineProperty(CW, "__esModule", { value: true });
  CW.Check = CW.ValueCheckUnknownTypeError = undefined;
  var B0 = k0(), Z$ = E$(), LW = D1(), H4 = W$(), G0 = f0();

  class f6 extends G0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  CW.ValueCheckUnknownTypeError = f6;
  CW.Check = i4;
});
var m6 = H0((_W) => {
  var h4 = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, n4 = function($, W2) {
    if ($.uniqueItems === true && !(0, r.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    else if (("contains" in $) && !(0, r.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    else if ("default" in $)
      return $.default;
    else if ($.minItems !== undefined)
      return Array.from({ length: $.minItems }).map((Y2) => {
        return y0($.items, W2);
      });
    else
      return [];
  }, o4 = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return async function* () {
      }();
  }, c4 = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return BigInt(0);
  }, l4 = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return false;
  }, t4 = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const Y2 = y0($.returns, W2);
      if (typeof Y2 === "object" && !Array.isArray(Y2))
        return class {
          constructor() {
            for (let [X2, Z] of Object.entries(Y2)) {
              const Q2 = this;
              Q2[X2] = Z;
            }
          }
        };
      else
        return class {
        };
    }
  }, s4 = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimumTimestamp !== undefined)
      return new Date($.minimumTimestamp);
    else
      return new Date(0);
  }, r4 = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return () => y0($.returns, W2);
  }, a4 = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, e4 = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const Y2 = $.allOf.reduce((X2, Z) => {
        const Q2 = y0(Z, W2);
        return typeof Q2 === "object" ? { ...X2, ...Q2 } : Q2;
      }, {});
      if (!(0, u4.Check)($, W2, Y2))
        throw new v6($);
      return Y2;
    }
  }, $J = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return function* () {
      }();
  }, WJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return $.const;
  }, YJ = function($, W2) {
    throw new d6($);
  }, XJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new y6($);
  }, ZJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return null;
  }, QJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, JJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const Y2 = new Set($.required);
      return $.default || Object.entries($.properties).reduce((X2, [Z, Q2]) => {
        return Y2.has(Z) ? { ...X2, [Z]: y0(Q2, W2) } : { ...X2 };
      }, {});
    }
  }, zJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return Promise.resolve(y0($.item, W2));
  }, HJ = function($, W2) {
    const [Y2, X2] = Object.entries($.patternProperties)[0];
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else if (!(Y2 === g0.PatternStringExact || Y2 === g0.PatternNumberExact))
      return Y2.slice(1, Y2.length - 1).split("|").reduce((Q2, J2) => {
        return { ...Q2, [J2]: y0(X2, W2) };
      }, {});
    else
      return {};
  }, qJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, GW.Deref)($, W2), W2);
  }, NJ = function($, W2) {
    if ($.pattern !== undefined)
      if (!(0, r.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with patterns must specify a default value");
      else
        return $.default;
    else if ($.format !== undefined)
      if (!(0, r.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with formats must specify a default value");
      else
        return $.default;
    else if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minLength !== undefined)
      return Array.from({ length: $.minLength }).map(() => ".").join("");
    else
      return "";
  }, MJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else if ("value" in $)
      return Symbol.for($.value);
    else
      return Symbol();
  }, AJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    const Y2 = g0.TemplateLiteralParser.ParseExact($.pattern);
    if (!g0.TemplateLiteralFinite.Check(Y2))
      throw new p6($);
    return g0.TemplateLiteralGenerator.Generate(Y2).next().value;
  }, FJ = function($, W2) {
    if (RW++ > bW)
      throw new i6($, bW);
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, GW.Deref)($, W2), W2);
  }, UJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    if ($.items === undefined)
      return [];
    else
      return Array.from({ length: $.minItems }).map((Y2, X2) => y0($.items[X2], W2));
  }, BJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, DJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.anyOf.length === 0)
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    else
      return y0($.anyOf[0], W2);
  }, wJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minByteLength !== undefined)
      return new Uint8Array($.minByteLength);
    else
      return new Uint8Array(0);
  }, KJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, jJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, PJ = function($, W2) {
    if ((0, r.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new Error("User defined types must specify a default value");
  }, y0 = function($, W2) {
    const Y2 = (0, r.IsString)($.$id) ? [...W2, $] : W2, X2 = $;
    switch (X2[g0.Kind]) {
      case "Any":
        return h4(X2, Y2);
      case "Array":
        return n4(X2, Y2);
      case "AsyncIterator":
        return o4(X2, Y2);
      case "BigInt":
        return c4(X2, Y2);
      case "Boolean":
        return l4(X2, Y2);
      case "Constructor":
        return t4(X2, Y2);
      case "Date":
        return s4(X2, Y2);
      case "Function":
        return r4(X2, Y2);
      case "Integer":
        return a4(X2, Y2);
      case "Intersect":
        return e4(X2, Y2);
      case "Iterator":
        return $J(X2, Y2);
      case "Literal":
        return WJ(X2, Y2);
      case "Never":
        return YJ(X2, Y2);
      case "Not":
        return XJ(X2, Y2);
      case "Null":
        return ZJ(X2, Y2);
      case "Number":
        return QJ(X2, Y2);
      case "Object":
        return JJ(X2, Y2);
      case "Promise":
        return zJ(X2, Y2);
      case "Record":
        return HJ(X2, Y2);
      case "Ref":
        return qJ(X2, Y2);
      case "String":
        return NJ(X2, Y2);
      case "Symbol":
        return MJ(X2, Y2);
      case "TemplateLiteral":
        return AJ(X2, Y2);
      case "This":
        return FJ(X2, Y2);
      case "Tuple":
        return UJ(X2, Y2);
      case "Undefined":
        return BJ(X2, Y2);
      case "Union":
        return DJ(X2, Y2);
      case "Uint8Array":
        return wJ(X2, Y2);
      case "Unknown":
        return KJ(X2, Y2);
      case "Void":
        return jJ(X2, Y2);
      default:
        if (!g0.TypeRegistry.Has(X2[g0.Kind]))
          throw new T6(X2);
        return PJ(X2, Y2);
    }
  }, OJ = function(...$) {
    return RW = 0, $.length === 2 ? y0($[0], $[1]) : y0($[0], []);
  };
  Object.defineProperty(_W, "__esModule", { value: true });
  _W.Create = _W.ValueCreateRecursiveInstantiationError = _W.ValueCreateTempateLiteralTypeError = _W.ValueCreateIntersectTypeError = _W.ValueCreateNotTypeError = _W.ValueCreateNeverTypeError = _W.ValueCreateUnknownTypeError = undefined;
  var r = k0(), u4 = Q$(), GW = D1(), g0 = f0();

  class T6 extends g0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  _W.ValueCreateUnknownTypeError = T6;

  class d6 extends g0.TypeBoxError {
    constructor($) {
      super("Never types cannot be created");
      this.schema = $;
    }
  }
  _W.ValueCreateNeverTypeError = d6;

  class y6 extends g0.TypeBoxError {
    constructor($) {
      super("Not types must have a default value");
      this.schema = $;
    }
  }
  _W.ValueCreateNotTypeError = y6;

  class v6 extends g0.TypeBoxError {
    constructor($) {
      super("Intersect produced invalid value. Consider using a default value.");
      this.schema = $;
    }
  }
  _W.ValueCreateIntersectTypeError = v6;

  class p6 extends g0.TypeBoxError {
    constructor($) {
      super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
      this.schema = $;
    }
  }
  _W.ValueCreateTempateLiteralTypeError = p6;

  class i6 extends g0.TypeBoxError {
    constructor($, W2) {
      super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
      this.schema = $, this.recursiveMaxDepth = W2;
    }
  }
  _W.ValueCreateRecursiveInstantiationError = i6;
  var bW = 512, RW = 0;
  _W.Create = OJ;
});
var dW = H0((fW) => {
  var kW = function($, W2, Y2) {
    return (0, m0.Check)($, W2, Y2) ? (0, m1.Clone)(Y2) : (0, M1.Create)($, W2);
  }, h6 = function($, W2, Y2) {
    return (0, m0.Check)($, W2, Y2) ? Y2 : (0, M1.Create)($, W2);
  }, RJ = function($, W2, Y2) {
    if ((0, m0.Check)($, W2, Y2))
      return (0, m1.Clone)(Y2);
    const X2 = (0, w1.IsArray)(Y2) ? (0, m1.Clone)(Y2) : (0, M1.Create)($, W2), Z = (0, w1.IsNumber)($.minItems) && X2.length < $.minItems ? [...X2, ...Array.from({ length: $.minItems - X2.length }, () => null)] : X2, J2 = ((0, w1.IsNumber)($.maxItems) && Z.length > $.maxItems ? Z.slice(0, $.maxItems) : Z).map((F2) => W1($.items, W2, F2));
    if ($.uniqueItems !== true)
      return J2;
    const z2 = [...new Set(J2)];
    if (!(0, m0.Check)($, W2, z2))
      throw new n6($, z2);
    return z2;
  }, _J = function($, W2, Y2) {
    if ((0, m0.Check)($, W2, Y2))
      return (0, M1.Create)($, W2);
    const X2 = new Set($.returns.required || []), Z = function() {
    };
    for (let [Q2, J2] of Object.entries($.returns.properties)) {
      if (!X2.has(Q2) && Y2.prototype[Q2] === undefined)
        continue;
      Z.prototype[Q2] = W1(J2, W2, Y2.prototype[Q2]);
    }
    return Z;
  }, EJ = function($, W2, Y2) {
    const X2 = (0, M1.Create)($, W2), Z = (0, w1.IsPlainObject)(X2) && (0, w1.IsPlainObject)(Y2) ? { ...X2, ...Y2 } : Y2;
    return (0, m0.Check)($, W2, Z) ? Z : (0, M1.Create)($, W2);
  }, VJ = function($, W2, Y2) {
    throw new o6($);
  }, xJ = function($, W2, Y2) {
    if ((0, m0.Check)($, W2, Y2))
      return Y2;
    if (Y2 === null || typeof Y2 !== "object")
      return (0, M1.Create)($, W2);
    const X2 = new Set($.required || []), Z = {};
    for (let [Q2, J2] of Object.entries($.properties)) {
      if (!X2.has(Q2) && Y2[Q2] === undefined)
        continue;
      Z[Q2] = W1(J2, W2, Y2[Q2]);
    }
    if (typeof $.additionalProperties === "object") {
      const Q2 = Object.getOwnPropertyNames($.properties);
      for (let J2 of Object.getOwnPropertyNames(Y2)) {
        if (Q2.includes(J2))
          continue;
        Z[J2] = W1($.additionalProperties, W2, Y2[J2]);
      }
    }
    return Z;
  }, kJ = function($, W2, Y2) {
    if ((0, m0.Check)($, W2, Y2))
      return (0, m1.Clone)(Y2);
    if (Y2 === null || typeof Y2 !== "object" || Array.isArray(Y2) || Y2 instanceof Date)
      return (0, M1.Create)($, W2);
    const X2 = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X2], Q2 = {};
    for (let [J2, z2] of Object.entries(Y2))
      Q2[J2] = W1(Z, W2, z2);
    return Q2;
  }, gJ = function($, W2, Y2) {
    return W1((0, VW.Deref)($, W2), W2, Y2);
  }, fJ = function($, W2, Y2) {
    return W1((0, VW.Deref)($, W2), W2, Y2);
  }, TJ = function($, W2, Y2) {
    if ((0, m0.Check)($, W2, Y2))
      return (0, m1.Clone)(Y2);
    if (!(0, w1.IsArray)(Y2))
      return (0, M1.Create)($, W2);
    if ($.items === undefined)
      return [];
    return $.items.map((X2, Z) => W1(X2, W2, Y2[Z]));
  }, dJ = function($, W2, Y2) {
    return (0, m0.Check)($, W2, Y2) ? (0, m1.Clone)(Y2) : u6.Create($, W2, Y2);
  }, W1 = function($, W2, Y2) {
    const X2 = (0, w1.IsString)($.$id) ? [...W2, $] : W2, Z = $;
    switch ($[N1.Kind]) {
      case "Array":
        return RJ(Z, X2, Y2);
      case "Constructor":
        return _J(Z, X2, Y2);
      case "Intersect":
        return EJ(Z, X2, Y2);
      case "Never":
        return VJ(Z, X2, Y2);
      case "Object":
        return xJ(Z, X2, Y2);
      case "Record":
        return kJ(Z, X2, Y2);
      case "Ref":
        return gJ(Z, X2, Y2);
      case "This":
        return fJ(Z, X2, Y2);
      case "Tuple":
        return TJ(Z, X2, Y2);
      case "Union":
        return dJ(Z, X2, Y2);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return kW($, W2, Y2);
      case "Any":
      case "AsyncIterator":
      case "BigInt":
      case "Boolean":
      case "Function":
      case "Integer":
      case "Iterator":
      case "Literal":
      case "Not":
      case "Null":
      case "Number":
      case "Promise":
      case "String":
      case "TemplateLiteral":
      case "Undefined":
      case "Unknown":
      case "Void":
        return h6(Z, X2, Y2);
      default:
        if (!N1.TypeRegistry.Has(Z[N1.Kind]))
          throw new c6(Z);
        return h6(Z, X2, Y2);
    }
  }, gW = function(...$) {
    return $.length === 3 ? W1($[0], $[1], $[2]) : W1($[0], [], $[1]);
  };
  Object.defineProperty(fW, "__esModule", { value: true });
  fW.Cast = fW.Default = fW.DefaultClone = fW.ValueCastUnknownTypeError = fW.ValueCastRecursiveTypeError = fW.ValueCastNeverTypeError = fW.ValueCastArrayUniqueItemsTypeError = undefined;
  var w1 = k0(), M1 = m6(), m0 = Q$(), m1 = p1(), VW = D1(), N1 = f0();

  class n6 extends N1.TypeBoxError {
    constructor($, W2) {
      super("Array cast produced invalid data due to uniqueItems constraint");
      this.schema = $, this.value = W2;
    }
  }
  fW.ValueCastArrayUniqueItemsTypeError = n6;

  class o6 extends N1.TypeBoxError {
    constructor($) {
      super("Never types cannot be cast");
      this.schema = $;
    }
  }
  fW.ValueCastNeverTypeError = o6;

  class xW extends N1.TypeBoxError {
    constructor($) {
      super("Cannot cast recursive schemas");
      this.schema = $;
    }
  }
  fW.ValueCastRecursiveTypeError = xW;

  class c6 extends N1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  fW.ValueCastUnknownTypeError = c6;
  var u6;
  (function($) {
    function W2(Z, Q2, J2) {
      if (Z[N1.Kind] === "Object" && typeof J2 === "object" && !(0, w1.IsNull)(J2)) {
        const z2 = Z, F2 = Object.getOwnPropertyNames(J2), w = Object.entries(z2.properties), [B2, S2] = [1 / w.length, w.length];
        return w.reduce((G2, [j, M2]) => {
          const O = M2[N1.Kind] === "Literal" && M2.const === J2[j] ? S2 : 0, K2 = (0, m0.Check)(M2, Q2, J2[j]) ? B2 : 0, A2 = F2.includes(j) ? B2 : 0;
          return G2 + (O + K2 + A2);
        }, 0);
      } else
        return (0, m0.Check)(Z, Q2, J2) ? 1 : 0;
    }
    function Y2(Z, Q2, J2) {
      let [z2, F2] = [Z.anyOf[0], 0];
      for (let w of Z.anyOf) {
        const B2 = W2(w, Q2, J2);
        if (B2 > F2)
          z2 = w, F2 = B2;
      }
      return z2;
    }
    function X2(Z, Q2, J2) {
      if ("default" in Z)
        return Z.default;
      else {
        const z2 = Y2(Z, Q2, J2);
        return gW(z2, Q2, J2);
      }
    }
    $.Create = X2;
  })(u6 || (u6 = {}));
  fW.DefaultClone = kW;
  fW.Default = h6;
  fW.Cast = gW;
});
var hW = H0((mW) => {
  var V$ = function($) {
    return (0, J0.IsString)($) && !isNaN($) && !isNaN(parseFloat($));
  }, oJ = function($) {
    return (0, J0.IsBigInt)($) || (0, J0.IsBoolean)($) || (0, J0.IsNumber)($);
  }, J$ = function($) {
    return $ === true || (0, J0.IsNumber)($) && $ === 1 || (0, J0.IsBigInt)($) && $ === BigInt("1") || (0, J0.IsString)($) && ($.toLowerCase() === "true" || $ === "1");
  }, z$ = function($) {
    return $ === false || (0, J0.IsNumber)($) && ($ === 0 || Object.is($, -0)) || (0, J0.IsBigInt)($) && $ === BigInt("0") || (0, J0.IsString)($) && ($.toLowerCase() === "false" || $ === "0" || $ === "-0");
  }, cJ = function($) {
    return (0, J0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, lJ = function($) {
    return (0, J0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, tJ = function($) {
    return (0, J0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, sJ = function($) {
    return (0, J0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, rJ = function($) {
    return (0, J0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test($);
  }, aJ = function($, W2) {
    const Y2 = pW($);
    return Y2 === W2 ? Y2 : $;
  }, eJ = function($, W2) {
    const Y2 = iW($);
    return Y2 === W2 ? Y2 : $;
  }, $9 = function($, W2) {
    const Y2 = vW($);
    return Y2 === W2 ? Y2 : $;
  }, W9 = function($, W2) {
    if (typeof $.const === "string")
      return aJ(W2, $.const);
    else if (typeof $.const === "number")
      return eJ(W2, $.const);
    else if (typeof $.const === "boolean")
      return $9(W2, $.const);
    else
      return (0, hJ.Clone)(W2);
  }, vW = function($) {
    return J$($) ? true : z$($) ? false : $;
  }, Y9 = function($) {
    return V$($) ? BigInt(parseInt($)) : (0, J0.IsNumber)($) ? BigInt($ | 0) : z$($) ? BigInt(0) : J$($) ? BigInt(1) : $;
  }, pW = function($) {
    return oJ($) ? $.toString() : (0, J0.IsSymbol)($) && $.description !== undefined ? $.description.toString() : $;
  }, iW = function($) {
    return V$($) ? parseFloat($) : J$($) ? 1 : z$($) ? 0 : $;
  }, X9 = function($) {
    return V$($) ? parseInt($) : (0, J0.IsNumber)($) ? $ | 0 : J$($) ? 1 : z$($) ? 0 : $;
  }, Z9 = function($) {
    return (0, J0.IsString)($) && $.toLowerCase() === "null" ? null : $;
  }, Q9 = function($) {
    return (0, J0.IsString)($) && $ === "undefined" ? undefined : $;
  }, J9 = function($) {
    return (0, J0.IsDate)($) ? $ : (0, J0.IsNumber)($) ? new Date($) : J$($) ? new Date(1) : z$($) ? new Date(0) : V$($) ? new Date(parseInt($)) : lJ($) ? new Date(`1970-01-01T${$}.000Z`) : cJ($) ? new Date(`1970-01-01T${$}`) : sJ($) ? new Date(`${$}.000Z`) : tJ($) ? new Date($) : rJ($) ? new Date(`${$}T00:00:00.000Z`) : $;
  }, l6 = function($) {
    return $;
  }, z9 = function($, W2, Y2) {
    if ((0, J0.IsArray)(Y2))
      return Y2.map((X2) => o0($.items, W2, X2));
    return Y2;
  }, H9 = function($, W2, Y2) {
    return Y9(Y2);
  }, q9 = function($, W2, Y2) {
    return vW(Y2);
  }, N9 = function($, W2, Y2) {
    return J9(Y2);
  }, M9 = function($, W2, Y2) {
    return X9(Y2);
  }, A9 = function($, W2, Y2) {
    return $.allOf.every((X2) => u1.TypeGuard.TObject(X2)) ? o0(u1.Type.Composite($.allOf), W2, Y2) : o0($.allOf[0], W2, Y2);
  }, F9 = function($, W2, Y2) {
    return W9($, Y2);
  }, U9 = function($, W2, Y2) {
    return Z9(Y2);
  }, B9 = function($, W2, Y2) {
    return iW(Y2);
  }, D9 = function($, W2, Y2) {
    if ((0, J0.IsObject)(Y2))
      return Object.getOwnPropertyNames($.properties).reduce((X2, Z) => {
        return Y2[Z] !== undefined ? { ...X2, [Z]: o0($.properties[Z], W2, Y2[Z]) } : { ...X2 };
      }, Y2);
    return Y2;
  }, w9 = function($, W2, Y2) {
    const X2 = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X2], Q2 = {};
    for (let [J2, z2] of Object.entries(Y2))
      Q2[J2] = o0(Z, W2, z2);
    return Q2;
  }, K9 = function($, W2, Y2) {
    return o0((0, yW.Deref)($, W2), W2, Y2);
  }, j9 = function($, W2, Y2) {
    return pW(Y2);
  }, P9 = function($, W2, Y2) {
    return (0, J0.IsString)(Y2) || (0, J0.IsNumber)(Y2) ? Symbol(Y2) : Y2;
  }, O9 = function($, W2, Y2) {
    return o0((0, yW.Deref)($, W2), W2, Y2);
  }, S9 = function($, W2, Y2) {
    if ((0, J0.IsArray)(Y2) && !(0, J0.IsUndefined)($.items))
      return Y2.map((X2, Z) => {
        return Z < $.items.length ? o0($.items[Z], W2, X2) : X2;
      });
    return Y2;
  }, L9 = function($, W2, Y2) {
    return Q9(Y2);
  }, C9 = function($, W2, Y2) {
    for (let X2 of $.anyOf) {
      const Z = o0(X2, W2, Y2);
      if ((0, nJ.Check)(X2, W2, Z))
        return Z;
    }
    return Y2;
  }, o0 = function($, W2, Y2) {
    const X2 = (0, J0.IsString)($.$id) ? [...W2, $] : W2, Z = $;
    switch ($[u1.Kind]) {
      case "Array":
        return z9(Z, X2, Y2);
      case "BigInt":
        return H9(Z, X2, Y2);
      case "Boolean":
        return q9(Z, X2, Y2);
      case "Date":
        return N9(Z, X2, Y2);
      case "Integer":
        return M9(Z, X2, Y2);
      case "Intersect":
        return A9(Z, X2, Y2);
      case "Literal":
        return F9(Z, X2, Y2);
      case "Null":
        return U9(Z, X2, Y2);
      case "Number":
        return B9(Z, X2, Y2);
      case "Object":
        return D9(Z, X2, Y2);
      case "Record":
        return w9(Z, X2, Y2);
      case "Ref":
        return K9(Z, X2, Y2);
      case "String":
        return j9(Z, X2, Y2);
      case "Symbol":
        return P9(Z, X2, Y2);
      case "This":
        return O9(Z, X2, Y2);
      case "Tuple":
        return S9(Z, X2, Y2);
      case "Undefined":
        return L9(Z, X2, Y2);
      case "Union":
        return C9(Z, X2, Y2);
      case "Any":
      case "AsyncIterator":
      case "Constructor":
      case "Function":
      case "Iterator":
      case "Never":
      case "Promise":
      case "TemplateLiteral":
      case "Uint8Array":
      case "Unknown":
      case "Void":
        return l6(Y2);
      default:
        if (!u1.TypeRegistry.Has(Z[u1.Kind]))
          throw new t6(Z);
        return l6(Y2);
    }
  }, I9 = function(...$) {
    return $.length === 3 ? o0($[0], $[1], $[2]) : o0($[0], [], $[1]);
  };
  Object.defineProperty(mW, "__esModule", { value: true });
  mW.Convert = mW.Default = mW.ValueConvertUnknownTypeError = undefined;
  var J0 = k0(), hJ = p1(), nJ = Q$(), yW = D1(), u1 = f0();

  class t6 extends u1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  mW.ValueConvertUnknownTypeError = t6;
  mW.Default = l6;
  mW.Convert = I9;
});
var a6 = H0((sW) => {
  Object.defineProperty(sW, "__esModule", { value: true });
  sW.EncodeTransform = sW.DecodeTransform = sW.HasTransform = sW.TransformEncodeError = sW.TransformDecodeError = sW.TransformEncodeCheckError = sW.TransformDecodeCheckError = sW.TransformUnknownTypeError = undefined;
  var c0 = k0(), h1 = D1(), n = f0();

  class H$ extends n.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  sW.TransformUnknownTypeError = H$;

  class lW extends n.TypeBoxError {
    constructor($, W2, Y2) {
      super("Unable to decode due to invalid value");
      this.schema = $, this.value = W2, this.error = Y2;
    }
  }
  sW.TransformDecodeCheckError = lW;

  class tW extends n.TypeBoxError {
    constructor($, W2, Y2) {
      super("Unable to encode due to invalid value");
      this.schema = $, this.value = W2, this.error = Y2;
    }
  }
  sW.TransformEncodeCheckError = tW;

  class s6 extends n.TypeBoxError {
    constructor($, W2, Y2) {
      super(`${Y2 instanceof Error ? Y2.message : "Unknown error"}`);
      this.schema = $, this.value = W2;
    }
  }
  sW.TransformDecodeError = s6;

  class r6 extends n.TypeBoxError {
    constructor($, W2, Y2) {
      super(`${Y2 instanceof Error ? Y2.message : "Unknown error"}`);
      this.schema = $, this.value = W2;
    }
  }
  sW.TransformEncodeError = r6;
  var nW;
  (function($) {
    function W2(D2, I2) {
      return n.TypeGuard.TTransform(D2) || O(D2.items, I2);
    }
    function Y2(D2, I2) {
      return n.TypeGuard.TTransform(D2) || O(D2.items, I2);
    }
    function X2(D2, I2) {
      return n.TypeGuard.TTransform(D2) || O(D2.returns, I2) || D2.parameters.some((b2) => O(b2, I2));
    }
    function Z(D2, I2) {
      return n.TypeGuard.TTransform(D2) || O(D2.returns, I2) || D2.parameters.some((b2) => O(b2, I2));
    }
    function Q2(D2, I2) {
      return n.TypeGuard.TTransform(D2) || n.TypeGuard.TTransform(D2.unevaluatedProperties) || D2.allOf.some((b2) => O(b2, I2));
    }
    function J2(D2, I2) {
      return n.TypeGuard.TTransform(D2) || O(D2.items, I2);
    }
    function z2(D2, I2) {
      return n.TypeGuard.TTransform(D2) || O(D2.not, I2);
    }
    function F2(D2, I2) {
      return n.TypeGuard.TTransform(D2) || Object.values(D2.properties).some((b2) => O(b2, I2)) || n.TypeGuard.TSchema(D2.additionalProperties) && O(D2.additionalProperties, I2);
    }
    function w(D2, I2) {
      return n.TypeGuard.TTransform(D2) || O(D2.item, I2);
    }
    function B2(D2, I2) {
      const b2 = Object.getOwnPropertyNames(D2.patternProperties)[0], V2 = D2.patternProperties[b2];
      return n.TypeGuard.TTransform(D2) || O(V2, I2) || n.TypeGuard.TSchema(D2.additionalProperties) && n.TypeGuard.TTransform(D2.additionalProperties);
    }
    function S2(D2, I2) {
      if (n.TypeGuard.TTransform(D2))
        return true;
      return O((0, h1.Deref)(D2, I2), I2);
    }
    function G2(D2, I2) {
      if (n.TypeGuard.TTransform(D2))
        return true;
      return O((0, h1.Deref)(D2, I2), I2);
    }
    function j(D2, I2) {
      return n.TypeGuard.TTransform(D2) || n.TypeGuard.TSchema(D2.items) && D2.items.some((b2) => O(b2, I2));
    }
    function M2(D2, I2) {
      return n.TypeGuard.TTransform(D2) || D2.anyOf.some((b2) => O(b2, I2));
    }
    function O(D2, I2) {
      const b2 = (0, c0.IsString)(D2.$id) ? [...I2, D2] : I2, V2 = D2;
      if (D2.$id && K2.has(D2.$id))
        return false;
      if (D2.$id)
        K2.add(D2.$id);
      switch (D2[n.Kind]) {
        case "Array":
          return W2(V2, b2);
        case "AsyncIterator":
          return Y2(V2, b2);
        case "Constructor":
          return X2(V2, b2);
        case "Function":
          return Z(V2, b2);
        case "Intersect":
          return Q2(V2, b2);
        case "Iterator":
          return J2(V2, b2);
        case "Not":
          return z2(V2, b2);
        case "Object":
          return F2(V2, b2);
        case "Promise":
          return w(V2, b2);
        case "Record":
          return B2(V2, b2);
        case "Ref":
          return S2(V2, b2);
        case "This":
          return G2(V2, b2);
        case "Tuple":
          return j(V2, b2);
        case "Union":
          return M2(V2, b2);
        case "Any":
        case "BigInt":
        case "Boolean":
        case "Date":
        case "Integer":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return n.TypeGuard.TTransform(D2);
        default:
          if (!n.TypeRegistry.Has(V2[n.Kind]))
            throw new H$(V2);
          return n.TypeGuard.TTransform(D2);
      }
    }
    const K2 = new Set;
    function A2(D2, I2) {
      return K2.clear(), O(D2, I2);
    }
    $.Has = A2;
  })(nW || (sW.HasTransform = nW = {}));
  var oW;
  (function($) {
    function W2(M2, O) {
      try {
        return n.TypeGuard.TTransform(M2) ? M2[n.Transform].Decode(O) : O;
      } catch (K2) {
        throw new s6(M2, O, K2);
      }
    }
    function Y2(M2, O, K2) {
      const A2 = K2.map((D2) => S2(M2.items, O, D2));
      return W2(M2, A2);
    }
    function X2(M2, O, K2) {
      if (!(0, c0.IsPlainObject)(K2) || (0, c0.IsValueType)(K2))
        return W2(M2, K2);
      const A2 = n.KeyResolver.ResolveKeys(M2, { includePatterns: false }), D2 = Object.entries(K2).reduce((b2, [V2, _2]) => {
        return !A2.includes(V2) ? { ...b2, [V2]: _2 } : { ...b2, [V2]: W2(n.IndexedAccessor.Resolve(M2, [V2]), _2) };
      }, {});
      if (!n.TypeGuard.TTransform(M2.unevaluatedProperties))
        return W2(M2, D2);
      const I2 = Object.entries(D2).reduce((b2, [V2, _2]) => {
        return A2.includes(V2) ? { ...b2, [V2]: _2 } : { ...b2, [V2]: W2(M2.unevaluatedProperties, _2) };
      }, {});
      return W2(M2, I2);
    }
    function Z(M2, O, K2) {
      const A2 = S2(M2.not, O, K2);
      return W2(M2, A2);
    }
    function Q2(M2, O, K2) {
      if (!(0, c0.IsPlainObject)(K2))
        return W2(M2, K2);
      const A2 = Object.entries(K2).reduce((b2, [V2, _2]) => {
        return !(V2 in M2.properties) ? { ...b2, [V2]: _2 } : { ...b2, [V2]: S2(M2.properties[V2], O, _2) };
      }, {});
      if (!n.TypeGuard.TSchema(M2.additionalProperties))
        return W2(M2, A2);
      const D2 = M2.additionalProperties, I2 = Object.entries(A2).reduce((b2, [V2, _2]) => {
        return V2 in M2.properties ? { ...b2, [V2]: _2 } : { ...b2, [V2]: S2(D2, O, _2) };
      }, {});
      return W2(M2, I2);
    }
    function J2(M2, O, K2) {
      if (!(0, c0.IsPlainObject)(K2))
        return W2(M2, K2);
      const A2 = Object.getOwnPropertyNames(M2.patternProperties)[0], D2 = M2.patternProperties[A2], I2 = new RegExp(A2), b2 = Object.entries(K2).reduce((a, [e, o]) => {
        return !I2.test(e) ? { ...a, [e]: o } : { ...a, [e]: S2(D2, O, o) };
      }, {});
      if (!n.TypeGuard.TSchema(M2.additionalProperties))
        return W2(M2, b2);
      const V2 = M2.additionalProperties, _2 = Object.entries(b2).reduce((a, [e, o]) => {
        return I2.test(e) ? { ...a, [e]: o } : { ...a, [e]: S2(V2, O, o) };
      }, {});
      return W2(M2, _2);
    }
    function z2(M2, O, K2) {
      const A2 = (0, h1.Deref)(M2, O), D2 = S2(A2, O, K2);
      return W2(M2, D2);
    }
    function F2(M2, O, K2) {
      const A2 = (0, h1.Deref)(M2, O), D2 = S2(A2, O, K2);
      return W2(M2, D2);
    }
    function w(M2, O, K2) {
      const A2 = (0, c0.IsArray)(M2.items) ? M2.items.map((D2, I2) => S2(D2, O, K2[I2])) : [];
      return W2(M2, A2);
    }
    function B2(M2, O, K2) {
      const A2 = W2(M2, K2);
      for (let D2 of M2.anyOf) {
        if (!G2(D2, O, A2))
          continue;
        return S2(D2, O, A2);
      }
      return A2;
    }
    function S2(M2, O, K2) {
      const A2 = typeof M2.$id === "string" ? [...O, M2] : O, D2 = M2;
      switch (M2[n.Kind]) {
        case "Array":
          return Y2(D2, A2, K2);
        case "Intersect":
          return X2(D2, A2, K2);
        case "Not":
          return Z(D2, A2, K2);
        case "Object":
          return Q2(D2, A2, K2);
        case "Record":
          return J2(D2, A2, K2);
        case "Ref":
          return z2(D2, A2, K2);
        case "Symbol":
          return W2(D2, K2);
        case "This":
          return F2(D2, A2, K2);
        case "Tuple":
          return w(D2, A2, K2);
        case "Union":
          return B2(D2, A2, K2);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return W2(D2, K2);
        default:
          if (!n.TypeRegistry.Has(D2[n.Kind]))
            throw new H$(D2);
          return W2(D2, K2);
      }
    }
    let G2 = () => false;
    function j(M2, O, K2, A2) {
      return G2 = A2, S2(M2, O, K2);
    }
    $.Decode = j;
  })(oW || (sW.DecodeTransform = oW = {}));
  var cW;
  (function($) {
    function W2(M2, O) {
      try {
        return n.TypeGuard.TTransform(M2) ? M2[n.Transform].Encode(O) : O;
      } catch (K2) {
        throw new r6(M2, O, K2);
      }
    }
    function Y2(M2, O, K2) {
      return W2(M2, K2).map((D2) => S2(M2.items, O, D2));
    }
    function X2(M2, O, K2) {
      const A2 = W2(M2, K2);
      if (!(0, c0.IsPlainObject)(K2) || (0, c0.IsValueType)(K2))
        return A2;
      const D2 = n.KeyResolver.ResolveKeys(M2, { includePatterns: false }), I2 = Object.entries(A2).reduce((b2, [V2, _2]) => {
        return !D2.includes(V2) ? { ...b2, [V2]: _2 } : { ...b2, [V2]: W2(n.IndexedAccessor.Resolve(M2, [V2]), _2) };
      }, {});
      if (!n.TypeGuard.TTransform(M2.unevaluatedProperties))
        return W2(M2, I2);
      return Object.entries(I2).reduce((b2, [V2, _2]) => {
        return D2.includes(V2) ? { ...b2, [V2]: _2 } : { ...b2, [V2]: W2(M2.unevaluatedProperties, _2) };
      }, {});
    }
    function Z(M2, O, K2) {
      const A2 = W2(M2, K2);
      return W2(M2.not, A2);
    }
    function Q2(M2, O, K2) {
      const A2 = W2(M2, K2);
      if (!(0, c0.IsPlainObject)(K2))
        return A2;
      const D2 = Object.entries(A2).reduce((b2, [V2, _2]) => {
        return !(V2 in M2.properties) ? { ...b2, [V2]: _2 } : { ...b2, [V2]: S2(M2.properties[V2], O, _2) };
      }, {});
      if (!n.TypeGuard.TSchema(M2.additionalProperties))
        return D2;
      const I2 = M2.additionalProperties;
      return Object.entries(D2).reduce((b2, [V2, _2]) => {
        return V2 in M2.properties ? { ...b2, [V2]: _2 } : { ...b2, [V2]: S2(I2, O, _2) };
      }, {});
    }
    function J2(M2, O, K2) {
      const A2 = W2(M2, K2);
      if (!(0, c0.IsPlainObject)(K2))
        return A2;
      const D2 = Object.getOwnPropertyNames(M2.patternProperties)[0], I2 = M2.patternProperties[D2], b2 = new RegExp(D2), V2 = Object.entries(A2).reduce((a, [e, o]) => {
        return !b2.test(e) ? { ...a, [e]: o } : { ...a, [e]: S2(I2, O, o) };
      }, {});
      if (!n.TypeGuard.TSchema(M2.additionalProperties))
        return W2(M2, V2);
      const _2 = M2.additionalProperties;
      return Object.entries(V2).reduce((a, [e, o]) => {
        return b2.test(e) ? { ...a, [e]: o } : { ...a, [e]: S2(_2, O, o) };
      }, {});
    }
    function z2(M2, O, K2) {
      const A2 = (0, h1.Deref)(M2, O), D2 = S2(A2, O, K2);
      return W2(M2, D2);
    }
    function F2(M2, O, K2) {
      const A2 = (0, h1.Deref)(M2, O), D2 = S2(A2, O, K2);
      return W2(M2, D2);
    }
    function w(M2, O, K2) {
      const A2 = W2(M2, K2);
      return (0, c0.IsArray)(M2.items) ? M2.items.map((D2, I2) => S2(D2, O, A2[I2])) : [];
    }
    function B2(M2, O, K2) {
      for (let A2 of M2.anyOf) {
        if (!G2(A2, O, K2))
          continue;
        const D2 = S2(A2, O, K2);
        return W2(M2, D2);
      }
      return W2(M2, K2);
    }
    function S2(M2, O, K2) {
      const A2 = typeof M2.$id === "string" ? [...O, M2] : O, D2 = M2;
      switch (M2[n.Kind]) {
        case "Array":
          return Y2(D2, A2, K2);
        case "Intersect":
          return X2(D2, A2, K2);
        case "Not":
          return Z(D2, A2, K2);
        case "Object":
          return Q2(D2, A2, K2);
        case "Record":
          return J2(D2, A2, K2);
        case "Ref":
          return z2(D2, A2, K2);
        case "This":
          return F2(D2, A2, K2);
        case "Tuple":
          return w(D2, A2, K2);
        case "Union":
          return B2(D2, A2, K2);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return W2(D2, K2);
        default:
          if (!n.TypeRegistry.Has(D2[n.Kind]))
            throw new H$(D2);
          return W2(D2, K2);
      }
    }
    let G2 = () => false;
    function j(M2, O, K2, A2) {
      return G2 = A2, S2(M2, O, K2);
    }
    $.Encode = j;
  })(cW || (sW.EncodeTransform = cW = {}));
});
var JY = H0((ZY) => {
  Object.defineProperty(ZY, "__esModule", { value: true });
  ZY.Value = undefined;
  var aW = I$(), f9 = jW(), T9 = W$(), d9 = SW(), eW = dW(), y9 = p1(), $Y = hW(), WY = m6(), x$ = Q$(), YY = E6(), k$ = a6(), XY;
  (function($) {
    function W2(...M2) {
      return eW.Cast.apply(eW, M2);
    }
    $.Cast = W2;
    function Y2(...M2) {
      return WY.Create.apply(WY, M2);
    }
    $.Create = Y2;
    function X2(...M2) {
      return x$.Check.apply(x$, M2);
    }
    $.Check = X2;
    function Z(...M2) {
      return $Y.Convert.apply($Y, M2);
    }
    $.Convert = Z;
    function Q2(M2) {
      return y9.Clone(M2);
    }
    $.Clone = Q2;
    function J2(...M2) {
      const [O, K2, A2] = M2.length === 3 ? [M2[0], M2[1], M2[2]] : [M2[0], [], M2[1]];
      if (!X2(O, K2, A2))
        throw new k$.TransformDecodeCheckError(O, A2, F2(O, K2, A2).First());
      return k$.DecodeTransform.Decode(O, K2, A2, x$.Check);
    }
    $.Decode = J2;
    function z2(...M2) {
      const [O, K2, A2] = M2.length === 3 ? [M2[0], M2[1], M2[2]] : [M2[0], [], M2[1]], D2 = k$.EncodeTransform.Encode(O, K2, A2, x$.Check);
      if (!X2(O, K2, D2))
        throw new k$.TransformEncodeCheckError(O, A2, F2(O, K2, A2).First());
      return D2;
    }
    $.Encode = z2;
    function F2(...M2) {
      return aW.Errors.apply(aW, M2);
    }
    $.Errors = F2;
    function w(M2, O) {
      return d9.Equal(M2, O);
    }
    $.Equal = w;
    function B2(M2, O) {
      return YY.Diff(M2, O);
    }
    $.Diff = B2;
    function S2(M2) {
      return T9.Hash(M2);
    }
    $.Hash = S2;
    function G2(M2, O) {
      return YY.Patch(M2, O);
    }
    $.Patch = G2;
    function j(M2, O) {
      f9.Mutate(M2, O);
    }
    $.Mutate = j;
  })(XY || (ZY.Value = XY = {}));
});
var e6 = H0((Y1) => {
  Object.defineProperty(Y1, "__esModule", { value: true });
  Y1.Value = Y1.ValuePointer = Y1.Delete = Y1.Update = Y1.Insert = Y1.Edit = Y1.ValueErrorIterator = Y1.ValueErrorType = undefined;
  var zY = I$();
  Object.defineProperty(Y1, "ValueErrorType", { enumerable: true, get: function() {
    return zY.ValueErrorType;
  } });
  Object.defineProperty(Y1, "ValueErrorIterator", { enumerable: true, get: function() {
    return zY.ValueErrorIterator;
  } });
  var g$ = E6();
  Object.defineProperty(Y1, "Edit", { enumerable: true, get: function() {
    return g$.Edit;
  } });
  Object.defineProperty(Y1, "Insert", { enumerable: true, get: function() {
    return g$.Insert;
  } });
  Object.defineProperty(Y1, "Update", { enumerable: true, get: function() {
    return g$.Update;
  } });
  Object.defineProperty(Y1, "Delete", { enumerable: true, get: function() {
    return g$.Delete;
  } });
  var v9 = b$();
  Object.defineProperty(Y1, "ValuePointer", { enumerable: true, get: function() {
    return v9.ValuePointer;
  } });
  var p9 = JY();
  Object.defineProperty(Y1, "Value", { enumerable: true, get: function() {
    return p9.Value;
  } });
});
var FY = H0((MY) => {
  Object.defineProperty(MY, "__esModule", { value: true });
  MY.TypeCompiler = MY.Policy = MY.TypeCompilerTypeGuardError = MY.TypeCompilerUnknownTypeError = MY.TypeCheck = undefined;
  var M$ = a6(), c2 = k0(), t9 = $$(), A$ = E$(), s9 = D1(), r9 = W$(), A0 = f0();

  class Z8 {
    constructor($, W2, Y2, X2) {
      this.schema = $, this.references = W2, this.checkFunc = Y2, this.code = X2, this.hasTransform = M$.HasTransform.Has($, W2);
    }
    Code() {
      return this.code;
    }
    Errors($) {
      return (0, t9.Errors)(this.schema, this.references, $);
    }
    Check($) {
      return this.checkFunc($);
    }
    Decode($) {
      if (!this.checkFunc($))
        throw new M$.TransformDecodeCheckError(this.schema, $, this.Errors($).First());
      return this.hasTransform ? M$.DecodeTransform.Decode(this.schema, this.references, $, (W2, Y2, X2) => this.Check(X2)) : $;
    }
    Encode($) {
      const W2 = this.hasTransform ? M$.EncodeTransform.Encode(this.schema, this.references, $, (Y2, X2, Z) => this.Check(Z)) : $;
      if (!this.checkFunc(W2))
        throw new M$.TransformEncodeCheckError(this.schema, $, this.Errors($).First());
      return W2;
    }
  }
  MY.TypeCheck = Z8;
  var A1;
  (function($) {
    function W2(Q2) {
      return Q2 === 36;
    }
    $.DollarSign = W2;
    function Y2(Q2) {
      return Q2 === 95;
    }
    $.IsUnderscore = Y2;
    function X2(Q2) {
      return Q2 >= 65 && Q2 <= 90 || Q2 >= 97 && Q2 <= 122;
    }
    $.IsAlpha = X2;
    function Z(Q2) {
      return Q2 >= 48 && Q2 <= 57;
    }
    $.IsNumeric = Z;
  })(A1 || (A1 = {}));
  var v$;
  (function($) {
    function W2(Q2) {
      if (Q2.length === 0)
        return false;
      return A1.IsNumeric(Q2.charCodeAt(0));
    }
    function Y2(Q2) {
      if (W2(Q2))
        return false;
      for (let J2 = 0;J2 < Q2.length; J2++) {
        const z2 = Q2.charCodeAt(J2);
        if (!(A1.IsAlpha(z2) || A1.IsNumeric(z2) || A1.DollarSign(z2) || A1.IsUnderscore(z2)))
          return false;
      }
      return true;
    }
    function X2(Q2) {
      return Q2.replace(/'/g, "\\'");
    }
    function Z(Q2, J2) {
      return Y2(J2) ? `${Q2}.${J2}` : `${Q2}['${X2(J2)}']`;
    }
    $.Encode = Z;
  })(v$ || (v$ = {}));
  var Y8;
  (function($) {
    function W2(Y2) {
      const X2 = [];
      for (let Z = 0;Z < Y2.length; Z++) {
        const Q2 = Y2.charCodeAt(Z);
        if (A1.IsNumeric(Q2) || A1.IsAlpha(Q2))
          X2.push(Y2.charAt(Z));
        else
          X2.push(`_${Q2}_`);
      }
      return X2.join("").replace(/__/g, "_");
    }
    $.Encode = W2;
  })(Y8 || (Y8 = {}));
  var X8;
  (function($) {
    function W2(Y2) {
      return Y2.replace(/'/g, "\\'");
    }
    $.Escape = W2;
  })(X8 || (X8 = {}));

  class Q8 extends A0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  MY.TypeCompilerUnknownTypeError = Q8;

  class p$ extends A0.TypeBoxError {
    constructor($) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = $;
    }
  }
  MY.TypeCompilerTypeGuardError = p$;
  var C1;
  (function($) {
    function W2(J2, z2, F2) {
      return A$.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${z2}' in ${J2} ? ${F2} : true)` : `(${v$.Encode(J2, z2)} !== undefined ? ${F2} : true)`;
    }
    $.IsExactOptionalProperty = W2;
    function Y2(J2) {
      return !A$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J2} === 'object' && ${J2} !== null && !Array.isArray(${J2}))` : `(typeof ${J2} === 'object' && ${J2} !== null)`;
    }
    $.IsObjectLike = Y2;
    function X2(J2) {
      return !A$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J2} === 'object' && ${J2} !== null && !Array.isArray(${J2}) && !(${J2} instanceof Date) && !(${J2} instanceof Uint8Array))` : `(typeof ${J2} === 'object' && ${J2} !== null && !(${J2} instanceof Date) && !(${J2} instanceof Uint8Array))`;
    }
    $.IsRecordLike = X2;
    function Z(J2) {
      return !A$.TypeSystemPolicy.AllowNaN ? `(typeof ${J2} === 'number' && Number.isFinite(${J2}))` : `typeof ${J2} === 'number'`;
    }
    $.IsNumberLike = Z;
    function Q2(J2) {
      return A$.TypeSystemPolicy.AllowNullVoid ? `(${J2} === undefined || ${J2} === null)` : `${J2} === undefined`;
    }
    $.IsVoidLike = Q2;
  })(C1 || (MY.Policy = C1 = {}));
  var NY;
  (function($) {
    function W2(P2) {
      return P2[A0.Kind] === "Any" || P2[A0.Kind] === "Unknown";
    }
    function* Y2(P2, E2, L2) {
      yield "true";
    }
    function* X2(P2, E2, L2) {
      yield `Array.isArray(${L2})`;
      const [p, T2] = [D0("value", "any"), D0("acc", "number")];
      if ((0, c2.IsNumber)(P2.maxItems))
        yield `${L2}.length <= ${P2.maxItems}`;
      if ((0, c2.IsNumber)(P2.minItems))
        yield `${L2}.length >= ${P2.minItems}`;
      const d = f(P2.items, E2, "value");
      if (yield `${L2}.every((${p}) => ${d})`, A0.TypeGuard.TSchema(P2.contains) || (0, c2.IsNumber)(P2.minContains) || (0, c2.IsNumber)(P2.maxContains)) {
        const Z0 = A0.TypeGuard.TSchema(P2.contains) ? P2.contains : A0.Type.Never(), O0 = f(Z0, E2, "value"), Q0 = (0, c2.IsNumber)(P2.minContains) ? [`(count >= ${P2.minContains})`] : [], N2 = (0, c2.IsNumber)(P2.maxContains) ? [`(count <= ${P2.maxContains})`] : [], l = `const count = value.reduce((${T2}, ${p}) => ${O0} ? acc + 1 : acc, 0)`, I0 = ["(count > 0)", ...Q0, ...N2].join(" && ");
        yield `((${p}) => { ${l}; return ${I0}})(${L2})`;
      }
      if (P2.uniqueItems === true)
        yield `((${p}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${L2})`;
    }
    function* Z(P2, E2, L2) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${L2})`;
    }
    function* Q2(P2, E2, L2) {
      if (yield `(typeof ${L2} === 'bigint')`, (0, c2.IsBigInt)(P2.exclusiveMaximum))
        yield `${L2} < BigInt(${P2.exclusiveMaximum})`;
      if ((0, c2.IsBigInt)(P2.exclusiveMinimum))
        yield `${L2} > BigInt(${P2.exclusiveMinimum})`;
      if ((0, c2.IsBigInt)(P2.maximum))
        yield `${L2} <= BigInt(${P2.maximum})`;
      if ((0, c2.IsBigInt)(P2.minimum))
        yield `${L2} >= BigInt(${P2.minimum})`;
      if ((0, c2.IsBigInt)(P2.multipleOf))
        yield `(${L2} % BigInt(${P2.multipleOf})) === 0`;
    }
    function* J2(P2, E2, L2) {
      yield `(typeof ${L2} === 'boolean')`;
    }
    function* z2(P2, E2, L2) {
      yield* v0(P2.returns, E2, `${L2}.prototype`);
    }
    function* F2(P2, E2, L2) {
      if (yield `(${L2} instanceof Date) && Number.isFinite(${L2}.getTime())`, (0, c2.IsNumber)(P2.exclusiveMaximumTimestamp))
        yield `${L2}.getTime() < ${P2.exclusiveMaximumTimestamp}`;
      if ((0, c2.IsNumber)(P2.exclusiveMinimumTimestamp))
        yield `${L2}.getTime() > ${P2.exclusiveMinimumTimestamp}`;
      if ((0, c2.IsNumber)(P2.maximumTimestamp))
        yield `${L2}.getTime() <= ${P2.maximumTimestamp}`;
      if ((0, c2.IsNumber)(P2.minimumTimestamp))
        yield `${L2}.getTime() >= ${P2.minimumTimestamp}`;
      if ((0, c2.IsNumber)(P2.multipleOfTimestamp))
        yield `(${L2}.getTime() % ${P2.multipleOfTimestamp}) === 0`;
    }
    function* w(P2, E2, L2) {
      yield `(typeof ${L2} === 'function')`;
    }
    function* B2(P2, E2, L2) {
      if (yield `(typeof ${L2} === 'number' && Number.isInteger(${L2}))`, (0, c2.IsNumber)(P2.exclusiveMaximum))
        yield `${L2} < ${P2.exclusiveMaximum}`;
      if ((0, c2.IsNumber)(P2.exclusiveMinimum))
        yield `${L2} > ${P2.exclusiveMinimum}`;
      if ((0, c2.IsNumber)(P2.maximum))
        yield `${L2} <= ${P2.maximum}`;
      if ((0, c2.IsNumber)(P2.minimum))
        yield `${L2} >= ${P2.minimum}`;
      if ((0, c2.IsNumber)(P2.multipleOf))
        yield `(${L2} % ${P2.multipleOf}) === 0`;
    }
    function* S2(P2, E2, L2) {
      const p = P2.allOf.map((T2) => f(T2, E2, L2)).join(" && ");
      if (P2.unevaluatedProperties === false) {
        const T2 = u(`${new RegExp(A0.KeyResolver.ResolvePattern(P2))};`), d = `Object.getOwnPropertyNames(${L2}).every(key => ${T2}.test(key))`;
        yield `(${p} && ${d})`;
      } else if (A0.TypeGuard.TSchema(P2.unevaluatedProperties)) {
        const T2 = u(`${new RegExp(A0.KeyResolver.ResolvePattern(P2))};`), d = `Object.getOwnPropertyNames(${L2}).every(key => ${T2}.test(key) || ${f(P2.unevaluatedProperties, E2, `${L2}[key]`)})`;
        yield `(${p} && ${d})`;
      } else
        yield `(${p})`;
    }
    function* G2(P2, E2, L2) {
      yield `(typeof value === 'object' && Symbol.iterator in ${L2})`;
    }
    function* j(P2, E2, L2) {
      if (typeof P2.const === "number" || typeof P2.const === "boolean")
        yield `(${L2} === ${P2.const})`;
      else
        yield `(${L2} === '${X8.Escape(P2.const)}')`;
    }
    function* M2(P2, E2, L2) {
      yield "false";
    }
    function* O(P2, E2, L2) {
      yield `(!${f(P2.not, E2, L2)})`;
    }
    function* K2(P2, E2, L2) {
      yield `(${L2} === null)`;
    }
    function* A2(P2, E2, L2) {
      if (yield C1.IsNumberLike(L2), (0, c2.IsNumber)(P2.exclusiveMaximum))
        yield `${L2} < ${P2.exclusiveMaximum}`;
      if ((0, c2.IsNumber)(P2.exclusiveMinimum))
        yield `${L2} > ${P2.exclusiveMinimum}`;
      if ((0, c2.IsNumber)(P2.maximum))
        yield `${L2} <= ${P2.maximum}`;
      if ((0, c2.IsNumber)(P2.minimum))
        yield `${L2} >= ${P2.minimum}`;
      if ((0, c2.IsNumber)(P2.multipleOf))
        yield `(${L2} % ${P2.multipleOf}) === 0`;
    }
    function* D2(P2, E2, L2) {
      if (yield C1.IsObjectLike(L2), (0, c2.IsNumber)(P2.minProperties))
        yield `Object.getOwnPropertyNames(${L2}).length >= ${P2.minProperties}`;
      if ((0, c2.IsNumber)(P2.maxProperties))
        yield `Object.getOwnPropertyNames(${L2}).length <= ${P2.maxProperties}`;
      const p = Object.getOwnPropertyNames(P2.properties);
      for (let T2 of p) {
        const d = v$.Encode(L2, T2), Z0 = P2.properties[T2];
        if (P2.required && P2.required.includes(T2)) {
          if (yield* v0(Z0, E2, d), A0.ExtendsUndefined.Check(Z0) || W2(Z0))
            yield `('${T2}' in ${L2})`;
        } else {
          const O0 = f(Z0, E2, d);
          yield C1.IsExactOptionalProperty(L2, T2, O0);
        }
      }
      if (P2.additionalProperties === false)
        if (P2.required && P2.required.length === p.length)
          yield `Object.getOwnPropertyNames(${L2}).length === ${p.length}`;
        else {
          const T2 = `[${p.map((d) => `'${d}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${L2}).every(key => ${T2}.includes(key))`;
        }
      if (typeof P2.additionalProperties === "object") {
        const T2 = f(P2.additionalProperties, E2, `${L2}[key]`), d = `[${p.map((Z0) => `'${Z0}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${L2}).every(key => ${d}.includes(key) || ${T2}))`;
      }
    }
    function* I2(P2, E2, L2) {
      yield `(typeof value === 'object' && typeof ${L2}.then === 'function')`;
    }
    function* b2(P2, E2, L2) {
      if (yield C1.IsRecordLike(L2), (0, c2.IsNumber)(P2.minProperties))
        yield `Object.getOwnPropertyNames(${L2}).length >= ${P2.minProperties}`;
      if ((0, c2.IsNumber)(P2.maxProperties))
        yield `Object.getOwnPropertyNames(${L2}).length <= ${P2.maxProperties}`;
      const [p, T2] = Object.entries(P2.patternProperties)[0], d = u(`${new RegExp(p)}`), Z0 = f(T2, E2, "value"), O0 = A0.TypeGuard.TSchema(P2.additionalProperties) ? f(P2.additionalProperties, E2, L2) : P2.additionalProperties === false ? "false" : "true", Q0 = `(${d}.test(key) ? ${Z0} : ${O0})`;
      yield `(Object.entries(${L2}).every(([key, value]) => ${Q0}))`;
    }
    function* V2(P2, E2, L2) {
      const p = (0, s9.Deref)(P2, E2);
      if (R2.functions.has(P2.$ref))
        return yield `${i(P2.$ref)}(${L2})`;
      yield* v0(p, E2, L2);
    }
    function* _2(P2, E2, L2) {
      if (yield `(typeof ${L2} === 'string')`, (0, c2.IsNumber)(P2.maxLength))
        yield `${L2}.length <= ${P2.maxLength}`;
      if ((0, c2.IsNumber)(P2.minLength))
        yield `${L2}.length >= ${P2.minLength}`;
      if (P2.pattern !== undefined)
        yield `${u(`${new RegExp(P2.pattern)};`)}.test(${L2})`;
      if (P2.format !== undefined)
        yield `format('${P2.format}', ${L2})`;
    }
    function* a(P2, E2, L2) {
      yield `(typeof ${L2} === 'symbol')`;
    }
    function* e(P2, E2, L2) {
      yield `(typeof ${L2} === 'string')`, yield `${u(`${new RegExp(P2.pattern)};`)}.test(${L2})`;
    }
    function* o(P2, E2, L2) {
      yield `${i(P2.$ref)}(${L2})`;
    }
    function* P0(P2, E2, L2) {
      if (yield `Array.isArray(${L2})`, P2.items === undefined)
        return yield `${L2}.length === 0`;
      yield `(${L2}.length === ${P2.maxItems})`;
      for (let p = 0;p < P2.items.length; p++)
        yield `${f(P2.items[p], E2, `${L2}[${p}]`)}`;
    }
    function* F0(P2, E2, L2) {
      yield `${L2} === undefined`;
    }
    function* C0(P2, E2, L2) {
      yield `(${P2.anyOf.map((T2) => f(T2, E2, L2)).join(" || ")})`;
    }
    function* Y0(P2, E2, L2) {
      if (yield `${L2} instanceof Uint8Array`, (0, c2.IsNumber)(P2.maxByteLength))
        yield `(${L2}.length <= ${P2.maxByteLength})`;
      if ((0, c2.IsNumber)(P2.minByteLength))
        yield `(${L2}.length >= ${P2.minByteLength})`;
    }
    function* X0(P2, E2, L2) {
      yield "true";
    }
    function* u0(P2, E2, L2) {
      yield C1.IsVoidLike(L2);
    }
    function* a0(P2, E2, L2) {
      const p = R2.instances.size;
      R2.instances.set(p, P2), yield `kind('${P2[A0.Kind]}', ${p}, ${L2})`;
    }
    function* v0(P2, E2, L2, p = true) {
      const T2 = (0, c2.IsString)(P2.$id) ? [...E2, P2] : E2, d = P2;
      if (p && (0, c2.IsString)(P2.$id)) {
        const Z0 = i(P2.$id);
        if (R2.functions.has(Z0))
          return yield `${Z0}(${L2})`;
        else {
          const O0 = q0(Z0, P2, E2, "value", false);
          return R2.functions.set(Z0, O0), yield `${Z0}(${L2})`;
        }
      }
      switch (d[A0.Kind]) {
        case "Any":
          return yield* Y2(d, T2, L2);
        case "Array":
          return yield* X2(d, T2, L2);
        case "AsyncIterator":
          return yield* Z(d, T2, L2);
        case "BigInt":
          return yield* Q2(d, T2, L2);
        case "Boolean":
          return yield* J2(d, T2, L2);
        case "Constructor":
          return yield* z2(d, T2, L2);
        case "Date":
          return yield* F2(d, T2, L2);
        case "Function":
          return yield* w(d, T2, L2);
        case "Integer":
          return yield* B2(d, T2, L2);
        case "Intersect":
          return yield* S2(d, T2, L2);
        case "Iterator":
          return yield* G2(d, T2, L2);
        case "Literal":
          return yield* j(d, T2, L2);
        case "Never":
          return yield* M2(d, T2, L2);
        case "Not":
          return yield* O(d, T2, L2);
        case "Null":
          return yield* K2(d, T2, L2);
        case "Number":
          return yield* A2(d, T2, L2);
        case "Object":
          return yield* D2(d, T2, L2);
        case "Promise":
          return yield* I2(d, T2, L2);
        case "Record":
          return yield* b2(d, T2, L2);
        case "Ref":
          return yield* V2(d, T2, L2);
        case "String":
          return yield* _2(d, T2, L2);
        case "Symbol":
          return yield* a(d, T2, L2);
        case "TemplateLiteral":
          return yield* e(d, T2, L2);
        case "This":
          return yield* o(d, T2, L2);
        case "Tuple":
          return yield* P0(d, T2, L2);
        case "Undefined":
          return yield* F0(d, T2, L2);
        case "Union":
          return yield* C0(d, T2, L2);
        case "Uint8Array":
          return yield* Y0(d, T2, L2);
        case "Unknown":
          return yield* X0(d, T2, L2);
        case "Void":
          return yield* u0(d, T2, L2);
        default:
          if (!A0.TypeRegistry.Has(d[A0.Kind]))
            throw new Q8(P2);
          return yield* a0(d, T2, L2);
      }
    }
    const R2 = { language: "javascript", functions: new Map, variables: new Map, instances: new Map };
    function f(P2, E2, L2, p = true) {
      return `(${[...v0(P2, E2, L2, p)].join(" && ")})`;
    }
    function i(P2) {
      return `check_${Y8.Encode(P2)}`;
    }
    function u(P2) {
      const E2 = `local_${R2.variables.size}`;
      return R2.variables.set(E2, `const ${E2} = ${P2}`), E2;
    }
    function q0(P2, E2, L2, p, T2 = true) {
      const [d, Z0] = ["\n", (l) => "".padStart(l, " ")], O0 = D0("value", "any"), Q0 = w0("boolean"), N2 = [...v0(E2, L2, p, T2)].map((l) => `${Z0(4)}${l}`).join(` &&${d}`);
      return `function ${P2}(${O0})${Q0} {${d}${Z0(2)}return (${d}${N2}${d}${Z0(2)})\n}`;
    }
    function D0(P2, E2) {
      const L2 = R2.language === "typescript" ? `: ${E2}` : "";
      return `${P2}${L2}`;
    }
    function w0(P2) {
      return R2.language === "typescript" ? `: ${P2}` : "";
    }
    function K0(P2, E2, L2) {
      const p = q0("check", P2, E2, "value"), T2 = D0("value", "any"), d = w0("boolean"), Z0 = [...R2.functions.values()], O0 = [...R2.variables.values()], Q0 = (0, c2.IsString)(P2.$id) ? `return function check(${T2})${d} {\n  return ${i(P2.$id)}(value)\n}` : `return ${p}`;
      return [...O0, ...Z0, Q0].join("\n");
    }
    function N0(...P2) {
      const E2 = { language: "javascript" }, [L2, p, T2] = P2.length === 2 && (0, c2.IsArray)(P2[1]) ? [P2[0], P2[1], E2] : P2.length === 2 && !(0, c2.IsArray)(P2[1]) ? [P2[0], [], P2[1]] : P2.length === 3 ? [P2[0], P2[1], P2[2]] : P2.length === 1 ? [P2[0], [], E2] : [null, [], E2];
      if (R2.language = T2.language, R2.variables.clear(), R2.functions.clear(), R2.instances.clear(), !A0.TypeGuard.TSchema(L2))
        throw new p$(L2);
      for (let d of p)
        if (!A0.TypeGuard.TSchema(d))
          throw new p$(d);
      return K0(L2, p, T2);
    }
    $.Code = N0;
    function B1(P2, E2 = []) {
      const L2 = N0(P2, E2, { language: "javascript" }), p = globalThis.Function("kind", "format", "hash", L2), T2 = new Map(R2.instances);
      function d(N2, l, I0) {
        if (!A0.TypeRegistry.Has(N2) || !T2.has(l))
          return false;
        const c$ = A0.TypeRegistry.Get(N2), l$ = T2.get(l);
        return c$(l$, I0);
      }
      function Z0(N2, l) {
        if (!A0.FormatRegistry.Has(N2))
          return false;
        return A0.FormatRegistry.Get(N2)(l);
      }
      function O0(N2) {
        return (0, r9.Hash)(N2);
      }
      const Q0 = p(d, Z0, O0);
      return new Z8(P2, E2, Q0, L2);
    }
    $.Compile = B1;
  })(NY || (MY.TypeCompiler = NY = {}));
});
var BY = H0((l0) => {
  var Y7 = l0 && l0.__createBinding || (Object.create ? function($, W2, Y2, X2) {
    if (X2 === undefined)
      X2 = Y2;
    var Z = Object.getOwnPropertyDescriptor(W2, Y2);
    if (!Z || ("get" in Z ? !W2.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return W2[Y2];
      } };
    Object.defineProperty($, X2, Z);
  } : function($, W2, Y2, X2) {
    if (X2 === undefined)
      X2 = Y2;
    $[X2] = W2[Y2];
  }), X7 = l0 && l0.__exportStar || function($, W2) {
    for (var Y2 in $)
      if (Y2 !== "default" && !Object.prototype.hasOwnProperty.call(W2, Y2))
        Y7(W2, $, Y2);
  };
  Object.defineProperty(l0, "__esModule", { value: true });
  l0.ValueErrorIterator = l0.ValueErrorType = undefined;
  var UY = I$();
  Object.defineProperty(l0, "ValueErrorType", { enumerable: true, get: function() {
    return UY.ValueErrorType;
  } });
  Object.defineProperty(l0, "ValueErrorIterator", { enumerable: true, get: function() {
    return UY.ValueErrorIterator;
  } });
  X7(FY(), l0);
});
var IY = H0((Bz, CY) => {
  var J7 = function($) {
    var W2 = $.indexOf("%");
    if (W2 === -1)
      return $;
    var Y2 = $.length, X2 = "", Z = 0, Q2 = 0, J2 = W2, z2 = SY;
    while (W2 > -1 && W2 < Y2) {
      var F2 = LY($[W2 + 1], 4), w = LY($[W2 + 2], 0), B2 = F2 | w, S2 = F8[B2];
      if (z2 = F8[256 + z2 + S2], Q2 = Q2 << 6 | B2 & F8[364 + S2], z2 === SY)
        X2 += $.slice(Z, J2), X2 += Q2 <= 65535 ? String.fromCharCode(Q2) : String.fromCharCode(55232 + (Q2 >> 10), 56320 + (Q2 & 1023)), Q2 = 0, Z = W2 + 3, W2 = J2 = $.indexOf("%", Z);
      else if (z2 === Q7)
        return null;
      else {
        if (W2 += 3, W2 < Y2 && $.charCodeAt(W2) === 37)
          continue;
        return null;
      }
    }
    return X2 + $.slice(Z);
  }, LY = function($, W2) {
    var Y2 = z7[$];
    return Y2 === undefined ? 255 : Y2 << W2;
  }, SY = 12, Q7 = 0, F8 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], z7 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  CY.exports = J7;
});
var EY = H0((Dz, _Y) => {
  var H7 = function($) {
    const W2 = new RY;
    if (typeof $ !== "string")
      return W2;
    let Y2 = $.length, X2 = "", Z = "", Q2 = -1, J2 = -1, z2 = false, F2 = false, w = false, B2 = false, S2 = false, G2 = 0;
    for (let j = 0;j < Y2 + 1; j++)
      if (G2 = j !== Y2 ? $.charCodeAt(j) : 38, G2 === 38) {
        if (S2 = J2 > Q2, !S2)
          J2 = j;
        if (X2 = $.slice(Q2 + 1, J2), S2 || X2.length > 0) {
          if (w)
            X2 = X2.replace(GY, " ");
          if (z2)
            X2 = bY(X2) || X2;
          if (S2) {
            if (Z = $.slice(J2 + 1, j), B2)
              Z = Z.replace(GY, " ");
            if (F2)
              Z = bY(Z) || Z;
          }
          const M2 = W2[X2];
          if (M2 === undefined)
            W2[X2] = Z;
          else if (M2.pop)
            M2.push(Z);
          else
            W2[X2] = [M2, Z];
        }
        Z = "", Q2 = j, J2 = j, z2 = false, F2 = false, w = false, B2 = false;
      } else if (G2 === 61)
        if (J2 <= Q2)
          J2 = j;
        else
          F2 = true;
      else if (G2 === 43)
        if (J2 > Q2)
          B2 = true;
        else
          w = true;
      else if (G2 === 37)
        if (J2 > Q2)
          F2 = true;
        else
          z2 = true;
    return W2;
  }, bY = IY(), GY = /\+/g, RY = function() {
  };
  RY.prototype = Object.create(null);
  _Y.exports = H7;
});
var xY = H0((wz, VY) => {
  var N7 = function($) {
    const W2 = $.length;
    if (W2 === 0)
      return "";
    let Y2 = "", X2 = 0, Z = 0;
    $:
      for (;Z < W2; Z++) {
        let Q2 = $.charCodeAt(Z);
        while (Q2 < 128) {
          if (q7[Q2] !== 1) {
            if (X2 < Z)
              Y2 += $.slice(X2, Z);
            X2 = Z + 1, Y2 += Z1[Q2];
          }
          if (++Z === W2)
            break $;
          Q2 = $.charCodeAt(Z);
        }
        if (X2 < Z)
          Y2 += $.slice(X2, Z);
        if (Q2 < 2048) {
          X2 = Z + 1, Y2 += Z1[192 | Q2 >> 6] + Z1[128 | Q2 & 63];
          continue;
        }
        if (Q2 < 55296 || Q2 >= 57344) {
          X2 = Z + 1, Y2 += Z1[224 | Q2 >> 12] + Z1[128 | Q2 >> 6 & 63] + Z1[128 | Q2 & 63];
          continue;
        }
        if (++Z, Z >= W2)
          throw new Error("URI malformed");
        const J2 = $.charCodeAt(Z) & 1023;
        X2 = Z + 1, Q2 = 65536 + ((Q2 & 1023) << 10 | J2), Y2 += Z1[240 | Q2 >> 18] + Z1[128 | Q2 >> 12 & 63] + Z1[128 | Q2 >> 6 & 63] + Z1[128 | Q2 & 63];
      }
    if (X2 === 0)
      return $;
    if (X2 < W2)
      return Y2 + $.slice(X2);
    return Y2;
  }, Z1 = Array.from({ length: 256 }, ($, W2) => "%" + ((W2 < 16 ? "0" : "") + W2.toString(16)).toUpperCase()), q7 = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  VY.exports = { encodeString: N7 };
});
var fY = H0((Kz, gY) => {
  var kY = function($) {
    const W2 = typeof $;
    if (W2 === "string")
      return U8($);
    else if (W2 === "bigint")
      return $.toString();
    else if (W2 === "boolean")
      return $ ? "true" : "false";
    else if (W2 === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : U8("" + $);
    return "";
  }, M7 = function($) {
    let W2 = "";
    if ($ === null || typeof $ !== "object")
      return W2;
    const Y2 = "&", X2 = Object.keys($), Z = X2.length;
    let Q2 = 0;
    for (let J2 = 0;J2 < Z; J2++) {
      const z2 = X2[J2], F2 = $[z2], w = U8(z2) + "=";
      if (J2)
        W2 += Y2;
      if (Array.isArray(F2)) {
        Q2 = F2.length;
        for (let B2 = 0;B2 < Q2; B2++) {
          if (B2)
            W2 += Y2;
          W2 += w, W2 += kY(F2[B2]);
        }
      } else
        W2 += w, W2 += kY(F2);
    }
    return W2;
  }, { encodeString: U8 } = xY();
  gY.exports = M7;
});
var B8 = H0((jz, B$) => {
  var TY = EY(), dY = fY(), yY = { parse: TY, stringify: dY };
  B$.exports = yY;
  B$.exports.default = yY;
  B$.exports.parse = TY;
  B$.exports.stringify = dY;
});
var _1 = ($, W2) => ({ part: $, store: null, inert: W2 !== undefined ? new Map(W2.map((Y2) => [Y2.part.charCodeAt(0), Y2])) : null, params: null, wildcardStore: null });
var L8 = ($, W2) => ({ ...$, part: W2 });
var C8 = ($) => ({ paramName: $, store: null, inert: null });

class j1 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, W2, Y2) {
    let X2;
    if (typeof W2 != "string")
      throw TypeError("Route path must be a string");
    W2 === "" ? W2 = "/" : W2[0] !== "/" && (W2 = `/${W2}`), this.history.push([$, W2, Y2]);
    let Z = W2[W2.length - 1] === "*";
    Z && (W2 = W2.slice(0, -1));
    let Q2 = W2.split(j1.regex.static), J2 = W2.match(j1.regex.params) || [];
    Q2[Q2.length - 1] === "" && Q2.pop(), X2 = this.root[$] ? this.root[$] : this.root[$] = _1("/");
    let z2 = 0;
    for (let F2 = 0;F2 < Q2.length; ++F2) {
      let w = Q2[F2];
      if (F2 > 0) {
        let B2 = J2[z2++].slice(1);
        if (X2.params === null)
          X2.params = C8(B2);
        else if (X2.params.paramName !== B2)
          throw Error(`Cannot create route "${W2}" with parameter "${B2}" because a route already exists with a different parameter name ("${X2.params.paramName}") in the same location`);
        let S2 = X2.params;
        if (S2.inert === null) {
          X2 = S2.inert = _1(w);
          continue;
        }
        X2 = S2.inert;
      }
      for (let B2 = 0;; ) {
        if (B2 === w.length) {
          if (B2 < X2.part.length) {
            let S2 = L8(X2, X2.part.slice(B2));
            Object.assign(X2, _1(w, [S2]));
          }
          break;
        }
        if (B2 === X2.part.length) {
          if (X2.inert === null)
            X2.inert = new Map;
          else if (X2.inert.has(w.charCodeAt(B2))) {
            X2 = X2.inert.get(w.charCodeAt(B2)), w = w.slice(B2), B2 = 0;
            continue;
          }
          let S2 = _1(w.slice(B2));
          X2.inert.set(w.charCodeAt(B2), S2), X2 = S2;
          break;
        }
        if (w[B2] !== X2.part[B2]) {
          let S2 = L8(X2, X2.part.slice(B2)), G2 = _1(w.slice(B2));
          Object.assign(X2, _1(X2.part.slice(0, B2), [S2, G2])), X2 = G2;
          break;
        }
        ++B2;
      }
    }
    if (z2 < J2.length) {
      let F2 = J2[z2], w = F2.slice(1);
      if (X2.params === null)
        X2.params = C8(w);
      else if (X2.params.paramName !== w)
        throw Error(`Cannot create route "${W2}" with parameter "${w}" because a route already exists with a different parameter name ("${X2.params.paramName}") in the same location`);
      return X2.params.store === null && (X2.params.store = Y2), X2.params.store;
    }
    return Z ? (X2.wildcardStore === null && (X2.wildcardStore = Y2), X2.wildcardStore) : (X2.store === null && (X2.store = Y2), X2.store);
  }
  find($, W2) {
    let Y2 = this.root[$];
    return Y2 ? s$(W2, W2.length, Y2, 0) : null;
  }
}
var s$ = ($, W2, Y2, X2) => {
  let Z = Y2?.part, Q2 = X2 + Z.length;
  if (Z.length > 1) {
    if (Q2 > W2)
      return null;
    if (Z.length < 15) {
      for (let J2 = 1, z2 = X2 + 1;J2 < Z.length; ++J2, ++z2)
        if (Z.charCodeAt(J2) !== $.charCodeAt(z2))
          return null;
    } else if ($.substring(X2, Q2) !== Z)
      return null;
  }
  if (Q2 === W2)
    return Y2.store !== null ? { store: Y2.store, params: {} } : Y2.wildcardStore !== null ? { store: Y2.wildcardStore, params: { "*": "" } } : null;
  if (Y2.inert !== null) {
    let J2 = Y2.inert.get($.charCodeAt(Q2));
    if (J2 !== undefined) {
      let z2 = s$($, W2, J2, Q2);
      if (z2 !== null)
        return z2;
    }
  }
  if (Y2.params !== null) {
    let J2 = Y2.params, z2 = $.indexOf("/", Q2);
    if (z2 !== Q2) {
      if (z2 === -1 || z2 >= W2) {
        if (J2.store !== null) {
          let F2 = {};
          return F2[J2.paramName] = $.substring(Q2, W2), { store: J2.store, params: F2 };
        }
      } else if (J2.inert !== null) {
        let F2 = s$($, W2, J2.inert, z2);
        if (F2 !== null)
          return F2.params[J2.paramName] = $.substring(Q2, z2), F2;
      }
    }
  }
  return Y2.wildcardStore !== null ? { store: Y2.wildcardStore, params: { "*": $.substring(Q2, W2) } } : null;
};
var G8 = Q1(b8(), 1);
var R8 = G8.default;
var _8 = ($, W2) => {
  return async function Y(X2) {
    const Z = X2.id;
    if (X2.event === "request" && X2.type === "begin") {
      const Q2 = $(), J2 = () => {
        let K2, A2, D2 = -1;
        const I2 = [], b2 = [];
        let V2 = false;
        const _2 = new Promise((o) => {
          K2 = (P0) => {
            if (V2)
              return;
            else
              V2 = true;
            o(P0);
          };
        });
        let a = false;
        const e = new Promise((o) => {
          A2 = (P0) => {
            if (a)
              return;
            else
              a = true;
            if (D2 === -1)
              D2 = 0;
            for (;D2 < b2.length; D2++) {
              let F0;
              const C0 = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((Y0) => {
                Y0(F0);
              }), children: [] };
              F0 = performance.now(), I2[D2](C0);
            }
            o(P0);
          };
        });
        return { signal: _2, consumeChild(o) {
          switch (o.type) {
            case "begin":
              const P0 = I2[++D2];
              if (P0)
                P0({ name: o.name, time: o.time, skip: false, end: new Promise((F0) => {
                  b2.push(F0);
                }) });
              else
                this.resolve(), console.log("SKIP");
              break;
            case "end":
              b2[D2]?.(o.time);
              break;
          }
        }, consume(o) {
          switch (o.type) {
            case "begin":
              const P0 = [], F0 = o.unit ?? 0;
              for (let C0 = 0;C0 < F0; C0++) {
                let Y0;
                P0.push(new Promise((X0) => {
                  Y0 = X0;
                })), I2.push(Y0);
              }
              K2({ name: o.name, time: o.time, skip: false, end: e, children: P0 });
              break;
            case "end":
              A2(o.time);
              break;
          }
        }, resolve() {
          if (V2 && a)
            return;
          let o;
          const P0 = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((F0) => {
            F0(o);
          }), children: [] };
          o = performance.now(), K2(P0), A2(o);
        } };
      }, z2 = J2(), F2 = J2(), w = J2(), B2 = J2(), S2 = J2(), G2 = J2(), j = J2(), M2 = J2();
      z2.consume(X2);
      const O = (K2) => {
        if (K2.id === Z)
          switch (K2.event) {
            case "request":
              z2.consume(K2);
              break;
            case "request.unit":
              z2.consumeChild(K2);
              break;
            case "parse":
              F2.consume(K2);
              break;
            case "parse.unit":
              F2.consumeChild(K2);
              break;
            case "transform":
              w.consume(K2);
              break;
            case "transform.unit":
              w.consumeChild(K2);
              break;
            case "beforeHandle":
              B2.consume(K2);
              break;
            case "beforeHandle.unit":
              B2.consumeChild(K2);
              break;
            case "handle":
              S2.consume(K2);
              break;
            case "afterHandle":
              G2.consume(K2);
              break;
            case "afterHandle.unit":
              G2.consumeChild(K2);
              break;
            case "error":
              j.consume(K2);
              break;
            case "error.unit":
              j.consumeChild(K2);
              break;
            case "response":
              if (K2.type === "begin")
                z2.resolve(), F2.resolve(), w.resolve(), B2.resolve(), S2.resolve(), G2.resolve(), j.resolve();
              else
                Q2.off("event", O);
              M2.consume(K2);
              break;
            case "response.unit":
              M2.consumeChild(K2);
              break;
          }
      };
      Q2.on("event", O), await W2({ id: X2.id, context: X2.ctx, set: X2.ctx?.set, store: X2.ctx?.store, time: X2.time, request: z2.signal, parse: F2.signal, transform: w.signal, beforeHandle: B2.signal, handle: S2.signal, afterHandle: G2.signal, error: j.signal, response: M2.signal }), Q2.emit(`res${Z}`, undefined);
    }
  };
};
var $8 = Q1(e6(), 1);
var HY = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var n1 = Symbol("ErrorCode");
var q$ = (HY?.NODE_ENV ?? HY?.ENV) === "production";

class f$ extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class L1 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}
class N$ extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, W2) {
    super(W2 ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class S0 extends Error {
  $;
  W;
  Y;
  code = "VALIDATION";
  status = 400;
  constructor($, W2, Y2) {
    const X2 = q$ ? undefined : W2.Errors(Y2).First(), Z = X2?.schema.error ? typeof X2.schema.error === "function" ? X2.schema.error($, W2, Y2) : X2.schema.error : undefined, Q2 = q$ ? Z ?? `Invalid ${$ ?? X2?.schema.error ?? X2?.message}` : Z ?? `Invalid ${$}, '${X2?.path?.slice(1) || "type"}': ${X2?.message}` + "\n\nExpected: " + JSON.stringify($8.Value.Create(W2.schema), null, 2) + "\n\nFound: " + JSON.stringify(Y2, null, 2);
    super(Q2);
    this.type = $;
    this.validator = W2;
    this.value = Y2;
    Object.setPrototypeOf(this, S0.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  get model() {
    return $8.Value.Create(this.validator.schema);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var W8 = { open($) {
  $.data.open?.($);
}, message($, W2) {
  $.data.message?.($, W2);
}, drain($) {
  $.data.drain?.($);
}, close($, W2, Y2) {
  $.data.close?.($, W2, Y2);
} };

class o1 {
  $;
  W;
  id;
  validator;
  constructor($, W2) {
    this.raw = $;
    this.data = W2;
    this.validator = $.data.validator, this.id = Date.now();
  }
  get publish() {
    return ($, W2 = undefined, Y2) => {
      if (this.validator?.Check(W2) === false)
        throw new S0("message", this.validator, W2);
      if (typeof W2 === "object")
        W2 = JSON.stringify(W2);
      return this.raw.publish($, W2, Y2), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new S0("message", this.validator, $);
      if (Buffer.isBuffer($))
        return this.raw.send($), this;
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var u9 = function($, W2) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var Y2 = {}, X2 = W2 || {}, Z = X2.decode || n9, Q2 = 0;
  while (Q2 < $.length) {
    var J2 = $.indexOf("=", Q2);
    if (J2 === -1)
      break;
    var z2 = $.indexOf(";", Q2);
    if (z2 === -1)
      z2 = $.length;
    else if (z2 < J2) {
      Q2 = $.lastIndexOf(";", J2 - 1) + 1;
      continue;
    }
    var F2 = $.slice(Q2, J2).trim();
    if (Y2[F2] === undefined) {
      var w = $.slice(J2 + 1, z2).trim();
      if (w.charCodeAt(0) === 34)
        w = w.slice(1, -1);
      Y2[F2] = l9(w, Z);
    }
    Q2 = z2 + 1;
  }
  return Y2;
};
var h9 = function($, W2, Y2) {
  var X2 = Y2 || {}, Z = X2.encode || o9;
  if (typeof Z !== "function")
    throw new TypeError("option encode is invalid");
  if (!T$.test($))
    throw new TypeError("argument name is invalid");
  var Q2 = Z(W2);
  if (Q2 && !T$.test(Q2))
    throw new TypeError("argument val is invalid");
  var J2 = $ + "=" + Q2;
  if (X2.maxAge != null) {
    var z2 = X2.maxAge - 0;
    if (isNaN(z2) || !isFinite(z2))
      throw new TypeError("option maxAge is invalid");
    J2 += "; Max-Age=" + Math.floor(z2);
  }
  if (X2.domain) {
    if (!T$.test(X2.domain))
      throw new TypeError("option domain is invalid");
    J2 += "; Domain=" + X2.domain;
  }
  if (X2.path) {
    if (!T$.test(X2.path))
      throw new TypeError("option path is invalid");
    J2 += "; Path=" + X2.path;
  }
  if (X2.expires) {
    var F2 = X2.expires;
    if (!c9(F2) || isNaN(F2.valueOf()))
      throw new TypeError("option expires is invalid");
    J2 += "; Expires=" + F2.toUTCString();
  }
  if (X2.httpOnly)
    J2 += "; HttpOnly";
  if (X2.secure)
    J2 += "; Secure";
  if (X2.priority) {
    var w = typeof X2.priority === "string" ? X2.priority.toLowerCase() : X2.priority;
    switch (w) {
      case "low":
        J2 += "; Priority=Low";
        break;
      case "medium":
        J2 += "; Priority=Medium";
        break;
      case "high":
        J2 += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (X2.sameSite) {
    var B2 = typeof X2.sameSite === "string" ? X2.sameSite.toLowerCase() : X2.sameSite;
    switch (B2) {
      case true:
        J2 += "; SameSite=Strict";
        break;
      case "lax":
        J2 += "; SameSite=Lax";
        break;
      case "strict":
        J2 += "; SameSite=Strict";
        break;
      case "none":
        J2 += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return J2;
};
var n9 = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var o9 = function($) {
  return encodeURIComponent($);
};
var c9 = function($) {
  return m9.call($) === "[object Date]" || $ instanceof Date;
};
var l9 = function($, W2) {
  try {
    return W2($);
  } catch (Y2) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var d$ = u9;
var y$ = h9;
var m9 = Object.prototype.toString;
var T$ = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var i$ = Q1(f0(), 1);
var F$ = Q1(e6(), 1);
var z8 = Q1(BY(), 1);
var J8 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var Z7 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") || t0(Object.getPrototypeOf($));
var F1 = ($, W2, { skipKeys: Y2 } = {}) => {
  if (J8($) && J8(W2))
    for (let [X2, Z] of Object.entries(W2)) {
      if (Y2?.includes(X2))
        continue;
      if (!J8(Z)) {
        $[X2] = Z;
        continue;
      }
      if (!(X2 in $)) {
        $[X2] = Z;
        continue;
      }
      if (Z7(Z)) {
        $[X2] = Z;
        continue;
      }
      $[X2] = F1($[X2], Z);
    }
  return $;
};
var DY = ($, W2) => F1($, W2, { skipKeys: ["properties"] });
var L0 = ($, W2) => {
  const Y2 = [...Array.isArray($) ? $ : [$]], X2 = [];
  for (let Z of Y2)
    if (Z.$elysiaChecksum)
      X2.push(Z.$elysiaChecksum);
  for (let Z of Array.isArray(W2) ? W2 : [W2])
    if (!X2.includes(Z?.$elysiaChecksum))
      Y2.push(Z);
  return Y2;
};
var I1 = ($, W2) => {
  return { body: W2?.body ?? $?.body, headers: W2?.headers ?? $?.headers, params: W2?.params ?? $?.params, query: W2?.query ?? $?.query, response: W2?.response ?? $?.response, type: $?.type || W2?.type, detail: F1(W2?.detail ?? {}, $?.detail ?? {}), parse: L0($?.parse ?? [], W2?.parse ?? []), transform: L0($?.transform ?? [], W2?.transform ?? []), beforeHandle: L0($?.beforeHandle ?? [], W2?.beforeHandle ?? []), afterHandle: L0($?.afterHandle ?? [], W2?.afterHandle ?? []), onResponse: L0($?.onResponse ?? [], W2?.onResponse ?? []), trace: L0($?.trace ?? [], W2?.trace ?? []), error: L0($?.error ?? [], W2?.error ?? []) };
};
var X1 = ($, { models: W2 = {}, additionalProperties: Y2 = false, dynamic: X2 = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in W2))
    return;
  const Z = typeof $ === "string" ? W2[$] : $;
  if (Z.type === "object" && ("additionalProperties" in Z) === false)
    Z.additionalProperties = Y2;
  if (X2)
    return { schema: Z, references: "", checkFunc: () => {
    }, code: "", Check: (Q2) => F$.Value.Check(Z, Q2), Errors: (Q2) => F$.Value.Errors(Z, Q2), Code: () => "" };
  return z8.TypeCompiler.Compile(Z);
};
var H8 = ($, { models: W2 = {}, additionalProperties: Y2 = false, dynamic: X2 = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in W2))
    return;
  const Z = typeof $ === "string" ? W2[$] : $, Q2 = (z2) => {
    if (X2)
      return { schema: z2, references: "", checkFunc: () => {
      }, code: "", Check: (F2) => F$.Value.Check(z2, F2), Errors: (F2) => F$.Value.Errors(z2, F2), Code: () => "" };
    return z8.TypeCompiler.Compile(z2);
  };
  if (i$.Kind in Z) {
    if (("additionalProperties" in Z) === false)
      Z.additionalProperties = Y2;
    return { 200: Q2(Z) };
  }
  const J2 = {};
  return Object.keys(Z).forEach((z2) => {
    const F2 = Z[+z2];
    if (typeof F2 === "string") {
      if (F2 in W2) {
        const w = W2[F2];
        w.type === "object" && ("additionalProperties" in w), J2[+z2] = (i$.Kind in w) ? Q2(w) : w;
      }
      return;
    }
    if (F2.type === "object" && ("additionalProperties" in F2) === false)
      F2.additionalProperties = Y2;
    J2[+z2] = (i$.Kind in F2) ? Q2(F2) : F2;
  }), J2;
};
var q8 = ($) => {
  let W2 = 9;
  for (let Y2 = 0;Y2 < $.length; )
    W2 = Math.imul(W2 ^ $.charCodeAt(Y2++), 387420489);
  return W2 = W2 ^ W2 >>> 9;
};
var m$ = ($, W2, Y2) => {
  const X2 = (Z) => {
    if (Y2)
      Z.$elysiaChecksum = Y2;
    return Z;
  };
  return { start: L0($.start, ("start" in W2 ? W2.start ?? [] : []).map(X2)), request: L0($.request, ("request" in W2 ? W2.request ?? [] : []).map(X2)), parse: L0($.parse, "parse" in W2 ? W2?.parse ?? [] : []).map(X2), transform: L0($.transform, (W2?.transform ?? []).map(X2)), beforeHandle: L0($.beforeHandle, (W2?.beforeHandle ?? []).map(X2)), afterHandle: L0($.afterHandle, (W2?.afterHandle ?? []).map(X2)), onResponse: L0($.onResponse, (W2?.onResponse ?? []).map(X2)), trace: L0($.trace, ("trace" in W2 ? W2.trace ?? [] : []).map(X2)), error: L0($.error, (W2?.error ?? []).map(X2)), stop: L0($.stop, ("stop" in W2 ? W2.stop ?? [] : []).map(X2)) };
};
var wY = ($, W2 = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (W2)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((Y2) => {
    if (W2)
      Y2.$elysiaHookType = "global";
    else
      Y2.$elysiaHookType = undefined;
    return Y2;
  });
};
var c1 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((W2) => W2.$elysiaHookType === "global");
};
var N8 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: c1($?.parse), transform: c1($?.transform), beforeHandle: c1($?.beforeHandle), afterHandle: c1($?.afterHandle), onResponse: c1($?.onResponse), error: c1($?.error) };
};
var M8 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var l1 = async ($, W2) => {
  if (typeof $ !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (W2 === null)
    throw new TypeError("Secret key must be provided.");
  const Y2 = new TextEncoder, X2 = await crypto.subtle.importKey("raw", Y2.encode(W2), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), Z = await crypto.subtle.sign("HMAC", X2, Y2.encode($)), Q2 = Array.from(new Uint8Array(Z)), J2 = btoa(String.fromCharCode(...Q2));
  return `${$}.${J2.replace(/=+$/, "")}`;
};
var A8 = async ($, W2) => {
  if (typeof $ !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (W2 === null)
    throw new TypeError("Secret key must be provided.");
  const Y2 = $.slice(0, $.lastIndexOf("."));
  return await l1(Y2, W2) === $ ? Y2 : false;
};

class s0 {
  $;
  W;
  name;
  setter;
  constructor($, W2 = {}) {
    this._value = $;
    this.property = W2;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const W2 = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in W2)
      this._value = W2.value, delete W2.value;
    return this.property = W2, this.sync();
  }
  set($) {
    const W2 = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in W2)
      this._value = W2.value, delete W2.value;
    return this.property = W2, this.sync();
  }
  remove($) {
    if (this.value === undefined)
      return;
    this.set({ domain: $?.domain, expires: new Date(0), maxAge: 0, path: $?.path, sameSite: $?.sameSite, secure: $?.secure, value: "" });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    if (this.property.domain === $)
      return;
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    if (this.property.expires?.getTime() === $?.getTime())
      return;
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    if (this.property.domain === $)
      return;
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    if (this.property.maxAge === $)
      return;
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    if (this.property.path === $)
      return;
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    if (this.property.priority === $)
      return;
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    if (this.property.sameSite === $)
      return;
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    if (this.property.secure === $)
      return;
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var KY = ($, W2, Y2) => new Proxy($, { get(X2, Z) {
  if (Z in X2)
    return X2[Z];
  const Q2 = new s0(undefined, Y2 ? { ...Y2 } : undefined);
  return Q2.setter = W2, Q2.name = Z, Q2;
}, set(X2, Z, Q2) {
  if (!(Q2 instanceof s0))
    return false;
  if (!W2.cookie)
    W2.cookie = {};
  return Q2.setter = W2, Q2.name = Z, Q2.sync(), X2[Z] = Q2, true;
} });
var u$ = async ($, W2, { secret: Y2, sign: X2, ...Z } = {}) => {
  if (!W2)
    return KY({}, $, Z);
  const Q2 = {}, J2 = typeof Y2 === "string";
  if (X2 && X2 !== true && !Array.isArray(X2))
    X2 = [X2];
  const z2 = Object.keys(d$(W2));
  for (let F2 = 0;F2 < z2.length; F2++) {
    const w = z2[F2];
    let B2 = d$(W2)[w];
    if (X2 === true || X2?.includes(w)) {
      if (!Y2)
        throw new Error("No secret is provided to cookie plugin");
      if (J2) {
        if (B2 = await A8(B2, Y2), B2 === false)
          throw new N$(w);
      } else {
        let j = true;
        for (let M2 = 0;M2 < Y2.length; M2++) {
          const O = await A8(B2, Y2[M2]);
          if (O !== false) {
            B2 = O, j = false;
            break;
          }
        }
        if (j)
          throw new N$(w);
      }
    }
    if (B2 === undefined)
      continue;
    const S2 = B2.charCodeAt(0);
    if (S2 === 123 || S2 === 91)
      try {
        const j = new s0(JSON.parse(B2));
        j.setter = $, j.name = w, Q2[w] = j;
        continue;
      } catch {
      }
    if (!Number.isNaN(+B2))
      B2 = +B2;
    else if (B2 === "true")
      B2 = true;
    else if (B2 === "false")
      B2 = false;
    const G2 = new s0(B2, Z);
    G2.setter = $, G2.name = w, Q2[w] = G2;
  }
  return KY(Q2, $);
};
var jY = "toJSON" in new Headers;
var t0 = ($) => {
  for (let W2 in $)
    return true;
  return false;
};
var PY = ($, W2) => {
  if (!$ || !Array.isArray(W2))
    return $;
  $.delete("Set-Cookie");
  for (let Y2 = 0;Y2 < W2.length; Y2++) {
    const X2 = W2[Y2].indexOf("=");
    $.append("Set-Cookie", `${W2[Y2].slice(0, X2)}=${W2[Y2].slice(X2 + 1)}`);
  }
  return $;
};
var OY = ($) => {
  if (!$ || typeof $ !== "object" || !t0($))
    return;
  const W2 = [];
  for (let [Y2, X2] of Object.entries($)) {
    if (!Y2 || !X2)
      continue;
    if (Array.isArray(X2.value))
      for (let Z = 0;Z < X2.value.length; Z++) {
        let Q2 = X2.value[Z];
        if (Q2 === undefined || Q2 === null)
          continue;
        if (typeof Q2 === "object")
          Q2 = JSON.stringify(Q2);
        W2.push(y$(Y2, Q2, X2));
      }
    else {
      let Z = X2.value;
      if (Z === undefined || Z === null)
        continue;
      if (typeof Z === "object")
        Z = JSON.stringify(Z);
      W2.push(y$(Y2, X2.value, X2));
    }
  }
  if (W2.length === 0)
    return;
  if (W2.length === 1)
    return W2[0];
  return W2;
};
var U1 = ($, W2) => {
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if (t0(W2.headers) || W2.status !== 200 || W2.redirect || W2.cookie) {
    if (typeof W2.status === "string")
      W2.status = M8[W2.status];
    if (W2.redirect) {
      if (W2.headers.Location = W2.redirect, !W2.status || W2.status < 300 || W2.status >= 400)
        W2.status = 302;
    }
    if (W2.cookie && t0(W2.cookie))
      W2.headers["Set-Cookie"] = OY(W2.cookie);
    if (W2.headers["Set-Cookie"] && Array.isArray(W2.headers["Set-Cookie"]))
      W2.headers = PY(new Headers(W2.headers), W2.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, { status: W2.status, headers: W2.headers });
      case "Object":
      case "Array":
        return Response.json($, W2);
      case undefined:
        if (!$)
          return new Response("", W2);
        return Response.json($, W2);
      case "Response":
        const Y2 = { ...W2.headers };
        if (jY)
          W2.headers = $.headers.toJSON();
        else
          for (let [Z, Q2] of $.headers.entries())
            if (Z in W2.headers)
              W2.headers[Z] = Q2;
        for (let Z in Y2)
          $.headers.append(Z, Y2[Z]);
        return $;
      case "Error":
        return U$($, W2);
      case "Promise":
        return $.then((Z) => U1(Z, W2));
      case "Function":
        return U1($(), W2);
      case "Number":
      case "Boolean":
        return new Response($.toString(), W2);
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, W2);
        return new Response($?.toString(), W2);
      default:
        const X2 = JSON.stringify($);
        if (X2.charCodeAt(0) === 123) {
          if (!W2.headers["Content-Type"])
            W2.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), W2);
        }
        return new Response(X2, W2);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return U$($, W2);
      case "Promise":
        return $.then((X2) => {
          const Z = K1(X2);
          if (Z !== undefined)
            return Z;
          return new Response("");
        });
      case "Function":
        return K1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, W2);
        return new Response($?.toString(), W2);
      default:
        const Y2 = JSON.stringify($);
        if (Y2.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(Y2);
    }
};
var r0 = ($, W2) => {
  if ($ === undefined || $ === null)
    return;
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if (t0(W2.headers) || W2.status !== 200 || W2.redirect || W2.cookie) {
    if (typeof W2.status === "string")
      W2.status = M8[W2.status];
    if (W2.redirect) {
      if (W2.headers.Location = W2.redirect, !W2.status || W2.status < 300 || W2.status >= 400)
        W2.status = 302;
    }
    if (W2.cookie && t0(W2.cookie))
      W2.headers["Set-Cookie"] = OY(W2.cookie);
    if (W2.headers["Set-Cookie"] && Array.isArray(W2.headers["Set-Cookie"]))
      W2.headers = PY(new Headers(W2.headers), W2.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, W2);
      case "Object":
      case "Array":
        return Response.json($, W2);
      case "ReadableStream":
        if (!W2.headers["content-type"]?.startsWith("text/event-stream"))
          W2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, W2);
      case undefined:
        if (!$)
          return;
        return Response.json($, W2);
      case "Response":
        const Y2 = Object.assign({}, W2.headers);
        if (jY)
          W2.headers = $.headers.toJSON();
        else
          for (let [Z, Q2] of $.headers.entries())
            if (!(Z in W2.headers))
              W2.headers[Z] = Q2;
        for (let Z in Y2)
          $.headers.append(Z, Y2[Z]);
        if ($.status !== W2.status)
          W2.status = $.status;
        return $;
      case "Promise":
        return $.then((Z) => {
          const Q2 = r0(Z, W2);
          if (Q2 !== undefined)
            return Q2;
          return;
        });
      case "Error":
        return U$($, W2);
      case "Function":
        return r0($(), W2);
      case "Number":
      case "Boolean":
        return new Response($.toString(), W2);
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, W2);
        return new Response($?.toString(), W2);
      default:
        const X2 = JSON.stringify($);
        if (X2.charCodeAt(0) === 123) {
          if (!W2.headers["Content-Type"])
            W2.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), W2);
        }
        return new Response(X2, W2);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((X2) => {
          const Z = r0(X2, W2);
          if (Z !== undefined)
            return Z;
          return;
        });
      case "Error":
        return U$($, W2);
      case "Function":
        return K1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, W2);
        return new Response($?.toString(), W2);
      default:
        const Y2 = JSON.stringify($);
        if (Y2.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(Y2);
    }
};
var K1 = ($) => {
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  switch ($?.constructor?.name) {
    case "String":
    case "Blob":
      return new Response($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "ReadableStream":
      return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return U$($);
    case "Promise":
      return $.then((Y2) => {
        const X2 = K1(Y2);
        if (X2 !== undefined)
          return X2;
        return new Response("");
      });
    case "Function":
      return K1($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      const W2 = JSON.stringify($);
      if (W2.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(W2);
  }
};
var U$ = ($, W2) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: W2?.status !== 200 ? W2?.status ?? 500 : 500, headers: W2?.headers });
var vY = Q1(B8(), 1);
var A7 = new Headers().toJSON;
var pY = new RegExp(" (\\w+) = context", "g");
var iY = { value: 0 };
var mY = ({ hasTrace: $, hasTraceSet: W2 = false, addFn: Y2, condition: X2 = {} }) => {
  if (Y2("\nconst reporter = getReporter()\n"), $)
    return (Z, { name: Q2, attribute: J2 = "", unit: z2 = 0 } = {}) => {
      const F2 = Z.indexOf("."), w = F2 === -1;
      if (Z !== "request" && Z !== "response" && !X2[w ? Z : Z.slice(0, F2)])
        return () => {
          if (W2 && Z === "afterHandle")
            Y2("\nawait traceDone\n");
        };
      if (w)
        Q2 ||= Z;
      else
        Q2 ||= "anonymous";
      Y2("\n" + `reporter.emit('event', { 
					id,
					event: '${Z}',
					type: 'begin',
					name: '${Q2}',
					time: performance.now(),
					${w ? `unit: ${z2},` : ""}
					${J2}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let B2 = false;
      return () => {
        if (B2)
          return;
        if (B2 = true, Y2("\n" + `reporter.emit('event', {
							id,
							event: '${Z}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), W2 && Z === "afterHandle")
          Y2("\nawait traceDone\n");
      };
    };
  else
    return () => () => {
    };
};
var D$ = ($) => {
  const W2 = $.indexOf(")");
  if ($.charCodeAt(W2 + 2) === 61 && $.charCodeAt(W2 + 5) !== 123)
    return true;
  return $.includes("return");
};
var F7 = ($, { injectResponse: W2 = "" } = {}) => ({ composeValidation: (Y2, X2 = `c.${Y2}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${Y2}',
${Y2},
${X2}
)` : `c.set.status = 400; return new ValidationError(
	'${Y2}',
	${Y2},
	${X2}
).toResponse(c.set.headers)`, composeResponseValidation: (Y2 = "r") => {
  const X2 = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${Y2}
)` : `return new ValidationError(
'response',
response[c.set.status],
${Y2}
).toResponse(c.set.headers)`;
  return `\n${W2}
		if(response[c.set.status]?.Check(${Y2}) === false) { 
	if(!(response instanceof Error))
		${X2}
}\n`;
} });
var j0 = ($, W2) => {
  if (W2 = W2.trimStart(), W2 = W2.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(W2))
    W2 = W2.slice(W2.indexOf("("));
  const Y2 = W2.charCodeAt(0) === 40 || W2.startsWith("function") ? W2.slice(W2.indexOf("(") + 1, W2.indexOf(")")) : W2.slice(0, W2.indexOf("=") - 1);
  if (Y2 === "")
    return false;
  const X2 = Y2.charCodeAt(0) === 123 ? Y2.indexOf("...") : -1;
  if (Y2.charCodeAt(0) === 123) {
    if (Y2.includes($))
      return true;
    if (X2 === -1)
      return false;
  }
  if (W2.match(new RegExp(`${Y2}(.${$}|\\["${$}"\\])`)))
    return true;
  const Z = X2 !== -1 ? Y2.slice(X2 + 3, Y2.indexOf(" ", X2 + 3)) : undefined;
  if (W2.match(new RegExp(`${Z}(.${$}|\\["${$}"\\])`)))
    return true;
  const Q2 = [Y2];
  if (Z)
    Q2.push(Z);
  for (let z2 of W2.matchAll(pY))
    Q2.push(z2[1]);
  const J2 = new RegExp(`{.*?} = (${Q2.join("|")})`, "g");
  for (let [z2] of W2.matchAll(J2))
    if (z2.includes(`{ ${$}`) || z2.includes(`, ${$}`))
      return true;
  return false;
};
var w$ = ($) => {
  if ($ = $.trimStart(), $ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const W2 = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (W2 === "")
    return false;
  const Y2 = W2.charCodeAt(0) === 123 ? W2.indexOf("...") : -1, X2 = Y2 !== -1 ? W2.slice(Y2 + 3, W2.indexOf(" ", Y2 + 3)) : undefined, Z = [W2];
  if (X2)
    Z.push(X2);
  for (let J2 of $.matchAll(pY))
    Z.push(J2[1]);
  for (let J2 of Z)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J2}\\b[^)]*\\)`).test($))
      return true;
  const Q2 = new RegExp(`{.*?} = (${Z.join("|")})`, "g");
  for (let [J2] of $.matchAll(Q2))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J2}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var t1 = Symbol.for("TypeBox.Kind");
var h$ = ($, W2) => {
  if (!W2)
    return;
  if ((t1 in W2) && W2[t1] === $)
    return true;
  if (W2.type === "object") {
    const Y2 = W2.properties;
    for (let X2 of Object.keys(Y2)) {
      const Z = Y2[X2];
      if (Z.type === "object") {
        if (h$($, Z))
          return true;
      } else if (Z.anyOf) {
        for (let Q2 = 0;Q2 < Z.anyOf.length; Q2++)
          if (h$($, Z.anyOf[Q2]))
            return true;
      }
      if ((t1 in Z) && Z[t1] === $)
        return true;
    }
    return false;
  }
  return W2.properties && (t1 in W2.properties) && W2.properties[t1] === $;
};
var D8 = Symbol.for("TypeBox.Transform");
var b1 = ($) => {
  if (!$)
    return;
  if ($.type === "object" && $.properties) {
    const W2 = $.properties;
    for (let Y2 of Object.keys(W2)) {
      const X2 = W2[Y2];
      if (X2.type === "object") {
        if (b1(X2))
          return true;
      } else if (X2.anyOf) {
        for (let Q2 = 0;Q2 < X2.anyOf.length; Q2++)
          if (b1(X2.anyOf[Q2]))
            return true;
      }
      if (D8 in X2)
        return true;
    }
    return false;
  }
  return (D8 in $) || $.properties && (D8 in $.properties);
};
var U7 = ($) => {
  if (!$)
    return;
  const W2 = $?.schema;
  if (W2 && ("anyOf" in W2)) {
    let Y2 = false;
    const X2 = W2.anyOf[0].type;
    for (let Z of W2.anyOf)
      if (Z.type !== X2) {
        Y2 = true;
        break;
      }
    if (!Y2)
      return X2;
  }
  return $.schema?.type;
};
var B7 = /(?:return|=>) \S*\(/g;
var M0 = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  return $.toString().match(B7);
};
var uY = ({ path: $, method: W2, hooks: Y2, validator: X2, handler: Z, handleError: Q2, definitions: J2, schema: z2, onRequest: F2, config: w, getReporter: B2 }) => {
  const S2 = w.forceErrorEncapsulation || Y2.error.length > 0 || typeof Bun === "undefined" || Y2.onResponse.length > 0 || !!Y2.trace.length, G2 = Y2.onResponse.length ? `\n;(async () => {${Y2.onResponse.map((R2, f) => `await res${f}(c)`).join(";")}})();\n` : "", j = Y2.trace.map((R2) => R2.toString());
  let M2 = false;
  if (w$(Z.toString()))
    M2 = true;
  if (!M2)
    for (let [R2, f] of Object.entries(Y2)) {
      if (!Array.isArray(f) || !f.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(R2))
        continue;
      for (let i of f) {
        if (typeof i !== "function")
          continue;
        if (w$(i.toString())) {
          M2 = true;
          break;
        }
      }
      if (M2)
        break;
    }
  const O = { parse: j.some((R2) => j0("parse", R2)), transform: j.some((R2) => j0("transform", R2)), handle: j.some((R2) => j0("handle", R2)), beforeHandle: j.some((R2) => j0("beforeHandle", R2)), afterHandle: j.some((R2) => j0("afterHandle", R2)), error: S2 || j.some((R2) => j0("error", R2)) }, K2 = Y2.trace.length > 0;
  let A2 = "";
  const D2 = X2 || W2 !== "GET" && W2 !== "HEAD" ? [Z, ...Y2.transform, ...Y2.beforeHandle, ...Y2.afterHandle].map((R2) => R2.toString()) : [], I2 = M2 || W2 !== "GET" && W2 !== "HEAD" && Y2.type !== "none" && (!!X2.body || !!Y2.type || D2.some((R2) => j0("body", R2))), b2 = M2 || X2.headers || D2.some((R2) => j0("headers", R2)), V2 = M2 || X2.cookie || D2.some((R2) => j0("cookie", R2)), _2 = X2?.cookie?.schema;
  let a = "";
  if (_2?.sign) {
    if (!_2.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${W2}) ${$}.`);
    const R2 = !_2.secrets ? undefined : typeof _2.secrets === "string" ? _2.secrets : _2.secrets[0];
    if (a += `const _setCookie = c.set.cookie
		if(_setCookie) {`, _2.sign === true)
      a += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${R2}')
			}`;
    else
      for (let f of _2.sign)
        a += `if(_setCookie['${f}']?.value) { c.set.cookie['${f}'].value = await signCookie(_setCookie['${f}'].value, '${R2}') }\n`;
    a += "}\n";
  }
  const { composeValidation: e, composeResponseValidation: o } = F7(S2);
  if (b2)
    A2 += A7 ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (V2) {
    const R2 = (i, u) => {
      const q0 = _2?.[i] ?? u;
      if (!q0)
        return typeof u === "string" ? `${i}: "${u}",` : `${i}: ${u},`;
      if (typeof q0 === "string")
        return `${i}: '${q0}',`;
      if (q0 instanceof Date)
        return `${i}: new Date(${q0.getTime()}),`;
      return `${i}: ${q0},`;
    }, f = _2 ? `{
			secret: ${_2.secrets !== undefined ? typeof _2.secrets === "string" ? `'${_2.secrets}'` : "[" + _2.secrets.reduce((i, u) => i + `'${u}',`, "") + "]" : "undefined"},
			sign: ${_2.sign === true ? true : _2.sign !== undefined ? "[" + _2.sign.reduce((i, u) => i + `'${u}',`, "") + "]" : "undefined"},
			${R2("domain")}
			${R2("expires")}
			${R2("httpOnly")}
			${R2("maxAge")}
			${R2("path", "/")}
			${R2("priority")}
			${R2("sameSite")}
			${R2("secure")}
		}` : "undefined";
    if (b2)
      A2 += `\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${f})\n`;
    else
      A2 += `\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${f})\n`;
  }
  if (M2 || X2.query || D2.some((R2) => j0("query", R2)))
    A2 += `const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`;
  const C0 = Y2.trace.map((R2) => R2.toString()).some((R2) => j0("set", R2) || w$(R2));
  M2 || Y2.trace.some((R2) => j0("set", R2.toString()));
  const Y0 = C0 || V2 || D2.some((R2) => j0("set", R2)) || F2.some((R2) => j0("set", R2.toString()));
  if (K2)
    A2 += "\nconst id = c.$$requestId\n";
  const X0 = mY({ hasTrace: K2, hasTraceSet: C0, condition: O, addFn: (R2) => {
    A2 += R2;
  } });
  if (A2 += S2 ? "try {\n" : "", K2)
    A2 += "\nconst traceDone = new Promise(r => { reporter.once(`res${id}`, r) })\n";
  const u0 = V2 || I2 || C0 || M0(Z) || Y2.parse.length > 0 || Y2.afterHandle.some(M0) || Y2.beforeHandle.some(M0) || Y2.transform.some(M0), a0 = X0("parse", { unit: Y2.parse.length });
  if (I2) {
    const R2 = U7(X2?.body);
    if (Y2.type && !Array.isArray(Y2.type)) {
      if (Y2.type)
        switch (Y2.type) {
          case "json":
          case "application/json":
            A2 += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            A2 += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            A2 += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            A2 += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            A2 += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (Y2.parse.length)
        A2 += "}}";
    } else {
      const i = (() => {
        if (Y2.parse.length && R2 && !Array.isArray(Y2.type)) {
          const u = X2?.body?.schema;
          switch (R2) {
            case "object":
              if (h$("File", u) || h$("Files", u))
                return `c.body = {}
		
								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue
			
									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (i)
        A2 += i;
      else {
        if (A2 += "\n", A2 += b2 ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", A2 += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, Y2.parse.length) {
          A2 += "let used = false\n";
          const u = X0("parse", { unit: Y2.parse.length });
          for (let q0 = 0;q0 < Y2.parse.length; q0++) {
            const D0 = X0("parse.unit", { name: Y2.parse[q0].name }), w0 = `bo${q0}`;
            if (q0 !== 0)
              A2 += "if(!used) {\n";
            if (A2 += `let ${w0} = parse[${q0}](c, contentType)\n`, A2 += `if(${w0} instanceof Promise) ${w0} = await ${w0}\n`, A2 += `if(${w0} !== undefined) { c.body = ${w0}; used = true }\n`, D0(), q0 !== 0)
              A2 += "}";
          }
          u();
        }
        if (Y2.parse.length)
          A2 += "if (!used)";
        A2 += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break
				
					case 'text/plain':
						c.body = await c.request.text()
						break
				
					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break
				
					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break
				
					case 'multipart/form-data':
						c.body = {}
				
						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue
				
							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
				
						break
					}\n`, A2 += "}\n";
      }
    }
    A2 += "\n";
  }
  if (a0(), Y2?.transform) {
    const R2 = X0("transform", { unit: Y2.transform.length });
    for (let f = 0;f < Y2.transform.length; f++) {
      const i = Y2.transform[f], u = X0("transform.unit", { name: i.name });
      if (i.$elysia === "derive")
        A2 += M0(Y2.transform[f]) ? `Object.assign(c, await transform[${f}](c));` : `Object.assign(c, transform[${f}](c));`;
      else
        A2 += M0(Y2.transform[f]) ? `await transform[${f}](c);` : `transform[${f}](c);`;
      u();
    }
    R2();
  }
  if (X2) {
    if (A2 += "\n", X2.headers) {
      if (A2 += `if(headers.Check(c.headers) === false) {
				${e("headers")}
			}`, b1(X2.headers.schema))
        A2 += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (X2.params) {
      if (A2 += `if(params.Check(c.params) === false) {
				${e("params")}
			}`, b1(X2.params.schema))
        A2 += "\nc.params = params.Decode(c.params)\n";
    }
    if (X2.query) {
      if (A2 += `if(query.Check(c.query) === false) {
				${e("query")} 
			}`, b1(X2.query.schema))
        A2 += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (X2.body) {
      if (A2 += `if(body.Check(c.body) === false) { 
				${e("body")}
			}`, b1(X2.body.schema))
        A2 += "\nc.body = body.Decode(c.body)\n";
    }
    if (t0(X2.cookie?.schema.properties ?? {})) {
      if (A2 += `const cookieValue = {}
			for(const [key, value] of Object.entries(c.cookie))
				cookieValue[key] = value.value

			if(cookie.Check(cookieValue) === false) {
				${e("cookie", "cookieValue")}
			}`, b1(X2.cookie.schema))
        A2 += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (Y2?.beforeHandle) {
    const R2 = X0("beforeHandle", { unit: Y2.beforeHandle.length });
    for (let f = 0;f < Y2.beforeHandle.length; f++) {
      const i = X0("beforeHandle.unit", { name: Y2.beforeHandle[f].name }), u = `be${f}`;
      if (!D$(Y2.beforeHandle[f].toString()))
        A2 += M0(Y2.beforeHandle[f]) ? `await beforeHandle[${f}](c);\n` : `beforeHandle[${f}](c);\n`, i();
      else {
        A2 += M0(Y2.beforeHandle[f]) ? `let ${u} = await beforeHandle[${f}](c);\n` : `let ${u} = beforeHandle[${f}](c);\n`, i(), A2 += `if(${u} !== undefined) {\n`;
        const D0 = X0("afterHandle", { unit: Y2.transform.length });
        if (Y2.afterHandle) {
          const w0 = u;
          for (let K0 = 0;K0 < Y2.afterHandle.length; K0++) {
            const N0 = D$(Y2.afterHandle[K0].toString()), B1 = X0("afterHandle.unit", { name: Y2.afterHandle[K0].name });
            if (A2 += `c.response = ${w0}\n`, !N0)
              A2 += M0(Y2.afterHandle[K0]) ? `await afterHandle[${K0}](c, ${w0});\n` : `afterHandle[${K0}](c, ${w0});\n`;
            else {
              const P2 = `af${K0}`;
              A2 += M0(Y2.afterHandle[K0]) ? `const ${P2} = await afterHandle[${K0}](c);\n` : `const ${P2} = afterHandle[${K0}](c);\n`, A2 += `if(${P2} !== undefined) { c.response = ${w0} = ${P2} }\n`;
            }
            B1();
          }
        }
        if (D0(), X2.response)
          A2 += o(u);
        A2 += a, A2 += `return mapEarlyResponse(${u}, c.set)}\n`;
      }
    }
    R2();
  }
  if (Y2?.afterHandle.length) {
    const R2 = X0("handle", { name: Z.name });
    if (Y2.afterHandle.length)
      A2 += M0(Z) ? "let r = c.response = await handler(c);\n" : "let r = c.response = handler(c);\n";
    else
      A2 += M0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n";
    R2();
    const f = X0("afterHandle", { unit: Y2.afterHandle.length });
    for (let i = 0;i < Y2.afterHandle.length; i++) {
      const u = `af${i}`, q0 = D$(Y2.afterHandle[i].toString()), D0 = X0("afterHandle.unit", { name: Y2.afterHandle[i].name });
      if (!q0)
        A2 += M0(Y2.afterHandle[i]) ? `await afterHandle[${i}](c)\n` : `afterHandle[${i}](c)\n`, D0();
      else {
        if (X2.response)
          A2 += M0(Y2.afterHandle[i]) ? `let ${u} = await afterHandle[${i}](c)\n` : `let ${u} = afterHandle[${i}](c)\n`;
        else
          A2 += M0(Y2.afterHandle[i]) ? `let ${u} = mapEarlyResponse(await afterHandle[${i}](c), c.set)\n` : `let ${u} = mapEarlyResponse(afterHandle[${i}](c), c.set)\n`;
        if (D0(), X2.response) {
          if (A2 += `if(${u} !== undefined) {`, A2 += o(u), A2 += `${u} = mapEarlyResponse(${u}, c.set)\n`, A2 += `if(${u}) {`, f(), C0)
            A2 += `${u} = mapEarlyResponse(${u}, c.set)\n`;
          A2 += `return ${u} } }`;
        } else {
          if (A2 += `if(${u}) {`, f(), C0)
            A2 += `${u} = mapEarlyResponse(${u}, c.set)\n`;
          A2 += `return ${u}}\n`;
        }
      }
    }
    if (f(), A2 += "r = c.response\n", X2.response)
      A2 += o();
    if (A2 += a, Y0)
      A2 += "return mapResponse(r, c.set)\n";
    else
      A2 += "return mapCompactResponse(r)\n";
  } else {
    const R2 = X0("handle", { name: Z.name });
    if (X2.response)
      if (A2 += M0(Z) ? "const r = await handler(c);\n" : "const r = handler(c);\n", R2(), A2 += o(), X0("afterHandle")(), A2 += a, Y0)
        A2 += "return mapResponse(r, c.set)\n";
      else
        A2 += "return mapCompactResponse(r)\n";
    else if (O.handle || V2)
      if (A2 += M0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n", R2(), X0("afterHandle")(), A2 += a, Y0)
        A2 += "return mapResponse(r, c.set)\n";
      else
        A2 += "return mapCompactResponse(r)\n";
    else {
      R2();
      const f = M0(Z) ? "await handler(c) " : "handler(c)";
      if (X0("afterHandle")(), Y0)
        A2 += `return mapResponse(${f}, c.set)\n`;
      else
        A2 += `return mapCompactResponse(${f})\n`;
    }
  }
  if (S2 || G2) {
    if (A2 += `
} catch(error) {`, !u0)
      A2 += "return (async () => {";
    A2 += `const set = c.set

		if (!set.status || set.status < 300) set.status = 500
	`;
    const R2 = X0("error", { unit: Y2.error.length });
    if (Y2.error.length)
      for (let f = 0;f < Y2.error.length; f++) {
        const i = `er${f}`, u = X0("error.unit", { name: Y2.error[f].name });
        if (A2 += `\nlet ${i} = handleErrors[${f}](
					Object.assign(c, {
						error: error,
						code: error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
					})
				)\n`, M0(Y2.error[f]))
          A2 += `if (${i} instanceof Promise) ${i} = await ${i}\n`;
        u(), A2 += `${i} = mapEarlyResponse(${i}, set)\n`, A2 += `if (${i}) {`, A2 += `return ${i} }\n`;
      }
    if (R2(), A2 += "return handleError(c, error)\n\n", !u0)
      A2 += "})()";
    if (A2 += "}", G2 || K2) {
      A2 += " finally { ";
      const f = X0("response", { unit: Y2.onResponse.length });
      A2 += G2, f(), A2 += "}";
    }
  }
  return A2 = `const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie
	} = hooks

	${Y2.onResponse.length ? `const ${Y2.onResponse.map((R2, f) => `res${f} = onResponse[${f}]`).join(",")}` : ""}

	return ${u0 ? "async" : ""} function(c) {
		${z2 && J2 ? "c.schema = schema; c.defs = definitions;" : ""}
		${A2}
	}`, Function("hooks", A2)({ handler: Z, hooks: Y2, validator: X2, handleError: Q2, utils: { mapResponse: U1, mapCompactResponse: K1, mapEarlyResponse: r0, parseQuery: vY.parse }, error: { NotFoundError: L1, ValidationError: S0, InternalServerError: f$ }, schema: z2, definitions: J2, ERROR_CODE: n1, getReporter: B2, requestId: iY, parseCookie: u$, signCookie: l1 });
};
var w8 = ($) => {
  let W2 = "", Y2 = "";
  for (let j of Object.keys($.decorators))
    W2 += `,${j}: app.decorators.${j}`;
  const { router: X2, staticRouter: Z } = $, Q2 = $.event.trace.length > 0, J2 = `
	const route = find(request.method, path) ${X2.root.ALL ? '?? find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : `new Response(error404, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})`}

	ctx.params = route.params

	return route.store(ctx)`;
  let z2 = "";
  for (let [j, { code: M2, all: O }] of Object.entries(Z.map))
    z2 += `case '${j}':\nswitch(request.method) {\n${M2}\n${O ?? "default: break map"}}\n\n`;
  const F2 = $.event.request.some(M0);
  Y2 += `const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}

	${Z.variables}

	const find = router.find.bind(router)
	const findWs = wsRouter.find.bind(wsRouter)
	const handleError = app.handleError.bind(this)

	${$.event.error.length ? "" : "const error404 = notFound.message.toString()"}

	return ${F2 ? "async" : ""} function map(request) {
	`;
  const w = $.event.trace.map((j) => j.toString()), B2 = mY({ hasTrace: Q2, hasTraceSet: $.event.trace.some((j) => {
    const M2 = j.toString();
    return j0("set", M2) || w$(M2);
  }), condition: { request: w.some((j) => j0("request", j) || w$(j)) }, addFn: (j) => {
    Y2 += j;
  } });
  if ($.event.request.length) {
    Y2 += `
			${Q2 ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					cookie: {},
					headers: {},
					status: 200
				}
				${Q2 ? ",$$requestId: +id" : ""}
				${W2}
			}
		`;
    const j = B2("request", { attribute: "ctx", unit: $.event.request.length });
    Y2 += "try {\n";
    for (let M2 = 0;M2 < $.event.request.length; M2++) {
      const O = $.event.request[M2], K2 = D$(O.toString()), A2 = M0(O), D2 = B2("request.unit", { name: $.event.request[M2].name }), I2 = `re${M2}`;
      if (K2)
        Y2 += `const ${I2} = mapEarlyResponse(
					${A2 ? "await" : ""} onRequest[${M2}](ctx),
					ctx.set
				)\n`, D2(), Y2 += `if(${I2}) return ${I2}\n`;
      else
        Y2 += `${A2 ? "await" : ""} onRequest[${M2}](ctx)\n`, D2();
    }
    Y2 += `} catch (error) {
			return app.handleError(ctx, error)
		}`, j(), Y2 += `
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`;
  } else
    Y2 += `
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		${Q2 ? "const id = +requestId.value++" : ""}

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${Q2 ? ",$$requestId: id" : ""}
			${W2}
		}`, B2("request", { unit: $.event.request.length, attribute: w.some((j) => j0("context", j)) || w.some((j) => j0("store", j)) || w.some((j) => j0("set", j)) ? "ctx" : "" })();
  const { wsPaths: S2, wsRouter: G2 } = $;
  if (Object.keys(S2).length || G2.history.length) {
    Y2 += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (let [j, M2] of Object.entries(S2))
      Y2 += `
					case '${j}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${M2}(ctx)
							
						break`;
    Y2 += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = findWs('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}\n`;
  }
  return Y2 += `
		map: switch(path) {
			${z2}

			default:
				break
		}

		${J2}
	}`, $.handleError = K8($), Function("data", Y2)({ app: $, mapEarlyResponse: r0, NotFoundError: L1, getReporter: () => $.reporter, requestId: iY });
};
var K8 = ($) => {
  let W2 = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${$.event.error.find(M0) ? "async" : ""} function(context, error) {
		const { set } = context
		`;
  for (let Y2 = 0;Y2 < $.event.error.length; Y2++) {
    const X2 = $.event.error[Y2], Z = `${M0(X2) ? "await " : ""}onError[${Y2}](
			Object.assign(context, {
				code: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',
				error
			})
		)`;
    if (D$(X2.toString()))
      W2 += `const r${Y2} = ${Z}; if(r${Y2} !== undefined) return mapResponse(r${Y2}, set)\n`;
    else
      W2 += Z + "\n";
  }
  return W2 += `if(error.constructor.name === "ValidationError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`, Function("inject", W2)({ app: $, mapResponse: U1, ERROR_CODE: n1 });
};
var n$ = Q1(B8(), 1);
var j8 = ($) => async (W2) => {
  const Y2 = { cookie: {}, status: 200, headers: {} };
  let X2;
  if ($.decorators)
    X2 = $.decorators, X2.request = W2, X2.set = Y2, X2.store = $.store;
  else
    X2 = { set: Y2, store: $.store, request: W2 };
  const Z = W2.url, Q2 = Z.indexOf("/", 11), J2 = Z.indexOf("?", Q2 + 1), z2 = J2 === -1 ? Z.substring(Q2) : Z.substring(Q2, J2);
  try {
    for (let K2 = 0;K2 < $.event.request.length; K2++) {
      const A2 = $.event.request[K2];
      let D2 = A2(X2);
      if (D2 instanceof Promise)
        D2 = await D2;
      if (D2 = r0(D2, Y2), D2)
        return D2;
    }
    const F2 = $.dynamicRouter.find(W2.method, z2) ?? $.dynamicRouter.find("ALL", z2);
    if (!F2)
      throw new L1;
    const { handle: w, hooks: B2, validator: S2, content: G2 } = F2.store;
    let j;
    if (W2.method !== "GET" && W2.method !== "HEAD")
      if (G2)
        switch (G2) {
          case "application/json":
            j = await W2.json();
            break;
          case "text/plain":
            j = await W2.text();
            break;
          case "application/x-www-form-urlencoded":
            j = n$.parse(await W2.text());
            break;
          case "application/octet-stream":
            j = await W2.arrayBuffer();
            break;
          case "multipart/form-data":
            j = {};
            const K2 = await W2.formData();
            for (let A2 of K2.keys()) {
              if (j[A2])
                continue;
              const D2 = K2.getAll(A2);
              if (D2.length === 1)
                j[A2] = D2[0];
              else
                j[A2] = D2;
            }
            break;
        }
      else {
        let K2 = W2.headers.get("content-type");
        if (K2) {
          const A2 = K2.indexOf(";");
          if (A2 !== -1)
            K2 = K2.slice(0, A2);
          for (let D2 = 0;D2 < $.event.parse.length; D2++) {
            let I2 = $.event.parse[D2](X2, K2);
            if (I2 instanceof Promise)
              I2 = await I2;
            if (I2) {
              j = I2;
              break;
            }
          }
          if (j === undefined)
            switch (K2) {
              case "application/json":
                j = await W2.json();
                break;
              case "text/plain":
                j = await W2.text();
                break;
              case "application/x-www-form-urlencoded":
                j = n$.parse(await W2.text());
                break;
              case "application/octet-stream":
                j = await W2.arrayBuffer();
                break;
              case "multipart/form-data":
                j = {};
                const D2 = await W2.formData();
                for (let I2 of D2.keys()) {
                  if (j[I2])
                    continue;
                  const b2 = D2.getAll(I2);
                  if (b2.length === 1)
                    j[I2] = b2[0];
                  else
                    j[I2] = b2;
                }
                break;
            }
        }
      }
    X2.body = j, X2.params = F2?.params || undefined, X2.query = J2 === -1 ? {} : n$.parse(Z.substring(J2 + 1)), X2.headers = {};
    for (let [K2, A2] of W2.headers.entries())
      X2.headers[K2] = A2;
    const M2 = S2?.cookie?.schema;
    X2.cookie = await u$(X2.set, X2.headers.cookie, M2 ? { secret: M2.secrets !== undefined ? typeof M2.secrets === "string" ? M2.secrets : M2.secrets.join(",") : undefined, sign: M2.sign === true ? true : M2.sign !== undefined ? typeof M2.sign === "string" ? M2.sign : M2.sign.join(",") : undefined } : undefined);
    for (let K2 = 0;K2 < B2.transform.length; K2++) {
      const A2 = B2.transform[K2](X2);
      if (B2.transform[K2].$elysia === "derive")
        if (A2 instanceof Promise)
          Object.assign(X2, await A2);
        else
          Object.assign(X2, A2);
      else if (A2 instanceof Promise)
        await A2;
    }
    if (S2) {
      if (S2.headers) {
        const K2 = {};
        for (let A2 in W2.headers)
          K2[A2] = W2.headers.get(A2);
        if (S2.headers.Check(K2) === false)
          throw new S0("header", S2.headers, K2);
      }
      if (S2.params?.Check(X2.params) === false)
        throw new S0("params", S2.params, X2.params);
      if (S2.query?.Check(X2.query) === false)
        throw new S0("query", S2.query, X2.query);
      if (S2.cookie) {
        const K2 = {};
        for (let [A2, D2] of Object.entries(X2.cookie))
          K2[A2] = D2.value;
        if (S2.cookie?.Check(K2) === false)
          throw new S0("cookie", S2.cookie, K2);
      }
      if (S2.body?.Check(j) === false)
        throw new S0("body", S2.body, j);
    }
    for (let K2 = 0;K2 < B2.beforeHandle.length; K2++) {
      let A2 = B2.beforeHandle[K2](X2);
      if (A2 instanceof Promise)
        A2 = await A2;
      if (A2 !== undefined) {
        X2.response = A2;
        for (let I2 = 0;I2 < B2.afterHandle.length; I2++) {
          let b2 = B2.afterHandle[I2](X2);
          if (b2 instanceof Promise)
            b2 = await b2;
          if (b2)
            A2 = b2;
        }
        const D2 = r0(A2, X2.set);
        if (D2)
          return D2;
      }
    }
    let O = w(X2);
    if (O instanceof Promise)
      O = await O;
    if (!B2.afterHandle.length) {
      const K2 = S2?.response?.[O.status];
      if (K2?.Check(O) === false)
        throw new S0("response", K2, O);
    } else {
      X2.response = O;
      for (let K2 = 0;K2 < B2.afterHandle.length; K2++) {
        let A2 = B2.afterHandle[K2](X2);
        if (A2 instanceof Promise)
          A2 = await A2;
        const D2 = r0(A2, X2.set);
        if (D2 !== undefined) {
          const I2 = S2?.response?.[O.status];
          if (I2?.Check(D2) === false)
            throw new S0("response", I2, D2);
          return D2;
        }
      }
    }
    if (X2.set.cookie && M2?.sign) {
      const K2 = !M2.secrets ? undefined : typeof M2.secrets === "string" ? M2.secrets : M2.secrets[0];
      if (M2.sign === true)
        for (let [A2, D2] of Object.entries(X2.set.cookie))
          X2.set.cookie[A2].value = await l1(D2.value, "${secret}");
      else
        for (let A2 of M2.sign) {
          if (!(A2 in M2.properties))
            continue;
          if (X2.set.cookie[A2]?.value)
            X2.set.cookie[A2].value = await l1(X2.set.cookie[A2].value, K2);
        }
    }
    return U1(O, X2.set);
  } catch (F2) {
    if (F2.status)
      Y2.status = F2.status;
    return $.handleError(X2, F2);
  } finally {
    for (let F2 of $.event.onResponse)
      await F2(X2);
  }
};
var hY = ($) => async (W2, Y2) => {
  const X2 = Object.assign(W2, Y2);
  X2.set = W2.set;
  for (let Z = 0;Z < $.event.error.length; Z++) {
    let Q2 = $.event.error[Z](X2);
    if (Q2 instanceof Promise)
      Q2 = await Q2;
    if (Q2 !== undefined && Q2 !== null)
      return U1(Q2, W2.set);
  }
  return new Response(typeof Y2.cause === "string" ? Y2.cause : Y2.message, { headers: W2.set.headers, status: Y2.status ?? 500 });
};
var G1 = Q1(E$(), 1);
var W0 = Q1(f0(), 1);
try {
  G1.TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), G1.TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), G1.TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), G1.TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch ($) {
}
var nY = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var P8 = ($, W2) => {
  if (!(W2 instanceof Blob))
    return false;
  if ($.minSize && W2.size < nY($.minSize))
    return false;
  if ($.maxSize && W2.size > nY($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!W2.type.startsWith($.extension))
        return false;
    } else {
      for (let Y2 = 0;Y2 < $.extension.length; Y2++)
        if (W2.type.startsWith($.extension[Y2]))
          return true;
      return false;
    }
  return true;
};
var D7 = G1.TypeSystem.Type("Files", ($, W2) => {
  if (!Array.isArray(W2))
    return P8($, W2);
  if ($.minItems && W2.length < $.minItems)
    return false;
  if ($.maxItems && W2.length > $.maxItems)
    return false;
  for (let Y2 = 0;Y2 < W2.length; Y2++)
    if (!P8($, W2[Y2]))
      return false;
  return true;
});
W0.FormatRegistry.Set("numeric", ($) => !isNaN(+$));
W0.FormatRegistry.Set("ObjectString", ($) => {
  let W2 = $.charCodeAt(0);
  if (W2 === 9 || W2 === 10 || W2 === 32)
    W2 = $.trimStart().charCodeAt(0);
  if (W2 !== 123 && W2 !== 91)
    return false;
  try {
    return JSON.parse($), true;
  } catch {
    return false;
  }
});
var R1 = { Numeric: ($) => W0.Type.Transform(W0.Type.Union([W0.Type.String({ format: "numeric", default: 0 }), W0.Type.Number($)])).Decode((W2) => {
  const Y2 = +W2;
  if (isNaN(Y2))
    return W2;
  return Y2;
}).Encode((W2) => W2), ObjectString: ($, W2) => W0.Type.Transform(W0.Type.Union([W0.Type.String({ format: "ObjectString", default: "" }), W0.Type.Object($, W2)])).Decode((Y2) => {
  if (typeof Y2 === "string")
    try {
      return JSON.parse(Y2);
    } catch {
      return Y2;
    }
  return Y2;
}).Encode((Y2) => JSON.stringify(Y2)), File: G1.TypeSystem.Type("File", P8), Files: ($ = {}) => W0.Type.Transform(W0.Type.Union([D7($)])).Decode((W2) => {
  if (Array.isArray(W2))
    return W2;
  return [W2];
}).Encode((W2) => W2), Nullable: ($) => W0.Type.Union([W0.Type.Null(), $]), MaybeEmpty: ($) => W0.Type.Union([W0.Type.Null(), W0.Type.Undefined(), $]), Cookie: ($, W2) => W0.Type.Object($, W2) };
W0.Type.ObjectString = R1.ObjectString;
W0.Type.Numeric = R1.Numeric;
W0.Type.File = ($ = {}) => R1.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
W0.Type.Files = ($ = {}) => R1.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
W0.Type.Nullable = ($) => R1.Nullable($);
W0.Type.MaybeEmpty = R1.MaybeEmpty;
W0.Type.Cookie = R1.Cookie;

class o$ {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new R8;
  server = null;
  getServer() {
    return this.server;
  }
  validator = null;
  router = new j1;
  wsRouter = new j1;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  wsPaths = {};
  dynamicRouter = new j1;
  lazyLoadModules = [];
  path = "";
  constructor($) {
    this.config = { forceErrorEncapsulation: false, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, ...$, seed: $?.seed === undefined ? "" : $?.seed };
  }
  add($, W2, Y2, X2, { allowMeta: Z = false, skipPrefix: Q2 = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof W2 === "string")
      W2 = [W2];
    for (let J2 of W2) {
      if (J2 = J2 === "" ? J2 : J2.charCodeAt(0) === 47 ? J2 : `/${J2}`, this.config.prefix && !Q2)
        J2 = this.config.prefix + J2;
      if (X2?.type)
        switch (X2.type) {
          case "text":
            X2.type = "text/plain";
            break;
          case "json":
            X2.type = "application/json";
            break;
          case "formdata":
            X2.type = "multipart/form-data";
            break;
          case "urlencoded":
            X2.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            X2.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const z2 = this.definitions.type;
      let F2 = X1(X2?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: z2, additionalProperties: true });
      if (t0(this.config.cookie ?? {}))
        if (F2)
          F2.schema = DY(F2.schema, this.config.cookie ?? {});
        else
          F2 = X1(W0.Type.Cookie({}, this.config.cookie), { dynamic: !this.config.aot, models: z2, additionalProperties: true });
      const w = { body: X1(X2?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: z2 }), headers: X1(X2?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: z2, additionalProperties: true }), params: X1(X2?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: z2 }), query: X1(X2?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: z2 }), cookie: F2, response: H8(X2?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: z2 }) }, B2 = I1(this.event, X2), S2 = J2.endsWith("/") ? J2.slice(0, J2.length - 1) : J2 + "/";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, J2, { validator: w, hooks: B2, content: X2?.type, handle: Y2 }), this.config.strictPath === false)
          this.dynamicRouter.add($, S2, { validator: w, hooks: B2, content: X2?.type, handle: Y2 });
        this.routes.push({ method: $, path: J2, composed: null, handler: Y2, hooks: B2 });
        return;
      }
      const G2 = uY({ path: J2, method: $, hooks: B2, validator: w, handler: Y2, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: Z ? this.definitions.type : undefined, schema: Z ? this.schema : undefined, getReporter: () => this.reporter }), j = this.routes.findIndex((M2) => M2.path === J2 && M2.method === $);
      if (j !== -1)
        this.routes.splice(j, 1);
      if (this.routes.push({ method: $, path: J2, composed: G2, handler: Y2, hooks: B2 }), $ === "$INTERNALWS") {
        const M2 = this.config.strictPath ? undefined : J2.endsWith("/") ? J2.slice(0, J2.length - 1) : J2 + "/";
        if (J2.indexOf(":") === -1 && J2.indexOf("*") === -1) {
          const O = this.staticRouter.handlers.length;
          if (this.staticRouter.handlers.push(G2), this.staticRouter.variables += `const st${O} = staticRouter.handlers[${O}]\n`, this.wsPaths[J2] = O, M2)
            this.wsPaths[M2] = O;
        } else if (this.wsRouter.add("ws", J2, G2), M2)
          this.wsRouter.add("ws", M2, G2);
        return;
      }
      if (J2.indexOf(":") === -1 && J2.indexOf("*") === -1) {
        const M2 = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(G2), this.staticRouter.variables += `const st${M2} = staticRouter.handlers[${M2}]\n`, !this.staticRouter.map[J2])
          this.staticRouter.map[J2] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[J2].all = `default: return st${M2}(ctx)\n`;
        else
          this.staticRouter.map[J2].code = `case '${$}': return st${M2}(ctx)\n${this.staticRouter.map[J2].code}`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[S2])
            this.staticRouter.map[S2] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[S2].all = `default: return st${M2}(ctx)\n`;
          else
            this.staticRouter.map[S2].code = `case '${$}': return st${M2}(ctx)\n${this.staticRouter.map[S2].code}`;
        }
      } else if (this.router.add($, J2, G2), !this.config.strictPath)
        this.router.add($, J2.endsWith("/") ? J2.slice(0, J2.length - 1) : J2 + "/", G2);
    }
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", _8(() => this.reporter, $)), this.on("trace", $), this;
  }
  addError($, W2) {
    return this.error($, W2);
  }
  error($, W2) {
    switch (typeof $) {
      case "string":
        return W2.prototype[n1] = $, this.definitions.error[$] = W2, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [Y2, X2] of Object.entries($))
      X2.prototype[n1] = Y2, this.definitions.error[Y2] = X2;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, W2) {
    for (let Y2 of Array.isArray(W2) ? W2 : [W2])
      switch (Y2 = wY(Y2), $) {
        case "start":
          this.event.start.push(Y2);
          break;
        case "request":
          this.event.request.push(Y2);
          break;
        case "response":
          this.event.onResponse.push(Y2);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, Y2);
          break;
        case "transform":
          this.event.transform.push(Y2);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(Y2);
          break;
        case "afterHandle":
          this.event.afterHandle.push(Y2);
          break;
        case "trace":
          this.event.trace.push(Y2);
          break;
        case "error":
          this.event.error.push(Y2);
          break;
        case "stop":
          this.event.stop.push(Y2);
          break;
      }
    return this;
  }
  group($, W2, Y2) {
    const X2 = new o$({ ...this.config, prefix: "" });
    X2.store = this.store;
    const Z = typeof W2 === "object", Q2 = (Z ? Y2 : W2)(X2);
    if (this.decorators = F1(this.decorators, X2.decorators), Q2.event.request.length)
      this.event.request = [...this.event.request, ...Q2.event.request];
    if (Q2.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...Q2.event.onResponse];
    return this.model(Q2.definitions.type), Object.values(X2.routes).forEach(({ method: J2, path: z2, handler: F2, hooks: w }) => {
      if (z2 = (Z ? "" : this.config.prefix) + $ + z2, Z) {
        const B2 = W2, S2 = w;
        this.add(J2, z2, F2, I1(B2, { ...S2, error: !S2.error ? Q2.event.error : Array.isArray(S2.error) ? [...S2.error, ...Q2.event.error] : [S2.error, ...Q2.event.error] }));
      } else
        this.add(J2, z2, F2, I1(w, { error: Q2.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, W2) {
    if (!W2)
      return this.event = m$(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const Y2 = new o$;
    Y2.store = this.store;
    const X2 = W2(Y2);
    if (this.decorators = F1(this.decorators, Y2.decorators), X2.event.request.length)
      this.event.request = [...this.event.request, ...X2.event.request];
    if (X2.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...X2.event.onResponse];
    return this.model(X2.definitions.type), Object.values(Y2.routes).forEach(({ method: Z, path: Q2, handler: J2, hooks: z2 }) => {
      this.add(Z, Q2, J2, I1($, { ...z2, error: !z2.error ? X2.event.error : Array.isArray(z2.error) ? [...z2.error, ...X2.event.error] : [z2.error, ...X2.event.error] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((W2) => {
        if (typeof W2 === "function")
          return W2(this);
        if (typeof W2.default === "function")
          return W2.default(this);
        return this._use(W2);
      }).then((W2) => W2.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const Z = $(this);
      if (Z instanceof Promise)
        return this.lazyLoadModules.push(Z.then((Q2) => {
          if (typeof Q2 === "function")
            return Q2(this);
          if (typeof Q2.default === "function")
            return Q2.default(this);
          return this._use(Q2);
        }).then((Q2) => Q2.compile())), this;
      return Z;
    }
    const { name: W2, seed: Y2 } = $.config;
    $.getServer = () => this.getServer();
    const X2 = $.config.scoped;
    if (X2) {
      if (W2) {
        if (!(W2 in this.dependencies))
          this.dependencies[W2] = [];
        const Q2 = Y2 !== undefined ? q8(W2 + JSON.stringify(Y2)) : 0;
        if (this.dependencies[W2].some((J2) => Q2 === J2))
          return this;
        this.dependencies[W2].push(Q2);
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.onRequest((Q2) => {
        Object.assign(Q2, this.decorators), Object.assign(Q2.store, this.store);
      }), $.event.trace = [...this.event.trace, ...$.event.trace], $.config.aot)
        $.compile();
      const Z = this.mount($.fetch);
      return this.routes = this.routes.concat(Z.routes), this;
    } else {
      $.reporter = this.reporter;
      for (let Z of $.event.trace)
        this.trace(Z);
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: Z, path: Q2, handler: J2, hooks: z2 } of Object.values($.routes))
      this.add(Z, Q2, J2, I1(z2, { error: $.event.error }));
    if (!X2)
      if (W2) {
        if (!(W2 in this.dependencies))
          this.dependencies[W2] = [];
        const Z = Y2 !== undefined ? q8(W2 + JSON.stringify(Y2)) : 0;
        if (this.dependencies[W2].some((Q2) => Z === Q2))
          return this;
        this.dependencies[W2].push(Z), this.event = m$(this.event, N8($.event), Z);
      } else
        this.event = m$(this.event, N8($.event));
    return this;
  }
  mount($, W2) {
    if (typeof $ === "function" || $.length === 0 || $ === "/") {
      const Z = typeof $ === "function" ? $ : W2, Q2 = async ({ request: J2, path: z2 }) => Z(new Request("http://a.cc" + z2 || "/", J2));
      return this.all("/", Q2, { type: "none" }), this.all("/*", Q2, { type: "none" }), this;
    }
    const Y2 = $.length, X2 = async ({ request: Z, path: Q2 }) => W2(new Request("http://a.cc" + Q2.slice(Y2) || "/", Z));
    return this.all($, X2, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), X2, { type: "none" }), this;
  }
  get($, W2, Y2) {
    return this.add("GET", $, W2, Y2), this;
  }
  post($, W2, Y2) {
    return this.add("POST", $, W2, Y2), this;
  }
  put($, W2, Y2) {
    return this.add("PUT", $, W2, Y2), this;
  }
  patch($, W2, Y2) {
    return this.add("PATCH", $, W2, Y2), this;
  }
  delete($, W2, Y2) {
    return this.add("DELETE", $, W2, Y2), this;
  }
  options($, W2, Y2) {
    return this.add("OPTIONS", $, W2, Y2), this;
  }
  all($, W2, Y2) {
    return this.add("ALL", $, W2, Y2), this;
  }
  head($, W2, Y2) {
    return this.add("HEAD", $, W2, Y2), this;
  }
  connect($, W2, Y2) {
    return this.add("CONNECT", $, W2, Y2), this;
  }
  ws($, W2) {
    const Y2 = W2.transformMessage ? Array.isArray(W2.transformMessage) ? W2.transformMessage : [W2.transformMessage] : undefined;
    let X2 = null;
    const Z = X1(W2?.body, { models: this.definitions.type }), Q2 = X1(W2?.response, { models: this.definitions.type }), J2 = (z2) => {
      if (typeof z2 === "string") {
        const F2 = z2?.charCodeAt(0);
        if (F2 === 47 || F2 === 123)
          try {
            z2 = JSON.parse(z2);
          } catch {
          }
        else if (!Number.isNaN(+z2))
          z2 = +z2;
      }
      if (Y2?.length)
        for (let F2 = 0;F2 < Y2.length; F2++) {
          const w = Y2[F2](z2);
          if (w !== undefined)
            z2 = w;
        }
      return z2;
    };
    return this.route("$INTERNALWS", $, (z2) => {
      const { set: F2, path: w, qi: B2, headers: S2, query: G2, params: j } = z2;
      if (X2 === null)
        X2 = this.getServer();
      if (X2?.upgrade(z2.request, { headers: typeof W2.upgrade === "function" ? W2.upgrade(z2) : W2.upgrade, data: { validator: Q2, open(M2) {
        W2.open?.(new o1(M2, z2));
      }, message: (M2, O) => {
        const K2 = J2(O);
        if (Z?.Check(K2) === false)
          return void M2.send(new S0("message", Z, K2).message);
        W2.message?.(new o1(M2, z2), K2);
      }, drain(M2) {
        W2.drain?.(new o1(M2, z2));
      }, close(M2, O, K2) {
        W2.close?.(new o1(M2, z2), O, K2);
      } } }))
        return;
      return F2.status = 400, "Expected a websocket connection";
    }, { beforeHandle: W2.beforeHandle, transform: W2.transform, headers: W2.headers, params: W2.params, query: W2.query }), this;
  }
  route($, W2, Y2, { config: X2, ...Z } = { config: { allowMeta: false } }) {
    return this.add($, W2, Y2, Z, X2), this;
  }
  state($, W2) {
    switch (typeof $) {
      case "object":
        return this.store = F1(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = W2;
    return this;
  }
  decorate($, W2) {
    switch (typeof $) {
      case "object":
        return this.decorators = F1(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = W2;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, W2) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([Y2, X2]) => {
          if (!(Y2 in this.definitions.type))
            this.definitions.type[Y2] = X2;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = W2, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, W2, Y2) {
    if (Y2 === "")
      return this;
    const X2 = ["_", "-", " "], Z = (F2) => F2[0].toUpperCase() + F2.slice(1), Q2 = $ === "prefix" ? (F2, w) => X2.includes(F2.at(-1) ?? "") ? F2 + w : F2 + Z(w) : X2.includes(Y2.at(-1) ?? "") ? (F2, w) => w + F2 : (F2, w) => w + Z(F2), J2 = (F2) => {
      const w = {};
      switch (F2) {
        case "decorator":
          for (let B2 in this.decorators)
            w[Q2(Y2, B2)] = this.decorators[B2];
          this.decorators = w;
          break;
        case "state":
          for (let B2 in this.store)
            w[Q2(Y2, B2)] = this.store[B2];
          this.store = w;
          break;
        case "model":
          for (let B2 in this.definitions.type)
            w[Q2(Y2, B2)] = this.definitions.type[B2];
          this.definitions.type = w;
          break;
        case "error":
          for (let B2 in this.definitions.error)
            w[Q2(Y2, B2)] = this.definitions.error[B2];
          this.definitions.error = w;
          break;
      }
    }, z2 = Array.isArray(W2) ? W2 : [W2];
    for (let F2 of z2.some((w) => w === "all") ? ["decorator", "state", "model", "error"] : z2)
      J2(F2);
    return this;
  }
  prefix($, W2) {
    return this.affix("prefix", $, W2);
  }
  suffix($, W2) {
    return this.affix("suffix", $, W2);
  }
  compile() {
    if (this.fetch = this.config.aot ? w8(this) : j8(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => (this.fetch = this.config.aot ? w8(this) : j8(this))($);
  handleError = async ($, W2) => (this.handleError = this.config.aot ? K8(this) : hY(this))($, W2);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, W2) => {
    if (!Bun)
      throw new Error("Bun to run");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const Y2 = this.fetch, X2 = typeof $ === "object" ? { development: !q$, ...this.config.serve, ...$, websocket: { ...this.config.websocket, ...W8 }, fetch: Y2, error: this.outerErrorHandler } : { development: !q$, ...this.config.serve, websocket: { ...this.config.websocket, ...W8 }, port: $, fetch: Y2, error: this.outerErrorHandler };
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.server = Bun?.serve(X2), this.event.start.length)
      (async () => {
        const Z = Object.assign(this.decorators, { store: this.store, app: this });
        for (let Q2 = 0;Q2 < this.event.transform.length; Q2++) {
          const J2 = this.event.transform[Q2](Z);
          if (this.event.transform[Q2].$elysia === "derive")
            if (J2 instanceof Promise)
              Object.assign(Z, await J2);
            else
              Object.assign(Z, J2);
        }
        for (let Q2 = 0;Q2 < this.event.start.length; Q2++)
          this.event.start[Q2](Z);
      })();
    if (W2)
      W2(this.server);
    return Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server.stop(), this.event.stop.length)
      (async () => {
        const $ = Object.assign(this.decorators, { store: this.store, app: this });
        for (let W2 = 0;W2 < this.event.transform.length; W2++) {
          const Y2 = this.event.transform[W2]($);
          if (this.event.transform[W2].$elysia === "derive")
            if (Y2 instanceof Promise)
              Object.assign($, await Y2);
            else
              Object.assign($, Y2);
        }
        for (let W2 = 0;W2 < this.event.stop.length; W2++)
          this.event.stop[W2]($);
      })();
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}
var export_t = W0.Type;

// node_modules/croner/dist/croner.min.js
var minitz = function(y2, m, d, h2, i, s2, tz, throwOnInvalid) {
  return minitz.fromTZ(minitz.tp(y2, m, d, h2, i, s2, tz), throwOnInvalid);
};
var getTimezoneOffset = function(timeZone, date = new Date) {
  const tz = date.toLocaleString("en-US", { timeZone, timeZoneName: "short" }).split(" ").slice(-1)[0];
  const dateString = date.toLocaleString("en-US").replace(/[\u202f]/, " ");
  return Date.parse(`${dateString} GMT`) - Date.parse(`${dateString} ${tz}`);
};
var parseISOLocal = function(dtStr, tz) {
  const pd = new Date(Date.parse(dtStr));
  if (isNaN(pd)) {
    throw new Error("minitz: Invalid ISO8601 passed to parser.");
  }
  const stringEnd = dtStr.substring(9);
  if (dtStr.includes("Z") || stringEnd.includes("-") || stringEnd.includes("+")) {
    return minitz.tp(pd.getUTCFullYear(), pd.getUTCMonth() + 1, pd.getUTCDate(), pd.getUTCHours(), pd.getUTCMinutes(), pd.getUTCSeconds(), "Etc/UTC");
  } else {
    return minitz.tp(pd.getFullYear(), pd.getMonth() + 1, pd.getDate(), pd.getHours(), pd.getMinutes(), pd.getSeconds(), tz);
  }
};
var CronOptions = function(options) {
  if (options === undefined) {
    options = {};
  }
  delete options.name;
  options.legacyMode = options.legacyMode === undefined ? true : options.legacyMode;
  options.paused = options.paused === undefined ? false : options.paused;
  options.maxRuns = options.maxRuns === undefined ? Infinity : options.maxRuns;
  options.catch = options.catch === undefined ? false : options.catch;
  options.interval = options.interval === undefined ? 0 : parseInt(options.interval, 10);
  options.utcOffset = options.utcOffset === undefined ? undefined : parseInt(options.utcOffset, 10);
  options.unref = options.unref === undefined ? false : options.unref;
  if (options.startAt) {
    options.startAt = new CronDate(options.startAt, options.timezone);
  }
  if (options.stopAt) {
    options.stopAt = new CronDate(options.stopAt, options.timezone);
  }
  if (options.interval !== null) {
    if (isNaN(options.interval)) {
      throw new Error("CronOptions: Supplied value for interval is not a number");
    } else if (options.interval < 0) {
      throw new Error("CronOptions: Supplied value for interval can not be negative");
    }
  }
  if (options.utcOffset !== undefined) {
    if (isNaN(options.utcOffset)) {
      throw new Error("CronOptions: Invalid value passed for utcOffset, should be number representing minutes offset from UTC.");
    } else if (options.utcOffset < -870 || options.utcOffset > 870) {
      throw new Error("CronOptions: utcOffset out of bounds.");
    }
    if (options.utcOffset !== undefined && options.timezone) {
      throw new Error("CronOptions: Combining 'utcOffset' with 'timezone' is not allowed.");
    }
  }
  if (options.unref !== true && options.unref !== false) {
    throw new Error("CronOptions: Unref should be either true, false or undefined(false).");
  }
  return options;
};
var CronDate = function(d, tz) {
  this.tz = tz;
  if (d && d instanceof Date) {
    if (!isNaN(d)) {
      this.fromDate(d);
    } else {
      throw new TypeError("CronDate: Invalid date passed to CronDate constructor");
    }
  } else if (d === undefined) {
    this.fromDate(new Date);
  } else if (d && typeof d === "string") {
    this.fromString(d);
  } else if (d instanceof CronDate) {
    this.fromCronDate(d);
  } else {
    throw new TypeError("CronDate: Invalid type (" + typeof d + ") passed to CronDate constructor");
  }
};
var CronPattern = function(pattern, timezone) {
  this.pattern = pattern;
  this.timezone = timezone;
  this.second = Array(60).fill(0);
  this.minute = Array(60).fill(0);
  this.hour = Array(24).fill(0);
  this.day = Array(31).fill(0);
  this.month = Array(12).fill(0);
  this.dayOfWeek = Array(8).fill(0);
  this.lastDayOfMonth = false;
  this.lastWeekdayOfMonth = false;
  this.starDOM = false;
  this.starDOW = false;
  this.parse();
};
var isFunction = function(v) {
  return Object.prototype.toString.call(v) === "[object Function]" || typeof v === "function" || v instanceof Function;
};
var unrefTimer = function(timer) {
  if (typeof Deno !== "undefined" && typeof Deno.unrefTimer !== "undefined") {
    Deno.unrefTimer(timer);
  } else if (timer && typeof timer.unref !== "undefined") {
    timer.unref();
  }
};
var Cron = function(pattern, fnOrOptions1, fnOrOptions2) {
  if (!(this instanceof Cron)) {
    return new Cron(pattern, fnOrOptions1, fnOrOptions2);
  }
  let options, func;
  if (isFunction(fnOrOptions1)) {
    func = fnOrOptions1;
  } else if (typeof fnOrOptions1 === "object") {
    options = fnOrOptions1;
  } else if (fnOrOptions1 !== undefined) {
    throw new Error("Cron: Invalid argument passed for optionsIn. Should be one of function, or object (options).");
  }
  if (isFunction(fnOrOptions2)) {
    func = fnOrOptions2;
  } else if (typeof fnOrOptions2 === "object") {
    options = fnOrOptions2;
  } else if (fnOrOptions2 !== undefined) {
    throw new Error("Cron: Invalid argument passed for funcIn. Should be one of function, or object (options).");
  }
  this.name = options ? options.name : undefined;
  this.options = CronOptions(options);
  this._states = { kill: false, blocking: false, previousRun: undefined, currentRun: undefined, once: undefined, currentTimeout: undefined, maxRuns: options ? options.maxRuns : undefined, paused: options ? options.paused : false, pattern: undefined };
  if (pattern && (pattern instanceof Date || typeof pattern === "string" && pattern.indexOf(":") > 0)) {
    this._states.once = new CronDate(pattern, this.options.timezone || this.options.utcOffset);
  } else {
    this._states.pattern = new CronPattern(pattern, this.options.timezone);
  }
  if (this.name) {
    const existing = scheduledJobs.find((j) => j.name === this.name);
    if (existing) {
      throw new Error("Cron: Tried to initialize new named job '" + this.name + "', but name already taken.");
    } else {
      scheduledJobs.push(this);
    }
  }
  if (func !== undefined) {
    this.fn = func;
    this.schedule();
  }
  return this;
};
minitz.fromTZISO = (localTimeStr, tz, throwOnInvalid) => {
  return minitz.fromTZ(parseISOLocal(localTimeStr, tz), throwOnInvalid);
};
minitz.fromTZ = function(tp, throwOnInvalid) {
  const inDate = new Date(Date.UTC(tp.y, tp.m - 1, tp.d, tp.h, tp.i, tp.s)), offset = getTimezoneOffset(tp.tz, inDate), dateGuess = new Date(inDate.getTime() - offset), dateOffsGuess = getTimezoneOffset(tp.tz, dateGuess);
  if (dateOffsGuess - offset === 0) {
    return dateGuess;
  } else {
    const dateGuess2 = new Date(inDate.getTime() - dateOffsGuess), dateOffsGuess2 = getTimezoneOffset(tp.tz, dateGuess2);
    if (dateOffsGuess2 - dateOffsGuess === 0) {
      return dateGuess2;
    } else if (!throwOnInvalid && dateOffsGuess2 - dateOffsGuess > 0) {
      return dateGuess2;
    } else if (!throwOnInvalid) {
      return dateGuess;
    } else {
      throw new Error("Invalid date passed to fromTZ()");
    }
  }
};
minitz.toTZ = function(d, tzStr) {
  const localDateString = d.toLocaleString("en-US", { timeZone: tzStr }).replace(/[\u202f]/, " ");
  const td = new Date(localDateString);
  return { y: td.getFullYear(), m: td.getMonth() + 1, d: td.getDate(), h: td.getHours(), i: td.getMinutes(), s: td.getSeconds(), tz: tzStr };
};
minitz.tp = (y2, m, d, h2, i, s2, tz) => {
  return { y: y2, m, d, h: h2, i, s: s2, tz };
};
minitz.minitz = minitz;
var DaysOfMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var RecursionSteps = [["month", "year", 0], ["day", "month", -1], ["hour", "day", 0], ["minute", "hour", 0], ["second", "minute", 0]];
CronDate.prototype.fromDate = function(inDate) {
  if (this.tz !== undefined) {
    if (typeof this.tz === "number") {
      this.ms = inDate.getUTCMilliseconds();
      this.second = inDate.getUTCSeconds();
      this.minute = inDate.getUTCMinutes() + this.tz;
      this.hour = inDate.getUTCHours();
      this.day = inDate.getUTCDate();
      this.month = inDate.getUTCMonth();
      this.year = inDate.getUTCFullYear();
      this.apply();
    } else {
      const d = minitz.toTZ(inDate, this.tz);
      this.ms = inDate.getMilliseconds();
      this.second = d.s;
      this.minute = d.i;
      this.hour = d.h;
      this.day = d.d;
      this.month = d.m - 1;
      this.year = d.y;
    }
  } else {
    this.ms = inDate.getMilliseconds();
    this.second = inDate.getSeconds();
    this.minute = inDate.getMinutes();
    this.hour = inDate.getHours();
    this.day = inDate.getDate();
    this.month = inDate.getMonth();
    this.year = inDate.getFullYear();
  }
};
CronDate.prototype.fromCronDate = function(d) {
  this.tz = d.tz;
  this.year = d.year;
  this.month = d.month;
  this.day = d.day;
  this.hour = d.hour;
  this.minute = d.minute;
  this.second = d.second;
  this.ms = d.ms;
};
CronDate.prototype.apply = function() {
  if (this.month > 11 || this.day > DaysOfMonth[this.month] || this.hour > 59 || this.minute > 59 || this.second > 59 || this.hour < 0 || this.minute < 0 || this.second < 0) {
    const d = new Date(Date.UTC(this.year, this.month, this.day, this.hour, this.minute, this.second, this.ms));
    this.ms = d.getUTCMilliseconds();
    this.second = d.getUTCSeconds();
    this.minute = d.getUTCMinutes();
    this.hour = d.getUTCHours();
    this.day = d.getUTCDate();
    this.month = d.getUTCMonth();
    this.year = d.getUTCFullYear();
    return true;
  } else {
    return false;
  }
};
CronDate.prototype.fromString = function(str) {
  return this.fromDate(minitz.fromTZISO(str, this.tz));
};
CronDate.prototype.findNext = function(options, target, pattern, offset) {
  const originalTarget = this[target];
  let lastDayOfMonth;
  if (pattern.lastDayOfMonth || pattern.lastWeekdayOfMonth) {
    if (this.month !== 1) {
      lastDayOfMonth = DaysOfMonth[this.month];
    } else {
      lastDayOfMonth = new Date(Date.UTC(this.year, this.month + 1, 0, 0, 0, 0, 0)).getUTCDate();
    }
  }
  const fDomWeekDay = !pattern.starDOW && target == "day" ? new Date(Date.UTC(this.year, this.month, 1, 0, 0, 0, 0)).getUTCDay() : undefined;
  for (let i = this[target] + offset;i < pattern[target].length; i++) {
    let match = pattern[target][i];
    if (target === "day" && pattern.lastDayOfMonth && i - offset == lastDayOfMonth) {
      match = true;
    }
    if (target === "day" && !pattern.starDOW) {
      let dowMatch = pattern.dayOfWeek[(fDomWeekDay + (i - offset - 1)) % 7];
      if (dowMatch && pattern.lastWeekdayOfMonth) {
        dowMatch = dowMatch && i - offset > lastDayOfMonth - 7;
      }
      if (options.legacyMode && !pattern.starDOM) {
        match = match || dowMatch;
      } else {
        match = match && dowMatch;
      }
    }
    if (match) {
      this[target] = i - offset;
      return originalTarget !== this[target] ? 2 : 1;
    }
  }
  return 3;
};
CronDate.prototype.recurse = function(pattern, options, doing) {
  const res = this.findNext(options, RecursionSteps[doing][0], pattern, RecursionSteps[doing][2]);
  if (res > 1) {
    let resetLevel = doing + 1;
    while (resetLevel < RecursionSteps.length) {
      this[RecursionSteps[resetLevel][0]] = -RecursionSteps[resetLevel][2];
      resetLevel++;
    }
    if (res === 3) {
      this[RecursionSteps[doing][1]]++;
      this[RecursionSteps[doing][0]] = -RecursionSteps[doing][2];
      this.apply();
      return this.recurse(pattern, options, 0);
    } else if (this.apply()) {
      return this.recurse(pattern, options, doing - 1);
    }
  }
  doing += 1;
  if (doing >= RecursionSteps.length) {
    return this;
  } else if (this.year >= 3000) {
    return null;
  } else {
    return this.recurse(pattern, options, doing);
  }
};
CronDate.prototype.increment = function(pattern, options, hasPreviousRun) {
  this.second += options.interval > 1 && hasPreviousRun ? options.interval : 1;
  this.ms = 0;
  this.apply();
  return this.recurse(pattern, options, 0);
};
CronDate.prototype.getDate = function(internal) {
  if (internal || this.tz === undefined) {
    return new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.ms);
  } else {
    if (typeof this.tz === "number") {
      return new Date(Date.UTC(this.year, this.month, this.day, this.hour, this.minute - this.tz, this.second, this.ms));
    } else {
      return minitz(this.year, this.month + 1, this.day, this.hour, this.minute, this.second, this.tz);
    }
  }
};
CronDate.prototype.getTime = function() {
  return this.getDate().getTime();
};
CronPattern.prototype.parse = function() {
  if (!(typeof this.pattern === "string" || this.pattern.constructor === String)) {
    throw new TypeError("CronPattern: Pattern has to be of type string.");
  }
  if (this.pattern.indexOf("@") >= 0)
    this.pattern = this.handleNicknames(this.pattern).trim();
  const parts = this.pattern.replace(/\s+/g, " ").split(" ");
  if (parts.length < 5 || parts.length > 6) {
    throw new TypeError("CronPattern: invalid configuration format ('" + this.pattern + "'), exacly five or six space separated parts required.");
  }
  if (parts.length === 5) {
    parts.unshift("0");
  }
  if (parts[3].indexOf("L") >= 0) {
    parts[3] = parts[3].replace("L", "");
    this.lastDayOfMonth = true;
  }
  if (parts[5].indexOf("L") >= 0) {
    parts[5] = parts[5].replace("L", "");
    this.lastWeekdayOfMonth = true;
  }
  if (parts[3] == "*") {
    this.starDOM = true;
  }
  if (parts[4].length >= 3)
    parts[4] = this.replaceAlphaMonths(parts[4]);
  if (parts[5].length >= 3)
    parts[5] = this.replaceAlphaDays(parts[5]);
  if (parts[5] == "*") {
    this.starDOW = true;
  }
  if (this.pattern.indexOf("?") >= 0) {
    const initDate = new CronDate(new Date, this.timezone).getDate(true);
    parts[0] = parts[0].replace("?", initDate.getSeconds());
    parts[1] = parts[1].replace("?", initDate.getMinutes());
    parts[2] = parts[2].replace("?", initDate.getHours());
    if (!this.starDOM)
      parts[3] = parts[3].replace("?", initDate.getDate());
    parts[4] = parts[4].replace("?", initDate.getMonth() + 1);
    if (!this.starDOW)
      parts[5] = parts[5].replace("?", initDate.getDay());
  }
  this.throwAtIllegalCharacters(parts);
  this.partToArray("second", parts[0], 0);
  this.partToArray("minute", parts[1], 0);
  this.partToArray("hour", parts[2], 0);
  this.partToArray("day", parts[3], -1);
  this.partToArray("month", parts[4], -1);
  this.partToArray("dayOfWeek", parts[5], 0);
  if (this.dayOfWeek[7]) {
    this.dayOfWeek[0] = 1;
  }
};
CronPattern.prototype.partToArray = function(type, conf, valueIndexOffset) {
  const arr = this[type];
  if (conf === "*")
    return arr.fill(1);
  const split = conf.split(",");
  if (split.length > 1) {
    for (let i = 0;i < split.length; i++) {
      this.partToArray(type, split[i], valueIndexOffset);
    }
  } else if (conf.indexOf("-") !== -1 && conf.indexOf("/") !== -1) {
    this.handleRangeWithStepping(conf, type, valueIndexOffset);
  } else if (conf.indexOf("-") !== -1) {
    this.handleRange(conf, type, valueIndexOffset);
  } else if (conf.indexOf("/") !== -1) {
    this.handleStepping(conf, type, valueIndexOffset);
  } else if (conf !== "") {
    this.handleNumber(conf, type, valueIndexOffset);
  }
};
CronPattern.prototype.throwAtIllegalCharacters = function(parts) {
  const reValidCron = /[^/*0-9,-]+/;
  for (let i = 0;i < parts.length; i++) {
    if (reValidCron.test(parts[i])) {
      throw new TypeError("CronPattern: configuration entry " + i + " (" + parts[i] + ") contains illegal characters.");
    }
  }
};
CronPattern.prototype.handleNumber = function(conf, type, valueIndexOffset) {
  const i = parseInt(conf, 10) + valueIndexOffset;
  if (isNaN(i)) {
    throw new TypeError("CronPattern: " + type + " is not a number: '" + conf + "'");
  }
  if (i < 0 || i >= this[type].length) {
    throw new TypeError("CronPattern: " + type + " value out of range: '" + conf + "'");
  }
  this[type][i] = 1;
};
CronPattern.prototype.handleRangeWithStepping = function(conf, type, valueIndexOffset) {
  const matches = conf.match(/^(\d+)-(\d+)\/(\d+)$/);
  if (matches === null)
    throw new TypeError("CronPattern: Syntax error, illegal range with stepping: '" + conf + "'");
  let [, lower, upper, steps] = matches;
  lower = parseInt(lower, 10) + valueIndexOffset;
  upper = parseInt(upper, 10) + valueIndexOffset;
  steps = parseInt(steps, 10);
  if (isNaN(lower))
    throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");
  if (isNaN(upper))
    throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");
  if (isNaN(steps))
    throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");
  if (steps === 0)
    throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");
  if (steps > this[type].length)
    throw new TypeError("CronPattern: Syntax error, steps cannot be greater than maximum value of part (" + this[type].length + ")");
  if (lower < 0 || upper >= this[type].length)
    throw new TypeError("CronPattern: Value out of range: '" + conf + "'");
  if (lower > upper)
    throw new TypeError("CronPattern: From value is larger than to value: '" + conf + "'");
  for (let i = lower;i <= upper; i += steps) {
    this[type][i] = 1;
  }
};
CronPattern.prototype.handleRange = function(conf, type, valueIndexOffset) {
  const split = conf.split("-");
  if (split.length !== 2) {
    throw new TypeError("CronPattern: Syntax error, illegal range: '" + conf + "'");
  }
  const lower = parseInt(split[0], 10) + valueIndexOffset, upper = parseInt(split[1], 10) + valueIndexOffset;
  if (isNaN(lower)) {
    throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");
  } else if (isNaN(upper)) {
    throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");
  }
  if (lower < 0 || upper >= this[type].length) {
    throw new TypeError("CronPattern: Value out of range: '" + conf + "'");
  }
  if (lower > upper) {
    throw new TypeError("CronPattern: From value is larger than to value: '" + conf + "'");
  }
  for (let i = lower;i <= upper; i++) {
    this[type][i] = 1;
  }
};
CronPattern.prototype.handleStepping = function(conf, type) {
  const split = conf.split("/");
  if (split.length !== 2) {
    throw new TypeError("CronPattern: Syntax error, illegal stepping: '" + conf + "'");
  }
  let start = 0;
  if (split[0] !== "*") {
    start = parseInt(split[0], 10);
  }
  const steps = parseInt(split[1], 10);
  if (isNaN(steps))
    throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");
  if (steps === 0)
    throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");
  if (steps > this[type].length)
    throw new TypeError("CronPattern: Syntax error, max steps for part is (" + this[type].length + ")");
  for (let i = start;i < this[type].length; i += steps) {
    this[type][i] = 1;
  }
};
CronPattern.prototype.replaceAlphaDays = function(conf) {
  return conf.replace(/-sun/gi, "-7").replace(/sun/gi, "0").replace(/mon/gi, "1").replace(/tue/gi, "2").replace(/wed/gi, "3").replace(/thu/gi, "4").replace(/fri/gi, "5").replace(/sat/gi, "6");
};
CronPattern.prototype.replaceAlphaMonths = function(conf) {
  return conf.replace(/jan/gi, "1").replace(/feb/gi, "2").replace(/mar/gi, "3").replace(/apr/gi, "4").replace(/may/gi, "5").replace(/jun/gi, "6").replace(/jul/gi, "7").replace(/aug/gi, "8").replace(/sep/gi, "9").replace(/oct/gi, "10").replace(/nov/gi, "11").replace(/dec/gi, "12");
};
CronPattern.prototype.handleNicknames = function(pattern) {
  const cleanPattern = pattern.trim().toLowerCase();
  if (cleanPattern === "@yearly" || cleanPattern === "@annually") {
    return "0 0 1 1 *";
  } else if (cleanPattern === "@monthly") {
    return "0 0 1 * *";
  } else if (cleanPattern === "@weekly") {
    return "0 0 * * 0";
  } else if (cleanPattern === "@daily") {
    return "0 0 * * *";
  } else if (cleanPattern === "@hourly") {
    return "0 * * * *";
  } else {
    return pattern;
  }
};
var maxDelay = 30 * 1000;
var scheduledJobs = [];
Cron.prototype.nextRun = function(prev) {
  const next = this._next(prev);
  return next ? next.getDate() : null;
};
Cron.prototype.nextRuns = function(n, previous) {
  if (n > this._states.maxRuns) {
    n = this._states.maxRuns;
  }
  const enumeration = [];
  let prev = previous || this._states.currentRun;
  while (n-- && (prev = this.nextRun(prev))) {
    enumeration.push(prev);
  }
  return enumeration;
};
Cron.prototype.getPattern = function() {
  return this._states.pattern ? this._states.pattern.pattern : undefined;
};
Cron.prototype.isRunning = function() {
  const msLeft = this.msToNext(this._states.currentRun);
  const isRunning = !this._states.paused;
  const isScheduled = this.fn !== undefined;
  const notIsKilled = !this._states.kill;
  return isRunning && isScheduled && notIsKilled && msLeft !== null;
};
Cron.prototype.isStopped = function() {
  return this._states.kill;
};
Cron.prototype.isBusy = function() {
  return this._states.blocking;
};
Cron.prototype.currentRun = function() {
  return this._states.currentRun ? this._states.currentRun.getDate() : null;
};
Cron.prototype.previousRun = function() {
  return this._states.previousRun ? this._states.previousRun.getDate() : null;
};
Cron.prototype.msToNext = function(prev) {
  const next = this._next(prev);
  prev = new CronDate(prev, this.options.timezone || this.options.utcOffset);
  if (next) {
    return next.getTime(true) - prev.getTime(true);
  } else {
    return null;
  }
};
Cron.prototype.stop = function() {
  this._states.kill = true;
  if (this._states.currentTimeout) {
    clearTimeout(this._states.currentTimeout);
  }
  const jobIndex = scheduledJobs.indexOf(this);
  if (jobIndex >= 0) {
    scheduledJobs.splice(jobIndex, 1);
  }
};
Cron.prototype.pause = function() {
  this._states.paused = true;
  return !this._states.kill;
};
Cron.prototype.resume = function() {
  this._states.paused = false;
  return !this._states.kill;
};
Cron.prototype.schedule = function(func, partial) {
  if (func && this.fn) {
    throw new Error("Cron: It is not allowed to schedule two functions using the same Croner instance.");
  } else if (func) {
    this.fn = func;
  }
  let waitMs = this.msToNext(partial ? partial : this._states.currentRun);
  const target = this.nextRun(partial ? partial : this._states.currentRun);
  if (waitMs === null || target === null)
    return this;
  if (waitMs > maxDelay) {
    waitMs = maxDelay;
  }
  this._states.currentTimeout = setTimeout(() => this._checkTrigger(target), waitMs);
  if (this._states.currentTimeout && this.options.unref) {
    unrefTimer(this._states.currentTimeout);
  }
  return this;
};
Cron.prototype._trigger = async function(initiationDate) {
  this._states.blocking = true;
  this._states.currentRun = new CronDate(undefined, this.options.timezone || this.options.utcOffset);
  if (this.options.catch) {
    try {
      await this.fn(this, this.options.context);
    } catch (_e) {
      if (isFunction(this.options.catch)) {
        this.options.catch(_e, this);
      }
    }
  } else {
    await this.fn(this, this.options.context);
  }
  this._states.previousRun = new CronDate(initiationDate, this.options.timezone || this.options.utcOffset);
  this._states.blocking = false;
};
Cron.prototype.trigger = async function() {
  await this._trigger();
};
Cron.prototype._checkTrigger = function(target) {
  const now = new Date, shouldRun = !this._states.paused && now.getTime() >= target, isBlocked = this._states.blocking && this.options.protect;
  if (shouldRun && !isBlocked) {
    this._states.maxRuns--;
    this._trigger();
  } else {
    if (shouldRun && isBlocked && isFunction(this.options.protect)) {
      setTimeout(() => this.options.protect(this), 0);
    }
  }
  this.schedule(undefined, now);
};
Cron.prototype._next = function(prev) {
  const hasPreviousRun = prev || this._states.currentRun ? true : false;
  prev = new CronDate(prev, this.options.timezone || this.options.utcOffset);
  if (this.options.startAt && prev && prev.getTime() < this.options.startAt.getTime()) {
    prev = this.options.startAt;
  }
  const nextRun = this._states.once || new CronDate(prev, this.options.timezone || this.options.utcOffset).increment(this._states.pattern, this.options, hasPreviousRun);
  if (this._states.once && this._states.once.getTime() <= prev.getTime()) {
    return null;
  } else if (nextRun === null || this._states.maxRuns <= 0 || this._states.kill || this.options.stopAt && nextRun.getTime() >= this.options.stopAt.getTime()) {
    return null;
  } else {
    return nextRun;
  }
};
Cron.Cron = Cron;
Cron.scheduledJobs = scheduledJobs;

// node_modules/@elysiajs/cron/dist/index.js
var cron = ({ pattern, name, run, ...options }) => (app) => {
  if (!pattern)
    throw new Error("pattern is required");
  if (!name)
    throw new Error("name is required");
  return app.state("cron", {
    ...app.store?.cron ?? {},
    [name]: new Cron(pattern, options, () => run(app.store))
  });
};

// node_modules/@research-ag/hpl-client/dist/candid/ledger.idl.js
var idlFactory = ({ IDL }) => {
  const IdRange = IDL.Tuple(IDL.Nat, IDL.Opt(IDL.Nat));
  const IdSelector = IDL.Variant({
    id: IDL.Nat,
    cat: IDL.Vec(IDL.Variant({ id: IDL.Nat, idRange: IdRange })),
    idRange: IdRange
  });
  const SubId = IDL.Nat;
  const AssetId = IDL.Nat;
  const AccountType = IDL.Variant({ ft: AssetId });
  const VirId = IDL.Nat;
  const AccountState = IDL.Variant({ ft: IDL.Nat });
  const Time = IDL.Nat64;
  const RemoteId = IDL.Tuple(IDL.Principal, IDL.Nat);
  const RemoteSelector = IDL.Variant({
    id: RemoteId,
    cat: IDL.Vec(IDL.Variant({ id: RemoteId }))
  });
  const FtSupply = IDL.Nat;
  const GlobalId = IDL.Tuple(IDL.Nat, IDL.Nat);
  const FtTransferErrors = IDL.Variant({
    DeletedVirtualAccount: IDL.Null,
    InvalidArguments: IDL.Text,
    InsufficientFunds: IDL.Null
  });
  const ProcessingError = IDL.Variant({ ftTransfer: FtTransferErrors });
  const TxOutput = IDL.Variant({
    ftTransfer: IDL.Record({ fee: IDL.Nat, amount: IDL.Nat })
  });
  const TxResult = IDL.Variant({
    failure: ProcessingError,
    success: TxOutput
  });
  const GidStatus = IDL.Variant({
    dropped: IDL.Record({}),
    awaited: IDL.Record({}),
    processed: IDL.Tuple(IDL.Opt(TxResult))
  });
  const LedgerIngressAPI = IDL.Service({
    accountInfo: IDL.Func([IdSelector], [IDL.Vec(IDL.Tuple(SubId, AccountType))], ["query"]),
    aggregatorPrincipal: IDL.Func([IDL.Nat], [
      IDL.Variant({
        ok: IDL.Principal,
        err: IDL.Variant({ NotFound: IDL.Null })
      })
    ], ["query"]),
    aggregators: IDL.Func([], [IDL.Vec(IDL.Tuple(IDL.Principal, IDL.Nat))], ["query"]),
    createFungibleToken: IDL.Func([IDL.Nat8, IDL.Text], [
      IDL.Variant({
        ok: AssetId,
        err: IDL.Variant({
          NoSpace: IDL.Null,
          FeeError: IDL.Null
        })
      })
    ], []),
    deleteVirtualAccount: IDL.Func([VirId], [
      IDL.Variant({
        ok: IDL.Variant({ ft: IDL.Nat }),
        err: IDL.Variant({
          DeletedVirtualAccount: IDL.Null,
          InvalidArguments: IDL.Text
        })
      })
    ], []),
    ftInfo: IDL.Func([IdSelector], [
      IDL.Vec(IDL.Tuple(AssetId, IDL.Record({
        controller: IDL.Principal,
        decimals: IDL.Nat8,
        description: IDL.Text
      })))
    ], ["query"]),
    nAccounts: IDL.Func([], [IDL.Nat], ["query"]),
    nFtAssets: IDL.Func([], [IDL.Nat], ["query"]),
    nStreams: IDL.Func([], [IDL.Nat], ["query"]),
    nVirtualAccounts: IDL.Func([], [IDL.Nat], ["query"]),
    openAccounts: IDL.Func([IDL.Nat, AccountType], [
      IDL.Variant({
        ok: IDL.Record({ first: SubId }),
        err: IDL.Variant({
          InvalidArguments: IDL.Text,
          NoSpaceForPrincipal: IDL.Null,
          NoSpaceForSubaccount: IDL.Null
        })
      })
    ], []),
    openVirtualAccount: IDL.Func([AccountType, IDL.Principal, AccountState, SubId, Time], [
      IDL.Variant({
        ok: IDL.Record({ id: VirId }),
        err: IDL.Variant({
          InvalidArguments: IDL.Text,
          NoSpaceForAccount: IDL.Null
        })
      })
    ], []),
    ping: IDL.Func([], [IDL.Int], []),
    state: IDL.Func([
      IDL.Record({
        ftSupplies: IDL.Opt(IdSelector),
        virtualAccounts: IDL.Opt(IdSelector),
        accounts: IDL.Opt(IdSelector),
        remoteAccounts: IDL.Opt(RemoteSelector)
      })
    ], [
      IDL.Record({
        ftSupplies: IDL.Vec(IDL.Tuple(AssetId, FtSupply)),
        virtualAccounts: IDL.Vec(IDL.Tuple(VirId, IDL.Opt(IDL.Tuple(AccountState, SubId, Time)))),
        accounts: IDL.Vec(IDL.Tuple(SubId, AccountState)),
        remoteAccounts: IDL.Vec(IDL.Tuple(RemoteId, IDL.Opt(IDL.Tuple(AccountState, Time))))
      })
    ], ["query"]),
    streamStatus: IDL.Func([IdSelector], [
      IDL.Vec(IDL.Tuple(IDL.Nat, IDL.Record({
        closed: IDL.Bool,
        source: IDL.Variant({
          internal: IDL.Null,
          aggregator: IDL.Principal
        }),
        length: IDL.Nat,
        lastActive: Time
      })))
    ], ["query"]),
    txStatus: IDL.Func([IDL.Vec(GlobalId)], [IDL.Vec(GidStatus)], ["query"]),
    updateVirtualAccount: IDL.Func([
      VirId,
      IDL.Record({
        backingAccount: IDL.Opt(SubId),
        state: IDL.Opt(IDL.Variant({
          ft_dec: IDL.Nat,
          ft_inc: IDL.Nat,
          ft_set: IDL.Nat
        })),
        expiration: IDL.Opt(Time)
      })
    ], [
      IDL.Variant({
        ok: IDL.Variant({ ft: IDL.Tuple(IDL.Nat, IDL.Int) }),
        err: IDL.Variant({
          DeletedVirtualAccount: IDL.Null,
          InvalidArguments: IDL.Text,
          InsufficientFunds: IDL.Null
        })
      })
    ], []),
    virtualAccountInfo: IDL.Func([IdSelector], [IDL.Vec(IDL.Tuple(VirId, IDL.Opt(IDL.Tuple(AccountType, IDL.Principal))))], ["query"])
  });
  return LedgerIngressAPI;
};

// node_modules/@research-ag/hpl-client/dist/candid/aggregator.idl.js
var idlFactory2 = ({ IDL }) => {
  const StreamStatus = IDL.Record({
    id: IDL.Nat,
    sent: IDL.Nat,
    length: IDL.Nat,
    received: IDL.Nat
  });
  const AccountRef = IDL.Variant({
    sub: IDL.Nat,
    vir: IDL.Tuple(IDL.Principal, IDL.Nat),
    mint: IDL.Null
  });
  const AssetId = IDL.Nat;
  const FtTransfer = IDL.Record({
    to: AccountRef,
    asset: AssetId,
    from: AccountRef,
    memo: IDL.Vec(IDL.Vec(IDL.Nat8)),
    amount: IDL.Variant({ max: IDL.Null, amount: IDL.Nat })
  });
  const TxInput = IDL.Variant({ ftTransfer: FtTransfer });
  const GlobalId = IDL.Tuple(IDL.Nat, IDL.Nat);
  const Time = IDL.Nat64;
  const GidStatus = IDL.Variant({
    pending: IDL.Record({}),
    other: IDL.Tuple(Time, IDL.Variant({ settled: IDL.Null, settledIfIssuedHere: IDL.Null })),
    queued: IDL.Tuple(IDL.Nat)
  });
  const AggregatorIngressAPI = IDL.Service({
    ping: IDL.Func([], [IDL.Int], []),
    streamStatus: IDL.Func([], [IDL.Vec(StreamStatus)], ["query"]),
    submitAndExecute: IDL.Func([IDL.Vec(TxInput)], [IDL.Vec(GlobalId)], []),
    txStatus: IDL.Func([IDL.Vec(GlobalId)], [IDL.Vec(GidStatus)], ["query"])
  });
  return AggregatorIngressAPI;
};

// src/index.ts
var getData = function() {
  if (script_mode === "FUNCTIONAL")
    return {
      data: {
        histogram: {
          name: "tracked_time_function",
          buckets: import_prom_client.default.linearBuckets(0, 1000, 25)
        },
        error_counter: "tracked_errors_function",
        requested_counter: "tracked_requests_function",
        labels: ["function"]
      }
    };
  if (script_mode === "PING")
    return {
      data: {
        histogram: {
          name: "ping_time_tracked",
          buckets: import_prom_client.default.linearBuckets(0, 1000, 25)
        },
        histogram_response: {
          name: "ping_time_response",
          buckets: import_prom_client.default.linearBuckets(0, 1000, 25)
        },
        histogram_call: {
          name: "ping_time_call",
          buckets: import_prom_client.default.linearBuckets(0, 1000, 25)
        },
        error_counter: "tracked_errors_time",
        requested_counter: "tracked_requests_time",
        labels: ["canister"]
      }
    };
  return {
    data: {
      histogram: {
        name: "transfer_time",
        buckets: import_prom_client.default.linearBuckets(0, 1000, 50)
      },
      error_counter: "transfer_errors",
      requested_counter: "transfer_requests",
      labels: ["aggregator"]
    }
  };
};
async function Metrics(request2) {
  const data = await register.metrics();
  return new Response(data, {
    status: 200,
    headers: {
      "Content-Type": register.contentType
    }
  });
}
async function controller(request2) {
  if (new URL(request2.url).pathname === "/")
    return new Response("Welcome to Bun!");
  else if (new URL(request2.url).pathname === "/metrics")
    return await Metrics(request2);
  else
    return new Response("Not found", { status: 404 });
}
var CreateSeedPrincipals = function() {
  return seedToIdentity(Bun.env.PRINCIPAL1_SECRET_KEY || "");
};
async function StartProcess() {
  const wallet = CreateSeedPrincipals();
  const client = startClients(wallet);
  if (!global.transactions)
    global.transactions = [];
  const promises2 = [
    new Promise(async (resolve, reject) => {
      requested("all");
      const start = Date.now();
      const data = await MakeTransfer(client);
      const seconds = Date.now() - start;
      try {
        log(["localId:", data.localId, "TxId:", data.TxId, "aggregator:", "all", "seconds:", seconds]);
        if (!data.err)
          transfers_time.labels({ aggregator: "all" }).observe(seconds);
      } catch (error) {
        console.log("error", error);
        reject(error);
      }
      global.transactions = [];
      resolve(true);
    })
  ];
  Promise.all(promises2);
}
async function StartProcessPerAggregator() {
  const wallet = CreateSeedPrincipals();
  const client = startClients(wallet);
  const aggregators = await client.getAggregators();
  const promises2 = [];
  if (!global.transactions)
    global.transactions = [];
  for (const aggregator2 of aggregators) {
    const promise = new Promise(async (resolve, reject) => {
      const aggPrincipal = aggregator2.canisterPrincipal.toText();
      requested(aggPrincipal);
      const start = Date.now();
      const data = await MakeTransfer(client, aggregator2.canisterPrincipal);
      const seconds = Date.now() - start;
      try {
        log(["localId:", data.localId, "TxId:", data.TxId, "aggregator:", aggPrincipal, "seconds:", seconds]);
        if (!data.err)
          transfers_time.labels({ aggregator: aggPrincipal }).observe(seconds);
      } catch (error) {
        log(["error", error]);
        reject(error);
      }
      global.transactions = [];
      resolve(true);
    });
    promises2.push(promise);
  }
  Promise.all(promises2);
}
async function StartProcessFunction() {
  const wallet = CreateSeedPrincipals();
  const client = startClients(wallet);
  if (!global.transactions)
    global.transactions = [];
  const promises2 = [
    new Promise(async (resolve, reject) => {
      requested_counter.labels({ function: "updateVirtualAccount" }).inc();
      const localId = getId();
      const start = Date.now();
      log(["localId:", localId, "Start"]);
      await updateVirtualAccount(localId, wallet).then((a) => console.log("result", a)).catch(async (error) => {
        console.log("error", error);
        log(["localId:", localId, "seconds:", seconds, "error:", JSON.stringify(error)]);
        error_counter.labels({ function: "updateVirtualAccount" }).inc();
      });
      const seconds = Date.now() - start;
      log(["localId:", localId, "seconds:", seconds, "function:", "updateVirtualAccount", "End"]);
      try {
        transfers_time.labels({ function: "updateVirtualAccount" }).observe(seconds);
      } catch (error) {
        console.log("error", error);
        reject(error);
      }
      global.transactions = [];
      resolve(true);
    })
  ];
  Promise.all(promises2);
}
async function StartProcessPing() {
  const wallet = CreateSeedPrincipals();
  const client = startClients(wallet);
  const aggregators = await client.getAggregators();
  if (!global.transactions)
    global.transactions = [];
  const promises2 = [
    new Promise(async (resolve, reject) => {
      requested_counter.labels({ canister: ledger_principal }).inc();
      const localId = getId();
      const start = Date.now();
      log(["localId:", localId, "aggregator:", "all", "Start"]);
      const value4 = await Ping(localId, wallet).then((a) => a).catch((error) => {
        console.log("error", error);
        error_counter.labels({ canister: ledger_principal }).inc();
      });
      const end = Date.now();
      const newValue = Number(value4) / 1e6;
      const seconds = end - start;
      let responsetime = Number(newValue) - start;
      let calltime = end - Number(newValue);
      if (responsetime < 0)
        responsetime = 0;
      if (calltime < 0)
        calltime = 0;
      log(["localId:", localId, "aggregator:", "all", "seconds:", seconds]);
      log(["localId:", localId, "aggregator:", "all", "responsetime:", responsetime]);
      log(["localId:", localId, "aggregator:", "all", "calltime:", calltime]);
      try {
        transfers_time.labels({ canister: ledger_principal }).observe(seconds);
        time_response.labels({ canister: ledger_principal }).observe(responsetime);
        time_call.labels({ canister: ledger_principal }).observe(calltime);
      } catch (error) {
        console.log("error", error);
        reject(error);
      }
      global.transactions = [];
      resolve(true);
    })
  ];
  for (const aggregator2 of aggregators) {
    const promise = new Promise(async (resolve, reject) => {
      const agg = aggregator2.canisterPrincipal.toText();
      requested_counter.labels({ canister: agg }).inc();
      const start = Date.now();
      const localId = getId();
      log(["localId:", localId, "aggregator:", agg, "Start"]);
      const value4 = await PingAgg(localId, agg, wallet).then((a) => a).catch((error) => {
        console.log("error", error);
        error_counter.labels({ canister: agg }).inc();
      });
      const end = Date.now();
      const newValue = Number(value4) / 1e6;
      const seconds = end - start;
      let responsetime = Number(newValue) - start;
      let calltime = end - Number(newValue);
      if (responsetime < 0)
        responsetime = 0;
      if (calltime < 0)
        calltime = 0;
      log(["localId:", localId, "aggregator:", agg, "seconds:", seconds]);
      log(["localId:", localId, "aggregator:", agg, "responsetime:", responsetime]);
      log(["localId:", localId, "aggregator:", agg, "calltime:", calltime]);
      try {
        transfers_time.labels({ canister: agg }).observe(seconds);
        time_response.labels({ canister: agg }).observe(responsetime);
        time_call.labels({ canister: agg }).observe(calltime);
      } catch (error) {
        console.log("error", error);
        reject(error);
      }
      global.transactions = [];
      resolve(true);
    });
    promises2.push(promise);
  }
  Promise.all(promises2);
}
async function updateVirtualAccount(localId, wallet) {
  log(["localId:", localId, "Start Agent"]);
  const myAgent = new HttpAgent({
    identity: wallet,
    host: AGENT_HOST
  });
  log(["localId:", localId, "Create Actor"]);
  const ingressActor = Actor.createActor(idlFactory, {
    agent: myAgent,
    canisterId: ledger_principal
  });
  log(["localId:", localId, "Execute Function"]);
  return ingressActor.updateVirtualAccount(BigInt(0), {
    backingAccount: [BigInt(0)],
    state: [{ ft_set: BigInt(1000) }],
    expiration: [BigInt(1000)]
  });
}
async function Ping(localId, wallet) {
  log(["localId:", localId, "aggregator:", "all", "Start Agent"]);
  const myAgent = new HttpAgent({
    identity: wallet,
    host: AGENT_HOST
  });
  log(["localId:", localId, "aggregator:", "all", "Create Actor"]);
  const ledgerActor = Actor.createActor(idlFactory, {
    agent: myAgent,
    canisterId: "rqx66-eyaaa-aaaap-aaona-cai"
  });
  log(["localId:", localId, "aggregator:", "all", "Execute Function"]);
  return ledgerActor.ping();
}
async function PingAgg(localId, aggregator2, wallet) {
  log(["localId:", localId, "aggregator:", aggregator2, "Start Agent"]);
  const myAgent = new HttpAgent({
    identity: wallet,
    host: AGENT_HOST
  });
  log(["localId:", localId, "aggregator:", aggregator2, "Create Actor"]);
  const aggActor = Actor.createActor(idlFactory2, {
    agent: myAgent,
    canisterId: aggregator2
  });
  log(["localId:", localId, "aggregator:", aggregator2, "Execute Function"]);
  return aggActor.ping();
}
var errors6 = function(aggregator2) {
  error_counter.labels({ aggregator: aggregator2 }).inc();
};
var requested = function(aggregator2) {
  requested_counter.labels({ aggregator: aggregator2 }).inc();
};
async function MakeTransfer(client, aggregator2) {
  const localId = getId();
  const from2 = {
    type: "sub",
    id: BigInt(1)
  };
  const to = {
    type: "sub",
    id: BigInt(2)
  };
  const data = await runOrPickupSimpleTransfer(localId, [from2, to, BigInt(1), "max"], client, () => {
  }, { errors: errors6 }, aggregator2);
  return { TxId: data.txId, localId, err: data.err };
}
var startClients = function(wallet) {
  const client1 = new Ht(Bun.env.LEDGER_PRINCIPAL || "", "ic");
  client1.setIdentity(wallet);
  return client1;
};
var getId = function() {
  return Date.now() + randomId(10);
};
var port = "9080";
var ledger_principal = "rqx66-eyaaa-aaaap-aaona-cai";
var interval_time = "*/5 * * * * *";
var script_mode = "AGGREGATOR";
var AGENT_HOST = "https://identity.ic0.app";
var register = new import_prom_client.default.Registry;
var transfers_time = new import_prom_client.default.Histogram({
  name: getData().data.histogram.name,
  help: "Count of time took to process",
  labelNames: getData().data.labels,
  buckets: getData().data.histogram.buckets
});
register.registerMetric(transfers_time);
var time_response = new import_prom_client.default.Histogram({
  name: getData().data.histogram_response?.name || "ping_time_response",
  help: "Count of time took to process",
  labelNames: getData().data.labels,
  buckets: getData().data.histogram_response?.buckets || []
});
register.registerMetric(time_response);
var time_call = new import_prom_client.default.Histogram({
  name: getData().data.histogram_call?.name || "ping_time_call",
  help: "Count of time took to process",
  labelNames: getData().data.labels,
  buckets: getData().data.histogram_call?.buckets || []
});
register.registerMetric(time_call);
var error_counter = new import_prom_client.default.Counter({
  name: getData().data.error_counter,
  help: "Count of errors on process",
  labelNames: getData().data.labels
});
register.registerMetric(error_counter);
var requested_counter = new import_prom_client.default.Counter({
  name: getData().data.requested_counter,
  help: "Count of requests on process",
  labelNames: getData().data.labels
});
register.registerMetric(requested_counter);
register.setDefaultLabels({
  app: "hpl-script"
});
new o$().use(cron({
  name: "execute-transfer",
  pattern: interval_time,
  run() {
    if (script_mode === "ALL")
      StartProcess();
    if (script_mode === "AGGREGATOR")
      StartProcessPerAggregator();
    if (script_mode === "FUNCTIONAL")
      StartProcessFunction();
    if (script_mode === "PING")
      StartProcessPing();
  }
})).listen(8080);
var server = Bun.serve({
  port,
  fetch(request2) {
    return controller(request2);
  }
});
console.log(`Listening on localhost: ${server.port}`);
